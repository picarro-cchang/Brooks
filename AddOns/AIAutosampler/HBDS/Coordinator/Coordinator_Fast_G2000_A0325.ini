# G2000 Vaporizer 3
# 2010-10-11 Alex Lee -- Added the logic to control the Arduino board in vaporizer 3

[Mode]
inject_mode=automatic

[Files]
output = "c:/IsotopeData/Fast_IsoWater"
sequence = "c:/windows/PicarroSeq.txt"
prefix = "P"

[Output]
line="Line",%6s
analysis="Analysis",%10s
timeCode="Time Code",%22s
injNum = "Inj Nr",%8d
Delta_18_16_ir="d(18_16)_IR",%14.3f
Delta_D_H_ir="d(D_H)_IR",%14.3f
Delta_18_16_range="d(18_16)_Range",%14.3f
Delta_D_H_range="d(D_H)_Range",%14.3f
galpeak77_int="GALPEAK_77_INT",%14.3f
galpeak82_int="GALPEAK_82_INT",%14.3f
h2o_spline_max_int="SPLINE_MAX_INT",%14.3f
h2o_int="H2O_INT",%14.3f
H2O_mean="H2O_Mean",%14.3f
Delta_18_16_mean="d(18_16)_Mean",%14.3f
Delta_D_H_mean="d(D_H)_Mean",%14.3f
ignore="Ignore",%8d
Good="Good",%5d
Identifier 1 = Identifier 1, %40s
Identifier 2 = Identifier 2, %40s
gasConfig="Gas Configuration",%20s
timestamp_mean="Timestamp Mean",%14.2f
H2O_std="H2O_SD",%14.3f
H2O_slope="H2O_Sl",%14.3f
organic_base_mean="ORGANIC_BASE",%14.5f
organic_MeOHampl_mean="ORGANIC_MEOH_AMPL",%14.5f
organic_slope_mean="ORGANIC_SLOPE",%14.5f
organic_ch4conc_mean="ORGANIC_CH4CONC",%14.5f
organic_shift_mean="ORGANIC_CM_SHIFT",%14.5f
organic_res_mean="ORGANIC_STDEV",%14.5f
organic_y_mean="ORGANIC_Y",%14.5f
organic_77_mean="ORGANIC_77",%14.5f
organic_82_mean="ORGANIC_82",%14.5f
organic_splinemax_mean="ORGANIC_SPLINEMAX",%14.5f
organic_squish_mean="ORGANIC_SQUISH",%14.5f
standard_base_mean="STANDARD_BASE",%14.5f
standard_residuals_mean="STANDARD_STDEV",%14.5f
dasTemp="DAS Temp",%14.3f
trayName="Tray",%10s
sampleNum="Sample",%8s
jobNum="Job",%8d
methodName="Method",%10s
errCode = Error Code, %8d

[Setup]
initial=StateSetupVaporizer
final=StateDone
error=StateError
# script=CoordinatorScripts.py

[Trays]
tray1 = 1

[StateSetupVaporizer]
action = """
logFunc("Searching Vaporizer...\n")
vaporizer = None
vaporizerFound = False
for p in range(2,100):
    if vaporizer:
        vaporizer.close()
        vaporizer = None
    try:
        vaporizer = SerIntrf(p, timeout=1, xonxoff=0)
        sleep(3)
    except:
        continue
    try:
        logFunc("Talking to COM%d...\n"%(p+1))
        vaporizer.sendString("sz")
        status = vaporizer.getLine()
        if "ok from vaporizer" in status.lower():
            logFunc("Vaporizer found at COM%d...\n"%(p+1))
            vaporizerFound = True
            break
    except:
        pass
        
if not vaporizerFound:
    logFunc("Vaporizer not found.\n")
    if vaporizer:
        vaporizer.close()
        vaporizer = None
    GUI.popWarning("Vaporizer not found", "Vaporizer not found")
    raise Exception, "Vaporizer not found"
    
def getPIDStatus():
    if vaporizer:
        vaporizer.sendString("st")
        status = vaporizer.getLine()
        logFunc("%s\n" % status)
        return status
    else:
        GUI.popWarning("Vaporizer not found", "Vaporizer not found")
        raise Exception, "Vaporizer not found"
    
def openValve(valIdx):
    if vaporizer:
        if valIdx == 1:
            vaporizer.sendString("sq")
            status = vaporizer.getLine()
            if "on" in status.lower():
                pass
            else:
                vaporizer.sendString("sf")
                status = vaporizer.getLine()
        else:
            status = "N/A"
        logFunc("%s\n" % status)
        return status
    else:
        GUI.popWarning("Vaporizer not found", "Vaporizer not found")
        raise Exception, "Vaporizer not found"
        
def closeValve(valIdx):
    if vaporizer:
        if valIdx == 1:
            vaporizer.sendString("sq")
            status = vaporizer.getLine()
            if "off" in status.lower():
                pass
            else:
                vaporizer.sendString("sf")
                status = vaporizer.getLine()
        else:
            status = "N/A"
        logFunc("%s\n" % status)
        return status
    else:
        GUI.popWarning("Vaporizer not found", "Vaporizer not found")
        raise Exception, "Vaporizer not found"
    
def calcArea(mList, tList):
    totalArea = 0.0
    for idx in range(len(mList)-1):
        totalArea += 0.5*(mList[idx] + mList[idx+1])*(tList[idx+1] - tList[idx])
    return totalArea
    
logFunc("Wait until PID loop is locked...\n")
pidLockedTimeout = 3600
closeValve(1)
waitSteps = 0
NEXT = "StateWaitForPIDLocked"
"""

[StateWaitForPIDLocked]
action="""
status = getPIDStatus()
if "PID locked" not in status:
    logFunc(".")
    sleep(1.0)
    waitSteps += 1
    if waitSteps < pidLockedTimeout:
        NEXT="StateWaitForPIDLocked"
    else:
        logFunc("\nPID loop timeout...\n")
        NEXT="StateDone"
else:
    logFunc("PID loop is locked...\n")
    NEXT="StateStart"
"""

[StateStart]
action="""
lineNum = 0
currentSampleNum = -1
currentTrayName  = ""
injNum = -1
dasTemp = 0.0
injTimeout = 1800
analysisTimeout = 210
maxWetFlushIter = 0
concNameList = ["H2O", "Delta_18_16", "Delta_D_H", "galpeak77", "galpeak82", "h2o_spline_max", "organic_base", \
                "organic_MeOHampl", "organic_slope", "organic_ch4conc", "organic_shift", "organic_res", "organic_y", \
                "organic_77", "organic_82", "organic_splinemax", "organic_squish", "standard_residuals", "standard_base"]
thres1Pair = [6500, 30000]  #this is the upslope trigger   
thres2Pair = [6500, 30000]  #this is the downslope trigger       
pulseAnalyzerSet(source = "analyze_iH2O", concNameList = concNameList,
                 targetConc = "H2O", thres1Pair = thres1Pair, thres2Pair = thres2Pair,  
                 triggerType = "in", waitTime = 10.0,
                 validTimeAfterTrigger = 10, validTimeBeforeEnd = 8,
                 timeout = 172800, bufSize = 5000, numPointsToTrigger = 1, numPointsToRelease = 1)

pulseAnalyzerStartRunning()
initTimeout = time.time() + 300
setMeasBuffer("analyze_iH2O", ["H2O"], 30)
clearMeasBuffer()
h2oConcBuffer = []
h2oConcBufferSize = 10
GUI.setStatusText("")
openValve(1)
logFunc("Asserting start\n")
NEWAUTOSAMPLER.assertStart()
logFunc("Wait until H2O concentration lower than 500 ppm\n")
NEXT="StateWaitToDry"
"""

[StateWaitToDry]
action = """
if time.time() < initTimeout:
    results = measGetBufferFirst()
    if not results:
        sleep(1.0)
        NEXT="StateWaitToDry"
    else:
        h2oConcBuffer.append(results["H2O"])
        if len(h2oConcBuffer) >= h2oConcBufferSize:
            h2oConcBuffer = h2oConcBuffer[-h2oConcBufferSize:]
            h2oConcMean = mean(h2oConcBuffer)
            if h2oConcMean < 500:
                NEXT="StateAssertStartInit"
            else:
                NEXT="StateWaitToDry"
        else:
            NEXT="StateWaitToDry"
else:
    NEXT="StateAssertStartInit"
"""

[StateAssertStartInit]
action="""
#logFunc("Asserting start and inject\n")
#AUTOSAMPLER.assertStart()
logFunc("Asserting inject\n")
NEWAUTOSAMPLER.assertInject()
logFunc("\nFlushing pulse analyzer results buffer\n")
pulseAnalyzerReset()
t = 0
waitSteps = 0
logFunc("\nWaiting for injection\n")
NEXT="StateWaitForInjected"
"""

[StateWaitForInjected]
action="""
if not NEWAUTOSAMPLER.getInjected():
    if t % 150 == 0: logFunc("\n%3.1f s " % (t*0.2))
    t += 1
    logFunc(".")
    sleep(0.2)
    waitSteps += 1
    if waitSteps < injTimeout*5:
        NEXT="StateWaitForInjected"
    else:
        logFunc("\nInjection timeout...\n")
        NEXT="StateDone"
else:
    logFunc("\nReceived injected\n")
    NEWAUTOSAMPLER.deassertInject()
    NEXT="StateGetAutosamplerLog"
"""

[StateGetAutosamplerLog]
action="""
timeCode, trayName, sampleNum, jobNum, methodName, errCode = NEWAUTOSAMPLER.getLog()
#logFunc("%s\n" % logString)
injNum += 1
trayName = str(trayName)
if currentSampleNum != sampleNum or currentTrayName != trayName:
    incrAnalysisNumber()
    currentSampleNum = sampleNum
    currentTrayName  = trayName
    injNum = 1
    logFunc("\ninjNum set to 1 in StateGetAutosamplerLog\n")    
logFunc("Inject number = %d\n" % injNum)
seqNum = getAnalysisNumber()
analysis = "P-%d" % seqNum   
lineNum += 1
gasConfig = "H2O"
autosampDict = dict(line=lineNum,analysis=analysis,timeCode=timeCode,gasConfig=gasConfig,injNum=injNum,
    trayName=trayName,sampleNum=sampleNum,jobNum=jobNum,methodName=methodName,errCode=errCode)

waitSteps = 0
t = 0
NEXT="StateWaitForAnalysisDone"
"""

[StateWaitForAnalysisDone]
action = """
if not pulseAnalyzerGetDataReady():
    if t % 30 == 0: logFunc("\n%3d s " % t)
    t += 1
    logFunc(".")
    sleep(1.0)
    waitSteps += 1
    if waitSteps < analysisTimeout:
        NEXT="StateWaitForAnalysisDone"
    else:
        fileDataFunc(autosampDict)
        logFunc("\nAnalysis timeout\n")
        NEXT="StateAssertStartInit"
else:
    try:
        (startTime, endTime) = pulseAnalyzerGetPulseStartEndTime()
        setLineMarkerColor("red", startTime)
        setLineMarkerColor(None, endTime)
    except Exception, err:
        logFunc("\n%r\n" % err)
    results = pulseAnalyzerGetStatistics()
    results["Good"] = 17000.0 <= results["H2O_mean"] <= 23000.0
    results.update(autosampDict)
    results["ignore"] = -int(results["injNum"] <=3 or not results["Good"])
    results["dasTemp"] = getDasTemperature()
    
    instrCal = getInstrCalibrations()
    dataBuffer = pulseAnalyzerGetOutput()[2]
    tList = dataBuffer["timestamp"]
    h20_int = calcArea(dataBuffer["H2O"], tList)
    galpeak77_int = calcArea(dataBuffer["galpeak77"], tList)
    galpeak82_int = calcArea(dataBuffer["galpeak82"], tList)
    h2o_spline_max_int = calcArea(dataBuffer["h2o_spline_max"], tList)
    results["h2o_int"] = h20_int
    results["galpeak77_int"] = galpeak77_int
    results["galpeak82_int"] = galpeak82_int
    results["h2o_spline_max_int"] = h2o_spline_max_int
    results["Delta_18_16_ir"] = (galpeak77_int/h2o_spline_max_int)*instrCal["delta_1816_slope"]+instrCal["delta_1816_intercept"]
    results["Delta_D_H_ir"] = (galpeak82_int/h2o_spline_max_int)*instrCal["delta_dh_slope"]+instrCal["delta_dh_intercept"]
    results["Delta_18_16_range"] = max(dataBuffer["Delta_18_16"]) - min(dataBuffer["Delta_18_16"])
    results["Delta_D_H_range"] = max(dataBuffer["Delta_D_H"]) - min(dataBuffer["Delta_D_H"])
    #h2o_array = array(dataBuffer["H2O"])
    #results["h2o_int"] = sum(h2o_array)
    #results["Delta_18_16_int"] = dot(array(dataBuffer["Delta_18_16"]), h2o_array)
    #results["Delta_D_H_int"] = dot(array(dataBuffer["Delta_D_H"]), h2o_array)
    #results["Delta_18_16_ir"] = results["Delta_18_16_int"]/results["h2o_int"]
    #results["Delta_D_H_ir"] = results["Delta_D_H_int"]/results["h2o_int"]
    fileDataFunc(results)
    logFunc("\nAnalysis done\n")
    NEXT="StateAssertStartInit"
"""

[StateDone]
action="""
closeValve(1)
logFunc("Done!")
"""

[StateError]
action="""
logFunc("Error %s in state %s\n" % (ERROR_MSG,ERROR_STATE))
NEXT = "StateDone"
"""
