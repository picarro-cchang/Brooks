# G2000 Vaporizer 3
# 2010-10-11 Alex Lee -- Added the logic to control the Arduino board in vaporizer 3

[Mode]
inject_mode=automatic

[Files]
output = "c:/IsotopeData/Fast_IsoWater"
sequence = "c:/windows/PicarroSeq.txt"
prefix = "P"

[Output]
line = Line, %6s
analysis = Analysis, %10s
timeCode = Time Code, %22s
port = Port, %15s
injNum = Inj Nr, %8d
Delta_18_16_mean = d(18_16)Mean, %14.3f
Delta_D_H_mean = d(D_H)Mean, %14.3f
H2O_mean = H2O_Mean, %14.0f
delta_18_16_ir= d(18_16)_IR, %14.3f
delta_D_H_ir= d(D_H)_IR, %14.3f
ignore = Ignore, %8d
Good = Good, %5d
Identifier 1 = Identifier 1, %40s
Identifier 2 = Identifier 2, %40s
gasConfig = Gas Configuration, %20s
timestamp_mean = Timestamp Mean, %14.2f
Delta_18_16_std = d(18_16)_SD, %14.3f
Delta_D_H_std = d(D_H)_SD, %14.3f
H2O_std = H2O_SD, %14.3f
Delta_18_16_slope = d(18_16)_Sl, %14.3f
Delta_D_H_slope = d(D_H)_Sl, %14.3f
H2O_slope = H2O_Sl, %14.3f
baseline_shift_mean = baseline_shift, %14.3f
slope_shift_mean = slope_shift, %14.3f
residuals_mean = residuals, %14.3f
baseline_curvature_mean = baseline_curvature, %14.3f
interval_mean = interval, %14.3f
CH4_mean = ch4_ppm, %14.3f
h16od_adjust_mean = h16od_adjust, %14.4f
h16od_shift_mean = h16od_shift, %14.4f
n2_flag_mean = n2_flag, %5d
dasTemp = DAS Temp, %14.3f
trayName = Tray, %10s
sampleNum = Sample, %8s
jobNum = Job, %8d
methodName = Method, %10s
errCode = Error Code, %8d

[Setup]
initial=StateSetupVaporizer
final=StateDone
error=StateError
# script=CoordinatorScripts.py

[Trays]
tray1=MT1-Frnt
tray2=MT1-Rear

[StateSetupVaporizer]
action = """
logFunc("Searching Vaporizer...\n")
vaporizer = None
vaporizerFound = False
for p in range(2,100):
    if vaporizer:
        vaporizer.close()
        vaporizer = None
    try:
        vaporizer = SerIntrf(p, timeout=1, xonxoff=0)
        sleep(3)
    except:
        continue
    try:
        logFunc("Talking to COM%d...\n"%(p+1))
        vaporizer.sendString("sz")
        status = vaporizer.getLine()
        if "ok from vaporizer" in status.lower():
            logFunc("Vaporizer found at COM%d...\n"%(p+1))
            vaporizerFound = True
            break
    except:
        pass
        
if not vaporizerFound:
    logFunc("Vaporizer not found.\n")
    if vaporizer:
        vaporizer.close()
        vaporizer = None
    GUI.popWarning("Vaporizer not found", "Vaporizer not found")
    raise Exception, "Vaporizer not found"
    
def getPIDStatus():
    if vaporizer:
        vaporizer.sendString("st")
        status = vaporizer.getLine()
        logFunc("%s\n" % status)
        return status
    else:
        GUI.popWarning("Vaporizer not found", "Vaporizer not found")
        raise Exception, "Vaporizer not found"
    
def openValve(valIdx):
    if vaporizer:
        if valIdx == 1:
            vaporizer.sendString("sq")
            status = vaporizer.getLine()
            if "on" in status.lower():
                pass
            else:
                vaporizer.sendString("sf")
                status = vaporizer.getLine()
        else:
            status = "N/A"
        logFunc("%s\n" % status)
        return status
    else:
        GUI.popWarning("Vaporizer not found", "Vaporizer not found")
        raise Exception, "Vaporizer not found"
        
def closeValve(valIdx):
    if vaporizer:
        if valIdx == 1:
            vaporizer.sendString("sq")
            status = vaporizer.getLine()
            if "off" in status.lower():
                pass
            else:
                vaporizer.sendString("sf")
                status = vaporizer.getLine()
        else:
            status = "N/A"
        logFunc("%s\n" % status)
        return status
    else:
        GUI.popWarning("Vaporizer not found", "Vaporizer not found")
        raise Exception, "Vaporizer not found"
    
def calcArea(mList, tList):
    totalArea = 0.0
    for idx in range(len(mList)-1):
        totalArea += 0.5*(mList[idx] + mList[idx+1])*(tList[idx+1] - tList[idx])
    return totalArea
    
logFunc("Wait until PID loop is locked...\n")
pidLockedTimeout = 3600
closeValve(1)
waitSteps = 0
NEXT = "StateWaitForPIDLocked"
"""

[StateWaitForPIDLocked]
action="""
status = getPIDStatus()
if "PID locked" not in status:
    logFunc(".")
    sleep(1.0)
    waitSteps += 1
    if waitSteps < pidLockedTimeout:
        NEXT="StateWaitForPIDLocked"
    else:
        logFunc("\nPID loop timeout...\n")
        NEXT="StateDone"
else:
    logFunc("PID loop is locked...\n")
    NEXT="StateStart"
"""

[StateStart]
action="""
lineNum = 0
currentSampleNum = -1
currentTrayName  = ""
injNum = -1
dasTemp = 0.0
injTimeout = 1800
analysisTimeout = 210
maxWetFlushIter = 0
concNameList = ["Delta_18_16", "Delta_D_H", "H2O", "baseline_shift", "slope_shift", "CH4", "residuals", "baseline_curvature", "h16od_adjust", "h16od_shift", "interval", "n2_flag", "peak1", "peak2", "peak3", "delta_18_16_ir", "delta_D_H_ir"]
thres1Pair = [6500, 30000]  #this is the upslope trigger   
thres2Pair = [6500, 30000]  #this is the downslope trigger       
pulseAnalyzerSet(source = "analyze_iH2O7200", concNameList = concNameList,
                 targetConc = "H2O", thres1Pair = thres1Pair, thres2Pair = thres2Pair,  
                 triggerType = "in", waitTime = 10.0,
                 validTimeAfterTrigger = 10, validTimeBeforeEnd = 8,
                 timeout = 172800, bufSize = 5000, numPointsToTrigger = 1, numPointsToRelease = 1)

pulseAnalyzerStartRunning()
GUI.setStatusText("")
openValve(1)
logFunc("Asserting start\n")
NEWAUTOSAMPLER.assertStart()
NEXT="StateAssertStartInit"
"""

[StateAssertStartInit]
action="""
#logFunc("Asserting start and inject\n")
#AUTOSAMPLER.assertStart()
logFunc("Asserting inject\n")
NEWAUTOSAMPLER.assertInject()
logFunc("\nFlushing pulse analyzer results buffer\n")
pulseAnalyzerReset()
t = 0
waitSteps = 0
logFunc("\nWaiting for injection\n")
NEXT="StateWaitForInjected"
"""

[StateWaitForInjected]
action="""
if not NEWAUTOSAMPLER.getInjected():
    if t % 150 == 0: logFunc("\n%3.1f s " % (t*0.2))
    t += 1
    logFunc(".")
    sleep(0.2)
    waitSteps += 1
    if waitSteps < injTimeout*5:
        NEXT="StateWaitForInjected"
    else:
        logFunc("\nInjection timeout...\n")
        NEXT="StateDone"
else:
    logFunc("\nReceived injected\n")
    NEWAUTOSAMPLER.deassertInject()
    NEXT="StateGetAutosamplerLog"
"""

[StateGetAutosamplerLog]
action="""
timeCode, trayName, sampleNum, jobNum, methodName, errCode = NEWAUTOSAMPLER.getLog()
#logFunc("%s\n" % logString)

injNum += 1
if currentSampleNum != sampleNum or currentTrayName != trayName:
    incrAnalysisNumber()
    currentSampleNum = sampleNum
    currentTrayName  = trayName
    injNum = 1
    logFunc("\ninjNum set to 1 in StateGetAutosamplerLog\n")    
logFunc("Inject number = %d\n" % injNum)
seqNum = getAnalysisNumber()
analysis = "P-%d" % seqNum   
lineNum += 1
gasConfig = "H2O"
autosampDict = dict(line=lineNum,analysis=analysis,timeCode=timeCode,gasConfig=gasConfig,injNum=injNum,
    trayName=trayName,sampleNum=sampleNum,jobNum=jobNum,methodName=methodName,errCode=errCode)

waitSteps = 0
t = 0
NEXT="StateWaitForAnalysisDone"
"""

[StateWaitForAnalysisDone]
action = """
if not pulseAnalyzerGetDataReady():
    if t % 30 == 0: logFunc("\n%3d s " % t)
    t += 1
    logFunc(".")
    sleep(1.0)
    waitSteps += 1
    if waitSteps < analysisTimeout:
        NEXT="StateWaitForAnalysisDone"
    else:
        fileDataFunc(autosampDict)
        logFunc("\nAnalysis timeout\n")
        NEXT="StateAssertStartInit"
else:
    try:
        (startTime, endTime) = pulseAnalyzerGetPulseStartEndTime()
        setLineMarkerColor("red", startTime)
        setLineMarkerColor(None, endTime)
    except Exception, err:
        logFunc("\n%r\n" % err)
    results = pulseAnalyzerGetStatistics()
    results["Good"] = 17000.0 <= results["H2O_mean"] <= 23000.0
    results.update(autosampDict)
    results["ignore"] = -int(results["injNum"] <=3 or not results["Good"])
    results["dasTemp"] = getDasTemperature()
    
    instrCal = getInstrCalibrations()
    dataBuffer = pulseAnalyzerGetOutput()[2]
    tList = dataBuffer["timestamp"]
    h20_int = calcArea(dataBuffer["H2O"], tList)
    peak1_int = calcArea(dataBuffer["peak1"], tList)
    peak3_int = calcArea(dataBuffer["peak3"], tList)
    peak2_int = calcArea(dataBuffer["peak2"], tList)
    results["h2o_int"] = h20_int
    #results["galpeak77_int"] = galpeak77_int
    #results["galpeak82_int"] = galpeak82_int
    #results["h2o_spline_max_int"] = h2o_spline_max_int
    #results["Delta_18_16_ir"] = (galpeak77_int/h2o_spline_max_int)*instrCal["delta_1816_slope"]+instrCal["delta_1816_intercept"]
    #results["Delta_D_H_ir"] = (galpeak82_int/h2o_spline_max_int)*instrCal["delta_dh_slope"]+instrCal["delta_dh_intercept"]
    
    int181 = peak1_int*instrCal["concentration_h18oh_gal_slope"]+instrCal["concentration_h18oh_gal_intercept"]
    int161 = peak2_int*instrCal["concentration_h16oh_gal_slope"]+instrCal["concentration_h16oh_gal_intercept"]
    int162 = peak3_int*instrCal["concentration_h16od_gal_slope"]+instrCal["concentration_h16od_gal_intercept"]
    delta_18_16_ir= calcResults["delta_18_16_ir"] = (int181/int161)*instrCal["delta_18o_slope"]+instrCal["delta_18o_intercept"]
    delta_D_H_ir=calcResults["delta_D_H_ir"] = (int162/int161)*instrCal["delta_d_slope"]+instrCal["delta_d_intercept"]
    results["delta_18_16_ir"] = delta_18_16_ir
    results["delta_D_H_ir"] = delta_D_H_ir
    
    #h2o_array = array(dataBuffer["H2O"])
    #results["h2o_int"] = sum(h2o_array)
    #results["Delta_18_16_int"] = dot(array(dataBuffer["Delta_18_16"]), h2o_array)
    #results["Delta_D_H_int"] = dot(array(dataBuffer["Delta_D_H"]), h2o_array)
    #results["Delta_18_16_ir"] = results["Delta_18_16_int"]/results["h2o_int"]
    #results["Delta_D_H_ir"] = results["Delta_D_H_int"]/results["h2o_int"]
    fileDataFunc(results)
    logFunc("\nAnalysis done\n")
    NEXT="StateAssertStartInit"
"""

[StateDone]
action="""
closeValve(1)
logFunc("Done!")
"""

[StateError]
action="""
logFunc("Error %s in state %s\n" % (ERROR_MSG,ERROR_STATE))
NEXT = "StateDone"
"""
