# Use this coordinator regardless of whether water scanning is enabled or not.
# Used to connect to an OI Aurora or Costech ECS4010 via a Caddy Interface
# Uses a fixed runtime from sample to sample and is good for single pulses only
# Uses a fixed Threshold (user editable) to trigger CO2 peak start and end
# Does NOT Use "FanState" to send contact closure to Front-end (NS)
# Does NOT Use a repeated trigger of "FanState" with longer "sleep time" to ensure that front-end triggers (Aug 29-2012)
# No baseline subtraction is implemented
# Max CO2 is reported
# Uses Fan Temp change to send contact closure to Front-end, lines 88-90(NS,Aug 29-2012)

[Mode]
inject_mode=automatic

[Files]
output = "C:\Picarro\IsotopicData\IsotopicData"

[UserEditableParams]
num_disp_params = 1
0 = "numSamples", "Total number of samples", "0"
1 = "preTriggerTime", "Pre-trigger time (seconds)", "0.0"
2 = "postTriggerTime", "Post-trigger time (seconds)", "60.0"
3 = "thresRatio", "Threshold above baseline", "70.0"
4 = "waitTime", "Sample Run time(seconds)", "960.0"

[Output]
sampleNum           = "Sample Id"               , %10s
peakNum             = "Peak Number"             , %10s
description         = "Description"             , %40s
startTime           = "Start Time"              , %25s
endTime             = "End Time"                , %10s
CO2_12_Max          = "Max 12CO2 (ppm)"         , %20.3f
int12CO2            = "12CO2 Integral"          , %20.3f
int13CO2            = "13CO2 Integral"          , %20.3f
#delta13C            = "Delta 13C calc"          , %20.3f
crdsDelta           = "Delta 13C"               , %20.3f
CO2_12Base          = "12CO2 Baseline"          , %20.3f
CO2_13Base          = "13CO2 Baseline"          , %20.3f
threshold           = "Threshold"               , %20.3f
numPoints           = "Number of data points"   , %10d
timeInterval        = "Time interval (seconds)" , %10.3f

[Setup]
initial = StateInit
final = StateDone
error = StateError

[StateInit]
action = """
triggerValCode = 16
baseMeasTime = 30.0
deltaOffset = 0.0
deltaSlope = 1.0

numSamples = int(editParamDict["numSamples"])
preTriggerTime = float(editParamDict["preTriggerTime"])
postTriggerTime = float(editParamDict["postTriggerTime"])
#thresRatio = float(editParamDict["thresRatio"]) * 0.01
thresRatio = float(editParamDict["thresRatio"])
waitTime = float(editParamDict["waitTime"])

from collections import deque
def calcArea(timeList, concList):
    # Calculate the trapezoidal area
    totalArea = 0.0
    for idx in range(len(timeList)-1):
        totalArea += 0.5*(concList[idx] + concList[idx+1])*(timeList[idx+1] - timeList[idx])
    totalTime = timeList[-1] - timeList[0]
    return totalArea, totalTime

setMeasBuffer("analyze_iCO2", ["12CO2", "13CO2", "Delta_Raw"], 50)
clearMeasBuffer()
sampleNum = 0
GUI.setStatusText("")
GUI.popPause("Press \'OK\' to start processing samples")
NEXT = "StateStartSample"
"""

[StateStartSample]
action = """
sampleNum += 1
if sampleNum <= numSamples:
    # Trigger Front-end
    #setFanState(1)
    #sleep(5.0)
    #setFanState(1)
    #sleep(5.0)
    #setFanState(0)
    wrDasReg("FAN_CNTRL_TEMPERATURE_REGISTER", -10.0)
    sleep(30.0)
    wrDasReg("FAN_CNTRL_TEMPERATURE_REGISTER", 80.0)
    CO2_12BaseBuff = []
    CO2_13BaseBuff = []
    clearMeasBuffer()
    baseEndTime = time.time() + baseMeasTime
    logFunc("Taking baseline measurement for %.2f seconds...\n" % baseMeasTime)
    NEXT = "StateGetBaseMeas"
else:
    NEXT = "StateDone"
"""

[StateGetBaseMeas]
action = """
# Get base concentration
currTime = time.time()
if currTime < baseEndTime:
    results = measGetBufferFirst()
    if not results:
        sleep(0.5)
        NEXT="StateGetBaseMeas"
    else:
        CO2_12BaseBuff.append(results["12CO2"])
        CO2_13BaseBuff.append(results["13CO2"])
        NEXT="StateGetBaseMeas"
else:
    measCO2_12Base = abs(mean(CO2_12BaseBuff))
    measCO2_13Base = abs(mean(CO2_13BaseBuff))
    logFunc("Base measurement: 12CO2 = %.3f, 13CO2 = %.3f\n" % (measCO2_12Base, measCO2_13Base))
    threshold = thresRatio
    #threshold = 10+(measCO2_12Base * thresRatio)
    logFunc("Threshold = %.3f\n" % threshold)
    peakNum = 1
    # De-trigger combustion module
    # setValveMask(0)
    NEXT = "StatePrePulseAnalysis"
"""

[StatePrePulseAnalysis]
action = """
timeBuffer = deque()
CO2_12Buffer = deque()
CO2_13Buffer = deque()
DeltaBuffer = deque()
clearMeasBuffer()
status = "armed"
lastStatus = ""
endWaitingTime = time.time() + waitTime
logFunc("Detecting Pulses...\n")
NEXT = "StatePulseAnalysis"
"""

[StatePulseAnalysis]
action = """
currTime = time.time()
results = measGetBufferFirst()
if not results:
    sleep(1.0)
    NEXT="StatePulseAnalysis"
else:
    timeBuffer.append(results["measTime"])
    CO2_12Buffer.append(results["12CO2"])
    CO2_13Buffer.append(results["13CO2"])
    DeltaBuffer.append(results["Delta_Raw"])
    if lastStatus != status:
        logFunc("Pulse analyzer new status = %s\n" % status)
    if status == "armed":
        lastStatus = "armed"
        while timeBuffer[0] < (timeBuffer[-1] - preTriggerTime):
            timeBuffer.popleft()
            CO2_12Buffer.popleft()
            CO2_13Buffer.popleft()
            DeltaBuffer.popleft()
        if CO2_12Buffer[-1] >= threshold:
            status = "triggered"
            NEXT="StatePulseAnalysis"
        elif currTime > endWaitingTime:
            NEXT="StateStartSample"
    elif status == "triggered":
        lastStatus = "triggered"
        if CO2_12Buffer[-1] < threshold:
            endTime = time.time() + postTriggerTime
            status = "extended"
        NEXT="StatePulseAnalysis"
    elif status == "extended":
        lastStatus = "extended"
        if time.time() > endTime:
            NEXT="StatePostPulseAnalysis"
        else:
            NEXT="StatePulseAnalysis"
"""

[StatePostPulseAnalysis]
action = """
currTime = time.time()
startTime = timeBuffer[0]
endTime = timeBuffer[-1]
setLineMarkerColor("red", startTime)
setLineMarkerColor(None, endTime)
results = {}
results["startTime"] = time.strftime("%Y/%m/%d %H:%M:%S", time.localtime(startTime))
results["endTime"] = time.strftime("%Y/%m/%d %H:%M:%S", time.localtime(endTime))
results["numPoints"] = len(CO2_12Buffer)
CO2_12Base = min(measCO2_12Base, min(CO2_12Buffer))
CO2_13Base = min(measCO2_13Base, min(CO2_13Buffer))
#CO2_12Buffer = array(CO2_12Buffer)-CO2_12Base
#CO2_13Buffer = array(CO2_13Buffer)-CO2_13Base
CO2_12Buffer = array(CO2_12Buffer)
CO2_13Buffer = array(CO2_13Buffer)
CO2_12_Delta = array(CO2_12Buffer)*array(DeltaBuffer)
CO2_12_Max = max(CO2_12Buffer)
int12CO2, timeInterval = calcArea(timeBuffer, CO2_12Buffer)
int13CO2 = calcArea(timeBuffer, CO2_13Buffer)[0]
int12CO2Delta = calcArea(timeBuffer, CO2_12_Delta)[0]
crdsDelta = int12CO2Delta/int12CO2
delta13C = (((int13CO2/int12CO2)-0.0111802)/0.0111802)*1000
delta13C = deltaOffset + delta13C*deltaSlope
results["int12CO2"] = int12CO2
results["int13CO2"] = int13CO2
results["delta13C"] = delta13C
results["crdsDelta"] = crdsDelta
results["CO2_12Base"] = CO2_12Base
results["CO2_13Base"] = CO2_13Base
results["CO2_12_Max"] = CO2_12_Max
results["timeInterval"] = timeInterval
results["peakNum"] = peakNum
results["sampleNum"] = sampleNum
results["threshold"] = threshold
fileDataFunc(results)
peakNum += 1
currTime = time.time()
nextPulseTime = endWaitingTime - currTime
logFunc("The current run will end in %.2f seconds\n" % nextPulseTime)
NEXT="StateWaitForNextPulse"
"""

[StateWaitForNextPulse]
action = """
currTime = time.time()
if currTime > endWaitingTime:
    NEXT="StateStartSample"
else:
    sleep(1.0)
    NEXT="StateWaitForNextPulse"
"""

[StateDone]
action="""
# setValveMask(0)
logFunc("Done!")
"""

[StateError]
action="""
logFunc("Error %s in state %s\n" % (ERROR_MSG,ERROR_STATE))
NEXT = "StateDone"
"""
