# 2010-02-17 alex  In this verion an external pressure sensor reading is used to replace the analyzer pressure sensor. Need to install USB driver before running this script.
#                               If the external pressure sensor is not found, the analyzer inlet pressure sensor will be used instead.
# 2010-02-18 alex  Added measurement statistics and pre- and post-measurement time period. Note: new host software needs to be installed for timestamp reporting.
# 2010-04-09 alex  Added integrator to calculates the area during each measurement.
# 2010-04-13 alex  Added flow meter reading.
# 2010-04-14 alex  Added cubic spline function. Showed remaining time of measurement.
# 2010-04-15 alex  Added base concentration correction

[UserEditableParams]

[Mode]
inject_mode=automatic

[Files]
output = "C:\DilutionData\Dilution"

[Output]
quality         = "Quality"                 , %10s
sampleCO2       = "CO2"                     , %14.3f
sampleCO        = "CO"                     , %14.3f
sampleH2O       = "H2O"                     , %14.3f
mixRatio        = "Mix Ratio"               , %10s
resultTime      = "Date/Time"               , %15s
meanTime        = "Timestamp"               , %14.5f
aveFlow         = "Average Flow Rate"       , %14.3f
pressureBase    = "Baseline Pressure"       , %14.3f
pressureSample  = "Sample Pressure"         , %14.3f
pressureBuffer  = "Buffer Pressure"         , %14.3f
pressureSprdSmp = "Spread Sample Pressure"  , %14.3f
sampleSplineCO2 = "Spline CO2"              , %14.3f
sampleSplineCO  = "Spline CO"              , %14.3f
sampleSplineH2O = "Spline H2O"              , %14.3f
rawIntegCO2     = "Raw Integ CO2"           , %14.3f
rawIntegCO      = "Raw Integ CO"           , %14.3f
rawIntegH2O     = "Raw Integ H2O"           , %14.3f
integCO2        = "Integ CO2"               , %14.3f
integCO         = "Integ CO"               , %14.3f
integH2O        = "Integ H2O"               , %14.3f
splineCO2       = "Spline CO2"              , %14.3f
splineCO        = "Spline CO"              , %14.3f
splineH2O       = "Spline H2O"              , %14.3f
maxCO2          = "Max CO2"                 , %14.3f
maxCO           = "Max CO"                 , %14.3f
maxH2O          = "Max H2O"                 , %14.3f
baseCO2         = "Base CO2"                , %14.3f
baseCO          = "Base CO"                , %14.3f
baseH2O         = "Base H2O"                , %14.3f
timeInterval    = "Time Interval"           , %14.3f
numPoints       = "Num Data Points"         , %3d
dilutionVolume  = "Dilution Volume"         , %14.3f

[Setup]
initial = StateFindExternalSensor
final = StateDone
error = StateError

[StateFindExternalSensor]
action = """
logFunc("Searching external sensor (to measure pressure and flow rate)...\n")
voltList = [1.0, 1.9, 2.67, 3.27, 3.75, 4.17, 4.5, 4.8, 5.0]
flowList = [0.0, 25.0, 50.0, 75.0, 100.0, 125.0, 150.0, 175.0, 200.0]
flowFitFunc = polyfit(voltList, flowList, 3)
ExtPressureCal = 784
externalSensor = None
externalSensorFound = False
for p in range(100):
    if externalSensor:
        externalSensor.close()
        externalSensor = None
    try:
        externalSensor = SerIntrf(p, timeout=1, xonxoff=0)
        sleep(3)
    except:
        continue
    try:
        externalSensor.sendString("us")
        status = externalSensor.getLine()
        if "ok" in status:
            logFunc("External sensor found at COM%d...\n"%(p+1))
            externalSensorFound = True
            break
    except:
        pass

if not externalSensorFound:
    logFunc("External sensor (pressure sensor and flow meter) not found.\n")
    if externalSensor:
        externalSensor.close()
        externalSensor = None
    raise Exception, "External sensor (pressure sensor and flow meter) not available"

def getPressure():
    if externalSensor:
        try:
            # Need to read twice due to a hardware issue
            externalSensor.sendString("u7")
            pressureReading = float(externalSensor.getLine())
            externalSensor.sendString("u7")
            pressureReading = float(externalSensor.getLine())
            pResult = pressureReading*ExtPressureCal
            logFunc("Pressure read from external sensor = %.3f Torr\n" % pResult)
            return pResult
        except:
            logFunc("Pressure sensor not available\n")
            raise Exception, "Pressure sensor not available"
    else:
        logFunc("Pressure sensor not available\n")
        raise Exception, "Pressure sensor not available"

def getFlow():
    if externalSensor:
        try:
            externalSensor.sendString("f0")
            flowVoltageReading = float(externalSensor.getLine())
            #logFunc("Flow meter voltage read from external sensor = %.3f v\n" % flowVoltageReading)
            fResult = max(0.0, polyval(flowFitFunc, flowVoltageReading))
            #logFunc("Flow rate read from external sensor = %.3f SCCM\n" % fResult)
            return fResult
        except:
            logFunc("Flow meter not available\n")
            raise Exception, "Flow rate not available"
    else:
        logFunc("Flow meter not available\n")
        raise Exception, "Flow meter not available"

NEXT = "StateInitConfig"
"""

[StateInitConfig]
action = """
evacuateTime    = 30
pumpOutTime     = 60
sampleTime      = 10
dilutionTime    = 10
mixTime         = 40
preMeasTime     = 10
measTime        = 600
postMeasTime    = 5
ambientPressure = 760

def calcArea(timeList, concList):
    # Calculate the trapezoidal area
    totalArea = 0.0
    for idx in range(len(timeList)-1):
        totalArea += 0.5*(concList[idx] + concList[idx+1])*(timeList[idx+1] - timeList[idx])
    totalTime = timeList[-1] - timeList[0]
    return totalArea, totalTime

# Define FITTER
setMeasBuffer("analyze_CFADS", ["co2_conc", "co_conc", "h2o_conc"], 50)
clearMeasBuffer()
GUI.setStatusText("")

# Initial values
CO2Base = 0.0
COBase = 0.0
H2OBase = 0.0

# Constants
secPerMin = 60
dilutionVolume = 75.0
atmPressure = 760.0
integConvFactor = atmPressure/secPerMin/dilutionVolume
timeFormat = "%y/%m/%d %H:%M:%S"
ConcBranchTime = measTime
# Limit break points correspond approximately 1500 and 15000 ppmv CO2 (no longer 1000 and 10000)
#  This is so that max peak values are between 100 and 1000 ppmv at analyzer.
LowerLimit100 = 10000
LowerLimit10 = 1000
# ratio of actual volumes in max dilution; volumes cav1/cav3 in cc from Josh 2010 03 11
#HighMixRatio = 77.1/0.769
HighMixRatio = 100.0
# ratio of actual volumes in middle dilution; volumes (cav1+cav2)/cav3 in cc from Josh 2010 03 11
#MedMixRatio = 77.1/(0.769+6.91)
MedMixRatio = 10.0
# no dilution => ratio = 1
NoMixRatio = 1.0
mixRatio = HighMixRatio
sampleBagHooked = False
sampleValveOpen = False
setValveMask(8)
logFunc("PLEASE HOOK UP SAMPLE BAG WITH VALVE CLOSED AND CONTINUE...\n")
pauseStartTime = time.time()
pause()
NEXT = "StatePauseOrGo"
"""

[StatePauseOrGo]
action="""
if runningFlag:
    currTime = time.time()
    if not sampleBagHooked:
        sampleBagHooked = True
        NEXT = "StatePumpAndPurge"
    elif not sampleValveOpen:
        sampleValveOpen = True
        setValveMask(4)
        sleep(5)
        logFunc("Base pressure: ")
        pressureBase = getPressure()
        setValveMask(5)
        sampleEndTime = time.time() + sampleTime
        NEXT = "StateSample"
else:
    sleep(1)
    pauseDur = time.time() - pauseStartTime
    if pauseDur > 3600:
        NEXT = "StateDone"
    else:
        NEXT = "StatePauseOrGo"
"""

[StatePumpAndPurge]
action="""
# setValveMask(14) is for unattended testing automation (bag valve always open).  Use mask 15 for real application.
#setValveMask(14)
setValveMask(15)
# Do rough pump out before purge:
sleep(pumpOutTime/2)
# setValveMask(6) for unattended testing automation (bag valve always open).  Use mask 7 for real application
#setValveMask(6)
setValveMask(7)
sleep(2)

# setValveMask(38) for unattended testing automation (bag valve always open).  Use mask 39 for real application
#setValveMask(38)
setValveMask(39)
# Purge:
#sleep(dilutionTime)
sleep(pumpOutTime/2)
setValveMask(6)
sleep(2)
# Start full pump out:
setValveMask(14)
pumpOutEndTime = time.time() + pumpOutTime
sleep(pumpOutTime/4)
# setValveMask(14) is for unattended testing automation (bag valve always open).  Use mask 15 for real application.
#setValveMask(14)
setValveMask(15)
logFunc("\nPumping out...\n")
NEXT = "StatePumpOut"
"""

[StatePumpOut]
action = """
currTime = time.time()
if currTime < pumpOutEndTime:
    sleep(1.0)
    NEXT="StatePumpOut"
elif not sampleValveOpen:
    logFunc("Check pressure: ")
    checkPressure = getPressure()
# check if pump out is near complete, wait another 5 sec before closing valves and measuring base pressure
# or continue pumping if not low enough yet, or break if time-out (defined as an additional pumpOutTime)
    sleep(5)
    if checkPressure > 5:
        if currTime < pumpOutEndTime + pumpOutTime:
            NEXT = "StatePumpOut"
        else:
            logFunc("Pump out time out.  Check gas handling system.\n")
            NEXT = "StateDone"
    else:
        # Check two base pressure when V1 still open (sample valve closed) and make sure they are not far away from each other
        pressureBaseCheck1 = getPressure()
        sleep(20)
        pressureBaseCheck2 = getPressure()
        logFunc("Leak Check: %.3f\n" % (pressureBaseCheck2-pressureBaseCheck1))
        setValveMask(14)
        sleep(5)
        logFunc("Check pressure: ")
        getPressure()
        logFunc("PLEASE OPEN SAMPLE BAG VALVE AND CONTINUE...\n")
        pauseStartTime = time.time()
        pause()
        NEXT = "StatePauseOrGo"
else:
    setValveMask(6)
    logFunc("Base pressure: ")
    pressureBase = getPressure()
    if mixRatio == MedMixRatio:
        setValveMask(2)
        sleep(2)
        setValveMask(3)
    else:
        setValveMask(6)
        sleep(2)
        setValveMask(7)
    sampleEndTime = time.time() + sampleTime
    NEXT="StateSample"
"""

[StateSample]
action = """
quality = ""
sleep(sampleTime)
if mixRatio == NoMixRatio:
    setValveMask(6)
    sleep(10)
    logFunc("Sample pressure: ")
    pressureSample = getPressure()
    pressureSpreadSample = pressureSample
    pressureBuffer = pressureSample
#    Bypass buffer gas fill when NoMixRatio:
    NEXT="StatePreMeas"
else:
    if mixRatio == HighMixRatio:
        setValveMask(4)
    elif mixRatio == MedMixRatio:
        setValveMask(2)
    sleep(5)
    logFunc("Sample pressure: ")
    pressureSample = getPressure()
    if pressureSample < ambientPressure/2:
    # If sample pressure is low (not enough sample) then draw in whole sample
        logFunc("Sample pressure is low.  Using more sample.\n")
        quality = "Pressure Low"
        setValveMask(7)
        mixRatio = NoMixRatio
        sleep(sampleTime)
    setValveMask(6)
    sleep(10)
    logFunc("Spread sample pressure: ")
    pressureSpreadSample = getPressure()
    if mixRatio == NoMixRatio:
        pressureSample = pressureSpreadSample
    NEXT="StateMix"
"""

[StateMix]
action = """
# pulse buffer gas for as short as possible (twice), then continue filling to capacity =>
setValveMask(38)
sleep(0.1)
setValveMask(6)
sleep(2)
setValveMask(38)
sleep(0.1)
setValveMask(6)
sleep(2)
setValveMask(38)
sleep(dilutionTime)
logFunc("Buffer pressure: ")
pressureBuffer = getPressure()
setValveMask(0)
mixEndTime = time.time() + mixTime
CO2BaseBuff = []
COBaseBuff = []
H2OBaseBuff = []
clearMeasBuffer()
logFunc("\nMixing gas and taking base measurement...\n")
NEXT = "StateGetBaseMeas"
"""

[StateGetBaseMeas]
action = """
# Get base concentration
currTime = time.time()
if currTime < mixEndTime:
    results = measGetBufferFirst()
    if not results:
        sleep(0.5)
        NEXT="StateGetBaseMeas"
    else:
        CO2BaseBuff.append(results["co2_conc"])
        COBaseBuff.append(results["co_conc"])
        H2OBaseBuff.append(results["h2o_conc"])
        NEXT="StateGetBaseMeas"
else:
    CO2Base = mean(CO2BaseBuff)
    COBase = mean(COBaseBuff)
    H2OBase = mean(H2OBaseBuff)
    logFunc("\nBase measurement: CO2 = %.3f, CO = %.3f, H2O = %.3f\n" % (CO2Base, COBase, H2OBase))
    NEXT = "StatePreMeas"
"""

[StatePreMeas]
action = """
setValveMask(54)
sleep(preMeasTime)
timeBuffer = []
CO2Buffer = []
COBuffer = []
H2OBuffer = []
flowBuffer = []
clearMeasBuffer()
timeMark = time.time()
measEndTime = timeMark + measTime
ConcBranchEndTime = timeMark + ConcBranchTime
timeCount = 0
logFunc("\nStart measurement...\n")
logFunc("Starting time = %s\n" % time.strftime("%Y-%m-%d %H:%M:%S",time.localtime()))
NEXT = "StateMeas"
"""

[StateMeas]
action = """
currTime = time.time()
if currTime - timeMark >= 30:
    timeCount += 1
    logFunc("Remaining time of measurement = %.1f seconds...\n" % (measTime-timeCount*30.0) )
    timeMark = currTime

if currTime < measEndTime:
    results = measGetBufferFirst()
    if not results:
        sleep(1.0)
        NEXT="StateMeas"
    else:
        timeBuffer.append(results["measTime"])
        CO2Buffer.append(results["co2_conc"])
        COBuffer.append(results["co_conc"])
        H2OBuffer.append(results["h2o_conc"])
        flowBuffer.append(getFlow())
        #if (currTime>ConcBranchEndTime) and (mixRatio == HighMixRatio) and (mean(CO2Buffer) < LowerLimit100):
        #   NEXT="StatePostMeas"
        #else:
        #   NEXT="StateMeas"
        NEXT="StateMeas"
else:
    logFunc("\nFinish measurement...\n")
    NEXT = "StatePostMeas"
"""

[StatePostMeas]
action = """
startTime = timeBuffer[0]
endTime = timeBuffer[-1]
setLineMarkerColor("red", startTime)
setLineMarkerColor(None, endTime)
results = {}
results["meanTime"] = mean(timeBuffer)
results["mixRatio"] = mixRatio
numPoints = len(CO2Buffer)
CO2Base = min(CO2Base, min(CO2Buffer))
COBase = min(COBase, min(COBuffer))
H2OBase = min(H2OBase, min(H2OBuffer))
CO2Buffer = array(CO2Buffer)-CO2Base
COBuffer = array(COBuffer)-COBase
H2OBuffer = array(H2OBuffer)-H2OBase
flowBuffer = array(flowBuffer)
calCO2Buffer = CO2Buffer*flowBuffer
calCOBuffer = COBuffer*flowBuffer
calH2OBuffer = H2OBuffer*flowBuffer
integCO2, timeInterval = calcArea(timeBuffer, calCO2Buffer)
integCO = calcArea(timeBuffer, calCOBuffer)[0]
integH2O = calcArea(timeBuffer, calH2OBuffer)[0]
rawIntegCO2 = calcArea(timeBuffer, CO2Buffer)[0]
rawIntegCO = calcArea(timeBuffer, COBuffer)[0]
rawIntegH2O = calcArea(timeBuffer, H2OBuffer)[0]
newTime, newCO2 = cubicSpline(timeBuffer, calCO2Buffer, 1200)
newTime, newCO = cubicSpline(timeBuffer, calCOBuffer, 1200)
newTime, newH2O = cubicSpline(timeBuffer, calH2OBuffer, 1200)
splineCO2 = calcArea(newTime, newCO2)[0]
splineCO = calcArea(newTime, newCO)[0]
splineH2O = calcArea(newTime, newH2O)[0]
aveFlow = mean(flowBuffer)
maxCO2 = max(CO2Buffer)
maxCO = max(COBuffer)
maxH2O = max(H2OBuffer)
#BackRatio = (pressureBuffer-pressureBase)/(pressureSpreadSample-pressureBase)
BackRatio = integConvFactor/(pressureSpreadSample-pressureBase)
sampleCO2 = integCO2 * BackRatio
sampleCO = integCO * BackRatio
sampleH2O = integH2O * BackRatio
sampleSplineCO2 = splineCO2 * BackRatio
sampleSplineCO = splineCO * BackRatio
sampleSplineH2O = splineH2O * BackRatio
resultTime = time.strftime(timeFormat, time.localtime(mean(timeBuffer)))
results["rawIntegCO2"] = rawIntegCO2
results["rawIntegCO"] = rawIntegCO
results["rawIntegH2O"] = rawIntegH2O
results["integCO2"] = integCO2
results["integCO"] = integCO
results["integH2O"] = integH2O
results["splineCO2"] = splineCO2
results["splineCO"] = splineCO
results["splineH2O"] = splineH2O
results["timeInterval"] = timeInterval
results["aveFlow"] = aveFlow
results["baseCO2"] = CO2Base
results["baseCO"] = COBase
results["baseH2O"] = H2OBase
results["sampleCO2"] = sampleCO2
results["sampleCO"] = sampleCO
results["sampleH2O"] = sampleH2O
results["sampleSplineCO2"] = sampleSplineCO2
results["sampleSplineCO"] = sampleSplineCO
results["sampleSplineH2O"] = sampleSplineH2O
results["maxCO2"] = maxCO2
results["maxCO"] = maxCO
results["maxH2O"] = maxH2O
results["numPoints"] = numPoints
results["pressureBase"] = pressureBase
results["pressureSample"] = pressureSample
results["pressureBuffer"] = pressureBuffer
results["pressureSprdSmp"] = pressureSpreadSample
results["resultTime"] = resultTime
results["dilutionVolume"] = dilutionVolume

# Add post-measurement idle time here
sleep(postMeasTime)
if (mixRatio == HighMixRatio) and (sampleCO2 < LowerLimit100):
    if sampleCO2 >= LowerLimit10:
        mixRatio = MedMixRatio
        logFunc("\nRun 1/10 Mixing loop...\n")
    else:
        mixRatio = NoMixRatio
        logFunc("\nRun No Mixing loop...\n")
    if quality != "Pressure Low":
        quality = "Trial"
    results["quality"] = quality
    fileDataFunc(results)
    setValveMask(0)
    sleep(2)
#    setValveMask(8)
#    sleep(pumpOutTime-15)
    setValveMask(14)
    pumpOutEndTime = time.time() + pumpOutTime
    NEXT = "StatePumpOut"
else:
    if quality != "Pressure Low":
        quality = "Good"
    results["quality"] = quality
    fileDataFunc(results)
    logFunc("\nSample bag finished...\n")
    mixRatio = HighMixRatio
    sampleBagHooked = False
    sampleValveOpen = False
    setValveMask(8)
    logFunc("PLEASE HOOK UP SAMPLE BAG WITH VALVE CLOSED AND CONTINUE...\n")
    pauseStartTime = time.time()
    pause()
    NEXT = "StatePauseOrGo"
"""

[StateDone]
action="""
setValveMask(0)
if externalSensor:
    externalSensor.close()
logFunc("Done!")
"""

[StateError]
action="""
logFunc("Error %s in state %s\n" % (ERROR_MSG,ERROR_STATE))
NEXT = "StateDone"
"""
