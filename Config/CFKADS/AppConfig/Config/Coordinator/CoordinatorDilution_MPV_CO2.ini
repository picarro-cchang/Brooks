# 2010-02-17 alex  In this verion an external pressure sensor reading is used to replace the analyzer pressure sensor. Need to install USB driver before running this script.
#                               If the external pressure sensor is not found, the analyzer inlet pressure sensor will be used instead.
# 2010-02-18 alex  Added measurement statistics and pre- and post-measurement time period. Note: new host software needs to be installed for timestamp reporting.
# 2010-04-09 alex  Added integrator to calculates the area during each measurement.
# 2010-04-13 alex  Added flow meter reading.
# 2010-04-14 alex  Added cubic spline function. Showed remaining time of measurement.
# 2010-04-15 alex  Added base concentration correction
# 2010-04-20 alex  Run standard as many times as each sample. Increase the port evacuation time.

[UserEditableParams]
num_disp_params = 0
0 = "standardCO2", "Standard CO2 Concentration", ""
1 = "numSamples", "Number of Sample Ports (between 1 and 7)", "1"
2 = "repeatedMeas", "Number of Repeats per Sample (between 1 and 5)", "1"
3 = "measurementMode", "Measurement Mode: 1=One Time; 2=Continuous Loop", "2"

[Mode]
inject_mode=automatic

[Files]
output = "C:\DilutionData\Dilution"

[SerialPorts]
RotValve = COM2

[Output]
source          = "Source"                  , %10s
quality         = "Quality"                 , %10s
corrCO2         = "Corrected CO2"           , %14.3f
sampleCO2       = "CO2"                     , %14.3f
sampleCH4       = "CH4"                     , %14.3f
sampleH2O       = "H2O"                     , %14.3f
mixRatio        = "Mix Ratio"               , %10s
resultTime      = "Date/Time"               , %15s
meanTime        = "Timestamp"               , %14.5f
aveFlow         = "Average Flow Rate"       , %14.3f
pressureBase    = "Baseline Pressure"       , %14.3f
pressureSample  = "Sample Pressure"         , %14.3f
pressureBuffer  = "Buffer Pressure"         , %14.3f
pressureSprdSmp = "Spread Sample Pressure"  , %14.3f
sampleSplineCO2 = "Spline CO2"              , %14.3f
sampleSplineCH4 = "Spline CH4"              , %14.3f
sampleSplineH2O = "Spline H2O"              , %14.3f
rawIntegCO2     = "Raw Integ CO2"           , %14.3f
rawIntegCH4     = "Raw Integ CH4"           , %14.3f
rawIntegH2O     = "Raw Integ H2O"           , %14.3f
integCO2        = "Integ CO2"               , %14.3f
integCH4        = "Integ CH4"               , %14.3f
integH2O        = "Integ H2O"               , %14.3f
splineCO2       = "Spline CO2"              , %14.3f
splineCH4       = "Spline CH4"              , %14.3f
splineH2O       = "Spline H2O"              , %14.3f
maxCO2          = "Max CO2"                 , %14.3f
maxCH4          = "Max CH4"                 , %14.3f
maxH2O          = "Max H2O"                 , %14.3f
baseCO2         = "Base CO2"                , %14.3f
baseCH4         = "Base CH4"                , %14.3f
baseH2O         = "Base H2O"                , %14.3f
timeInterval    = "Time Interval"           , %14.3f
numPoints       = "Num Data Points"         , %3d
dilutionVolume  = "Dilution Volume"         , %14.3f
standardCO2     = "Standard CO2"            , %14.3f

[PostProcessing]
type = dilutionCorr
output = C:\DilutionData\Corrected\
dilution = CO2

[Setup]
initial = StateFindExternalSensor
final = StateDone
error = StateError

[StateFindExternalSensor]
action = """
logFunc("Searching external sensor (to measure pressure and flow rate)...\n")
voltList = [1.0, 1.9, 2.67, 3.27, 3.75, 4.17, 4.5, 4.8, 5.0]
flowList = [0.0, 25.0, 50.0, 75.0, 100.0, 125.0, 150.0, 175.0, 200.0]
flowFitFunc = polyfit(voltList, flowList, 3)
ExtPressureCal = 784
externalSensor = None
externalSensorFound = False
rotValve = None
for p in range(100):
    if externalSensor:
        externalSensor.close()
        externalSensor = None
    try:
        externalSensor = SerIntrf(p, timeout=1, xonxoff=0)
        sleep(3)
    except:
        continue
    try:
        externalSensor.sendString("us")
        status = externalSensor.getLine()
        if "ok" in status:
            logFunc("External sensor found at COM%d...\n"%(p+1))
            externalSensorFound = True
            break
    except:
        pass

if not externalSensorFound:
    logFunc("External sensor (pressure sensor and flow meter) not found.\n")
    if externalSensor:
        externalSensor.close()
        externalSensor = None
    raise Exception, "External sensor (pressure sensor and flow meter) not available"

def getPressure():
    if externalSensor:
        try:
            # Need to read twice due to a hardware issue
            externalSensor.sendString("u7")
            pressureReading = float(externalSensor.getLine())
            externalSensor.sendString("u7")
            pressureReading = float(externalSensor.getLine())
            pResult = pressureReading*ExtPressureCal
            logFunc("Pressure read from external sensor = %.3f Torr\n" % pResult)
            return pResult
        except:
            logFunc("Pressure sensor not available\n")
            raise Exception, "Pressure sensor not available"
    else:
        logFunc("Pressure sensor not available\n")
        raise Exception, "Pressure sensor not available"

def getFlow():
    if externalSensor:
        try:
            externalSensor.sendString("f0")
            flowVoltageReading = float(externalSensor.getLine())
            #logFunc("Flow meter voltage read from external sensor = %.3f v\n" % flowVoltageReading)
            fResult = max(0.0, polyval(flowFitFunc, flowVoltageReading))
            #logFunc("Flow rate read from external sensor = %.3f SCCM\n" % fResult)
            return fResult
        except:
            logFunc("Flow meter not available\n")
            raise Exception, "Flow rate not available"
    else:
        logFunc("Flow meter not available\n")
        raise Exception, "Flow meter not available"

NEXT = "StateInitConfig"
"""

[StateInitConfig]
action = """
standardCO2 = float(editParamDict["standardCO2"])
numUsedPorts = 1 + max(0, min(7, int(editParamDict["numSamples"])))
repeatedMeas = max(1, min(5, int(editParamDict["repeatedMeas"])))
measurementMode = editParamDict["measurementMode"]
if measurementMode not in ["1", "2"]:
    measurementMode = "2"
evacuateTime    = 30
pumpOutTime     = 60
sampleTime      = 10
dilutionTime    = 10
mixTime         = 40
preMeasTime     = 10
measTime        = 600
postMeasTime    = 5
ambientPressure = 760

def calcArea(timeList, concList):
    # Calculate the trapezoidal area
    totalArea = 0.0
    for idx in range(len(timeList)-1):
        totalArea += 0.5*(concList[idx] + concList[idx+1])*(timeList[idx+1] - timeList[idx])
    totalTime = timeList[-1] - timeList[0]
    return totalArea, totalTime

# Define FITTER
setMeasBuffer("analyze_CFADS", ["co2_conc", "ch4_conc", "h2o_conc"], 50)
clearMeasBuffer()
GUI.setStatusText("")

# COM2 for rotary valve (RS-232)
try:
    # Use COM1 for now
    #rotValve = SerIntrf(0, baudrate=9600, xonxoff=0, timeout=1.0)
    rotValve = SerIntrf(portDict["RotValve"], baudrate=9600, xonxoff=0, timeout=1.0)
    rotValve.open()
    errorCodeFailSend = 128
except Exception, err:
    logFunc("Multi-port valve NOT enabled correctly.\n")
    if rotValve:
        try:
            rotValve.close()
        except:
            pass
        rotValve = None
    raise Exception, "Multi-port valve NOT enabled correctly.\n"

def readValvePos():
    try:
        rotValve.sendString("CP")
        cp = rotValve.getLine()
        currPos = cp.split("= ")[-1].strip()
        logFunc("Current multi-port valve position is %s\n" % currPos)
        return currPos
    except:
        raise Exception, "Multi-port valve NOT enabled correctly.\n"

def moveRotValve(targetPos):
    timeOut = 40
    startTime = time.time()
    if rotValve:
        currPos = readValvePos()
        while currPos != targetPos:
            if (time.time() - startTime) < timeOut:
                try:
                    logFunc("Multi-port valve: Go to position: %2s\n" % targetPos)
                    rotValve.sendString("GO%s" % targetPos)
                    setRotValveMask(targetPos)
                    sleep(3)
                    currPos = readValvePos()
                except:
                    logFunc("Multi-port valve: Failed to send valve position command\n")
                    setRotValveMask(errorCodeFailSend)
            else:
                logFunc("Error: Can't drive multi-port valve to desired port\n")
                break
    else:
        logFunc("Multi-port valve NOT enabled correctly.\n")

# Try to communicate with rotary valve
readValvePos()

# Initial values
CO2Base = 0.0
CH4Base = 0.0
H2OBase = 0.0
targetPort = 2
numMeasCompleted = 0
source = "Standard"
runLastStandard = False
stopCoordinatorCnt = repeatedMeas

# Constants
secPerMin = 60
dilutionVolume = 75.0
atmPressure = 760.0
integConvFactor = atmPressure/secPerMin/dilutionVolume
timeFormat = "%y/%m/%d %H:%M:%S"
ConcBranchTime = measTime
# Limit break points correspond approximately 1500 and 15000 ppmv CO2 (no longer 1000 and 10000)
#  This is so that max peak values are between 100 and 1000 ppmv at analyzer.
LowerLimit100 = 10000
LowerLimit10 = 1000
# ratio of actual volumes in max dilution; volumes cav1/cav3 in cc from Josh 2010 03 11
#HighMixRatio = 77.1/0.769
HighMixRatio = 100.0
# ratio of actual volumes in middle dilution; volumes (cav1+cav2)/cav3 in cc from Josh 2010 03 11
#MedMixRatio = 77.1/(0.769+6.91)
MedMixRatio = 10.0
# no dilution => ratio = 1
NoMixRatio = 1.0
mixRatio = HighMixRatio
sampleBagHooked = False
sampleValveOpen = False
setValveMask(8)
logFunc("PLEASE HOOK UP STANDARD GAS AND SAMPLE BAGS WITH VALVES CLOSED AND SELECT \"RESUME\" UNDER \"CONTROL\" TO CONTINUE...\n")
pauseStartTime = time.time()
pause()
NEXT = "StatePauseOrGo"
"""

[StatePauseOrGo]
action="""
if runningFlag:
    currTime = time.time()
    if not sampleBagHooked:
        sampleBagHooked = True
        NEXT = "StateEvacuatePorts"
    elif not sampleValveOpen:
        sampleValveOpen = True
        NEXT = "StatePurge"
else:
    sleep(1)
    pauseDur = time.time() - pauseStartTime
    if pauseDur > 3600:
        NEXT = "StateDone"
    else:
        NEXT = "StatePauseOrGo"
"""

[StateEvacuatePorts]
action = """
# Evacuate each port (1-16)
setValveMask(15)
for port in range(1,17):
    moveRotValve(str(port))
    logFunc("Evacuating port position %d\n" % port)
    sleep(evacuateTime)
moveRotValve("1")
NEXT = "StateOpenValves"
"""

[StateOpenValves]
action = """
# Ask user to open sample bag valves
setValveMask(0)
logFunc("PLEASE OPEN STANDARD GAS VALVE AND ALL THE SAMPLE BAG VALVES AND SELECT \"RESUME\" UNDER \"CONTROL\" TO CONTINUE...\n")
pauseStartTime = time.time()
pause()
NEXT = "StatePauseOrGo"
"""

[StatePurge]
action="""
moveRotValve(str(targetPort-1))
sleep(2)
logFunc("\nPurging...\n")
# Start pre-pump-out
setValveMask(15)
sleep(pumpOutTime/2)
setValveMask(7)
sleep(2)
setValveMask(39)
# Purge:
#sleep(dilutionTime)
sleep(pumpOutTime/2)
setValveMask(7)
sleep(2)
# Start full pump out:
setValveMask(15)
pumpOutEndTime = time.time() + pumpOutTime
logFunc("\nPumping out...\n")
NEXT = "StatePumpOut"
"""

[StatePumpOut]
action = """
currTime = time.time()
if currTime < pumpOutEndTime:
    sleep(1.0)
    NEXT="StatePumpOut"
else:
    newPumpOutEndTime = pumpOutEndTime + pumpOutTime
    logFunc("Check pressure: ")
    checkPressure = getPressure()
# check if pump out is near complete, wait another 5 sec before closing valves and measuring base pressure
# or continue pumping if not low enough yet, or break if time-out (defined as an additional pumpOutTime)
    if checkPressure > 5:
        if currTime < newPumpOutEndTime:
            sleep(1.0)
            NEXT = "StatePumpOut"
        else:
            logFunc("Pump out time out.  Check gas handling system.\n")
            NEXT = "StateDone"
    else:
        # Check two base pressure when V1 still open and make sure they are not far away from each other
        pressureBaseCheck1 = getPressure()
        sleep(20)
        pressureBaseCheck2 = getPressure()
        logFunc("Leak Check: %.3f\n" % (pressureBaseCheck2-pressureBaseCheck1))
        setValveMask(6)
        sleep(5)
        logFunc("Base pressure: ")
        pressureBase = getPressure()
        if mixRatio == HighMixRatio:
            setValveMask(0)
        elif mixRatio == MedMixRatio:
            setValveMask(2)
        else:
            setValveMask(6)
        sleep(2)
        sampleEndTime = time.time() + sampleTime
        logFunc("\nGetting sample into sample loop...\n")
        NEXT="StateSample"
"""

[StateSample]
action = """
quality = ""
moveRotValve(str(targetPort))
if mixRatio == HighMixRatio:
    setValveMask(1)
elif mixRatio == MedMixRatio:
    setValveMask(3)
else:
    setValveMask(7)
sleep(sampleTime)
if mixRatio == NoMixRatio:
    setValveMask(6)
    sleep(10)
    logFunc("Sample pressure: ")
    pressureSample = getPressure()
    pressureSpreadSample = pressureSample
    pressureBuffer = pressureSample
#    Bypass buffer gas fill when NoMixRatio:
    NEXT="StatePreMeas"
else:
    if mixRatio == HighMixRatio:
        setValveMask(4)
    elif mixRatio == MedMixRatio:
        setValveMask(2)
    sleep(5)
    logFunc("Sample pressure: ")
    pressureSample = getPressure()
    if pressureSample < ambientPressure/2:
    # If sample pressure is low (not enough sample) then draw in whole sample
        logFunc("Sample pressure is low.  Using more sample.\n")
        quality = "Pressure Low"
        setValveMask(7)
        mixRatio = NoMixRatio
        sleep(sampleTime)
    setValveMask(6)
    sleep(10)
    logFunc("Spread sample pressure: ")
    pressureSpreadSample = getPressure()
    if mixRatio == NoMixRatio:
        pressureSample = pressureSpreadSample
    NEXT="StateMix"
"""

[StateMix]
action = """
# pulse buffer gas for as short as possible (twice), then continue filling to capacity =>
setValveMask(38)
sleep(0.1)
setValveMask(6)
sleep(2)
setValveMask(38)
sleep(0.1)
setValveMask(6)
sleep(2)
setValveMask(38)
sleep(dilutionTime)
logFunc("Buffer pressure: ")
pressureBuffer = getPressure()
setValveMask(0)
mixEndTime = time.time() + mixTime
CO2BaseBuff = []
CH4BaseBuff = []
H2OBaseBuff = []
clearMeasBuffer()
logFunc("\nMixing gas and taking base measurement...\n")
NEXT = "StateGetBaseMeas"
"""

[StateGetBaseMeas]
action = """
# Get base concentration
currTime = time.time()
if currTime < mixEndTime:
    results = measGetBufferFirst()
    if not results:
        sleep(0.5)
    else:
        CO2BaseBuff.append(results["co2_conc"])
        CH4BaseBuff.append(results["ch4_conc"])
        H2OBaseBuff.append(results["h2o_conc"])
    NEXT="StateGetBaseMeas"
else:
    CO2Base = mean(CO2BaseBuff)
    CH4Base = mean(CH4BaseBuff)
    H2OBase = mean(H2OBaseBuff)
    logFunc("\nBase measurement: CO2 = %.3f, CH4 = %.3f, H2O = %.3f\n" % (CO2Base, CH4Base, H2OBase))
    NEXT = "StatePreMeas"
"""

[StatePreMeas]
action = """
setValveMask(54)
sleep(preMeasTime)
timeBuffer = []
CO2Buffer = []
CH4Buffer = []
H2OBuffer = []
flowBuffer = []
clearMeasBuffer()
timeMark = time.time()
measEndTime = timeMark + measTime
ConcBranchEndTime = timeMark + ConcBranchTime
timeCount = 0
logFunc("\nStart measurement...\n")
logFunc("Starting time = %s\n" % time.strftime("%Y-%m-%d %H:%M:%S",time.localtime()))
NEXT = "StateMeas"
"""

[StateMeas]
action = """
currTime = time.time()
if currTime - timeMark >= 30:
    timeCount += 1
    logFunc("Remaining time of measurement = %.1f seconds...\n" % (measTime-timeCount*30.0) )
    timeMark = currTime

if currTime < measEndTime:
    results = measGetBufferFirst()
    if not results:
        sleep(1.0)
        NEXT="StateMeas"
    else:
        timeBuffer.append(results["measTime"])
        CO2Buffer.append(results["co2_conc"])
        CH4Buffer.append(results["ch4_conc"])
        H2OBuffer.append(results["h2o_conc"])
        flowBuffer.append(getFlow())
        #if (currTime>ConcBranchEndTime) and (mixRatio == HighMixRatio) and (mean(CO2Buffer) < LowerLimit100):
        #   NEXT="StatePostMeas"
        #else:
        #   NEXT="StateMeas"
        NEXT="StateMeas"
else:
    logFunc("\nFinish measurement...\n")
    NEXT = "StatePostMeas"
"""

[StatePostMeas]
action = """
startTime = timeBuffer[0]
endTime = timeBuffer[-1]
setLineMarkerColor("red", startTime)
setLineMarkerColor(None, endTime)
results = {}
results["meanTime"] = mean(timeBuffer)
results["mixRatio"] = mixRatio
numPoints = len(CO2Buffer)
CO2Base = min(CO2Base, min(CO2Buffer))
CH4Base = min(CH4Base, min(CH4Buffer))
H2OBase = min(H2OBase, min(H2OBuffer))
CO2Buffer = array(CO2Buffer)-CO2Base
CH4Buffer = array(CH4Buffer)-CH4Base
H2OBuffer = array(H2OBuffer)-H2OBase
flowBuffer = array(flowBuffer)
calCO2Buffer = CO2Buffer*flowBuffer
calCH4Buffer = CH4Buffer*flowBuffer
calH2OBuffer = H2OBuffer*flowBuffer
integCO2, timeInterval = calcArea(timeBuffer, calCO2Buffer)
integCH4 = calcArea(timeBuffer, calCH4Buffer)[0]
integH2O = calcArea(timeBuffer, calH2OBuffer)[0]
rawIntegCO2 = calcArea(timeBuffer, CO2Buffer)[0]
rawIntegCH4 = calcArea(timeBuffer, CH4Buffer)[0]
rawIntegH2O = calcArea(timeBuffer, H2OBuffer)[0]
newTime, newCO2 = cubicSpline(timeBuffer, calCO2Buffer, 1200)
newTime, newCH4 = cubicSpline(timeBuffer, calCH4Buffer, 1200)
newTime, newH2O = cubicSpline(timeBuffer, calH2OBuffer, 1200)
splineCO2 = calcArea(newTime, newCO2)[0]
splineCH4 = calcArea(newTime, newCH4)[0]
splineH2O = calcArea(newTime, newH2O)[0]
aveFlow = mean(flowBuffer)
maxCO2 = max(CO2Buffer)
maxCH4 = max(CH4Buffer)
maxH2O = max(H2OBuffer)
#BackRatio = (pressureBuffer-pressureBase)/(pressureSpreadSample-pressureBase)
BackRatio = integConvFactor/(pressureSpreadSample-pressureBase)
sampleCO2 = integCO2 * BackRatio
sampleCH4 = integCH4 * BackRatio
sampleH2O = integH2O * BackRatio
sampleSplineCO2 = splineCO2 * BackRatio
sampleSplineCH4 = splineCH4 * BackRatio
sampleSplineH2O = splineH2O * BackRatio
resultTime = time.strftime(timeFormat, time.localtime(mean(timeBuffer)))
results["rawIntegCO2"] = rawIntegCO2
results["rawIntegCH4"] = rawIntegCH4
results["rawIntegH2O"] = rawIntegH2O
results["integCO2"] = integCO2
results["integCH4"] = integCH4
results["integH2O"] = integH2O
results["splineCO2"] = splineCO2
results["splineCH4"] = splineCH4
results["splineH2O"] = splineH2O
results["timeInterval"] = timeInterval
results["aveFlow"] = aveFlow
results["baseCO2"] = CO2Base
results["baseCH4"] = CH4Base
results["baseH2O"] = H2OBase
results["sampleCO2"] = sampleCO2
results["sampleCH4"] = sampleCH4
results["sampleH2O"] = sampleH2O
results["sampleSplineCO2"] = sampleSplineCO2
results["sampleSplineCH4"] = sampleSplineCH4
results["sampleSplineH2O"] = sampleSplineH2O
results["maxCO2"] = maxCO2
results["maxCH4"] = maxCH4
results["maxH2O"] = maxH2O
results["numPoints"] = numPoints
results["pressureBase"] = pressureBase
results["pressureSample"] = pressureSample
results["pressureBuffer"] = pressureBuffer
results["pressureSprdSmp"] = pressureSpreadSample
results["resultTime"] = resultTime
results["dilutionVolume"] = dilutionVolume
results["source"] = source
results["standardCO2"] = standardCO2

# Add post-measurement idle time here
sleep(postMeasTime)
if (mixRatio == HighMixRatio) and (sampleCO2 < LowerLimit100):
    if sampleCO2 >= LowerLimit10:
        mixRatio = MedMixRatio
        logFunc("\nRun 1/10 Mixing loop...\n")
    else:
        mixRatio = NoMixRatio
        logFunc("\nRun No Mixing loop...\n")
    if quality != "Pressure Low":
        quality = "Trial"
    results["quality"] = quality
    fileDataFunc(results)
    NEXT = "StatePurge"
else:
    if quality != "Pressure Low":
        quality = "Good"
    results["quality"] = quality
    fileDataFunc(results)
    logFunc("\nSample finished...\n")
    numMeasCompleted += 1
    mixRatio = HighMixRatio
    if stopCoordinatorCnt > 0:
        if (measurementMode == "1") and (numMeasCompleted == repeatedMeas) and (targetPort == numUsedPorts*2):
            runLastStandard = True
        if runLastStandard and source == "Standard":
            stopCoordinatorCnt -= 1

        if numMeasCompleted == repeatedMeas:
            targetPort = 2 * (((targetPort/2)%numUsedPorts)+1)
            numMeasCompleted = 0
        if targetPort == 2:
            source = "Standard"
        else:
            source = "Sample %d" % (targetPort/2-1)
        logFunc("\nNext source is %s...\n" % source)
        NEXT = "StatePurge"
    else:
        NEXT = "StateDone"
"""

[StateDone]
action="""
setValveMask(0)
if rotValve:
    try:
        moveRotValve("1")
        rotValve.close()
        logFunc("\nMove multi-port valve to position 1 and close connection.\n")
    except Exception, err:
        logFunc("\n%s\n" % err)
    rotValve = None
if externalSensor:
    externalSensor.close()
logFunc("Done!")
"""

[StateError]
action="""
logFunc("Error %s in state %s\n" % (ERROR_MSG,ERROR_STATE))
NEXT = "StateDone"
"""
