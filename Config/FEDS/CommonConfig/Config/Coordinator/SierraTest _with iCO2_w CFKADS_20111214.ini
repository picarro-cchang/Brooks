############################################################################################################################################
#Date:              Date Modified:         Notes:               
#20111130           E.Lai                  Dry Check
############################################################################################################################################
[UserEditableParams]
num_disp_params = 0
0 = "cycleCount", Number of Cycles (Max is 2)", "1"

[FlowSeq]
#Step Duration Channel1 Channel2
0 = 150.0, 0.000, 0.040
1 = 150.0, 0.001, 0.039
2 = 150.0, 0.002, 0.038
3 = 150.0, 0.003, 0.037
4 = 150.0, 0.005, 0.035
5 = 150.0, 0.007, 0.033
6 = 150.0, 0.010, 0.030
7 = 150.0, 0.015, 0.025
8 = 150.0, 0.020, 0.020
9 = 150.0, 0.015, 0.025
10 = 150.0, 0.010, 0.030
11 = 150.0, 0.007, 0.033
12 = 150.0, 0.005, 0.035
13 = 150.0, 0.003, 0.037
14 = 150.0, 0.002, 0.038
15 = 150.0, 0.001, 0.039
16 = 150.0, 0.000, 0.040

[Mode]
inject_mode=automatic

[Files]
output = "C:/Picarro/G2000/InstrConfig/Integration/DryCheck/DryCheck"

[Output]
#iCO2 Param
CO2_dry    = CO2_dry,   %10.4f
CH4_dry    = CH4_dry,   %10.4f
H2O        = H2O,       %10.4f
CO         = CO,        %10.4f
12CO2_dry  = 12CO2_dry, %10.4f
13CO2_dry  = 13CO2_dry, %10.4f
#MFC Param
seqIdx     = seqIdx,    %10s
ActFlow1   = ActFlow1,  %10.2f
ActFlow2   = ActFlow2,  %10.2f
SetFlow1   = SetFlow1,  %10.2f
SetFlow2   = SetFlow2,  %10.2f
#Comment
Comment    = Comment,   %128s

[Setup]
initial = StateStart
final = StateDone
error = StateError

[StateStart]
action = """
#Import Python Modules
from numpy import*
from os import makedirs
from os.path import exists, join 
from time import strftime
from configobj import ConfigObj
from pylab import figure, plot, grid, xlabel, ylabel, title, savefig, text
import matplotlib.pyplot as plt
import binascii
import serial
import time
import string
import os

#Serial Class Function
class TimeoutError(Exception):
    pass

class SerialIntrf(object):
    def __init__(self,port,baudrate=9600,timeout=1,xonxoff=1):
        # port = 0 means port = "COM1"
        self.serCnnct = serial.Serial(port=port,baudrate=baudrate,timeout=timeout,xonxoff=xonxoff)
    def openComm(self):
        self.serCnnct.open()
    def closeComm(self):
        self.serCnnct.close()
    def dataflush(self):
        self.serCnnct.flushInput()
    def sendComm(self,str):
        self.serCnnct.write(str + "\r\n")        
    def getString(self):
        line = []
        while True:
            ch = self.serCnnct.read()
            if not ch:
                raise TimeoutError
            if ch != '\r':
                line.append(ch)
            else:
                return "".join(line)                
    def getStrings(self):
        lines = []
        while True:
            try:
                lines.append(self.getString())
            except TimeoutError:
                return "\n".join(lines)            

#definition to convert ascii to hex
def asctohex(ascString):
    hexList = [hex(ord(x)) for x in ascString]
    return reduce(lambda x,y: hex(int(x,16) + int(y,16)), hexList)

#definition to convert Decimal to Binary
def dec2bin(n):
    bStr = ''
    if n < 0: raise ValueError
    if n == 0: return '0'
    while n > 0:
        bStr = str(n % 2) + bStr
        n = n >> 1
    return bStr    

#definition to convert hex to binary
def tobin(x, count = 8):
    return "".join(map(lambda y:str((x>>y)&1), range(count-1, -1, -1)))

#definition to calculate Two's Complement       
def twoscomp(numStr):
    if len(numStr) != 8:
        diff = 8 - len(numStr)
        zeroString = '0'*diff
        numStr = zeroString+numStr
        return tobin(-int(numStr,2), len(numStr))
    else:
        return tobin(-int(numStr,2), len(numStr))        

#definition to convert binary to hex
def bintohex(s):    
    return ''.join(["%x"%string.atoi(bin,2) for bin in s.split()])    
 
#definition to generate LRC Value
def lrcCommand(command):
    ascString = command
    hexString = asctohex(ascString)
    hexString = hexString[0:2]+hexString[-2:]
    hexVal = eval(hexString)
    decVal = dec2bin(hexVal)
    bin2CompVal = twoscomp(decVal)
    ascHexVal = bintohex(bin2CompVal)
    return ascHexVal

#definition to find active com-port    
def findComPorts():
    activePort = []
    for portCount in range(2,99):
        try:
            print portCount
            mfcIntrf = SerialIntrf(portCount)
            mfcIntrf.openComm()
            serValLRC = lrcCommand('?Srnm')
            serCommand = '?Srnm'+str(serValLRC)
            mfcIntrf.sendComm(serCommand)
            serVal = mfcIntrf.getString()
            print serVal
            if  serVal == 'Srnm1423522F':
                activePort.append(portCount)
                mfcIntrf.closeComm()
            elif serVal == 'Srnm1469941F':
                activePort.append(portCount)
                mfcIntrf.closeComm()
            else:
                mfcIntrf.closeComm()
        except Exception, err:
            continue
    return activePort
    
#Get AnalyzerType
analyzerType = getAnalyzerType()
#Output Directory
outputDir = "C:/Picarro/G2000/InstrConfig/Integration/DryCheck"
#Flow Sequence
flowSeq = config["FlowSeq"]
lenSeq = len(flowSeq)
#Initial Step
seqIdx = 0
logFunc('Their are %s steps in the DryCheck test'%(lenSeq))
#Number of Cycles
cycleCount = int(editParamDict["cycleCount"])
currCycle = 0

#Instrument Type    
if analyzerType in ["CFADS", "CFDDS"]:
    setMeasBuffer("analyze_CFADS", ["co2_adjust", "ch4_adjust", "h2o_adjust", "CO2_dry", "CH4_dry", "H2O", "CavityPressure", "EtalonTemp"],200)
    logFunc("Instrument is a CFADS type (CO2, CH4, H2O) analyzer.\n")
    logFunc("Now will commence preparation for Dry-Check Test.\n")
    clearMeasBuffer()
    NEXT = "StateDriver"
elif analyzerType in ["CFFDS", "CFGDS"]:
    setMeasBuffer("analyze_iCO2", ["adjust_87", "adjust_88", "adjust_75", "12CO2_dry", "13CO2_dry", "H2O", "CavityPressure", "EtalonTemp"],200)
    logFunc("Instrument is an iCO2 type (12CO2, 13CO2, Delta Raw) analyzer.\n")
    logFunc("Now will commence preparation for Dry-Check Test.\n")
    clearMeasBuffer()
    NEXT = "StateDriver"
elif analyzerType in ["CKADS"]:
    setMeasBuffer("analyze_CKADS", ["co2_adjust", "co_adjust", "CO2_dry", "H2O", "CavityPressure", "EtalonTemp"],200)
    logFunc("Instrument is a CKADS type (CO2, CO, H2O) analyzer.\n")
    logFunc("Now will commence preparation for Dry-Check Test.\n")
    clearMeasBuffer()
    NEXT = "StateDriver"
elif analyzerType in ["CFKADS", "CFKBDS"]:
    setMeasBuffer("analyze_CFKADS", ["co2_adjust", "ch4_adjust", "co_adjust", "CO2_dry", "CH4_dry", "H2O", "CavityPressure", "EtalonTemp"],200)
    logFunc("Instrument is a CFKADS type (CO2, CH4, CO, H2O) analyzer.\n")
    logFunc("Now will commence preparation for Dry-Check Test.\n")
    clearMeasBuffer()
    NEXT = "StateDriver" 
"""
[StateDriver]
action = """
GUI.popPause("Please load driver for serial USB hub if havent done so.","FlightCalibrationCoordinator")
NEXT = "StateFindActivePorts"
"""

[StateFindActivePorts]
action = """
activePorts = findComPorts()
if len(activePorts) == 2:
    logFunc("Com port %s is live with Sierra Flow Meter(S/N: Srnm1423522F).\n" %(activePorts[0]))
    mfcIntrf1 = SerialIntrf(int(activePorts[0]))
    mfcIntrf1.openComm()
    logFunc("Com port %s is live with Sierra Flow Meter(S/N: Srnm1469941F).\n" %(activePorts[1]))
    mfcIntrf2 = SerialIntrf(int(activePorts[1]))
    mfcIntrf2.openComm()
    NEXT = "StateWaitMeasuring"
else:
    logFunc("Coordinator was not able to find the 2 active com ports for flow meters.\n")
    NEXT = "StateDone"
"""

[StateWaitMeasuring]
action = """
meas = measGetBufferFirst()
if not meas:
    sleep(1.0)
    logFunc('.')
    NEXT = "StateWaitMeasuring"
else:
    logFunc("Instrument is now measuring.\n")
    logFunc("Now will wait for instrument to reach steady state.\n")
    #Initial CMAdjust Points
    cavityPressure = 0
    etalonStart = 0
    instrAdjustStart = 0
    if analyzerType in ["CFADS", "CFDDS"]:
        adjustParam = ["co2_adjust", "ch4_adjust", "h2o_adjust"]
    elif analyzerType in ["CFFDS", "CFGDS"]:
        adjustParam = ["adjust_87", "adjust_88", "adjust_75"]
    elif analyzerType in ["CKADS"]:
        adjustParam = ["co2_adjust", "co_adjust"]
    elif analyzerType in ["CFKADS", "CFKBDS"]:
        adjustParam = ["co2_adjust", "ch4_adjust", "co_adjust"]
    NEXT = "StateInstrCavityPressure"        
"""

[StateInstrCavityPressure]
action = """
meas = measGetBufferFirst()
#Verifiy Cavity Pressure
if analyzerType in ["CFADS", "CFDDS", "CKADS", "CFKADS", "CFKBDS"]:
    a = "CO2_dry"
elif analyzerType in ["CFFDS", "CFGDS"]:
    a = "12CO2_dry"
    
if not meas or (a not in meas):
    sleep(1.0)
    logFunc('.')
    NEXT = "StateInstrCavityPressure"
else:
    cavityPress_meas = meas["CavityPressure"]
    if cavityPressure != 3:
        if abs(cavityPress_meas - 140.0) >= 0.05:
            logFunc("Waiting for Cavity Pressure to settle.\n")
            cavityPressure = 0
            NEXT = "StateInstrCavityPressure"
        else:
            logFunc(".")
            cavityPressure += 1
            NEXT = "StateInstrCavityPressure"
    else:
        logFunc("Cavity Pressure has reached setpoint of 140 Torr.\n")
        NEXT = "StateInstrEtalonCert"
"""        

[StateInstrEtalonCert]
action = """
meas = measGetBufferFirst()
#Wait for Instrument Etalon Temp to settle
if not meas:
    sleep(1.0)
    logFunc('.')
    NEXT = "StateInstrEtalonCert"
else:
    initTemp = meas["EtalonTemp"]
    sleep(10.0)
    etalMeas = measGetBufferFirst()
    etalTemp = etalMeas["EtalonTemp"]
    if etalonStart != 3:
        etalonDiff = abs(etalTemp - initTemp)
        if etalonDiff > 0.0005:
            logFunc("Waiting for Etalon Temp to settle.\n")
            etalonStart = 0
            NEXT = "StateInstrEtalonCert"
        else:
            logFunc(".")
            etalonStart += 1
            NEXT = "StateInstrEtalonCert"
    else:
        logFunc("Instrument Etalon Temp is settled to nominal temp of 45.0 C.\n")
        NEXT = "StateInstrAdjustCert"
"""

[StateInstrAdjustCert]
action = """
meas = measGetBufferFirst()
#Wait for WLM to Center
if not meas:
    sleep(1.0)
    logFunc('.')
    NEXT="StateInstrAdjustCert"
else:
    for adjustCount in range(len(adjustParam)):
        cmVal = meas[adjustParam[adjustCount]]
        if abs(cmVal) > 0.0003:
            logFunc("Waiting for WLM to center.\n")
            instrAdjustStart = 0
            NEXT = "StateInstrAdjustCert"
        else:
            instrAdjustStart += 1
            
    if instrAdjustStart == len(adjustParam):
        if analyzerType in ["CFADS", "CFDDS"]:
            logFunc("Verified Instrument WLM is centered.\n")
            measDict = {'CO2_dry':[], 'CH4_dry':[], 'H2O':[], 'co2_adjust':[], 'ch4_adjust':[], 'h2o_adjust':[]}
            aveMeasDict = {'CO2_dry':[], 'CH4_dry':[], 'H2O':[], 'co2_adjust':[], 'ch4_adjust':[], 'h2o_adjust':[]}
            measVal = ['CO2_dry', 'CH4_dry', 'H2O', 'co2_adjust', 'ch4_adjust', 'h2o_adjust']
            NEXT = "StateSetMFC"        
        elif analyzerType in ["CFFDS", "CFGDS"]:   
            logFunc("Verified Instrument WLM is centered.\n")
            measDict = {'12CO2_dry':[], '13CO2_dry':[], 'H2O':[], 'adjust_87':[], 'adjust_88':[], 'adjust_75':[]}
            aveMeasDict = {'12CO2_dry':[], '13CO2_dry':[], 'H2O':[], 'adjust_87':[], 'adjust_88':[], 'adjust_75':[]}
            measVal = ['12CO2_dry', '13CO2_dry', 'H2O', 'adjust_87', 'adjust_88', 'adjust_75']  
            NEXT = "StateSetMFC"
        elif analyzerType in ["CKADS"]:
            logFunc("Verified Instrument WLM is centered.\n")
            measDict = {'CO2_dry':[], 'H2O':[], 'co2_adjust':[], 'co_adjust':[]}
            aveMeasDict = {"CO2_dry":[], "H2O":[], "co2_adjust":[], "co_adjust":[]}
            measVal = ['CO2_dry', 'H2O', 'co2_adjust', 'co_adjust']  
            NEXT = "StateSetMFC"
        elif analyzerType in ["CFKADS", "CFKBDS"]:
            logFunc("Verified Instrument WLM is centered.\n")
            measDict = {'CO2_dry':[], 'CH4_dry':[], 'H2O':[], 'co2_adjust':[], 'ch4_adjust':[], 'co_adjust':[]}
            aveMeasDict = {"CO2_dry":[], "CH4_dry":[], "H2O":[], "co2_adjust":[], "ch4_adjust":[], "co_adjust":[]}
            measVal = ['CO2_dry', 'CH4_dry', 'H2O', 'co2_adjust', 'ch4_adjust', 'co_adjust']  
            NEXT = "StateSetMFC"            
"""

[StateSetMFC]
action = """
(duration, f1, f2) = flowSeq[str(seqIdx)]        
channelsFlowRate = [str(f) for f in [f1, f2]]
logFunc('Set Sierra Flow Channels to respective Flow Rates: %s\n'%(channelsFlowRate))
stopTime = time.time() + float(duration)

#Set FLow
for flowNum in range(len(channelsFlowRate)):
    setCommand = '!Setr'+channelsFlowRate[flowNum]
    print setCommand
    ascHexVal = lrcCommand(setCommand)
    setCommandFull = setCommand+ascHexVal
    print setCommandFull
    if flowNum == 0:
        mfcIntrf1.sendComm(setCommandFull)
    else:
        mfcIntrf2.sendComm(setCommandFull)   
    NEXT = "StateDataCollect"
"""

[StateDataCollect]
action = """
meas = measGetBufferFirst()

if time.time() < stopTime:
    if not meas:
        sleep(1.0)
        logFunc('.')
        NEXT = "StateDataCollect"
    else:
        #Append measured values to appropriate lists
        for measCount in range(len(measVal)):
            measDict[measVal[measCount]].append(meas[measVal[measCount]])
else:
    NEXT = "StateDataAve"
"""

[StateDataAve]
action = """
#Increment Sequence Step Size 
seqIdx += 1
aveList = []

for paramNum in range(len(measVal)):
    #Calc ave value
    aveVal = average(measDict[measVal[paramNum]][-int(len(measDict[measVal[paramNum]])*0.80):])
    aveMeasDict[measVal[paramNum]].append(aveVal)
    aveList.append(aveVal)
    #Clear list in dictionary
    measDict[measVal[paramNum]][:] = []
    
print aveList     
#Write data to .csv file
paramDict = dict(zip(measVal, aveList))
fileDataFunc(paramDict)
aveList[:] = []

#Cyclic Restrictions
if seqIdx == (lenSeq-1):
    currCycle += 1
    seqIdx = 0
    
#Cycle Count    
if int(currCycle) == cycleCount:
    NEXT = "StateDataPlot"
else:
    NEXT = "StateSetMFC"
"""

[StateDataPlot]
action = """
stepIndex = linspace(1, lenSeq, lenSeq)

def plotGasSpecies(species, plotTitleName, yTitleName):
    fig = plt.figure()
    ax1 = fig.add_subplot(111)
    ax1.plot(stepIndex, species,'r')
    ax1.set_title(plotTitleName)
    ax1.grid(True, color = 'gray')
    ax1.set_xlabel('Step Index', color = 'g', fontweight = 'bold')
    ax1.set_ylabel(yTitleName, color = 'g', fontweight = 'bold')
    ax2 = ax1.twinx()
    ax2.set_ylabel('H2O', color = 'b', fontweight = 'bold')    
    ax2.plot(stepIndex, aveMeasDict['H2O'], 'b')
    
#Plot response of dry correction for gas species
if analyzerType in ["CFADS", "CFDDS", "CFKADS", "CFKBDS"]:   
    co2Plot = plotGasSpecies(aveMeasDict['CO2_dry'], 'Dry Mole Fraction-CO2', 'CO2 Dry (ppm)')
    ch4Plot = plotGasSpecies(aveMeasDict['CH4_dry'], 'Dry Mole Fraction-CH4', 'CH4 Dry (ppm)') 
elif analyzerType in ["CFFDS", "CFGDS"]:
    c12Plot = plotGasSpecies(aveMeasDict['12CO2_dry'], 'Dry Mole Fraction-12CO2', '12CO2 Dry (ppm)')
    c13Plot = plotGasSpecies(aveMeasDict['13CO2_dry'], 'Dry Mole Fraction-13CO2', '13CO2 Dry (ppm)')
elif analyzerType in ["CKADS"]:
    co2Plot = plotGasSpecies(aveMeasDict['CO2_dry'], 'Dry Mole Fraction-CO2', 'CO2 Dry (ppm)') 
NEXT = "StateDone"
"""

[StateDone]
action="""
GUI.popInfo("2D Interference Test is now complete.\n","CoordinatorDryCheck")
logFunc("Done!")
"""

[StateError]
action="""
logFunc("Error %s in state %s\n" % (ERROR_MSG,ERROR_STATE))
NEXT = "StateDone"
"""
    