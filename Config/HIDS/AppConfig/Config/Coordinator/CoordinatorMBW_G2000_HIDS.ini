# Coordinator for Matrix Bound Water
[Archiver]
archiveGroupName = Coordinator

[Mode]
inject_mode=manual

[Files]
output = "c:/IsotopeData/IsoWater"
log = "c:/IsotopeData/Log/Log"

[Output]
lineNum                     = "Sample",%8d
cycleCnt                    = "Lifetime Cycle",%14s
resistance                  = "Resistance (Ohms)",%14s
startTime                   = "Start Time",%25s
endTime                     = "End Time",%25s
method                      = "Recipe",%10s
Option                      = "Sample Type",%10s
description                 = "Description",%-40s
delta_18_16_ir       = "Delta O18",%25.3f
delta_D_H_ir         = "Delta D",%25.3f
#delta_18_16_ir_BLCorr       = "Delta O18 (BL Corrected)",%25.3f
#delta_D_H_ir_BLCorr         = "Delta D (BL Corrected)",%25.3f
volumeExt                   = "Est. H2O Volume (microliters)",%25.3f
h2o_int                     = "Integrated H2O Sig",%25.0f
h2o_max                     = "Maximum H2O (ppm)",%25.0f
baseline_shift_int          = "Spectroscopic Baseline Shift",%25.5f
#pre_baseline_shift_int      = "baseline_shift_IR (Preheat)",%25.5f
#these three peaks are not background subtracted
peak1_int                   = "H2O18 Sig",%25.3f
peak2_int                   = "H2O Sig",%25.3f
peak3_int                   = "HOD Sig",%25.3f
#pre_delta_18_16_ir          ="d(18_16)_IR (Preheat)",%25.3f
#pre_delta_D_H_ir            ="d(D_H)_IR (Preheat)",%25.3f
#pre_peak1_int               ="peak1_INT (Preheat)",%25.3f
#pre_peak3_int               ="peak3_INT (Preheat)",%25.3f
#pre_peak2_int               ="peak2_INT (Preheat)",%25.3f
#pre_h2o_int                 ="H2O_INT (Preheat)",%25.3f
#peak1_int_BLCorr            ="H2O18 Sig",%25.3f
#peak2_int_BLCorr            ="H2O Sig",%25.3f
#peak3_int_BLCorr            ="HOD Sig",%25.3f
blank_peak1_int              = "H2O18 Blank Sig",%25.3f
blank_peak2_int              = "H2O Blank Sig",%25.3f
blank_peak3_int              = "HOD Blank Sig",%25.3f
blank_peak1_ave              = "H2O18 Blank Ave Sig",%25.3f
blank_peak2_ave              = "H2O Blank Ave Sig",%25.3f
blank_peak3_ave              = "HOD Blank Ave Sig",%25.3f

[Setup]
initial=StateSetupMBW
final=StateDone
error=StateError

[StateSetupMBW]
action = """
logFunc("Searching for Induction Module...\n")
MBW = None
MBWFound = False
for p in range(2,100):
    if MBW:
        MBW.close()
        MBW = None
    try:
        MBW = SerIntrf(p, timeout=1, xonxoff=0)
        sleep(3)
    except:
        continue
    try:
        logFunc("Talking to COM%d...\n"%(p+1))
        MBW.sendString("us")
        status = MBW.getLine()
        if "MBW" in status:
            logFunc("Induction Module found on COM%d...\n"%(p+1))
            MBWFound = True
            break
    except:
        pass
        
if not MBWFound:
    logFunc("MBW not found.\n")
    if MBW:
        MBW.close()
        MBW = None
    GUI.popWarning("MBW not found", "MBW not found")
    raise Exception, "MBW not found"
else:
    # Turn on the organics removal system
    MBW.sendString("sd185") #New rev 2 Cartridge requires lower temperature
    status = MBW.getLine()
    #logFunc("%s\n" % status)
        
def isValveOn(valIdx):
    if MBW:
        MBW.sendString("sq")
        status = list(MBW.getLine())
        if status[valIdx] == "1":
            return True
        else:
            return False
    else:
        GUI.popWarning("MBW not found", "MBW not found")
        raise Exception, "MBW not found"
        
def toggleValve(valIdx):
    if MBW:
        MBW.sendString("s%d" % valIdx)
        status = MBW.getLine()
        logFunc("%s\n" % status)
    else:
        GUI.popWarning("MBW not found", "MBW not found")
        raise Exception, "MBW not found"

def getCycleCnt():
    if MBW:
        MBW.sendString("sc")
        cnt = MBW.getLine()
        logFunc("%s\n" % cnt)
        try:
            cnt = int(cnt.split("=")[-1])
        except:
            cnt = "N/A"
        return cnt
    else:
        GUI.popWarning("MBW not found", "MBW not found")
        raise Exception, "MBW not found"

def getResistance():
    if MBW:
        MBW.sendString("sj")
        cnt = MBW.getLine()
        logFunc("Resistance: %s\n" % cnt)
        try:
            cnt = float(cnt)
        except:
            cnt = "N/A"
        return cnt
    else:
        GUI.popWarning("MBW not found", "MBW not found")
        raise Exception, "MBW not found"
        
def setValves(onList, offList):
    for v in onList:
        if not isValveOn(v):
            toggleValve(v)
    for v in offList:
        if isValveOn(v):
            toggleValve(v)        
        
def setPWMByValue(value):
    # Map from 0~100 to 1023~0
    value1 = value
    value = 1023.0-int(value/100.0*1023.0) 
    if MBW:
        cmdString = "si%04d" % value
        cmdString1 = "%d" % value1
        logFunc("Induction Coil Power: %s\n" % cmdString1)   
        MBW.sendString(cmdString)
        status = MBW.getLine()
        logFunc("Response from Induction Module: %s\n\n" % status)
    else:
        GUI.popWarning("MBW not found", "MBW not found")
        raise Exception, "MBW not found"
        
def calcArea(mList, tList):
    totalArea = 0.0
    if len(mList) > 1:
        for idx in range(len(mList)-1):
            totalArea += 0.5*(mList[idx] + mList[idx+1])*(tList[idx+1] - tList[idx])
    elif len(mList) == 1:
        totalArea = mList[0]
    return totalArea
    
def calcBaseLine(sublist,duration):
    baseline = 0.0
    baseline = 0.25*(sublist[0]+sublist[1]+sublist[2]+sublist[3])*duration
    return baseline

NEXT = "StateStart"
"""

[StateStart]
action="""
cycleCntWarningThres = 500
concNameList = ["Delta_18_16", "Delta_D_H", "H2O", "baseline_shift", "slope_shift", "CH4", "residuals", "baseline_curvature", "h16od_adjust", "h16od_shift", "interval", "n2_flag","peak1_offset","peak2_offset","peak3_offset"]
setMeasBuffer("analyze_iH2O7200", concNameList, 30)
initTimeout = time.time() + 300
clearMeasBuffer()
h2oConcBuffer = []
h2oConcBufferSize = 10
lineCount = 0
method = None
Option = None
BlankCnt = 0
blank_peak1_int_ave = 0.0
blank_peak2_int_ave = 0.0
blank_peak3_int_ave = 0.0
GUI.setStatusText("")
setValves([1,2,3,4],[])  #Full Purge
logFunc("Starting time = %s\n" % time.strftime("%Y-%m-%d %H:%M:%S"))
logFunc("Drying out analyzer\n")
NEXT="StateSetup"
"""

[StateSetup]
action="""
resistance = getResistance()
if resistance != "N/A" and resistance > 100.0:
    GUI.popPause("The measured resistance across the oxidation cartrige is %.2f Ohms.\nPlease check cartridge installation and replace if necessary.\nTo check cartridge exit the coordinator, turn off and unplug IM unit, and wait 10 minutes before servicing." % resistance,
    "Check cartridge installation")
fd = open("C:\Picarro\G2000\AppConfig\Config\Coordinator\RecipeMBW.ini", "r")
recipe = configObj(fd)
fd.close()
methodList = recipe.list_sections() + ["Exit"]
if not method:
    method = methodList[-1]
    oldmethod = methodList[-1]
newMethod = GUI.popComboBox("Press \'OK\' after selecting Recipe", "Recipe Selection", "Current Recipe", methodList, method)
if newMethod:
    oldMethod = method
    method = newMethod
logFunc("Selected method: %s\n" % method)

if method == "Exit":
    NEXT="StateDone"
else:
    polyA = recipe.getfloat(method, "polyA")
    polyB = recipe.getfloat(method, "polyB")
    polyC = recipe.getfloat(method, "polyC")
    h2oLowThreshold = recipe.getfloat(method, "h2oLowThreshold")
    preheatTime = recipe.getfloat(method, "preheatTime")
    heatTime = recipe.getfloat(method, "heatTime")
    h2oEndHeatThreshold = recipe.getfloat(method, "h2oEndHeatThreshold")
    logFunc("Parameters: " + "%.5f "*7%(polyA, polyB, polyC, h2oLowThreshold, preheatTime, heatTime, h2oEndHeatThreshold) + "\n")

    heatingTimeout = heatTime + 120

    def PWMFunc(t):
        p = polyA * t**2 + polyB * t + polyC
        return min(50, max(0, p))
        
    def setPWMByTime(timeInterval):
        setPWMByValue(PWMFunc(timeInterval))
    
    
    OptionList = ["Blank"] + ["Sample"]
    if not Option:
        Option = OptionList[0]
    newOption = GUI.popComboBox("Press \'OK\' after selecting sample type", "Data Type", "Current Type", OptionList, Option)
    
    if newOption:
        Option = newOption
    if(Option == "Blank"):
        BlankCnt += 1
    elif(Option != "Blank"):
        BlankCnt = 0
  
    logFunc("Selected sample type: %s\n" % Option)
    NEXT = "StateReady"
"""

[StateReady]
action = """
if time.time() < initTimeout: #sometimes this times out...
    results = measGetBufferFirst()
    if not results:
        sleep(1.0)
        NEXT="StateReady"
    else:
        h2oConcBuffer.append(results["H2O"])
        if len(h2oConcBuffer) >= h2oConcBufferSize:
            h2oConcBuffer = h2oConcBuffer[-h2oConcBufferSize:]
            h2oConcMean = mean(h2oConcBuffer)
            if h2oConcMean < h2oLowThreshold:
                NEXT="StatePurge"
            else:
                NEXT="StateReady"
        else:
            NEXT="StateReady"
else:
    NEXT="StatePurge"
#   logFunc("Error: Purge Timeout Occurred")
"""

[StatePurge]
action="""
GUI.popPause("Press \'OK\' to begin purging... Please prepare the vial while purging.")
logFunc("Purging lines\n")
setValves([1,2,3,4],[])
sleep(60.0)
GUI.popPause("Press \'OK\' after the vial has been prepared")
setValves([1,2],[3,4])
GUI.popPause("Please insert the vial and click \'OK\' to begin measurement...")
setValves([1,3,4],[2])
clearMeasBuffer()
logFunc("Enabling PWM and induction coil\n")
logFunc("Running heating ramp\n")
dataBuffer = {}
startHeatingTime = time.time()
PWMOff = False
logFunc("Starting time = %s\n" % time.strftime("%Y-%m-%d %H:%M:%S"))
setPWMByTime(0)
NEXT="StateHeat"		#Changed to Skip StatePreheat
"""

[StateHeat]
action="""
timeInterval = time.time() - startHeatingTime
results = measGetBufferFirst()
if not results:
    sleep(1.0)
    if not PWMOff:
        setPWMByTime(timeInterval)
    NEXT="StateHeat"
else:
    for conc in results:
        if conc not in dataBuffer:
            dataBuffer[conc] = [results[conc]]
        else:
            dataBuffer[conc].append(results[conc])
    h2oConcMean = mean(dataBuffer["H2O"][-5:])
    if timeInterval > heatTime:
        if not PWMOff:
            setPWMByValue(0)
            PWMOff = True
            logFunc("Induction Coil Off\nStill collecting data...\n")
        if timeInterval > heatingTimeout:
            calcResults = {}
            logFunc("Report heating sample values\n")
            setValves([1,2,3,4],[])		# Full Purge 
            NEXT="StateCalcHeat"
        else:
            NEXT="StateHeat"
    else:
        NEXT="StateHeat"
"""

[StateCalcHeat]
action="""
instrCal = getInstrCalibrations()
userCal = getUserCalibrations()
tList = dataBuffer["measTime"]
startTime = tList[0]
endTime = tList[-1]
setLineMarkerColor("red", startTime)
setLineMarkerColor(None, endTime)
calcResults["startTime"] = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(startTime))
calcResults["endTime"] = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(endTime))
h20_int = calcArea(dataBuffer["H2O"], tList)
h2o_max = max(dataBuffer["H2O"])
peak1_int = calcArea(dataBuffer["peak1_offset"], tList)
peak2_int = calcArea(dataBuffer["peak2_offset"], tList)
peak3_int = calcArea(dataBuffer["peak3_offset"], tList)

baseline_shift_int = calcArea(dataBuffer["baseline_shift"], tList)

#baseline subtraction... uses average of first four data points in buffer... these are the lowest concentrations...
#duration = endTime-startTime
#peak1_int_BLCorr = peak1_int - calcBaseLine(dataBuffer["peak1_offset"], duration)
#peak2_int_BLCorr = peak2_int - calcBaseLine(dataBuffer["peak2_offset"], duration)
#peak3_int_BLCorr = peak3_int - calcBaseLine(dataBuffer["peak3_offset"], duration)

calcResults["h2o_int"] = h20_int
if h20_int < 1300000:
    logFunc("The total volume of water extracted is less than the recommended minimum of 2 microliters.\n")
volumeExt = float(float(h20_int)/625000.0)
logFunc("Estimated volume in microliters of Water Extracted: %5.2f\n" % volumeExt)
calcResults["volumeExt"] = volumeExt
calcResults["h2o_max"] = h2o_max

calcResults["baseline_shift_int"] = (baseline_shift_int/peak2_int)

if (Option == "Blank"):
    blankOpt = ["Include"] + ["Discard"]
    includeQ = blankOpt[0]
    includeQ = GUI.popComboBox("Please check the quality of the data in the 'Data Viewer' window and choose whether to include this run in the blank average.", "Blank Run", "Option", blankOpt, includeQ)
    if includeQ == "Include":
        blank_peak1_int_ave = ((BlankCnt-1)*blank_peak1_int_ave+peak1_int)/BlankCnt
        blank_peak2_int_ave = ((BlankCnt-1)*blank_peak2_int_ave+peak2_int)/BlankCnt
        blank_peak3_int_ave = ((BlankCnt-1)*blank_peak3_int_ave+peak3_int)/BlankCnt
        calcResults["Option"] = Option + ' ' + str(BlankCnt)
    if includeQ == "Discard":
        BlankCnt -= 1
        calcResults["Option"] = Option
    
    blank_peak1_int = peak1_int
    blank_peak2_int = peak2_int
    blank_peak3_int = peak3_int
    
    calcResults["blank_peak1_int"] = blank_peak1_int
    calcResults["blank_peak2_int"] = blank_peak2_int
    calcResults["blank_peak3_int"] = blank_peak3_int
    calcResults["blank_peak1_ave"] = blank_peak1_int_ave
    calcResults["blank_peak2_ave"] = blank_peak2_int_ave
    calcResults["blank_peak3_ave"] = blank_peak3_int_ave
    
else:
    peak1_int -= blank_peak1_int_ave
    peak2_int -= blank_peak2_int_ave
    peak3_int -= blank_peak3_int_ave
    calcResults["Option"] = Option

#baseline corrected values
#calcResults["peak1_int_BLCorr"] = peak1_int_BLCorr
#calcResults["peak2_int_BLCorr"] = peak2_int_BLCorr
#calcResults["peak3_int_BLCorr"] = peak3_int_BLCorr
#int181_BLCorr = peak1_int_BLCorr*instrCal["concentration_h18oh_gal_slope"]+instrCal["concentration_h18oh_gal_intercept"]
#int161_BLCorr = peak2_int_BLCorr*instrCal["concentration_h16oh_gal_slope"]+instrCal["concentration_h16oh_gal_intercept"]
#int162_BLCorr = peak3_int_BLCorr*instrCal["concentration_h16od_gal_slope"]+instrCal["concentration_h16od_gal_intercept"]
#delta_18_16_ir_instcal_BLCorr = (int181_BLCorr/int161_BLCorr)*instrCal["delta_18o_slope"]+instrCal["delta_18o_intercept"]
#delta_D_H_ir_instcal_BLCorr = (int162_BLCorr/int161_BLCorr)*instrCal["delta_d_slope"]+instrCal["delta_d_intercept"]
#calcResults["delta_18_16_ir_BLCorr"] = delta_18_16_ir_instcal_BLCorr*userCal["Delta_18_16"][0]+userCal["Delta_18_16"][1]
#calcResults["delta_D_H_ir_BLCorr"] = delta_D_H_ir_instcal_BLCorr*userCal["Delta_D_H"][0]+userCal["Delta_D_H"][1]

#blank corrected values...not baseline corrected
calcResults["peak1_int"] = peak1_int
calcResults["peak2_int"] = peak2_int
calcResults["peak3_int"] = peak3_int
int181 = peak1_int*instrCal["concentration_h18oh_gal_slope"]+instrCal["concentration_h18oh_gal_intercept"]
int161 = peak2_int*instrCal["concentration_h16oh_gal_slope"]+instrCal["concentration_h16oh_gal_intercept"]
int162 = peak3_int*instrCal["concentration_h16od_gal_slope"]+instrCal["concentration_h16od_gal_intercept"]
delta_18_16_ir_instcal = (int181/int161)*instrCal["delta_18o_slope"]+instrCal["delta_18o_intercept"]
delta_D_H_ir_instcal = (int162/int161)*instrCal["delta_d_slope"]+instrCal["delta_d_intercept"]
calcResults["delta_18_16_ir"] = delta_18_16_ir_instcal*userCal["Delta_18_16"][0]+userCal["Delta_18_16"][1]
calcResults["delta_D_H_ir"] = delta_D_H_ir_instcal*userCal["Delta_D_H"][0]+userCal["Delta_D_H"][1]


calcResults["method"] = method
lineCount += 1
calcResults["lineNum"] = lineCount
cycleCnt = getCycleCnt()
calcResults["cycleCnt"] = cycleCnt
calcResults["resistance"] = resistance
fileDataFunc(calcResults)
GUI.popPause("Water extraction is complete. Please remove sample vial and then press \'OK\'")
setValves([1,2,3,4], [])	#Changed
try:
    (d,m) = divmod(cycleCnt, cycleCntWarningThres)
    if cycleCnt > 0 and  m == 0:
        GUI.popPause("Estimated capacity of absorbent cartridge reached. Replace absorbent cartridge before continuing.")
        if d%2==0:
            GUI.popPause("Estimated lifetime of needle reached. Inspect or replace needle before continuing.")
except:
    pass
NEXT = "StateSetup"
"""

[StateDone]
action="""
logFunc("Exiting coordinator...\n")
setPWMByValue(0)
PWMOff = True
setValves([1,2,3,4],[])
# Turn off the organics removal system
MBW.sendString("sd000")
status = MBW.getLine()
logFunc("%s\n" % status)
logFunc("Done!")
"""

[StateError]
action="""
logFunc("Error %s in state %s\n" % (ERROR_MSG,ERROR_STATE))
NEXT = "StateDone"
"""
