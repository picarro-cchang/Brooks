<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sze.20150504102303.2" a="E"><vh>Monitoring data rate</vh>
<v t="sze.20150506185525.1" a="E"><vh>Changed code</vh>
<v t="sze.20150506170401.1"><vh>&lt;&lt;Initialization code&gt;&gt;</vh></v>
<v t="sze.20150506165934.1"><vh>&lt;&lt;AnalyzerStatus Masks&gt;&gt;</vh></v>
<v t="sze.20150506164942.1"><vh>&lt;&lt;Update AnalyzerStatus&gt;&gt;</vh></v>
<v t="sze.20150506170022.1"><vh>&lt;&lt;Alarm Parameters&gt;&gt;</vh></v>
<v t="sze.20150506194536.1"><vh>&lt;&lt;Setup Constants&gt;&gt;</vh></v>
<v t="sze.20150506182103.1"><vh>&lt;&lt;Report persistent variables&gt;&gt;</vh></v>
</v>
</v>
<v t="sze.20150504115900.1"><vh>@clean Config\FEDS\AppConfig\Scripts\Fitter\fitScriptFCDS_fast.py</vh>
<v t="sze.20150504120336.1"><vh>fitScriptFCDS_fast declarations</vh></v>
<v t="sze.20150504120336.2"><vh>expAverage</vh></v>
<v t="sze.20150504120336.3"><vh>initExpAverage</vh></v>
<v t="sze.20150504120336.4"><vh>fitQuality</vh></v>
<v t="sze.20150504120336.5"><vh>outlierFilter</vh></v>
<v t="sze.20150504120336.6"><vh>initialize_CFADS_Baseline</vh></v>
<v t="sze.20150504120336.7"><vh>initialize_CH4_Baseline</vh></v>
</v>
<v t="sze.20150506155541.1"><vh>@clean Config\FEDS\AppConfig\Scripts\DataManager\analyze_FBDS.py</vh>
<v t="sze.20150506155630.1"><vh>&lt;&lt;analyze_FBDS declarations&gt;&gt;</vh></v>
<v t="sze.20150506155630.2"><vh>evalLeaves</vh></v>
<v t="sze.20150506155630.3"><vh>clipReportData</vh></v>
<v t="sze.20150506155630.4"><vh>applyLinear</vh></v>
<v t="sze.20150506155630.5"><vh>apply2Linear</vh></v>
<v t="sze.20150506155630.6"><vh>protDivide</vh></v>
<v t="sze.20150506155630.7"><vh>expAverage</vh></v>
<v t="sze.20150506155630.8"><vh>boxAverage</vh></v>
<v t="sze.20150506155630.9"><vh>unstableWindSpeed</vh></v>
<v t="sze.20150506165859.1"><vh>&lt;&lt;SystemStatus Masks&gt;&gt;</vh></v>
<v t="sze.20150506165934.1"></v>
<v t="sze.20150506170022.1"></v>
<v t="sze.20150506194536.1"></v>
<v t="sze.20150506170104.1"><vh>&lt;&lt;Initialize System status flags&gt;&gt;</vh></v>
<v t="sze.20150506170135.1"><vh>&lt;&lt;Valve masks&gt;&gt;</vh></v>
<v t="sze.20150506170401.1"></v>
<v t="sze.20150506170534.1"><vh>&lt;&lt;Handle PeakDetector&gt;&gt;</vh></v>
<v t="sze.20150506170721.1"><vh>&lt;&lt;Ensure sensor minimal log is not running&gt;&gt;</vh></v>
<v t="sze.20150506162409.1"><vh>&lt;&lt;Handle command-line options&gt;&gt;</vh></v>
<v t="sze.20150506162645.1"><vh>&lt;&lt;Get info from InstrCal file&gt;&gt;</vh></v>
<v t="sze.20150506163129.1"><vh>&lt;&lt;Analyze Fit Output Data&gt;&gt;</vh></v>
<v t="sze.20150506163215.1"><vh>&lt;&lt;Analyze Peripheral Data&gt;&gt;</vh></v>
<v t="sze.20150506163404.1"><vh>&lt;&lt;Process Instrument Status&gt;&gt;</vh></v>
<v t="sze.20150506163500.1"><vh>&lt;&lt;Check data processing latency&gt;&gt;</vh></v>
<v t="sze.20150506163547.1"><vh>&lt;&lt;Check if warm box temperature is within WB_TEMP_ISO_THRESHOLD of setpoint&gt;&gt;</vh></v>
<v t="sze.20150506163653.1"><vh>&lt;&lt;Turn off heater&gt;&gt;</vh></v>
<v t="sze.20150506163722.1"><vh>&lt;&lt;Handle anemometer anomalies&gt;&gt;</vh></v>
<v t="sze.20150506163829.1"><vh>&lt;&lt;Update wavelength monitor offsets&gt;&gt;</vh></v>
<v t="sze.20150506164313.1"><vh>&lt;&lt;ChemDetect processing&gt;&gt;</vh></v>
<v t="sze.20150506181818.1"><vh>&lt;&lt;Handle AnalyzerStatus ChemDetect mask&gt;&gt;</vh></v>
<v t="sze.20150506181637.1"><vh>&lt;&lt;Set up alarmActive when not in capture mode&gt;&gt;</vh></v>
<v t="sze.20150506164529.1"><vh>&lt;&lt;Check mobile kit flow sensor reading&gt;&gt;</vh></v>
<v t="sze.20150506164740.1"><vh>&lt;&lt;Check for unstable wind speed and correlation between car speed and wind speed&gt;&gt;</vh></v>
<v t="sze.20150506164942.1"></v>
<v t="sze.20150506181904.1"><vh>&lt;&lt;Handle SystemStatus&gt;&gt;</vh></v>
<v t="sze.20150506182103.1"></v>
<v t="sze.20150506182201.1"><vh>&lt;&lt;Execute laser ageing script&gt;&gt;</vh></v>
<v t="sze.20150506182135.1"><vh>&lt;&lt;Report DATA and NEW_DATA&gt;&gt;</vh></v>
</v>
<v t="sze.20150507075702.1" a="E"><vh>@clean Host\Tests\AccessSurveyorDatabase\database_queries.py</vh>
<v t="sze.20150507075745.1"><vh>database_queries declarations</vh></v>
<v t="sze.20150507075745.2"><vh>getAnalyzerId</vh></v>
<v t="sze.20150507075745.3"><vh>getSurveysForAnalyzer</vh></v>
<v t="sze.20150507075745.4"><vh>getSurveyMinData</vh></v>
<v t="sze.20150507075745.5"><vh>get_backtraj_data</vh></v>
</v>
<v t="sze.20150507075912.1"><vh>@clean Host\Tests\AccessSurveyorDatabase\example_access.py</vh></v>
<v t="sze.20150507082344.1"><vh>@clean Host\Tests\AccessSurveyorDatabase\example_survey.py</vh></v>
<v t="sze.20150506154736.2" a="E"><vh>Recovered Nodes</vh>
<v t="sze.20150506154736.3"><vh>Recovered node "fitScriptFCDS_fast declarations" from fitScriptFCDS_fast.py</vh>
<v t="sze.20150506154736.4"><vh>old:fitScriptFCDS_fast declarations</vh></v>
<v t="sze.20150506154736.5"><vh>new:fitScriptFCDS_fast declarations</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="sze.20150504102303.2">FEDS2008 10.100.3.42

20140504
Interval 0.115s in survey mode (FCDS_highspeed)
Intervals 0.71s and 1.12s in isotopic capture mode (_FB2xxx_mobile_v29.sch)

John modified Fitter_FCDS_Fast.ini so that it reports the interval and spectrumID

Script0 = ../../Scripts/Fitter/fitScriptFCDS_fast.py
Script1 = ../../../CommonConfig/Scripts/Fitter/fitScriptLaserCurrentAverage.py
</t>
<t tx="sze.20150504115900.1">@language python
@tabwidth -4
@others
if INIT:
    fname = os.path.join(BASEPATH,r"./FCDS/spectral library FCDS v2_2.ini")
    loadSpectralLibrary(fname)
    loadPhysicalConstants(fname)
    loadSplineLibrary(fname)
    fname = os.path.join(BASEPATH,r"../../../InstrConfig/Calibration/InstrCal/FitterConfig.ini")
    instrParams = getInstrParams(fname)
     
    anCH4 = []
    anCH4.append(Analysis(os.path.join(BASEPATH,r"./FCDS/iCH4_C12only_v3_1.ini")))
    anCH4.append(Analysis(os.path.join(BASEPATH,r"./FCDS/iCH4_C12only_FC_FY_v3_1.ini")))
    anCH4.append(Analysis(os.path.join(BASEPATH,r"./FCDS/iCH4_C13only_v3_1.ini")))
    anCH4.append(Analysis(os.path.join(BASEPATH,r"./FCDS/iCH4_C13only_FC_FY_v3_1.ini")))
    anCH4.append(Analysis(os.path.join(BASEPATH,r"./FCDS/CH4+C2H6+H2O+CO2_v1_1.ini")))
    anCH4.append(Analysis(os.path.join(BASEPATH,r"./FCDS/C12interferences_v1_1.ini")))
    
    anCO2 = []
    anCO2.append(Analysis(os.path.join(BASEPATH,r"./FCDS/CO2 6056 VC VY v1_1.ini")))
    anCO2.append(Analysis(os.path.join(BASEPATH,r"./FCDS/CO2 6056 FC FY v1_1.ini")))   
  
    anH2O = []
    anH2O.append(Analysis(os.path.join(BASEPATH,r"./FCDS/H2O_v3_2.ini")))
    anH2O.append(Analysis(os.path.join(BASEPATH,r"./FCDS/H2O_FC_FY_v3_1.ini")))
    
    an12CH4 = []
    an12CH4.append(Analysis(os.path.join(BASEPATH,r"./CFADS/cFADS-1 CH4 v2_1 2008 0304.ini")))
    an12CH4.append(Analysis(os.path.join(BASEPATH,r"./CFADS/cFADS-1 CH4 FC VY v2_0 2008 0304.ini")))
    an12CH4.append(Analysis(os.path.join(BASEPATH,r"./CFADS/cFADS-1 CH4 FC FY v2_0 2008 0304.ini")))
    
    anH2OCFADS = []
    anH2OCFADS.append(Analysis(os.path.join(BASEPATH,r"./CFADS/FADS-1 H2O+CH4 v1_2 2011 0328.ini")))
    anH2OCFADS.append(Analysis(os.path.join(BASEPATH,r"./CFADS/FADS-1 H2O+CH4 FC v1_1 2011 0309.ini")))
    anH2OCFADS.append(Analysis(os.path.join(BASEPATH,r"./CFADS/FADS-1 H2O+CH4 v1_1 2011 0309.ini")))
 
    #  Import calibration constants from fitter_config.ini at initialization
    CFADS_baseline_level = instrParams['CFADS_baseline']
    CFADS_baseline_slope = instrParams['CFADS_Baseline_slope']
    CFADS_A0 = instrParams['CFADS_Sine0_ampl']
    CFADS_Nu0 = instrParams['CFADS_Sine0_freq']
    CFADS_Per0 = instrParams['CFADS_Sine0_period']
    CFADS_Phi0 = instrParams['CFADS_Sine0_phase']
    CFADS_A1 = instrParams['CFADS_Sine1_ampl']
    CFADS_Nu1 = instrParams['CFADS_Sine1_freq']
    CFADS_Per1 = instrParams['CFADS_Sine1_period']
    CFADS_Phi1 = instrParams['CFADS_Sine1_phase']
    ch4_baseline_level = instrParams['CH4_Baseline_level']
    ch4_baseline_slope = instrParams['CH4_Baseline_slope']
    ch4_A0 = instrParams['CH4_Sine0_ampl']
    ch4_Nu0 = instrParams['CH4_Sine0_freq']
    ch4_Per0 = instrParams['CH4_Sine0_period']
    ch4_Phi0 = instrParams['CH4_Sine0_phase']
    ch4_A1 = instrParams['CH4_Sine1_ampl']
    ch4_Nu1 = instrParams['CH4_Sine1_freq']
    ch4_Per1 = instrParams['CH4_Sine1_period']
    ch4_Phi1 = instrParams['CH4_Sine1_phase']

    H1_wd = instrParams['Water_lin_wd']
    H2_wd = instrParams['Water_quad_wd']
    
    H1_wd_CFADS_CH4 = instrParams['Water_lin_wd_CFADS_CH4']
    H2_wd_CFADS_CH4 = instrParams['Water_quad_wd_CFADS_CH4']
    
    H1_wd_iCH4 = instrParams['Water_lin_wd_iCH4']
    H2_wd_iCH4 = instrParams['Water_quad_wd_iCH4']
    
    P0_off = instrParams['Peak0_offset']
    P5_off = instrParams['Peak5_offset']
    P5_quad = instrParams['Peak5_quad']
    P5_A1 = instrParams['Peak5_CO2_lin']
    P5_H1 = instrParams['Peak5_water_lin']
    P5_M1H1 = instrParams['Peak5_water_CH4_bilin']
    P30_off = instrParams['Peak30_offset']
    P30_M1 = instrParams['Peak30_methane_linear']
    P24_off = instrParams['Peak24_offset']
    P24_M1 = instrParams['Peak24_methane_linear']
    H1 = instrParams['Water_lin']
    H2 = instrParams['Water_quad']
    C12_conc_lin = instrParams['C12_lin']

#   Globals for the isotopic methane fit 
    ch4_res12 = 0
    ch4_res13 = 0
    ch4_res_w = 0
    HC_res = 0
    last_time = None
    peak_0 = 1e-10
    peak0_spec = 1e-10
    peak0_spec_dry = 1e-10
    peak_5 = 0
    peak5_spec = 0
    peak5_spec_dry = 0
    peak_20 = 0
    peak_30 = 0
    peak24_spec = 0
    peak30_spec = 0
    c13toc12 = 0
    y_0 = 0
    vy_0 = 0
    y_5 = 0
    vy_5 = 0
    y_24 = 0
    vy_24 = 0
    y_30 = 0
    vy_30 = 0    
    base_0 = 0
    base_5 = 0
    base_24 = 0
    base_30 = 0
    shift_0 = 0
    adjust_0 = 0
    shift_5 = 0
    adjust_5 = 0
    shift_24 = 0
    adjust_24 = 0    
    shift_30 = 0
    adjust_30 = 0
    str_0 = 0
    str_30 = 0
    C12H4_conc_raw = 0
    C12H4_conc_raw_dry = 0
    C13H4_conc_raw = 0
    C13H4_conc_raw_dry = 0
    delta_no_bookend = 0
    h2o_conc_pct = 0
    ch4_conc_diff = 0
    C12H4_conc_raw_old = 0
    ch4_from_h2o = 0
    
    ntopper_12 = 0
    tiptop_12 = 0
    tipstd_12 = 0
    ntopper_13 = 0
    tiptop_13 = 0
    tipstd_13 = 0
    peakheight_0 = 0
    peakheight_5 = 0
    peakheight_ratio = 0
    delta_from_height = 0
    
    HC_base_offset = 0
    HC_slope_offset = 0
    HC_shift = 0
    HC_CH4_conc = 0
    HC_C12_conc = 0
    HC_H2O_conc = 0
    HC_C2H6_conc = 0
    
    PPF_res = 0
    PPF_base_offset = 0
    PPF_slope_offset = 0
    PPF_shift = 0
    PPF_CH4_conc = 0
    PPF_C12_conc = 0
    PPF_H2O_conc = 0
    PPF_C2H6_conc = 0
    PPF_C2H4_conc = 0
    PPF_NH3_conc = 0
    PPF_H2S_conc = 0
    
# CFADS 12CH4 and H2O
    peak_75 = 0.0
    base_75 = 0.0
    str_75 = 0.0
    y_75 = 0.0
    shift_75 = 0.0
    h2o_conc = 0.0
    CFADS_h2o_conc = 0.0
    adjust_75 = 0.0
        
    CFADS_counter = -25
    CFADS_base = 0.0
    CFADS_base_avg = instrParams['CFADS_baseline']
    ch4_low_shift = 0.0
    ch4_high_shift = 0.0
    ch4_high_adjust = 0.0
    CFADS_ch4_amp = 0.0
    ch4_splinemax = 0.5
    ch4_splinemax_dry = 0.5
    ch4_splinemax_for_correction = 0.0
    ch4_vy = 0.0
    ch4_y_avg = 1.08
    ch4_conc_ppmv_final = 0.0
    ch4_conc_ppmv_final_dry = 0.0  
    ch4_conc_for_correction = 0.0
    ch4_conc_diff = 0.0
    ch4_from_h2o = 0.0
    CFADS_ch4_y = 0.0
    
#  New CO2 in CFADS methane region (6056.6 wvn)
    adjust_24 = 0.0
    shift_24 = 0.0
    strength_24 = 0.0
    y_24 = 0.0
    base_24 = 0.0
    peak_24 = 0.0
    co2_conc = 0.0

    ignore_count = 5
    last_time = None
    
init = InitialValues()
deps = Dependencies()
ANALYSIS = []    
d = DATA

d.badRingdownFilter("uncorrectedAbsorbance",minVal=0.30,maxVal=20.0)
d.wlmSetpointFilter(maxDev=0.005,sigmaThreshold=10)
d.sparse(maxPoints=1000,width=0.005,height=100000.0,xColumn="waveNumber",yColumn="uncorrectedAbsorbance",outlierThreshold=4)
d.evaluateGroups(["waveNumber","uncorrectedAbsorbance"])
d.defineFitData(freq=d.groupMeans["waveNumber"],loss=1000*d.groupMeans["uncorrectedAbsorbance"],sdev=1/sqrt(array(d.groupSizes)))

P = d["cavitypressure"]
T = d["cavitytemperature"]
dasTemp = d.sensorDict["DasTemp"]

species = (d.subschemeId &amp; 0x1FF)[0]

tstart = time.clock()
RESULT = {}
r = None

in25 = (d.fitData["freq"] &gt;= 6056.81) &amp; (d.fitData["freq"] &lt;= 6057.39)
good25 = sum(in25)
in150 = (d.fitData["freq"] &gt;= 6028.4) &amp; (d.fitData["freq"] &lt;= 6029.2)
good150 = sum(in150)
fast_flag = -1
interval = 0

if species == 150 and good150 &gt; 35:
    fast_flag = 0
    initialize_CH4_Baseline()
    init[20,"strength"] = 0.07726*strength_24
    r = anCH4[0](d,init,deps)   #  First fit (12)CH4
    ANALYSIS.append(r)
    shift_0 = r["base",3]
    vy_0 = r[0,"y"]
    if (r[0,"peak"] &gt; 2) and (abs(shift_0) &lt; 0.04) and (abs(vy_0-1.18) &lt; 0.3):   
        adjust_0 = shift_0
        init["base",3] = shift_0
        init[0,"y"] = vy_0
    else:
        adjust_0 = 0.0
        
    r = anCH4[1](d,init,deps)
    ANALYSIS.append(r)
        
    ch4_res12 = r["std_dev_res"]
    y_0 = r[0,"y"]
    base_0 = r[0,"base"]
    peak_0 = r[0,"peak"]
    str_0 = r[0,"strength"]
    
    C12H4_conc_raw = 0.40148*peak_0
    ch4_conc_diff = abs(C12H4_conc_raw_old - C12H4_conc_raw)
    C12H4_conc_raw_old = C12H4_conc_raw
    
    f = d.waveNumber
    l = 1000*d.uncorrectedAbsorbance
    up_flag = (d.extra1 &gt; 0)
    down_flag = (d.extra1 == 0)
    t = d.timestamp

    topper_12 = (f &gt;= 6028.552) &amp; (f &lt;= 6028.554)
    top_loss_12 = l[topper_12]
    ntopper_12 = len(l[topper_12])
    if ntopper_12 &gt; 0:
        good_topper_12 = outlierFilter(top_loss_12,3)
        tiptop_12 = mean(top_loss_12[good_topper_12])
        tipstd_12 = std(top_loss_12[good_topper_12])
        ntopper_12 = len(top_loss_12[good_topper_12])
        peakheight_0 = (tiptop_12 - base_0)
    else:
        tiptop_12 = tipstd_12 = peakheight_0 = 0.0

    peak0_spec = peakheight_0 + P0_off
        
    wd_ratio_iCH4 = 1.0 + h2o_conc_pct*(H1_wd_iCH4 + H2_wd_iCH4*h2o_conc_pct)
    peak0_spec_dry = peak0_spec/wd_ratio_iCH4
    C12H4_conc_raw_dry = C12H4_conc_raw/wd_ratio_iCH4 
    
    init["base",3] = 0
    init[8,"strength"] = 0.1556*str_0
    init[20,"strength"] = 0.07726*strength_24
    init[21,"strength"] = 0.08073*strength_24
    r = anH2O[0](d,init,deps)   #  Next fit the water region with overlaping methane
    ANALYSIS.append(r)
    shift_30 = r["base",3]
    vy_30 = r[30,"y"]
 
    if (r[30,"peak"] &gt; 10) and (abs(shift_30) &lt; 0.04) and (abs(vy_30-1.35) &lt; 0.5):
        #  If the water peak is strong and believeable, use it as is    
        adjust_30 = shift_30
    elif (r[8,"peak"] &gt; 5) and (abs(shift_30) &lt; 0.04):
        #  If water is weak but methane is strong, use methane centration and fixed nominal ys
        adjust_30 = shift_30
        init["base",3] = shift_30
        r = anH2O[1](d,init,deps)
        ANALYSIS.append(r)
    else:
        #  If water and methane are both weak, use FY FC at nominal center frequency to estimate water 
        adjust_30 = 0.0
        r = anH2O[1](d,init,deps)
        ANALYSIS.append(r)

    ch4_res_w = r["std_dev_res"]
    y_30 = r[30,"y"]
    base_30 = r[30,"base"]
    peak_30 = r[30,"peak"]
    str_30 = r[30,"strength"]
    peak30_spec = peak_30 + P30_off + P30_M1*peak0_spec
    h2o_conc_pct = peak30_spec/61.0
    ch4_from_h2o = 1.5621*r[8,"peak"]
    
    init["base",3] = 0
    init[21,"strength"] = 0.08073*strength_24
    init[1002,2] = str_0   #  Now initialize (12)CH4 spline and fit the (13)CH4 triplet
    r = anCH4[2](d,init,deps)
    ANALYSIS.append(r)
    shift_5 = r["base",3]
    vy_5 = r[5,"y"]
 
    if (r[5,"peak"] &gt; 2) and (abs(shift_5) &lt; 0.04) and (abs(vy_5-1.14) &lt; 0.3):   
        adjust_5 = shift_5
        init["base",3] = shift_5
        init[5,"y"] =  0.966*y_0
    else:
        adjust_5 = 0.0
        
    r = anCH4[3](d,init,deps)
    ANALYSIS.append(r)
        
    ch4_res13 = r["std_dev_res"]
    y_5 = r[5,"y"]
    base_5 = r[5,"base"]
    peak_5 = r[5,"peak"]
     
    topper_13 = (f &gt;= 6029.102) &amp; (f &lt;= 6029.104)
    top_loss_13 = l[topper_13]
    ntopper_13 = len(l[topper_13])
    if ntopper_13 &gt; 0:
        good_topper_13 = outlierFilter(top_loss_13,3)
        tiptop_13 = mean(top_loss_13[good_topper_13])
        tipstd_13 = std(top_loss_13[good_topper_13])
        ntopper_13 = len(top_loss_13[good_topper_13])
        peakheight_5 = 0.9655*(tiptop_13 - base_5)  #Conversion from global peak to peak5 component
    else:
        tiptop_13 = tipstd_13 = peakheight_5 = 0.0
        
    init["base",3] = 0
    init[0,"strength"] = 0
    init[0,"y"] = y_0
    init[30,"strength"] = str_30
    init[30,"y"] = y_30
    init[20,"strength"] = 0.07726*strength_24
    init[21,"strength"] = 0.08073*strength_24
    init[1002,2] = str_0   #  Finally fit the entire spectrum looking for ethane on top of methane and water
    r = anCH4[4](d,init,deps)
    ANALYSIS.append(r)
    HC_res = r["std_dev_res"]
    HC_base_offset = r["base",0]-ch4_baseline_level
    HC_slope_offset = r["base",1]-ch4_baseline_slope
    HC_shift = r["base",3]
    HC_CH4_conc = 100*r[1002,2]
    HC_C12_conc = 0.40148*r[0,"peak"]
    HC_H2O_conc = r[30,"peak"]/61.0
    HC_C2H6_conc = 400*r[1003,2]
    
    #  Another postfit with more interfering species
    r = anCH4[5](d,init,deps)
    ANALYSIS.append(r)
    PPF_res = r["std_dev_res"]
    PPF_base_offset = r["base",0]-ch4_baseline_level
    PPF_slope_offset = r["base",1]-ch4_baseline_slope
    PPF_shift = r["base",3]
    PPF_CH4_conc = 100*r[1002,2]
    PPF_C12_conc = 0.40148*r[0,"peak"]
    PPF_H2O_conc = r[30,"peak"]/61.0
    PPF_C2H6_conc = 400*r[1003,2]
    PPF_C2H4_conc = r[1004,2]
    PPF_NH3_conc = 50*r[1005,2]
    PPF_H2S_conc = 1000*r[1006,2]

#  Apply corrections to isotopic peak height here for high conc mode   
#  C. Rella &amp; Y. He 20111006 changed H2O-CH4 bilinear term to P5_M1H1*peak30_spec*peakheight_5 to address enriched 13C cases     
    peak5_spec = peakheight_5 + P5_off + P5_quad*peak0_spec + P5_A1*peak24_spec + P5_H1*peak30_spec + P5_M1H1*peak30_spec*peakheight_5
    C13H4_conc_raw = 0.007772*peakheight_5

#  Calculate isotopic ratio and delta    
    try:
        c13toc12 = peakheight_5/peakheight_0
    except:
        pass
    delta_no_bookend = 1723.1*c13toc12 - 1000
    ch4_high_adjust = 0.0
    
    if last_time != None:
        interval = r["time"]-last_time
    last_time = r["time"]
    

if species in [25,150] and good25&gt;9:     #high precision CH4 at 6057.09
    if species == 25:
        fast_flag = 1       
    else:
        fast_flag = 0
    init = InitialValues()
    initialize_CFADS_Baseline()
    r = an12CH4[0](d,init,deps)
    ANALYSIS.append(r)
    if species == 25:
        if last_time != None:
            interval = r["time"]-last_time
        last_time = r["time"]    
    ch4_vy = r[1002,5]
    vch4_conc_ppmv = 10*r[1002,2]
    ch4_high_shift = r["base",3]
#  Polishing step with fixed center, variable y if line is strong and shift is small
    if (r[1002,2] &gt; 0.005) and (abs(ch4_high_shift) &lt;= 0.07):
        init["base",3] = ch4_high_shift
        ch4_high_adjust = ch4_high_shift
        r = an12CH4[1](d,init,deps)
        ANALYSIS.append(r)
#  Polishing step with fixed center and y if line is weak or shift is large
    else:    
        init["base",3] = 0.0
        ch4_high_adjust = 0.0
        init[1002,5] = 1.08
        r = an12CH4[2](d,init,deps)
        ANALYSIS.append(r)
    
    CFADS_ch4_amp = r[1002,2]
    ch4_conc_raw = 10*r[1002,2]
    CFADS_ch4_y = r[1002,5]
    CFADS_base = r["base",0]
    ch4_adjconc_ppmv = CFADS_ch4_y*ch4_conc_raw*(140.0/P)
    ch4_splinemax = r[1002,"peak"]
    ch4_peakvalue = ch4_splinemax+CFADS_base
    CFADS_base_avg  = initExpAverage(CFADS_base_avg,CFADS_base,1,100,CFADS_counter)
    ch4_peak_baseavg = ch4_peakvalue-CFADS_base_avg
    ch4_conc_ppmv_final = ch4_peak_baseavg/216.3
    
    wd_ratio_CFADS_CH4 = 1.0 + h2o_conc_pct*(H1_wd_CFADS_CH4 + H2_wd_CFADS_CH4*h2o_conc_pct)
    ch4_splinemax_dry = ch4_splinemax/wd_ratio_CFADS_CH4
    ch4_conc_ppmv_final_dry = ch4_conc_ppmv_final/wd_ratio_CFADS_CH4 
    
    ch4_res = r["std_dev_res"]
    CFADS_counter += 1           

if species == 150 and good150&gt;4 and good150&lt;10:    #  Minimal (12)CH4 for WLM offset only
    fast_flag = 1
    initialize_CH4_Baseline()
    r = anCH4[0](d,init,deps)   
    ANALYSIS.append(r)
    shift_0 = r["base",3]
    peak_0 = r[0,"peak"]
    str_0 = r[0,"strength"]
    vy_0 = r[0,"y"]
    if (peak_0 &gt; 2) and (abs(shift_0) &lt; 0.04) and (abs(vy_0-1.18) &lt; 0.3):   
        adjust_0 = shift_0
    else:
        adjust_0 = 0.0

if species == 151 and good150&gt;5:                   #  Minimal (13)CH4 for WLM offset only
    fast_flag = 1
    initialize_CH4_Baseline()
    init[1002,2] = 0.01*ch4_conc_ppmv_final
    r = anCH4[2](d,init,deps)
    ANALYSIS.append(r)
    shift_5 = r["base",3]
    peak_5 = r[5,"peak"]
    vy_5 = r[5,"y"]
    if (peak_5 &gt; 2) and (abs(shift_5) &lt; 0.04) and (abs(vy_5-1.14) &lt; 0.3):   
        adjust_5 = shift_5
    else:
        adjust_5 = 0.0

if species == 152 and good150&gt;4:                   #  Minimal water (6028.8) for WLM offset only
    fast_flag = 1
    initialize_CH4_Baseline()
    init[8,"strength"] = 0.1556*str_0
    r = anH2O[0](d,init,deps)                      #  Check this -- may need to fix peak8
    ANALYSIS.append(r)
    shift_30 = r["base",3]
    vy_30 = r[30,"y"]
 
    if (r[30,"peak"] &gt; 10) and (abs(shift_30) &lt; 0.04) and (abs(vy_30-1.35) &lt; 0.5):
        #  If the water peak is strong and believeable, use centration    
        adjust_30 = shift_30
    elif (r[8,"peak"] &gt; 5) and (abs(shift_30) &lt; 0.04):
        #  If water is weak but methane is strong, use centration
        adjust_30 = shift_30
    else:
        #  If water and methane are both weak, no WLM adjust
        adjust_30 = 0.0		
    
if species == 153:                # CO2 at 6056.5 
    fast_flag = 0
    initialize_CFADS_Baseline()
    init[1002,2] = 0.5*h2o_conc_pct
    init[1003,2] = 0.009041*C12H4_conc_raw
    r = anCO2[0](d,init,deps)
    ANALYSIS.append(r)
    shift_24 = r["base",3]
    vy_24 = r[24,"y"]
 
    if (r[24,"peak"] &gt; 5) and (abs(shift_24) &lt; 0.04) and (abs(vy_24-1.86) &lt; 0.5):   
        adjust_24 = shift_24
        init[24,"y"] = vy_24
    else:
        adjust_24 = 0.0
    
    init["base",3] = adjust_24
    r = anCO2[1](d,init,deps)
    ANALYSIS.append(r)    
    y_24 = r[24,"y"]
    strength_24 = r[24,"strength"]
    base_24 = r[24,"base"]
    peak_24 = r[24,"peak"]
    peak24_spec = peak_24 + P24_off + P24_M1*peak0_spec
    #co2_conc = 7.718*peak_24
    co2_conc = 7.718*peak24_spec

if species ==11 and d["ngroups"]&gt;9:   #H2O at 6057.8
    fast_flag = 0
    initialize_CFADS_Baseline()
    r = anH2OCFADS[0](d,init,deps)
    ANALYSIS.append(r)
    if abs(r["base",3]) &gt;= 0.01 or abs(r[75,"y"]-0.83)&gt;0.3:
        r = anH2OCFADS[1](d,init,deps)
        ANALYSIS.append(r)
    h2o_res = r["std_dev_res"]
    peak_75 = r[75,"peak"]
    h2o_quality = fitQuality(h2o_res,peak_75,50,1)
    shift_75 = r["base",3]
    ch4_from_h2o_CFADS = 100.0*r[1002,2]
    
    str_75 = r[75,"strength"]
    y_75 = r[75,"y"]
    z_75 = r[75,"z"]
    base_75 = r[75,"base"]                    
    h2o_conc = peak_75 * 0.01002
    if peak_75 &gt; 3.0 and abs(shift_75) &lt; 0.03 and h2o_quality &lt; 1.5:
        adjust_75 = shift_75
    else:
        adjust_75 = 0.0
        
    r = anH2OCFADS[2](d,init,deps)     #  Original CFADS fit included for comparison
    ANALYSIS.append(r)
    if abs(r["base",3]) &gt;= 0.01:
        r = anH2OCFADS[1](d,init,deps)
        ANALYSIS.append(r)
    CFADS_h2o_conc = r[75,"peak"] * 0.01002

    
now = time.clock()
fit_time = now-tstart
if r != None:
    IgnoreThis = False
else:
    IgnoreThis = True

if not IgnoreThis:    
    RESULT = {"ch4_res12":ch4_res12,"ch4_res13":ch4_res13,"ch4_res_w":ch4_res_w,
            "12CH4_raw":C12H4_conc_raw,"12CH4_raw_dry":C12H4_conc_raw_dry,
            "13CH4_raw":C13H4_conc_raw,"HC_res":HC_res,
            "peak0_spec":peak0_spec,"peak5_spec":peak5_spec,"peak30_spec":peak30_spec,
            "delta_no_bookend":delta_no_bookend,"c-13toc-12":c13toc12,
            "vy_0":vy_0,"y_0":y_0,"base_0":base_0,"shift_0":shift_0,"adjust_0":adjust_0,
            "vy_5":vy_5,"y_5":y_5,"base_5":base_5,"shift_5":shift_5,"adjust_5":adjust_5,
            "vy_24":vy_24,"y_24":y_24,"base_24":base_24,"shift_24":shift_24,"adjust_24":adjust_24,
            "vy_30":vy_30,"y_30":y_30,"base_30":base_30,"shift_30":shift_30,"adjust_30":adjust_30,                        
            "peak_0":peak_0,"str_0":str_0,"peak_5":peak_5,"peak_24":peak_24,"peak24_spec":peak24_spec,"peak_30":peak_30,
            "interval":interval,"datapoints":d["datapoints"],"datagroups":d["ngroups"],
            "h2o_conc_pct":h2o_conc_pct,"peak30_spec":peak30_spec,
            "ntopper_12":ntopper_12,"tiptop_12":tiptop_12,"tipstd_12":tipstd_12,
            "ntopper_13":ntopper_13,"tiptop_13":tiptop_13,"tipstd_13":tipstd_13,
            "peakheight_5":peakheight_5,"peakheight_ratio":peakheight_ratio,
            "delta_from_height":delta_from_height,"ch4_from_h2o":ch4_from_h2o,
            "species":species,"fittime":fit_time,"peakheight_0":peakheight_0,
            "HC_base_offset":HC_base_offset,"HC_slope_offset":HC_slope_offset,
            "HC_shift":HC_shift,"HC_CH4_conc":HC_CH4_conc,"HC_C12_conc":HC_C12_conc,
            "HC_H2O_conc":HC_H2O_conc,"HC_C2H6_conc":HC_C2H6_conc,
            "PPF_res":PPF_res,"PPF_base_offset":PPF_base_offset,"PPF_slope_offset":PPF_slope_offset,
            "PPF_shift":PPF_shift,"PPF_CH4_conc":PPF_CH4_conc,"PPF_H2O_conc":PPF_H2O_conc,
            "PPF_C2H6_conc":PPF_C2H6_conc,"PPF_C2H4_conc":PPF_C2H4_conc,
            "PPF_NH3_conc":PPF_NH3_conc,"PPF_H2S_conc":PPF_H2S_conc,
            "ch4_vy":ch4_vy,"ch4_high_shift":ch4_high_shift,"ch4_high_adjust":ch4_high_adjust,"CFADS_ch4_amp":CFADS_ch4_amp,
            "CFADS_ch4_y":CFADS_ch4_y,"CFADS_base":CFADS_base,"ch4_splinemax":ch4_splinemax,
            "CFADS_base_avg":CFADS_base_avg,"ch4_conc_ppmv_final":ch4_conc_ppmv_final,
            "ch4_splinemax_dry":ch4_splinemax_dry,"ch4_conc_ppmv_final_dry":ch4_conc_ppmv_final_dry,            
            "peak_75":peak_75,"shift_75":shift_75,"str_75":str_75,
            "y_75":y_75,"base_75":base_75,"h2o_conc":h2o_conc,"adjust_75":adjust_75,"CFADS_h2o_conc":CFADS_h2o_conc,"co2_conc":co2_conc,         
            "cavity_pressure":P,"cavity_temperature":T,"das_temp":dasTemp,"fast_flag":fast_flag
            }
    RESULT.update(d.sensorDict)
    RESULT["solenoid_valves"] = RESULT["ValveMask"]
</t>
<t tx="sze.20150504120336.1">#  G2000 isotopic methane fitter for the FCDS variation -- C-13/C-12 only with CFADS spectroscopy for C-12 measurement
#  Spectral IDs
#     11 -- H2O at 6057.8 (CFADS)
#    150 -- Isomethane and water vapor from 6028.4 to 6029.4 combined with CFADS methane at 6057 wvn
#    153 -- (12)CO2 at 6056.7
#  Spectral IDs added for high speed methane measurement (19 Nov 2013)
#     25 -- (12)CH4 only at 6057 wvn
#    150 -- (12)CH4 only at 6028.5 wvn
#    151 -- (13)CH4 only at 6029 wvn
#    152 -- Water vapor at 6028.8 wvn

#  09 Sep 2011:  Adapted from earlier CBDS and CFIDS fitters
#  07 Nov 2011:  New variant for potential PG&amp;E application with different schemes:  6029 and 6057 regions collected as 1 SID
#  17 Nov 2011:  Fixed a bad bug in the peak 5 WLM adjust logic.  Consolidated concentration calibration factors and adjusted to match CFADS on FCDS2003.
#  17 Nov 2011:  Changed sigma filter on WLM setpoint from 3 to 10
#  18 Nov 2011:  Changed VC water fit to fix methane y-parameter and increased minimum peak requirement for water WLM adjust.
#  01 Dec 2011:  Major change -- merged with the fitter  variant developed for PG&amp;E(R:\crd_G2000\FCDS\1061-FCDS2003\Config\20111122)
#  02 Dec 2011:  Fixed major bug in initialization of 6057 methane (high precision) fit for merged fitter.
#  06 Dec 2011:  Removed base average from CFADS CH4 fitter
#  10 Jan 2012:  Fixed y-parameter of C-13 triplet fit based on y of C-12 singlet (more stable at low concentration)
#  20 Jan 2012:  Include neighboring CO2 peaks in methane region fits to improve WLM tracking for low methane and high [CO2]
#  27 Apr 2012:  Incorporated improvements from CFIDS fitter:  (1) CO2 lines in spectral model for 6029 region;
#                (2) W/D calculation; (3) initialization of y_5 based on y_0; (4) newer spectral library
#  29 May 2012:  Removed bogus factor 0.84 from methane conc conversion in 6029 wvn region (messed up 6056 spline)
#  28 Feb 2013:  Fixed logic in shift/adjust of SID 153 (CO2 at 6056.5)
#   7 Jun 2013:  Fixed bug in HP methane -- WLM adjust was stuck when measurement 6057 wvn inactive
#  19 Nov 2013:  Start work on a version for high speed CH4 concentration measurement
#  17 Dec 2013:  Added output to distinguish high-speed from normal mode of operation
#  29 Jan 2014:  Initialized methane amplitude in water fit (peak8) using peak0 amplitude
#                Fixed minor bug in logic for adjust_0 = 0 and adjust_5 = 0.
#   3 Feb 2014:  Added PPF to isotopic (slow) mode.  Removed up/down methane reporting.
#   4 May 2015:  Changed the definition of "interval" to mean period between successive high-speed CH4 or isotopic measurements

import os.path
import time
from numpy import *

</t>
<t tx="sze.20150504120336.2">def expAverage(xavg,x,n,dxMax):
    if xavg is None: return x
    y = (x + (n-1)*xavg)/n
    if abs(y-xavg)&lt;dxMax: return y
    elif y&gt;xavg: return xavg+dxMax
    else: return xavg-dxMax

</t>
<t tx="sze.20150504120336.3">def initExpAverage(xavg,x,hi,dxMax,count):
    if xavg is None: return x
    n = min(max(count,1),hi)
    y = (x + (n-1)*xavg)/n
    if abs(y-xavg)&lt;dxMax: return y
    elif y&gt;xavg: return xavg+dxMax
    else: return xavg-dxMax

</t>
<t tx="sze.20150504120336.4">def fitQuality(sdFit,maxPeak,normPeak,sdTau):
    return sqrt(sdFit**2/((maxPeak/normPeak)**2 + sdTau**2))
    
</t>
<t tx="sze.20150504120336.5">def outlierFilter(x,threshold,minPoints=2):
    """ Return Boolean array giving points in the vector x which lie
    within +/- threshold * std_deviation of the mean. The filter is applied iteratively
    until there is no change or unless there are minPoints or fewer remaining"""
    good = ones(x.shape,bool_)
    order = list(x.argsort())
    while len(order)&gt;minPoints:
        maxIndex = order.pop()
        good[maxIndex] = 0
        mu = mean(x[good])
        sigma = std(x[good])
        if abs(x[maxIndex]-mu)&gt;=(threshold*sigma):
            continue
        good[maxIndex] = 1
        minIndex = order.pop(0)
        good[minIndex] = 0
        mu = mean(x[good])
        sigma = std(x[good])
        if abs(x[minIndex]-mu)&gt;=(threshold*sigma):
            continue
        good[minIndex] = 1
        break
    return good
    
</t>
<t tx="sze.20150504120336.6">def initialize_CFADS_Baseline():
    init["base",1] = CFADS_baseline_slope
    init[1000,0] = CFADS_A0
    init[1000,1] = CFADS_Nu0
    init[1000,2] = CFADS_Per0
    init[1000,3] = CFADS_Phi0
    init[1001,0] = CFADS_A1
    init[1001,1] = CFADS_Nu1
    init[1001,2] = CFADS_Per1
    init[1001,3] = CFADS_Phi1
    
</t>
<t tx="sze.20150504120336.7">def initialize_CH4_Baseline():
    init["base",1] = ch4_baseline_slope
    init[1000,0] = ch4_A0
    init[1000,1] = ch4_Nu0
    init[1000,2] = ch4_Per0
    init[1000,3] = ch4_Phi0
    init[1001,0] = ch4_A1
    init[1001,1] = ch4_Nu1
    init[1001,2] = ch4_Per1
    init[1001,3] = ch4_Phi1

</t>
<t tx="sze.20150506154736.2"></t>
<t tx="sze.20150506154736.3">(uncached) sze.20150504120336.1
Diff...
  #  G2000 isotopic methane fitter for the FCDS variation -- C-13/C-12 only with CFADS spectroscopy for C-12 measurement
  #  Spectral IDs
  #     11 -- H2O at 6057.8 (CFADS)
  #    150 -- Isomethane and water vapor from 6028.4 to 6029.4 combined with CFADS methane at 6057 wvn
  #    153 -- (12)CO2 at 6056.7
  #  Spectral IDs added for high speed methane measurement (19 Nov 2013)
  #     25 -- (12)CH4 only at 6057 wvn
  #    150 -- (12)CH4 only at 6028.5 wvn
  #    151 -- (13)CH4 only at 6029 wvn
  #    152 -- Water vapor at 6028.8 wvn
  
  #  09 Sep 2011:  Adapted from earlier CBDS and CFIDS fitters
  #  07 Nov 2011:  New variant for potential PG&amp;E application with different schemes:  6029 and 6057 regions collected as 1 SID
  #  17 Nov 2011:  Fixed a bad bug in the peak 5 WLM adjust logic.  Consolidated concentration calibration factors and adjusted to match CFADS on FCDS2003.
  #  17 Nov 2011:  Changed sigma filter on WLM setpoint from 3 to 10
  #  18 Nov 2011:  Changed VC water fit to fix methane y-parameter and increased minimum peak requirement for water WLM adjust.
  #  01 Dec 2011:  Major change -- merged with the fitter  variant developed for PG&amp;E(R:\crd_G2000\FCDS\1061-FCDS2003\Config\20111122)
  #  02 Dec 2011:  Fixed major bug in initialization of 6057 methane (high precision) fit for merged fitter.
  #  06 Dec 2011:  Removed base average from CFADS CH4 fitter
  #  10 Jan 2012:  Fixed y-parameter of C-13 triplet fit based on y of C-12 singlet (more stable at low concentration)
  #  20 Jan 2012:  Include neighboring CO2 peaks in methane region fits to improve WLM tracking for low methane and high [CO2]
  #  27 Apr 2012:  Incorporated improvements from CFIDS fitter:  (1) CO2 lines in spectral model for 6029 region;
  #                (2) W/D calculation; (3) initialization of y_5 based on y_0; (4) newer spectral library
  #  29 May 2012:  Removed bogus factor 0.84 from methane conc conversion in 6029 wvn region (messed up 6056 spline)
  #  28 Feb 2013:  Fixed logic in shift/adjust of SID 153 (CO2 at 6056.5)
  #   7 Jun 2013:  Fixed bug in HP methane -- WLM adjust was stuck when measurement 6057 wvn inactive
  #  19 Nov 2013:  Start work on a version for high speed CH4 concentration measurement
  #  17 Dec 2013:  Added output to distinguish high-speed from normal mode of operation
  #  29 Jan 2014:  Initialized methane amplitude in water fit (peak8) using peak0 amplitude
  #                Fixed minor bug in logic for adjust_0 = 0 and adjust_5 = 0.
  #   3 Feb 2014:  Added PPF to isotopic (slow) mode.  Removed up/down methane reporting.
- #   4 May 2015:  Changed the definition of "interval" to mean period between successive high-speed CH4 or isotopic measurements
  
  import os.path
  import time
  from numpy import *
  
</t>
<t tx="sze.20150506154736.4">#  G2000 isotopic methane fitter for the FCDS variation -- C-13/C-12 only with CFADS spectroscopy for C-12 measurement
#  Spectral IDs
#     11 -- H2O at 6057.8 (CFADS)
#    150 -- Isomethane and water vapor from 6028.4 to 6029.4 combined with CFADS methane at 6057 wvn
#    153 -- (12)CO2 at 6056.7
#  Spectral IDs added for high speed methane measurement (19 Nov 2013)
#     25 -- (12)CH4 only at 6057 wvn
#    150 -- (12)CH4 only at 6028.5 wvn
#    151 -- (13)CH4 only at 6029 wvn
#    152 -- Water vapor at 6028.8 wvn

#  09 Sep 2011:  Adapted from earlier CBDS and CFIDS fitters
#  07 Nov 2011:  New variant for potential PG&amp;E application with different schemes:  6029 and 6057 regions collected as 1 SID
#  17 Nov 2011:  Fixed a bad bug in the peak 5 WLM adjust logic.  Consolidated concentration calibration factors and adjusted to match CFADS on FCDS2003.
#  17 Nov 2011:  Changed sigma filter on WLM setpoint from 3 to 10
#  18 Nov 2011:  Changed VC water fit to fix methane y-parameter and increased minimum peak requirement for water WLM adjust.
#  01 Dec 2011:  Major change -- merged with the fitter  variant developed for PG&amp;E(R:\crd_G2000\FCDS\1061-FCDS2003\Config\20111122)
#  02 Dec 2011:  Fixed major bug in initialization of 6057 methane (high precision) fit for merged fitter.
#  06 Dec 2011:  Removed base average from CFADS CH4 fitter
#  10 Jan 2012:  Fixed y-parameter of C-13 triplet fit based on y of C-12 singlet (more stable at low concentration)
#  20 Jan 2012:  Include neighboring CO2 peaks in methane region fits to improve WLM tracking for low methane and high [CO2]
#  27 Apr 2012:  Incorporated improvements from CFIDS fitter:  (1) CO2 lines in spectral model for 6029 region;
#                (2) W/D calculation; (3) initialization of y_5 based on y_0; (4) newer spectral library
#  29 May 2012:  Removed bogus factor 0.84 from methane conc conversion in 6029 wvn region (messed up 6056 spline)
#  28 Feb 2013:  Fixed logic in shift/adjust of SID 153 (CO2 at 6056.5)
#   7 Jun 2013:  Fixed bug in HP methane -- WLM adjust was stuck when measurement 6057 wvn inactive
#  19 Nov 2013:  Start work on a version for high speed CH4 concentration measurement
#  17 Dec 2013:  Added output to distinguish high-speed from normal mode of operation
#  29 Jan 2014:  Initialized methane amplitude in water fit (peak8) using peak0 amplitude
#                Fixed minor bug in logic for adjust_0 = 0 and adjust_5 = 0.
#   3 Feb 2014:  Added PPF to isotopic (slow) mode.  Removed up/down methane reporting.

import os.path
import time
from numpy import *

</t>
<t tx="sze.20150506154736.5">#  G2000 isotopic methane fitter for the FCDS variation -- C-13/C-12 only with CFADS spectroscopy for C-12 measurement
#  Spectral IDs
#     11 -- H2O at 6057.8 (CFADS)
#    150 -- Isomethane and water vapor from 6028.4 to 6029.4 combined with CFADS methane at 6057 wvn
#    153 -- (12)CO2 at 6056.7
#  Spectral IDs added for high speed methane measurement (19 Nov 2013)
#     25 -- (12)CH4 only at 6057 wvn
#    150 -- (12)CH4 only at 6028.5 wvn
#    151 -- (13)CH4 only at 6029 wvn
#    152 -- Water vapor at 6028.8 wvn

#  09 Sep 2011:  Adapted from earlier CBDS and CFIDS fitters
#  07 Nov 2011:  New variant for potential PG&amp;E application with different schemes:  6029 and 6057 regions collected as 1 SID
#  17 Nov 2011:  Fixed a bad bug in the peak 5 WLM adjust logic.  Consolidated concentration calibration factors and adjusted to match CFADS on FCDS2003.
#  17 Nov 2011:  Changed sigma filter on WLM setpoint from 3 to 10
#  18 Nov 2011:  Changed VC water fit to fix methane y-parameter and increased minimum peak requirement for water WLM adjust.
#  01 Dec 2011:  Major change -- merged with the fitter  variant developed for PG&amp;E(R:\crd_G2000\FCDS\1061-FCDS2003\Config\20111122)
#  02 Dec 2011:  Fixed major bug in initialization of 6057 methane (high precision) fit for merged fitter.
#  06 Dec 2011:  Removed base average from CFADS CH4 fitter
#  10 Jan 2012:  Fixed y-parameter of C-13 triplet fit based on y of C-12 singlet (more stable at low concentration)
#  20 Jan 2012:  Include neighboring CO2 peaks in methane region fits to improve WLM tracking for low methane and high [CO2]
#  27 Apr 2012:  Incorporated improvements from CFIDS fitter:  (1) CO2 lines in spectral model for 6029 region;
#                (2) W/D calculation; (3) initialization of y_5 based on y_0; (4) newer spectral library
#  29 May 2012:  Removed bogus factor 0.84 from methane conc conversion in 6029 wvn region (messed up 6056 spline)
#  28 Feb 2013:  Fixed logic in shift/adjust of SID 153 (CO2 at 6056.5)
#   7 Jun 2013:  Fixed bug in HP methane -- WLM adjust was stuck when measurement 6057 wvn inactive
#  19 Nov 2013:  Start work on a version for high speed CH4 concentration measurement
#  17 Dec 2013:  Added output to distinguish high-speed from normal mode of operation
#  29 Jan 2014:  Initialized methane amplitude in water fit (peak8) using peak0 amplitude
#                Fixed minor bug in logic for adjust_0 = 0 and adjust_5 = 0.
#   3 Feb 2014:  Added PPF to isotopic (slow) mode.  Removed up/down methane reporting.
#   4 May 2015:  Changed the definition of "interval" to mean period between successive high-speed CH4 or isotopic measurements

import os.path
import time
from numpy import *

</t>
<t tx="sze.20150506155541.1">@language python
@tabwidth -4
&lt;&lt;analyze_FBDS declarations&gt;&gt;

@others

CHEM_DETECT = 0
&lt;&lt;SystemStatus Masks&gt;&gt;
&lt;&lt;AnalyzerStatus Masks&gt;&gt;
&lt;&lt;Alarm Parameters&gt;&gt;
&lt;&lt;Setup Constants&gt;&gt;
&lt;&lt;Initialize System status flags&gt;&gt;
&lt;&lt;Valve masks&gt;&gt;

if _PERSISTENT_["init"]:
    &lt;&lt;Initialization code&gt;&gt;
    
&lt;&lt;Handle PeakDetector&gt;&gt;    
&lt;&lt;Ensure sensor minimal log is not running&gt;&gt;


&lt;&lt;Handle command-line options&gt;&gt;
&lt;&lt;Get info from InstrCal file&gt;&gt;

Warmbox_setpoint = _DRIVER_.rdDasReg('WARM_BOX_TEMP_CNTRL_USER_SETPOINT_REGISTER')
    
&lt;&lt;Analyze Fit Output Data&gt;&gt;
suppressReporting = _DATA_['fast_flag'] and _DATA_['species'] != 25

&lt;&lt;Analyze Peripheral Data&gt;&gt;
&lt;&lt;Process Instrument Status&gt;&gt;
&lt;&lt;Check data processing latency&gt;&gt;
&lt;&lt;Check if warm box temperature is within WB_TEMP_ISO_THRESHOLD of setpoint&gt;&gt;

if not good:
    print "Updating WLM offset not done because of bad instrument status"
else:
    &lt;&lt;Turn off heater&gt;&gt;
    &lt;&lt;Handle anemometer anomalies&gt;&gt;
    &lt;&lt;Update wavelength monitor offsets&gt;&gt;
    
&lt;&lt;ChemDetect processing&gt;&gt;

if _DATA_["species"] in TARGET_SPECIES and _PERSISTENT_["plot_iCH4"] and not suppressReporting:
    &lt;&lt;Handle AnalyzerStatus ChemDetect mask&gt;&gt;
    &lt;&lt;Set up alarmActive when not in capture mode&gt;&gt;
    &lt;&lt;Check mobile kit flow sensor reading&gt;&gt;
    &lt;&lt;Check for unstable wind speed and correlation between car speed and wind speed&gt;&gt;
    &lt;&lt;Update AnalyzerStatus&gt;&gt;
    
&lt;&lt;Handle SystemStatus&gt;&gt;

if _DATA_["species"] in TARGET_SPECIES and _PERSISTENT_["plot_iCH4"] and not suppressReporting:
    &lt;&lt;Report persistent variables&gt;&gt;
    &lt;&lt;Execute laser ageing script&gt;&gt;
    &lt;&lt;Report DATA and NEW_DATA&gt;&gt;
</t>
<t tx="sze.20150506155630.1">#  Data analysis script for the experimental instrument combining CBDS with CFADS for methane and water
#  2011 0323 - removed wlm3 feedback for SID 109 (old water at 6250) and used VL3 for the
#              high precision CH4 measurement, SID 25.  Now wlm4 is used exclusively for the
#              low precision CH4 measurement, SID 29, which is also used for iCO2 correction.
#  2011 0727 - modified isotopic methane analysis to use new schemes that report the entire spectrum in one piece
# 2014 0602 removed unnecessary sections left from CFI
#           added flag for isotopic capture when WB within .07 degC tolerance
#           improved reporting structure for Peripheral health monitoring

import os
import sys
import inspect
import traceback
import collections

from math import exp

import numpy
from numpy import mean, isfinite, isnan

from Host import PeriphIntrf
from Host.Common.EventManagerProxy import Log, LogExc
from Host.Common.InstMgrInc import INSTMGR_STATUS_CAVITY_TEMP_LOCKED, INSTMGR_STATUS_WARM_CHAMBER_TEMP_LOCKED
from Host.Common.InstMgrInc import INSTMGR_STATUS_WARMING_UP, INSTMGR_STATUS_SYSTEM_ERROR, INSTMGR_STATUS_PRESSURE_LOCKED
from Host.Common.timestamp import getTimestamp

here = os.path.split(os.path.abspath(inspect.getfile( inspect.currentframe())))[0]
if here not in sys.path:
    sys.path.append(here)

from Chemdetect.instructionprocess import InstructionProcess # new ChemDetect
from Host.Common.CustomConfigObj import CustomConfigObj # new ChemDetect

</t>
<t tx="sze.20150506155630.2"># From fitterThread.py -- should be integrated into DM to use the "flat" .ini structure of FitterConfig.ini
def evalLeaves(d):
    for k in d:
        if isinstance(d[k],dict):
            evalLeaves(d[k])
        else:
            try:
                d[k] = eval(d[k])
            except:
                pass
    return d


</t>
<t tx="sze.20150506155630.3">def clipReportData(value):
    if value &gt; REPORT_UPPER_LIMIT:
        return REPORT_UPPER_LIMIT
    elif  value &lt; REPORT_LOWER_LIMIT:
        return REPORT_LOWER_LIMIT
    else:
        return value

</t>
<t tx="sze.20150506155630.4">def applyLinear(value,xform):
    return xform[0]*value + xform[1]

</t>
<t tx="sze.20150506155630.5">def apply2Linear(value,xform1,xform2):
    return applyLinear(applyLinear(value,xform1),xform2)

</t>
<t tx="sze.20150506155630.6">def protDivide(num,den):
    if den != 0:
        return num/den
    return 0

</t>
<t tx="sze.20150506155630.7">def expAverage(xavg,x,dt,tau):
    if xavg is None:
        xavg = x
    else:
        xavg = (1.0-exp(-dt/tau))*x + exp(-dt/tau)*xavg
    return xavg

</t>
<t tx="sze.20150506155630.8">def boxAverage(buffer,x,t,tau):
    buffer.append((x,t))
    while t-buffer[0][1] &gt; tau:
        buffer.pop(0)
    return mean([d for (d,t) in buffer])

</t>
<t tx="sze.20150506155630.9">def unstableWindSpeed(windSpeed):
    _PERSISTENT_['windSpeedBuffer'].append(windSpeed)
    windSpeedHistoryStd = numpy.std(_PERSISTENT_['windSpeedBuffer'], ddof=1)
    return windSpeed &gt; (2.6 * windSpeedHistoryStd)

</t>
<t tx="sze.20150506162409.1"># Handle options from command line
optDict = eval("dict(%s)" % _OPTIONS_)
conc = optDict.get("conc", "high").lower()</t>
<t tx="sze.20150506162645.1"># Define linear transformtions for post-processing
DELTA_iCH4 = (_INSTR_["iCH4_concentration_iso_slope"],_INSTR_["iCH4_concentration_iso_intercept"])
RATIO_iCH4 = (_INSTR_["iCH4_concentration_r_slope"],_INSTR_["iCH4_concentration_r_intercept"])
C12_iCH4 = (_INSTR_["iCH4_concentration_c12_gal_slope"],_INSTR_["iCH4_concentration_c12_gal_intercept"])
C13_iCH4 = (_INSTR_["iCH4_concentration_c13_gal_slope"],_INSTR_["iCH4_concentration_c13_gal_intercept"])
C12_CH4_CFADS = (_INSTR_["CH4_CFADS_concentration_c12_gal_slope"],_INSTR_["CH4_CFADS_concentration_c12_gal_intercept"])
H2O = (_INSTR_["concentration_h2o_gal_slope"],_INSTR_["concentration_h2o_gal_intercept"])
CO2 = (_INSTR_["concentration_co2_gal_slope"],_INSTR_["concentration_co2_gal_intercept"])
DELTA_iCO2 = (_INSTR_["iCO2_concentration_iso_slope"],_INSTR_["iCO2_concentration_iso_intercept"])
RATIO_iCO2 = (_INSTR_["iCO2_concentration_r_slope"],_INSTR_["iCO2_concentration_r_intercept"])
C12_iCO2 = (_INSTR_["iCO2_concentration_c12_gal_slope"],_INSTR_["iCO2_concentration_c12_gal_intercept"])
C13_iCO2 = (_INSTR_["iCO2_concentration_c13_gal_slope"],_INSTR_["iCO2_concentration_c13_gal_intercept"])
DELTA_HIGH_CONC_iCH4 = (_INSTR_["iCH4_high_concentration_iso_slope"],_INSTR_["iCH4_high_concentration_iso_intercept"])
CH4_HIGH_THRESHOLD = _INSTR_["ch4_high_threshold"]
CH4_LOW_THRESHOLD = _INSTR_["ch4_low_threshold"]

P5_off_low_conc = _INSTR_["Peak5_offset_low_conc"]
P5_quad_low_conc = _INSTR_["Peak5_quad_low_conc"]
P5_A1_low_conc = _INSTR_["Peak5_CO2_lin_low_conc"]
P5_H1_low_conc = _INSTR_["Peak5_water_lin_low_conc"]
P5_H1M1_low_conc = _INSTR_["Peak5_water_bilin_low_conc"]

try:
    NUM_BLOCKING_DATA = _INSTR_["num_blocking_data"]
except:
    NUM_BLOCKING_DATA = 20
</t>
<t tx="sze.20150506163129.1">#iCH4

_12_ch4_raw = 0.0

# Uses high concentration methane
try:
    _12_ch4_raw = _DATA_["12CH4_raw"]
    temp = applyLinear(_12_ch4_raw,C12_iCH4)
    _NEW_DATA_["12CH4_high_range"] = temp
    _NEW_DATA_["HR_12CH4"] = temp
except:
    pass

try:
    temp = applyLinear(_DATA_["13CH4_raw"],C13_iCH4)  # Uses high concentration methane
    _NEW_DATA_["13CH4"] = temp
except:
    pass

# Calculate delta without CFADS laser
try:
    if _DATA_["species"] == 150:
        temp = protDivide(_DATA_["peak5_spec"],_DATA_["peak0_spec"])
        delta_high_conc_iCH4 = applyLinear(temp,DELTA_HIGH_CONC_iCH4)
        now = _OLD_DATA_["peak5_spec"][-1].time
        # calculate delta time interval
        if _PERSISTENT_["last_delta_time"] != 0:
            delta_interval = now - _PERSISTENT_["last_delta_time"]
        else:
            delta_interval = 0
        _PERSISTENT_["last_delta_time"] = now
        _PERSISTENT_["delta_high_conc_iCH4"] = delta_high_conc_iCH4
        _PERSISTENT_["delta_high_conc_iCH4_30s"] = boxAverage(_PERSISTENT_["buffer30_iCH4_high_conc"],delta_high_conc_iCH4,now,30)
        _PERSISTENT_["delta_high_conc_iCH4_2min"] = boxAverage(_PERSISTENT_["buffer120_iCH4_high_conc"],delta_high_conc_iCH4,now,120)
        _PERSISTENT_["delta_high_conc_iCH4_5min"] = boxAverage(_PERSISTENT_["buffer300_iCH4_high_conc"],delta_high_conc_iCH4,now,300)
        _PERSISTENT_["delta_interval"] = delta_interval
        # end of calculate delta time interval
        if _PERSISTENT_["num_delta_iCH4_values"] &lt;= NUM_BLOCKING_DATA:
            _PERSISTENT_["num_delta_iCH4_values"] += 1
        elif not _PERSISTENT_["plot_iCH4"]:
            _PERSISTENT_["plot_iCH4"] = True
except Exception,e:
    pass

_NEW_DATA_["HR_Delta_iCH4_Raw"] = _PERSISTENT_["delta_high_conc_iCH4"]
_NEW_DATA_["HR_Delta_iCH4_30s"] = _PERSISTENT_["delta_high_conc_iCH4_30s"]
_NEW_DATA_["HR_Delta_iCH4_2min"] = _PERSISTENT_["delta_high_conc_iCH4_2min"]
_NEW_DATA_["HR_Delta_iCH4_5min"] = _PERSISTENT_["delta_high_conc_iCH4_5min"]
_NEW_DATA_["delta_interval"] = _PERSISTENT_["delta_interval"]
_NEW_DATA_["HP_or_HR_mode"] = 1

# Calculate delta with CFADS laser
try:
    if _DATA_["species"]  == 150:
        peak5_spec_low_conc = _DATA_["peakheight_5"] + P5_off_low_conc + P5_quad_low_conc*(_DATA_["ch4_splinemax"])*(_DATA_["ch4_splinemax"])
        peak5_spec_low_conc += P5_A1_low_conc*_DATA_["peak24_spec"] + P5_H1_low_conc*_DATA_["peak30_spec"]+ P5_H1M1_low_conc*_DATA_["peak30_spec"]*_DATA_["peakheight_5"]
        temp = protDivide(peak5_spec_low_conc, _DATA_["ch4_splinemax"])
        delta_iCH4 = applyLinear(temp,DELTA_iCH4)
        _NEW_DATA_["HP_Delta_iCH4_Raw"] = delta_iCH4
        now = _OLD_DATA_["peak5_spec"][-1].time
        _NEW_DATA_["HP_Delta_iCH4_30s"] = boxAverage(_PERSISTENT_["buffer30_iCH4"],delta_iCH4,now,30)
        _NEW_DATA_["HP_Delta_iCH4_2min"] = boxAverage(_PERSISTENT_["buffer120_iCH4"],delta_iCH4,now,120)
        _NEW_DATA_["HP_Delta_iCH4_5min"] = boxAverage(_PERSISTENT_["buffer300_iCH4"],delta_iCH4,now,300)
        ratio_iCH4 = applyLinear(temp,RATIO_iCH4)
        _NEW_DATA_["Ratio_Raw_iCH4"] = ratio_iCH4
        _NEW_DATA_["Ratio_30s_iCH4"] = boxAverage(_PERSISTENT_["ratio30_iCH4"],ratio_iCH4,now,30)
        _NEW_DATA_["Ratio_2min_iCH4"] = boxAverage(_PERSISTENT_["ratio120_iCH4"],ratio_iCH4,now,120)
        _NEW_DATA_["Ratio_5min_iCH4"] = boxAverage(_PERSISTENT_["ratio300_iCH4"],ratio_iCH4,now,300)
    else:
        _NEW_DATA_["HP_Delta_iCH4_Raw"] = _OLD_DATA_["HP_Delta_iCH4_Raw"][-1].value
        _NEW_DATA_["HP_Delta_iCH4_30s"] = _OLD_DATA_["HP_Delta_iCH4_30s"][-1].value
        _NEW_DATA_["HP_Delta_iCH4_2min"] = _OLD_DATA_["HP_Delta_iCH4_2min"][-1].value
        _NEW_DATA_["HP_Delta_iCH4_5min"] = _OLD_DATA_["HP_Delta_iCH4_5min"][-1].value
        _NEW_DATA_["Ratio_Raw_iCH4"] = _OLD_DATA_["Ratio_Raw_iCH4"][-1].value
        _NEW_DATA_["Ratio_30s_iCH4"] = _OLD_DATA_["Ratio_30s_iCH4"][-1].value
        _NEW_DATA_["Ratio_2min_iCH4"] = _OLD_DATA_["Ratio_2min_iCH4"][-1].value
        _NEW_DATA_["Ratio_5min_iCH4"] = _OLD_DATA_["Ratio_5min_iCH4"][-1].value
except Exception,e:
    print "Error %s (%r)" % (e,e) #For VA: Errors happened are "deque index out of range" (due to IF line) (probably because there are no '-3' and '-2'
        #at the beginning of data) and "KeyError('Delta_Raw_iCH4',)" due to Delta_Raw_iCH4 line at the beginning of ELSE section

if "HP_Delta_iCH4_Raw" in _NEW_DATA_:
    _PERSISTENT_["Delta_iCH4_Raw"] = _NEW_DATA_["HP_Delta_iCH4_Raw"]

_NEW_DATA_["Delta_iCH4_Raw"] = _PERSISTENT_["Delta_iCH4_Raw"]

try:
    temp = applyLinear(_DATA_["h2o_conc_pct"],H2O)
    _NEW_DATA_["H2O"] = temp
except:
    pass

try:
    temp = applyLinear(_DATA_["co2_conc"],CO2)
    _NEW_DATA_["CO2"] = temp
except:
    pass

# Uses low concentration methane (CFADS)
try:
    temp = applyLinear(_DATA_["ch4_conc_ppmv_final"],C12_CH4_CFADS)
    _NEW_DATA_["HP_12CH4"] = temp
    _DATA_["CH4"] = temp
except:
    pass

for v in ['HC_res2_a1', 'HC_res2_diff', 'HC_res2', 'HC_base_offset2_a1', 'HC_base_offset2_diff', 'HC_base_offset2']:
    _NEW_DATA_[v] = 0 # so these always exist in slow or fast modes
    
try: # new ChemDetect section
    Cor_HP_HCres_CO2 = _PERSISTENT_["chemdetect_inst"].current_var_values['Cor_HP_HCres_CO2']
    Cor_HP_HCbaseoffset_H2O = _PERSISTENT_["chemdetect_inst"].current_var_values['Cor_HP_HCbaseoffset_H2O']
    _NEW_DATA_["HC_res2"] = _DATA_["HC_res"] - Cor_HP_HCres_CO2 * _NEW_DATA_["CO2"] # CO2 Correction on HC_res
    _NEW_DATA_["HC_base_offset2"]= _DATA_["HC_base_offset"] - Cor_HP_HCbaseoffset_H2O * _NEW_DATA_["H2O"] # H2O Cor on HC_base_offset
    a0_HC_base_offset2 = _PERSISTENT_["chemdetect_inst"].current_var_values['a0_HC_base_offset2_HP']
    a1_HC_base_offset2 = _PERSISTENT_["chemdetect_inst"].current_var_values['a1_HC_base_offset2_HP']
    a0_HC_res2 = _PERSISTENT_["chemdetect_inst"].current_var_values['a0_HC_res2_HP']
    a1_HC_res2 = _PERSISTENT_["chemdetect_inst"].current_var_values['a1_HC_res2_HP']

    HC_base_offset2_fit = a0_HC_base_offset2 + _NEW_DATA_["12CH4_high_range"] * a1_HC_base_offset2 #fit params obtained from 3D data 2011-09-25
    _NEW_DATA_["HC_base_offset2_diff"]= _NEW_DATA_["HC_base_offset2"] - HC_base_offset2_fit
    _NEW_DATA_["HC_base_offset2_a1"] = (_NEW_DATA_["HC_base_offset2"] - a0_HC_base_offset2) / _NEW_DATA_["12CH4_high_range"]
    HC_res2_fit = a0_HC_res2 + _NEW_DATA_["12CH4_high_range"] * a1_HC_res2  #fit params obtained from 3D data on 2011-09-25
    _NEW_DATA_["HC_res2_diff"] = _NEW_DATA_["HC_res2"] - HC_res2_fit
    _NEW_DATA_["HC_res2_a1"] = (_NEW_DATA_["HC_res2"] - a0_HC_res2) / _NEW_DATA_["12CH4_high_range"]
except:
    pass
try:
    _DATA_["CH4up"] = _DATA_["12CH4_up"]
    _DATA_["CH4down"] = _DATA_["12CH4_down"]
    _DATA_["CH4dt"] = _DATA_["C12H4_time_separation"]
except:
    pass</t>
<t tx="sze.20150506163215.1"># Get peripheral data
try:
    if _PERIPH_INTRF_:
        try:
            interpData = _PERIPH_INTRF_( _DATA_["timestamp"], _PERIPH_INTRF_COLS_)
            for i in range(len(_PERIPH_INTRF_COLS_)):
                if interpData[i] is not None:
                    _NEW_DATA_[_PERIPH_INTRF_COLS_[i]] = interpData[i]
        except Exception, err:
            print "%r" % err
except:
    pass</t>
<t tx="sze.20150506163404.1"># Check instrument status and do not do any updates if any parameters are unlocked

pressureLocked =    _INSTR_STATUS_ &amp; INSTMGR_STATUS_PRESSURE_LOCKED
cavityTempLocked =  _INSTR_STATUS_ &amp; INSTMGR_STATUS_CAVITY_TEMP_LOCKED
warmboxTempLocked = _INSTR_STATUS_ &amp; INSTMGR_STATUS_WARM_CHAMBER_TEMP_LOCKED
warmingUp =         _INSTR_STATUS_ &amp; INSTMGR_STATUS_WARMING_UP
systemError =       _INSTR_STATUS_ &amp; INSTMGR_STATUS_SYSTEM_ERROR
good = pressureLocked and cavityTempLocked and warmboxTempLocked and (not warmingUp) and (not systemError)</t>
<t tx="sze.20150506163500.1">nowTs = getTimestamp()
delay = nowTs-_DATA_["timestamp"]
if delay &gt; max_delay*1000:
    Log("Large data processing latency, check excessive processor use",
        Data=dict(delay='%.1f s' % (0.001*delay,)),Level=2)
    good = False</t>
<t tx="sze.20150506163547.1">if _DATA_['WarmBoxTemp'] &gt; Warmbox_setpoint - WB_TEMP_ISO_THRESHOLD and _DATA_['WarmBoxTemp'] &lt; Warmbox_setpoint + WB_TEMP_ISO_THRESHOLD:
    WBisoTempLocked = True
else:
    WBisoTempLocked = False</t>
<t tx="sze.20150506163653.1"># Turn off heater on first good data
if _PERSISTENT_["turnOffHeater"]:
    Log("Heater turned off")
    _DRIVER_.wrDasReg("HEATER_TEMP_CNTRL_STATE_REGISTER","HEATER_CNTRL_DisabledState")
    _PERSISTENT_["turnOffHeater"] = False</t>
<t tx="sze.20150506163722.1"># Wind anomaly handling
validWindCheck = True
windFields = ['PERIPHERAL_STATUS', 'CAR_SPEED', 'GPS_FIT']

for f in windFields:
    validWindCheck &amp;= (f in _NEW_DATA_)

if validWindCheck:
    if (int(_NEW_DATA_['PERIPHERAL_STATUS']) &amp; PeriphIntrf.PeripheralStatus.PeripheralStatus.WIND_ANOMALY) &gt; 0:
        if not isnan(_NEW_DATA_['CAR_SPEED']) and _NEW_DATA_['GPS_FIT'] == GPS_GOOD:
            Log("Wind NaN due to anomaly")
            _PERSISTENT_['inactiveForWind'] = True

        else:
            Log("Wind NaN due to GPS")
    else:
        if _PERSISTENT_['inactiveForWind']:
            Log("Survey status back to active after wind anomaly")
            _PERSISTENT_['inactiveForWind'] = False</t>
<t tx="sze.20150506163829.1">if _DATA_["species"] == 150: # Update the offset for virtual laser 3,4,5
    try:
        ch4_adjust = _DATA_["adjust_5"]
        ch4_adjust = min(max_adjust,max(-max_adjust,damp*ch4_adjust))
        newOffset0 = _FREQ_CONV_.getWlmOffset(3) + ch4_adjust
        _NEW_DATA_["wlm3_offset"] = newOffset0
        _PERSISTENT_["wlm3_offset"] = newOffset0
        _FREQ_CONV_.setWlmOffset(3,float(newOffset0))
    except:
        pass

    try:
        ch4_adjust = _DATA_["adjust_0"]
        ch4_adjust = min(max_adjust,max(-max_adjust,damp*ch4_adjust))
        newOffset0 = _FREQ_CONV_.getWlmOffset(4) + ch4_adjust
        _NEW_DATA_["wlm4_offset"] = newOffset0
        _PERSISTENT_["wlm4_offset"] = newOffset0
        _FREQ_CONV_.setWlmOffset(4,float(newOffset0))
    except:
        pass

    try:
        h2o_adjust = _DATA_["adjust_30"]
        h2o_adjust = min(max_adjust,max(-max_adjust,damp*h2o_adjust))
        newOffset0 = _FREQ_CONV_.getWlmOffset(5) + h2o_adjust
        _NEW_DATA_["wlm5_offset"] = newOffset0
        _PERSISTENT_["wlm5_offset"] = newOffset0
        _FREQ_CONV_.setWlmOffset(5,float(newOffset0))
    except:
        pass

    try:
        ch4_high_adjust = _DATA_["ch4_high_adjust"]
        ch4_high_adjust = min(max_adjust,max(-max_adjust,damp*ch4_high_adjust))
        newOffset0 = _FREQ_CONV_.getWlmOffset(8) + ch4_high_adjust
        _NEW_DATA_["wlm8_offset"] = newOffset0
        _PERSISTENT_["wlm8_offset"] = newOffset0
        _FREQ_CONV_.setWlmOffset(8,float(newOffset0))
    except:
        pass

elif _DATA_["species"] == 11: # Update the offset for virtual laser 7
    try:
        h2o_adjust = _DATA_["adjust_75"]
        h2o_adjust = min(max_adjust,max(-max_adjust,damp*h2o_adjust))
        newOffset0 = _FREQ_CONV_.getWlmOffset(7) + h2o_adjust
        _NEW_DATA_["wlm7_offset"] = newOffset0
        _PERSISTENT_["wlm7_offset"] = newOffset0
        _FREQ_CONV_.setWlmOffset(7,float(newOffset0))
    except:
        pass

elif _DATA_["species"] == 153: # Update the offset for virtual laser 6
    try:
        co2_adjust = _DATA_["adjust_24"]
        co2_adjust = min(max_adjust,max(-max_adjust,damp*co2_adjust))
        newOffset0 = _FREQ_CONV_.getWlmOffset(6) + co2_adjust
        _NEW_DATA_["wlm6_offset"] = newOffset0
        _PERSISTENT_["wlm6_offset"] = newOffset0
        _FREQ_CONV_.setWlmOffset(6,float(newOffset0))
    except:
        pass</t>
<t tx="sze.20150506164313.1"># Save all the variables defined in the _OLD_DATA_  and  _NEW_DATA_ arrays in the
# _PERSISTENT_ arrays so that they can be used in the ChemDetect spreadsheet.
for colname in _OLD_DATA_:    #  new ChemDetect section
    _PERSISTENT_["chemdetect_inst"].current_var_values[colname] = _OLD_DATA_[colname][-1].value

for colname in _NEW_DATA_:
    _PERSISTENT_["chemdetect_inst"].current_var_values[colname] = _NEW_DATA_[colname]

if _OLD_DATA_["species"][-1].value == 150 and not _DATA_['fast_flag']:
    _PERSISTENT_["chemdetect_inst"].process_set()

    if _PERSISTENT_["chemdetect_inst"].current_var_values['RED'] == True:
        pass
        #print "WARNING: ChemDetect Status is RED"</t>
<t tx="sze.20150506164529.1">if 'MOBILE_FLOW' in _DATA_:
    if _DATA_['MOBILE_FLOW'] == IntakeFlowRateDisconnected:
        AnalyzerStatus |= AnalyzerStatusIntakeFlowDisconnected

    elif _DATA_['MOBILE_FLOW'] &lt; IntakeFlowRateMin and alarmActive and alarmActiveState:
        AnalyzerStatus |= AnalyzerStatusIntakeFlowRateMask

    elif _DATA_['MOBILE_FLOW'] &gt; IntakeFlowRateMax and alarmActive and alarmActiveState:
        AnalyzerStatus |= AnalyzerStatusIntakeFlowRateMask</t>
<t tx="sze.20150506164740.1">if ('WIND_N' in _DATA_) and ('WIND_E' in _DATA_):
    windSpeed = 0.0

    if (not numpy.isnan(_DATA_['WIND_N'])) and (not numpy.isnan(_DATA_['WIND_E'])):
        windN = _DATA_['WIND_N']
        windE = _DATA_['WIND_E']
        windSpeed = numpy.sqrt(windN * windN + windE * windE)

    if unstableWindSpeed(windSpeed):
        PeripheralStatus |= PeriphIntrf.PeripheralStatus.PeripheralStatus.WIND_UNSTABLE

    if ('CAR_VEL_N' in _DATA_) and ('CAR_VEL_E' in _DATA_):
        carSpeed = 0.0

        if (not numpy.isnan(_DATA_['CAR_VEL_N'])) and (not numpy.isnan(_DATA_['CAR_VEL_E'])):
            carN = _DATA_['CAR_VEL_N']
            carE = _DATA_['CAR_VEL_E']
            carSpeed = numpy.sqrt(carN * carN + carE * carE)

        if (carSpeed != 0.0) and (carSpeed &gt; CarSpeedMaximum) and \
           (numpy.absolute((windSpeed / carSpeed) - 1.0) &gt; CarWindSpeedCorrelation):
            PeripheralStatus |= PeriphIntrf.PeripheralStatus.PeripheralStatus.WIND_SPEED_CAR_SPEED_UNCORRELATED</t>
<t tx="sze.20150506164942.1"># Check for the interval between methane data points and set the AnalyzerStatusDataRateMask if the exponentially averaged rate
#  is too slow
tooSlow = False
dt = _DATA_['interval']
if _DATA_['SpectrumID'] == FastMethaneSpectrumId:
    _PERSISTENT_["fastMethaneInterval"] = expAverage(_PERSISTENT_["fastMethaneInterval"], dt, dt, MethaneIntervalAveragingTime)
    tooSlow = _PERSISTENT_["fastMethaneInterval"] &gt; FastMethaneIntervalMax
elif _DATA_['SpectrumID'] == IsotopicMethaneSpectrumId:
    _PERSISTENT_["isotopicMethaneInterval"] = expAverage(_PERSISTENT_["isotopicMethaneInterval"], dt, dt, MethaneIntervalAveragingTime)
    tooSlow = _PERSISTENT_["isotopicMethaneInterval"] &gt; IsotopicMethaneIntervalMax
if tooSlow:
    AnalyzerStatus |= AnalyzerStatusDataRateMask

if _DATA_['CFADS_base'] &gt; CavityBaselineLossScaleFactor * _PERSISTENT_['baselineCavityLoss']:
    AnalyzerStatus |= AnalyzerStatusCavityBaselineLossMask

if (_NEW_DATA_['delta_interval'] &gt; DeltaIntervalMax) and (not alarmActive) and alarmActiveState:
    AnalyzerStatus |= AnalyzerStatusSamplingIntervalMask

if _DATA_['spect_latency'] &gt; SpectrumLatencyMax:
    AnalyzerStatus |= AnalyzerStatusRingdownRateMask

if numpy.absolute(_DATA_['ch4_high_shift']) &gt; WlmShiftMax:
    AnalyzerStatus |= AnalyzerStatusWlmShiftMask

if numpy.absolute(_DATA_['ch4_high_adjust']) &gt; WlmAdjustMax:
    AnalyzerStatus |= AnalyzerStatusWlmAdjustMask

if (numpy.absolute(_DATA_['ch4_high_shift']) &gt;= WlmShiftAdjustLimit) and (numpy.absolute(_DATA_['ch4_high_adjust']) &lt; WlmShiftAdjustLimit):
    AnalyzerStatus |= AnalyzerStatusWlmShiftAdjustCorrelationMask

_PERSISTENT_['wlmOffsetBuffer'].append(_PERSISTENT_['wlm6_offset'])
wlm6OffsetMean = numpy.mean(_PERSISTENT_['wlmOffsetBuffer'])
wlm6OffsetMax = max(_PERSISTENT_['wlmOffsetBuffer'])
wlm6OffsetMin = min(_PERSISTENT_['wlmOffsetBuffer'])

if wlm6OffsetMean != 0.0:
    if ((wlm6OffsetMax - wlm6OffsetMin) / wlm6OffsetMean) &gt; WlmTargetFreqMaxDrift:
        AnalyzerStatus |= AnalyzerStatusWlmTargetFreqMask
        
# Set the InvalidData mask in the AnalyzerStatus. Currently it is set only if the data rate is too low.
if 0 != (AnalyzerStatus &amp; AnalyzerStatusDataRateMask):
    AnalyzerStatus |= AnalyzerStatusInvalidDataMask

        </t>
<t tx="sze.20150506165859.1">SystemStatusPeripheralMask = 0x00000001
SystemStatusAnalyzerMask = 0x00000002</t>
<t tx="sze.20150506165934.1">AnalyzerStatusIntakeFlowRateMask = 0x00000001
AnalyzerStatusCavityBaselineLossMask = 0x00000002
AnalyzerStatusSamplingIntervalMask = 0x00000004
AnalyzerStatusRingdownRateMask = 0x00000008
AnalyzerStatusWlmShiftMask = 0x00000010
AnalyzerStatusWlmAdjustMask = 0x00000020
AnalyzerStatusWlmShiftAdjustCorrelationMask = 0x00000040
AnalyzerStatusWlmTargetFreqMask = 0x00000080
AnalyzerStatusIntakeFlowDisconnected = 0x00000100
AnalyzerStatusChemDetectMask = 0x00000200
AnalyzerStatusDataRateMask = 0x00000400
# The following bit invalidates the data (shown as a red path)
AnalyzerStatusInvalidDataMask = 0x80000000</t>
<t tx="sze.20150506170022.1"># Alarm parameters
IntakeFlowRateMin = 3.75
IntakeFlowRateMax = 5.0
IntakeFlowRateDisconnected = -9999.0
WindSpeedHistoryBufferLen = 100
CarSpeedMaximum = 4.47
CarWindSpeedCorrelation = 0.75
DeltaIntervalMax = 1.6
SpectrumLatencyMax = 3.0
WlmShiftMax = 2e-3
WlmAdjustMax = 2e-3
WlmShiftAdjustLimit = 5e-5
WlmTargetFreqMaxDrift = 0.05
WlmTargetFreqHistoryBufferLen = 6000
CavityBaselineLossScaleFactor = 1.1
FastMethaneIntervalMax = 0.4
IsotopicMethaneIntervalMax = 1.6
</t>
<t tx="sze.20150506170104.1"># System status flags
SystemStatus = 0x00000000
AnalyzerStatus = 0x00000000
PeripheralStatus = 0x00000000</t>
<t tx="sze.20150506170135.1"># Valve masks
VALVE_MASK_ACTIVE = 0x10
VALVE_MASK_CHECK_ALARM = 0x03</t>
<t tx="sze.20150506170401.1">_PERSISTENT_["turnOffHeater"] = True
_PERSISTENT_["wlm1_offset"] = 0.0
_PERSISTENT_["wlm2_offset"] = 0.0
_PERSISTENT_["wlm3_offset"] = 0.0
_PERSISTENT_["wlm4_offset"] = 0.0
_PERSISTENT_["wlm5_offset"] = 0.0
_PERSISTENT_["wlm6_offset"] = 0.0
_PERSISTENT_["wlm7_offset"] = 0.0
_PERSISTENT_["wlm8_offset"] = 0.0
_PERSISTENT_["buffer30_iCH4"]  = []
_PERSISTENT_["buffer120_iCH4"] = []
_PERSISTENT_["buffer300_iCH4"] = []
_PERSISTENT_["buffer30_iCH4_high_conc"] = []
_PERSISTENT_["buffer120_iCH4_high_conc"] = []
_PERSISTENT_["buffer300_iCH4_high_conc"] = []
_PERSISTENT_["ratio30_iCH4"]  = []
_PERSISTENT_["ratio120_iCH4"] = []
_PERSISTENT_["ratio300_iCH4"] = []
_PERSISTENT_["buffer30_iCO2"]  = []
_PERSISTENT_["buffer120_iCO2"] = []
_PERSISTENT_["buffer300_iCO2"] = []
_PERSISTENT_["ratio30_iCO2"]  = []
_PERSISTENT_["ratio120_iCO2"] = []
_PERSISTENT_["ratio300_iCO2"] = []
_PERSISTENT_["init"] = False
_PERSISTENT_["num_delta_iCH4_values"] = 0
_PERSISTENT_["num_delta_iCO2_values"] = 0
_PERSISTENT_["plot_iCH4"] = False
_PERSISTENT_["plot_iCO2"] = False
_PERSISTENT_["last_delta_time"] = 0
_PERSISTENT_["delta_high_conc_iCH4"] = 0
_PERSISTENT_["delta_high_conc_iCH4_30s"] = 0
_PERSISTENT_["delta_high_conc_iCH4_2min"] = 0
_PERSISTENT_["delta_high_conc_iCH4_5min"] = 0
_PERSISTENT_["delta_interval"] = 0
_PERSISTENT_["Delta_iCH4_Raw"] = 0.0
_PERSISTENT_["fineLaserCurrent_6_mean"] = 0
_PERSISTENT_["windSpeedBuffer"] = collections.deque(maxlen=WindSpeedHistoryBufferLen)
_PERSISTENT_["wlmOffsetBuffer"] = collections.deque(maxlen=WlmTargetFreqHistoryBufferLen)
_PERSISTENT_["peakDetectState"] = collections.deque(maxlen=50)
_PERSISTENT_["fastMethaneInterval"] = 0.0
_PERSISTENT_["isotopicMethaneInterval"] = 0.0

WBisoTempLocked = False

# For ChemDetect
_PERSISTENT_["chemdetect_inst"] = InstructionProcess()
configFile = os.path.join(here,"..\..\..\InstrConfig\Calibration\InstrCal\ChemDetect\ChemDetect.ini")
configPath = os.path.split(configFile)[0]

config = CustomConfigObj(configFile)
# Get the ChemDetect excel file name from the ini file
ChemDetect_FileName = config.get("Main", "ChemDetect_FileName") 
_PERSISTENT_["chemdetect_inst"].load_set_from_csv(os.path.join(configPath,ChemDetect_FileName))
# need to replace with self.instruction_path
_PERSISTENT_["ChemDetect_previous"] = 0.0

_PERSISTENT_['outletValve_min'] = _DRIVER_.rdDasReg(
    'VALVE_CNTRL_OUTLET_VALVE_MIN_REGISTER')
_PERSISTENT_['outletValve_max'] = _DRIVER_.rdDasReg(
    'VALVE_CNTRL_OUTLET_VALVE_MAX_REGISTER')

_PERSISTENT_['inactiveForWind'] = False

#For Laser Aging
script = "adjustTempOffset.py"
scriptRelPath = os.path.join(here, '..', '..', '..', 'CommonConfig',
                             'Scripts', 'DataManager', script)
cp = file(os.path.join(here, scriptRelPath), "rU")
codeAsString = cp.read() + "\n"
cp.close()
_PERSISTENT_["adjustOffsetScript"] = compile(codeAsString, script, 'exec')

fitterConfigFile = os.path.join(here, '..', '..', '..', 'InstrConfig', 'Calibration', 'InstrCal', 'FitterConfig.ini')
fitterConfig = evalLeaves(CustomConfigObj(fitterConfigFile, list_values=False).copy())
_PERSISTENT_['baselineCavityLoss'] = fitterConfig['CFADS_baseline']</t>
<t tx="sze.20150506170534.1"># read peak detect state register
# # Enumerated definitions for PEAK_DETECT_CNTRL_StateType
# PEAK_DETECT_CNTRL_StateType = c_uint
# PEAK_DETECT_CNTRL_IdleState = 0 # Idle
# PEAK_DETECT_CNTRL_ArmedState = 1 # Armed
# PEAK_DETECT_CNTRL_TriggerPendingState = 2 # Trigger Pending
# PEAK_DETECT_CNTRL_TriggeredState = 3 # Triggered
# PEAK_DETECT_CNTRL_InactiveState = 4 # Inactive
# PEAK_DETECT_CNTRL_CancellingState = 5 # Cancelling
# PEAK_DETECT_CNTRL_PrimingState = 6 # Priming
# PEAK_DETECT_CNTRL_PurgingState = 7 # Purging
# PEAK_DETECT_CNTRL_InjectionPendingState = 8 # Injection Pending
peakDetectState = _DRIVER_.rdDasReg('PEAK_DETECT_CNTRL_STATE_REGISTER') #integer value, see interface.py
_PERSISTENT_["peakDetectState"].append(peakDetectState)
#read peak detect register to get number of remaining samples
remainingPeakSamples = _DRIVER_.rdDasReg('PEAK_DETECT_CNTRL_REMAINING_TRIGGERED_SAMPLES_REGISTER') #number of samples integer, samples are 0.2 seconds</t>
<t tx="sze.20150506170721.1">try:
    if _DATA_LOGGER_ and _DATA_LOGGER_.DATALOGGER_logEnabledRpc('DataLog_Sensor_Minimal'):
        try:
            _DATA_LOGGER_.DATALOGGER_stopLogRpc("DataLog_Sensor_Minimal")
        except Exception, err:
            pass###print "_DATA_LOGGER_ Error: %r" % err
except:
    pass</t>
<t tx="sze.20150506181637.1"># Update the upper alarm status bits with some additional instrument status
# flags.
alarmActive = (int(_DATA_['ValveMask']) &amp; VALVE_MASK_CHECK_ALARM) == 0

alarmActiveState = numpy.sum( numpy.abs( numpy.diff(_PERSISTENT_["peakDetectState"]) ) ) &lt; 1
###print "alarmActive: " + str(alarmActive) + ", alarmActiveState: " + str(alarmActiveState)</t>
<t tx="sze.20150506181818.1">if _OLD_DATA_["species"][-1].value == 150:
    if _PERSISTENT_["chemdetect_inst"].current_var_values['RED'] == True:
        CHEM_DETECT = 1.0  # BAD data
    else:
        CHEM_DETECT = 0.0  # Good data
else:
    CHEM_DETECT = _PERSISTENT_["ChemDetect_previous"]

_PERSISTENT_["ChemDetect_previous"] = CHEM_DETECT
if CHEM_DETECT == 1.0:
    AnalyzerStatus |= AnalyzerStatusChemDetectMask</t>
<t tx="sze.20150506181904.1">if ('PERIPHERAL_STATUS' in _NEW_DATA_) and (int(_NEW_DATA_['PERIPHERAL_STATUS'])) &gt; 0:
    SystemStatus |= SystemStatusPeripheralMask

if AnalyzerStatus &gt; 0:
    SystemStatus |= SystemStatusAnalyzerMask</t>
<t tx="sze.20150506182103.1">_REPORT_["wlm1_offset"] = _PERSISTENT_["wlm1_offset"]
_REPORT_["wlm2_offset"] = _PERSISTENT_["wlm2_offset"]
_REPORT_["wlm3_offset"] = _PERSISTENT_["wlm3_offset"]
_REPORT_["wlm4_offset"] = _PERSISTENT_["wlm4_offset"]
_REPORT_["wlm5_offset"] = _PERSISTENT_["wlm5_offset"]
_REPORT_["wlm6_offset"] = _PERSISTENT_["wlm6_offset"]
_REPORT_["wlm7_offset"] = _PERSISTENT_["wlm7_offset"]
_REPORT_["wlm8_offset"] = _PERSISTENT_["wlm8_offset"]
_REPORT_["SystemStatus"] = SystemStatus
if 'PERIPHERAL_STATUS' in _NEW_DATA_:
    _REPORT_['PeripheralStatus'] = PeripheralStatus | int(_NEW_DATA_['PERIPHERAL_STATUS'])
_REPORT_['AnalyzerStatus'] = AnalyzerStatus
_REPORT_["CHEM_DETECT"] = CHEM_DETECT
_REPORT_["WBisoTempLocked"] = WBisoTempLocked
_REPORT_["fineLaserCurrent_6_mean"] = _PERSISTENT_["fineLaserCurrent_6_mean"]  #report 0 for VL6 made to prevent new Column upon mode switch when WL is on to track CO2
_REPORT_["fastMethaneInterval"] = _PERSISTENT_["fastMethaneInterval"]
_REPORT_["isotopicMethaneInterval"] = _PERSISTENT_["isotopicMethaneInterval"]</t>
<t tx="sze.20150506182135.1">for k in _DATA_.keys():
    _REPORT_[k] = _DATA_[k]

for k in _NEW_DATA_.keys():
    if k.startswith("Delta"):
        _REPORT_[k] = clipReportData(_NEW_DATA_[k])
    else:
        _REPORT_[k] = _NEW_DATA_[k]</t>
<t tx="sze.20150506182201.1">exec _PERSISTENT_["adjustOffsetScript"] in globals()</t>
<t tx="sze.20150506185525.1">@language python</t>
<t tx="sze.20150506194536.1"># Limits for delta values reported
REPORT_UPPER_LIMIT = 20000.0
REPORT_LOWER_LIMIT = -20000.0
# WB Temperature Proximity condition for isotopic measurement
WB_TEMP_ISO_THRESHOLD = 0.07
# SpectrumIds used
TARGET_SPECIES = [11, 25, 105, 106, 150, 153]
# Parameters for updating WLM Offsets
max_adjust = 1.0e-5
max_adjust_H2O = 1.0e-4
damp = 0.2
# Maximum delay before signalling data manager latency
max_delay = 20
# Constants for calculating mean interval between data points
FastMethaneSpectrumId = 25
IsotopicMethaneSpectrumId = 150
MethaneIntervalAveragingTime = 30.0</t>
<t tx="sze.20150507075702.1">@language python
@tabwidth -4
@others
</t>
<t tx="sze.20150507075745.1">import numpy as np
import pyodbc

</t>
<t tx="sze.20150507075745.2">def getAnalyzerId(analyzer):
    
    # constructing and running query
    server = "b-eng-db01.picarro.int"
    database = "SurveyorEngineering"
    uid = "engineering"
    password = "aDs76WoiJn"
    connection = pyodbc.connect('DRIVER={SQL Server}; SERVER=%s; DATABASE=%s; UID=%s; PWD=%s' %
                            (server, database, uid, password))
    cursor = connection.cursor()
    
    analyzerId = None
    cursor.execute("""
        SELECT Id
            FROM [SurveyorEngineering].[dbo].[Analyzer]
            WHERE SerialNumber = '%s'
    """ % analyzer)
    for row in cursor:
        analyzerId = row[0]
    return analyzerId

</t>
<t tx="sze.20150507075745.3">def getSurveysForAnalyzer(analyzer,center,radius,num_points=20):
    
    angles = np.linspace(0.0,2*np.pi,num_points+1)[:-1]
    vectors = [cmath.rect(radius,angles[i]) for i in xrange(len(angles))]
    outline = [coordinatePlusDistance(center,vectors[i].real,vectors[i].imag)
              for i in xrange(len(vectors))]
    outline.append(outline[0])
    lat , lng = zip(*outline)
    outline = zip(lng,lat)
    
    analyzer_ID = getAnalyzerId(analyzer)
    
    server = "b-eng-db01.picarro.int"
    database = "SurveyorEngineering"
    uid = "engineering"
    password = "aDs76WoiJn"
    connection = pyodbc.connect('DRIVER={SQL Server}; SERVER=%s; DATABASE=%s; UID=%s; PWD=%s' %
                            (server, database, uid, password))
    cursor = connection.cursor()
    
    surveys = []
    start_epochs = []
    end_epochs = []
    cursor.execute("""
    
        declare @bounds geometry = geometry::STGeomFromText('POLYGON((%s))', 4326);
    
        SELECT DISTINCT Segment.SurveyId , Survey.StartEpoch, Survey.EndEpoch
        FROM     Segment INNER JOIN
                          Survey ON Segment.SurveyId = Survey.Id
        WHERE  (Segment.Shape.MakeValid().STIntersects(@bounds) = 1)
        AND   (Survey.AnalyzerId='%s')
        
    """ % (','.join([str(v[0])+' '+str(v[1]) for v in outline ]),analyzer_ID))
    for row in cursor:
        surveys.append(row[0])
        start_epochs.append(row[1])
        end_epochs.append(row[2])
        
    return surveys , start_epochs , end_epochs

 def getRelevantSurveyData(start_epoch,end_epoch,analyzer,center,radius,num_points):
    
    angles = np.linspace(0.0,2*np.pi,num_points+1)[:-1]
    vectors = [cmath.rect(radius,angles[i]) for i in xrange(len(angles))]
    outline = [coordinatePlusDistance(center,vectors[i].real,vectors[i].imag)
              for i in xrange(len(vectors))]
    outline.append(outline[0])
    lat , lng = zip(*outline)
    outline = zip(lng,lat)
    
    analyzer_ID = getAnalyzerId(analyzer)
    
    server = "b-eng-db01.picarro.int"
    database = "SurveyorEngineering"
    uid = "engineering"
    password = "aDs76WoiJn"
    connection = pyodbc.connect('DRIVER={SQL Server}; SERVER=%s; DATABASE=%s; UID=%s; PWD=%s' %
                            (server, database, uid, password))
    cursor = connection.cursor()
    
    min_data = {
    'EPOCH_TIME':[],
    'CH4': [],
    'GPS_ABS_LAT': [],
    'GPS_ABS_LONG': [],
    'CAR_VEL_N': [],
    'CAR_VEL_E': [],
    'WS_WIND_LAT': [],
    'WS_WIND_LON': [],
    'WIND_N': [],
    'WIND_E': [],
    'WIND_DIR_SDEV': [],
    }
    
    cursor.execute("""
    
        declare @bounds geometry = geometry::STGeomFromText('POLYGON((%s))', 4326);
    
        SELECT [EpochTime]
              ,[GpsLatitude]
              ,[GpsLongitude]
              ,[CarSpeedNorth]
              ,[CarSpeedEast]
              ,[WindSpeedNorth]
              ,[WindSpeedEast]
              ,[WindDirectionStdDev]
              ,[WindSpeedLateral]
              ,[WindSpeedLongitudinal]
              ,[CH4]
        FROM [SurveyorEngineering].[dbo].[Measurement]
        WHERE (EpochTime BETWEEN '%s' AND '%s')
        AND (AnalyzerId = '%s')
        AND (Shape.STIntersects(@bounds) = 1)
        AND (GpsFit=2)
        
    """ % (','.join([str(v[0])+' '+str(v[1]) for v in outline ]),str(start_epoch),str(end_epoch),analyzer_ID))
    
    for row in cursor:
        min_data['EPOCH_TIME'].append(row[0])
        min_data['GPS_ABS_LAT'].append(row[1])
        min_data['GPS_ABS_LONG'].append(row[2])
        min_data['CAR_VEL_N'].append(row[3])
        min_data['CAR_VEL_E'].append(row[4])
        min_data['WIND_N'].append(row[5])
        min_data['WIND_E'].append(row[6])
        min_data['WIND_DIR_SDEV'].append(row[7])
        min_data['WS_WIND_LAT'].append(row[8])
        min_data['WS_WIND_LON'].append(row[9])
        min_data['CH4'].append(row[10])
    for key in min_data.keys():
        min_data[key] = np.asarray(min_data[key])[::-1]
    min_data['CAR_SPEED'] = np.sqrt(min_data['CAR_VEL_N']**2+min_data['CAR_VEL_E']**2)
    
    return min_data

</t>
<t tx="sze.20150507075745.4">def getSurveyMinData(start_epoch,end_epoch,analyzer,plot=False):
    
    analyzer_ID = getAnalyzerId(analyzer)
    
    server = "b-eng-db01.picarro.int"
    database = "SurveyorEngineering"
    uid = "engineering"
    password = "aDs76WoiJn"
    connection = pyodbc.connect('DRIVER={SQL Server}; SERVER=%s; DATABASE=%s; UID=%s; PWD=%s' %
                            (server, database, uid, password))
    cursor = connection.cursor()
    
    min_data = {
    'EPOCH_TIME':[],
    'CH4': [],
    'GPS_ABS_LAT': [],
    'GPS_ABS_LONG': [],
    'CAR_VEL_N': [],
    'CAR_VEL_E': [],
    'WS_WIND_LAT': [],
    'WS_WIND_LON': [],
    'WIND_N': [],
    'WIND_E': [],
    'WIND_DIR_SDEV': [],
    }
    
    cursor.execute("""
    
        SELECT [EpochTime]
              ,[GpsLatitude]
              ,[GpsLongitude]
              ,[CarSpeedNorth]
              ,[CarSpeedEast]
              ,[WindSpeedNorth]
              ,[WindSpeedEast]
              ,[WindDirectionStdDev]
              ,[WindSpeedLateral]
              ,[WindSpeedLongitudinal]
              ,[CH4]
        FROM [SurveyorEngineering].[dbo].[Measurement]
        WHERE (EpochTime BETWEEN '%s' AND '%s')
        AND (AnalyzerId = '%s')
        AND (GpsFit=2)
        
    """ % (str(start_epoch),str(end_epoch),analyzer_ID))
    
    for row in cursor:
        min_data['EPOCH_TIME'].append(row[0])
        min_data['GPS_ABS_LAT'].append(row[1])
        min_data['GPS_ABS_LONG'].append(row[2])
        min_data['CAR_VEL_N'].append(row[3])
        min_data['CAR_VEL_E'].append(row[4])
        min_data['WIND_N'].append(row[5])
        min_data['WIND_E'].append(row[6])
        min_data['WIND_DIR_SDEV'].append(row[7])
        min_data['WS_WIND_LAT'].append(row[8])
        min_data['WS_WIND_LON'].append(row[9])
        min_data['CH4'].append(row[10])
        
    for key in min_data.keys():
        a = np.asarray(min_data[key],dtype=np.float)
        is_nan = np.isnan(a)
        if np.any(is_nan):
            good = np.where(is_nan==False)[0]
            bad = np.where(is_nan==True)[0]
            i = np.arange(a.size,dtype=np.int)
            a[bad] = np.interp(i[bad],i[good],a[good])
        min_data[key] = a
        
    if plot:
        plt.figure()
        plt.plot(min_data['GPS_ABS_LONG'],min_data['GPS_ABS_LAT'])
        plt.show()
    
    min_data['CAR_SPEED'] = np.sqrt(min_data['CAR_VEL_N']**2+min_data['CAR_VEL_E']**2)
    
    lat1 = min_data['GPS_ABS_LAT'][:-1]
    lng1 = min_data['GPS_ABS_LONG'][:-1]
    lat2 = min_data['GPS_ABS_LAT'][1:]
    lng2 = min_data['GPS_ABS_LONG'][1:]
    dist = haversine_vectorized(lat1,lng1,lat2,lng2)
    dist = np.cumsum(dist)
    dist = np.insert(dist,0,0.0)
    min_data['DISTANCE'] = dist
    
    return min_data

</t>
<t tx="sze.20150507075745.5">def get_backtraj_data(analyzer,epoch_time,duration):
    
    epoch_times = []
    lats = []
    lngs = []
    car_vel_norths = []
    car_vel_easts = []
    wind_lats = []
    wind_lngs = []
    
    analyzer_ID = getAnalyzerId(analyzer)
    
    server = "b-eng-db01.picarro.int"
    database = "SurveyorEngineering"
    uid = "engineering"
    password = "aDs76WoiJn"
    connection = pyodbc.connect('DRIVER={SQL Server}; SERVER=%s; DATABASE=%s; UID=%s; PWD=%s' %
                            (server, database, uid, password))
    cursor = connection.cursor()
    
    cursor.execute("""
    
        SELECT [EpochTime]
              ,[GpsLatitude]
              ,[GpsLongitude]
              ,[CarSpeedNorth]
              ,[CarSpeedEast]
              ,[WindSpeedLateral]
              ,[WindSpeedLongitudinal]
        FROM [SurveyorEngineering].[dbo].[Measurement]
        WHERE (EpochTime BETWEEN '%s' AND '%s')
        AND (AnalyzerId = '%s')
        AND (GpsFit=2)
        
    """ % (str(epoch_time-duration),str(epoch_time),analyzer_ID))
    
    for row in cursor:
        epoch_times.append(row[0])
        lats.append(row[1])
        lngs.append(row[2])
        car_vel_norths.append(row[3])
        car_vel_easts.append(row[4])
        wind_lats.append(row[5])
        wind_lngs.append(row[6])
        
    return dict(epoch_time=np.asarray(epoch_times),latitude=np.asarray(lats),
                longitude=np.asarray(lngs),car_vel_n=np.asarray(car_vel_norths),
                car_vel_e=np.asarray(car_vel_easts),wind_lat=np.asarray(wind_lats),
                wind_lng=np.asarray(wind_lngs))
    
</t>
<t tx="sze.20150507075912.1">@language python
@tabwidth -4

import numpy as np
import pyodbc

# constructing and running query
server = "b-eng-db01.picarro.int"
database = "SurveyorEngineering"
uid = "engineering"
password = "aDs76WoiJn"
connection = pyodbc.connect('DRIVER={SQL Server}; SERVER=%s; DATABASE=%s; UID=%s; PWD=%s' %
                        (server, database, uid, password))
cursor = connection.cursor()

# Get table names
cursor.execute("""
    SELECT DISTINCT TABLE_NAME
        FROM [SurveyorEngineering].INFORMATION_SCHEMA.COLUMNS
""")
print "\nTables Available"
for row in cursor:
    print row


# Get analyzer table column names
cursor.execute("""
    SELECT COLUMN_NAME
        FROM [SurveyorEngineering].INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_NAME = 'Analyzer'
""")

print "\nAnalyzer table columns"
for row in cursor:
    print row

# Get analyzer names and Id
cursor.execute("""
    SELECT SerialNumber, Id
        FROM [SurveyorEngineering].[dbo].[Analyzer]
""")

print "\nAnalyzers in database"
for row in cursor:
    print row

# Get measurement table column names
print "\nMeasurement table columns"
cursor.execute("""
    SELECT COLUMN_NAME
        FROM [SurveyorEngineering].INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_NAME = 'Measurement'
""")

for row in cursor:
    print row
</t>
<t tx="sze.20150507082344.1">@language python
@tabwidth -4

import numpy as np
import pyodbc

# constructing and running query
server = "b-eng-db01.picarro.int"
database = "SurveyorEngineering"
uid = "engineering"
password = "aDs76WoiJn"
connection = pyodbc.connect('DRIVER={SQL Server}; SERVER=%s; DATABASE=%s; UID=%s; PWD=%s' %
                        (server, database, uid, password))
cursor = connection.cursor()

# Get table names
cursor.execute("""
    SELECT DISTINCT TABLE_NAME
        FROM [SurveyorEngineering].INFORMATION_SCHEMA.COLUMNS
""")
print "\nTables Available"
for row in cursor:
    print row


# Get analyzer table column names
cursor.execute("""
    SELECT COLUMN_NAME
        FROM [SurveyorEngineering].INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_NAME = 'Analyzer'
""")

print "\nAnalyzer table columns"
for row in cursor:
    print row

# Get analyzer names and Id
cursor.execute("""
    SELECT SerialNumber, Id
        FROM [SurveyorEngineering].[dbo].[Analyzer]
""")

print "\nAnalyzers in database"
for row in cursor:
    print row

# Get measurement table column names
print "\nMeasurement table columns"
cursor.execute("""
    SELECT COLUMN_NAME
        FROM [SurveyorEngineering].INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_NAME = 'Measurement'
""")

for row in cursor:
    print row
    
# Get survey table column names
print "\nSurvey table columns"
cursor.execute("""
    SELECT COLUMN_NAME
        FROM [SurveyorEngineering].INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_NAME = 'Survey'
""")

for row in cursor:
    print row
    
</t>
</tnodes>
</leo_file>
