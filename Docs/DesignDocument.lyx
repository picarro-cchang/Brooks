#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This document provides a high-level description of the software and firmware
 architecture of the proposed Picarro cost-reduced CRDS platform.
 There are three main programmable devices on the logic board, a Cypress
 CY7C68013 USB controller (USBC), a Texas Instruments TMS320C6713 floating
 point digital signal processor (DSP), and a Xilinx Spartan 3 Field Programmable
 Gate Array (FPGA).
 A feature of the USBC is that it can be configured at power-up by a host
 computer connected via the USB cable.
 Following the configuration process, the USBC renumerates as a new device,
 with the configured functionality.
 The USBC connected via its General Programmable Interface (GPIF) to the
 Host Port Interface (HPI) of the DSP.
 By programming the GPIF appropriately within the USBC configuration, USB
 transfers may be used to access DSP memory directly, and in particular,
 may be used to download the DSP image.
 The USBC is also connected to the FPGA via a slave serial interface, which
 allows the FPGA configuration to be downloaded through the USB interface,
 as well.
 In this way, it is possible for the the host computer to configure all
 the devices on the logic board at startup, largely removing the need to
 have non-volatile memory on the target device.
\end_layout

\begin_layout Standard
The host code is written in Python, and USB communications are handled via
 the LibUSB library, which is wrapped using a ctypes interface.
 The code on the USBC is written in C and compiled using the Keil 8051 compiler.
 The DSP code is written in C using the Texas Instruments Code Composer
 Studio.
 The FPGA is programmed in MyHDL, which is a Python based hardware description
 languuage which can be compiled into VHDL and synthesized using the Xilinx
 development tools.
\end_layout

\begin_layout Standard
The guiding principle of the proposed design is to perform as much of the
 computations as possible on the host, leaving the code within the analyzer
 to be as simple as possible.
 Ideally, the code on the analyzer should consist of modules, each controlling
 a small section of the hardware, which may be coordinated at a high level
 by the host.
 Only operations which have to occur so quickly that performance would be
 compromised by communications with the host should be implemented within
 the analyzer.
 Another principle (which is imposed by to the use of USB for communications)
 is that the host has to initiate all transfers of data.
 Despite this, it is sometimes important for some data generation processes
 to take place at precise times which mean that buffering has to be provided
 within the analyzer so that the host can recover these data at a convenient
 time.
\end_layout

\begin_layout Section
Interfaces between host and analyzer
\end_layout

\begin_layout Standard
The host is able to access the memory space of the DSP via the HPI interface.
 Part of this memory space is organized as 
\begin_inset Quotes eld
\end_inset

software registers
\begin_inset Quotes erd
\end_inset

, each containing a 32-bit integer or floating point number.
 These registers are used to communicate quantities between host and analyzer.
 Some care is required when using these software registers due to caching
 in the DSP, so an access protocol has been designed to avoid these problems.
 Additional areas of the DSP memory are designated for the transfer of sensor
 data and ringdown data from the DSP to the host, and for transfer of scheme
 data from the host to the DSP.
\end_layout

\begin_layout Standard
The main functions of the DSP software are:
\end_layout

\begin_layout Enumerate
The execution of several tasks on a fixed schedule.
 These include the collection of data from a number of sensors, running
 various controllers, using the controller outputs to set the values of
 a number of actuators, and recording the sensor data in a buffer where
 they may be accessed by the host.
\end_layout

\begin_layout Enumerate
Handling ringdown sequencing and processing.
 This involves setting up the parameters for each ringdown in accordance
 with the scheme table specified by the host, setting up the tuner parameters
 to allow the cavity and laser to come into resonance, collecting the ringdown
 data and metadata, performing the exponential fit on the data to extract
 the ringdown parameters, and processing the metadata to recover conditions
 at the time of the ringdown.
 The processed ringdown data are recorded in a buffer where they may be
 accessed by the host.
\end_layout

\begin_layout Enumerate
Running watchdog and sentry checking routines, and performing recovery actions
 as necessary.
\end_layout

\begin_layout Standard
In order to facilitate code development, most of the tasks that the DSP
 performs are written as short code modules (
\begin_inset Quotes eld
\end_inset

operations
\begin_inset Quotes erd
\end_inset

) which can be independently tested.
 Each code module operates on a set of software registers and places the
 results in another set of registers.
 The input and output registers are considered as operands for the module,
 which is assigned a 
\begin_inset Quotes eld
\end_inset

operation code
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
These operations are scheduled by collecting them into groups, and assigning
 a period and priority to each group.
 The scheduler clock increments at a period of 0.2s, and runs all groups
 whose periods divide the current value of the clock.
 All groups scheduled for a given time are executed in order of priority.
 The order of execution of groups of the same priority is not defined.
\end_layout

\begin_layout Subsection
Date and Time Handling
\end_layout

\begin_layout Standard
Time on the instrument is maintained as a 64 bit integer, which has millisecond
 resolution and is always based on Universal Coordinated Time.
 This clock is downloaded on power-up and may be updated periodically to
 keep it in synchronization with the host clock.
 The Python datetime class has the attributes year, month, day, hour, minute,
 second and microsecond.
 The tzinfo attribute is set to None.
 Conversion of a datetime t to the 64 bit integer is carried out as follows:
\end_layout

\begin_layout LyX-Code
return (((t.toordinal()*24 + t.hour)*60 + t.minute)*60 + t.second)*1000 + t.microseco
nd//1000
\end_layout

\begin_layout Standard
This is equivalent to
\end_layout

\begin_layout LyX-Code
td = t - datetime.datetime(datetime.MINYEAR,1,1,0,0,0,0) 
\end_layout

\begin_layout LyX-Code
return (td.days*86400 + td.seconds)*1000 + td.microseconds//1000 
\end_layout

\begin_layout Subsection
The Wheel of Control
\end_layout

\begin_layout Standard
The analyzer contains a collection of:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

sensors
\begin_inset Quotes erd
\end_inset

 which measure various quantities such as temperatures, pressures, currents
 etc.
 The DSP may be set up to read these periodically and to place the raw results
 (typically ADC readings) in software registers,
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

converters
\begin_inset Quotes erd
\end_inset

 which convert raw results to physically meaningful quantities, under the
 control of appropriate conversion parameters.
 The inputs, outputs and conversion parameters are all read from or written
 to software registers.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

actuators
\begin_inset Quotes erd
\end_inset

 such as TECs, valves, etc.
 whose values need to be adjusted from time to time.
 The DSP may be set up to write these values from the software registers
 periodically to the actual hardware (e.g., a DAC or a PWM generator implemented
 in the FPGA).
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

controllers
\begin_inset Quotes erd
\end_inset

 which update the actuator values depending on the sensor values and the
 parameters of the controller.
\end_layout

\begin_layout Standard
The recommended order of execution is:
\end_layout

\begin_layout Itemize
When the timer event occurs, write all precomputed actuator values to the
 hardware
\end_layout

\begin_layout Itemize
Read all the sensors
\end_layout

\begin_layout Itemize
Execute the converters
\end_layout

\begin_layout Itemize
Execute the controllers
\end_layout

\begin_layout Standard
Functions are called to perform each of the operations such as reading a
 sensor, performing a conversion, writing an actuator value, and stepping
 a controller.
 The host can cause the DSP to perform a function, or it can enqueue the
 function on a timer wheel with a specified execution period.
 The timer wheel can be started and stopped under the control of the host.
\end_layout

\begin_layout Standard
We want to construct a P-code interpreter on the DSP which runs functions
 selected from a library, each function having a parameter list consisting
 of constants.
 Each constant can be the index of a software register.
 For example, such a function might be:
\end_layout

\begin_layout LyX-Code
GET_LASER1_TEMP("LASER1_COEFF_A","LASER1_COEFF_B","LASER1_COEFF_C","LASER1_TEMP"
)
\end_layout

\begin_layout Standard
The string parameters correspond to software registers that provide the
 arguments to the function.
 We want to be able to make the DSP execute one of these, by sending it
 the P-code representation of the call.
 This is useful for testing the operation of the functions.
\end_layout

\begin_layout Standard
During normal operation of the analyzer, each functions can be specified
 for periodic execution on the DSP.
 Each function is assigned a type, which can be 
\family typewriter
output
\family default
, 
\family typewriter
input
\family default
 or 
\family typewriter
computation
\family default
.
 The time at which the function is to be called next, and the period are
 specified.
 For example, we might define a sequence such as:
\end_layout

\begin_layout LyX-Code
GET_LASER1_TEMP("LASER1_COEFF_A","LASER1_COEFF_B","LASER1_COEFF_C","LASER1_TEMP"
),type="input",start=0,period=0.2 GET_LASER2_TEMP("LASER2_COEFF_A","LASER2_COEFF_
B","LASER2_COEFF_C","LASER2_TEMP"),type="input",start=0,period=0.2 
\end_layout

\begin_layout LyX-Code
STREAM_DATA("LASER1_TEMP"),type="controller",start=0,period=0.2 STREAM_DATA("LASE
R2_TEMP"),type="controller",start=0,period=0.2 SET_LASER1_TEC("LASER1_TEC"),type=
"output",start=0,period=0.2 SET_LASER2_TEC("LASER2_TEC"),type="output",start=0,pe
riod=0.2 
\end_layout

\begin_layout LyX-Code
PID_CONTROLLER(...
 regList ...),type="controller",start=0,period=0.2 
\end_layout

\begin_layout LyX-Code
PID_CONTROLLER(...
 regList ...),type="controller",start=0,period=0.2 GET_CAVITY_PRESSURE("CAVITY_PRESS
URE_SENSOR_GAIN","CAVITY_PRESSURE_SENSOR_OFFSET"),type="input",start=0,period=1.0
 
\end_layout

\begin_layout LyX-Code
VALVE_CONTROLLER(...list of registers which define valve controller...),type="controll
er",start=0,period=1.0
\end_layout

\begin_layout Standard
Each operation translates into a TaskFunc, which is a function which can
 be placed on the timer wheel.
\end_layout

\begin_layout Itemize
We need to be able to download this into the DSP and have it run without
 further intervention from the host.
\end_layout

\begin_layout Itemize
The host should be able to pause/restart execution of this wheel.
\end_layout

\begin_layout Subsection
Schemes
\end_layout

\begin_layout Standard
The analyzer is responsible for collecting ringdowns in accordance with
 
\begin_inset Quotes eld
\end_inset

schemes
\begin_inset Quotes erd
\end_inset

 specified by the host.
 The host is responsible for all aspects of wavelength monitor calibration.
 As far as the analyzer is concerned, a scheme row specifies:
\end_layout

\begin_layout Itemize
Which laser to use
\end_layout

\begin_layout Itemize
The nominal laser temperature to be used
\end_layout

\begin_layout Itemize
The wavelength monitor angle parameter
\end_layout

\begin_layout Itemize
The number of ringdowns to collect before stepping to the next row
\end_layout

\begin_layout Itemize
The ringdown threshold to use
\end_layout

\begin_layout Standard
Schemes are stored in SDRAM of the DSP.
 Each can have up to 8192 rows.
 It is probably only necessary to have up to four schemes in the analyzer
 since we have to keep 
\begin_inset Quotes eld
\end_inset

compiling
\begin_inset Quotes erd
\end_inset

 them in the host and downloading them.
 The subscheme ID which labels each scheme row can be kept in the host since
 it is not used by the analyzer.
\end_layout

\begin_layout Standard
It must be possible for the host to load a scheme while another scheme is
 being run.
 A flag indicates whether data collection is to end after the current scheme,
 or if collection is to proceed without interruption to the scheme specified
 by the 
\begin_inset Quotes eld
\end_inset

next scheme
\begin_inset Quotes erd
\end_inset

 register.
 It should be possible to stop a scheme before completion to return to the
 idle state.
\end_layout

\begin_layout Standard
During calibration, the wavelength monitor ratios 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are fitted to an ellipse of the form
\begin_inset Formula \begin{eqnarray*}
x & = & x_{0}+A\cos\theta\\
y & = & y_{0}+B\sin\left(\theta+\varepsilon\right)\end{eqnarray*}

\end_inset

The parameters 
\begin_inset Formula $x_{0},$
\end_inset

 
\begin_inset Formula $y_{0},$
\end_inset

 
\begin_inset Formula $A,$
\end_inset

 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $\varepsilon$
\end_inset

 are all stored in the analyzer.
 The value of 
\begin_inset Formula $\theta$
\end_inset

 is linearly related to the frequency 
\begin_inset Formula $\nu$
\end_inset

 in the ideal case.
 In practice, we keep track of the function 
\begin_inset Formula $\nu\left(\theta\right)$
\end_inset

 as the sum of a linear model and a cubic spline, which is updated during
 calibration scans.
\end_layout

\begin_layout Standard
When we wish to lock the laser to a given frequency, the value of 
\begin_inset Formula $\theta_{c}$
\end_inset

 is calculated from the function 
\begin_inset Formula $\nu\left(\theta\right)$
\end_inset

 by solving the cubic equation.
 The angle is called 
\begin_inset Formula $\theta_{c}$
\end_inset

 to indicate that it is the angle required if the conditions are the same
 as they were when the monitor was calibrated.
 
\end_layout

\begin_layout Standard
The laser wavelength locking network adjusts the laser current so as to
 achieve
\begin_inset Formula \[
w_{1}\left(x-x_{0}\right)+w_{2}\left(y-y_{0}\right)=0.\]

\end_inset

The host calculates 
\begin_inset Formula $w_{1}$
\end_inset

 and 
\begin_inset Formula $w_{2}$
\end_inset

 for the wavelength monitor angle 
\begin_inset Formula $\theta$
\end_inset

 using the formulas:
\begin_inset Formula \[
w_{1}=-\frac{\sin\left(\theta+\varepsilon\right)}{A\cos\varepsilon},\; w_{2}=\frac{\cos\theta}{B\cos\varepsilon}\]

\end_inset

where the angle 
\begin_inset Formula $\theta$
\end_inset

 is related to 
\begin_inset Formula $\theta_{c}$
\end_inset

 by
\begin_inset Formula \[
\theta=\theta_{c}-\alpha_{1}\left(T_{\mathrm{e}}-T_{\mathrm{e,cal}}\right)-\left(c_{0}+c_{1}\left(P-P_{\mathrm{cal}}\right)+c_{2}\left(P-P_{\mathrm{cal}}\right)^{2}+c_{3}\left(P-P_{\mathrm{cal}}\right)^{3}\right).\]

\end_inset

Here 
\begin_inset Formula $\alpha_{1}$
\end_inset

 represents the sensitivity of the angle to the deviation of the etalon
 temperature 
\begin_inset Formula $T_{\mathrm{e}}$
\end_inset

 from the value used during calibration 
\begin_inset Formula $T_{\mathrm{e,cal}}$
\end_inset

 and 
\begin_inset Formula $c_{i}$
\end_inset

 specify how the angle varies with deviation of the ambient pressure 
\begin_inset Formula $P$
\end_inset

 from the value used during calibration, 
\begin_inset Formula $P_{\mathrm{cal}}$
\end_inset

.
\end_layout

\begin_layout Standard
The analyzer is responsible for taking 
\begin_inset Formula $\theta_{c}$
\end_inset

 and calculating 
\begin_inset Formula $w_{1}$
\end_inset

 and 
\begin_inset Formula $w_{2}$
\end_inset

 since the values of 
\begin_inset Formula $T_{e}$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 are measured by the analyzer as the data are taken.
 The values of 
\begin_inset Formula $w_{1}$
\end_inset

 and 
\begin_inset Formula $w_{2}$
\end_inset

 are parameters that have to be loaded into the FPGA to perform the laser
 frequency locking.
\end_layout

\begin_layout Subsection
Data Streams
\end_layout

\begin_layout Standard
The data streams from the analyzer which may be read by the host are placed
 in three memory regions in the DSP address space:
\end_layout

\begin_layout Itemize
the ringdown results buffer
\end_layout

\begin_layout Itemize
the sensor stream buffer
\end_layout

\begin_layout Itemize
the ringdown data, metadata and parameter buffers
\end_layout

\begin_layout Standard
The host can read from any of these buffers.
 The analyzer treats each as a circular buffer to which it writes results
 without regard to overflow since it is up to the host to keep reading quickly
 enough so that it the buffers are not lapped.
 In order for this to work, each data record in each buffer has a timestamp
 field which is written to last.
 When the host reads from one of these buffers, it keeps track of the largest
 timestamp that it has seen so far.
 The host stops reading when it encounters a timestamp smaller than this,
 and remembers where in the buffer it is currently at.
 To help the host find where to start reading from, the DSP also records
 the buffer address of the last write.
\end_layout

\begin_layout Section
Persistance
\end_layout

\begin_layout Standard
Use a sqlite3 database or a HDF5 table in the host for the following:
\end_layout

\begin_layout Itemize
We need to store parameters in the host so they can be downloaded to the
 analyzer at bootup.
\end_layout

\begin_layout Itemize
Diagnostic information (min/max sensor data etc.) which must be periodically
 acquired by the host.
 This is decimated periodically to limit size of the database.
\end_layout

\begin_layout Standard
It consists of two main sections, one in 
\family typewriter
6713_HPI_gpif.c
\family default
 which is used to configure the GPIF and the other in 
\family typewriter
analyzerUsb.c
\family default
, which dispatches the various USB commands within the standard framework
 provided by 
\family typewriter
fw.c
\family default
.
 Witin the 
\family typewriter
TD_Poll
\family default
 function, which is called repeatedly when the device is idle, there is
 a handler which supervises bulk transfers between the host and the DSP
 HPI bus using FIFO endpoints EP2 and EP6.
 Transfers are made to and from the HPID register, using auto-increment,
 so that the address only needs to be set up at the start of the transfer
 using the HPIA register.
 Due to a bug in early revisions of the DSP silicon, auto-increment must
 be turned off for the last transfer of each group.
 A number of vendor commands are implemented, which fall into several categories
:
\end_layout

\begin_layout Itemize
Reading version information of the USB configuration firmware,
\end_layout

\begin_layout Itemize
Programming the FPGA using the slave serial interface,
\end_layout

\begin_layout Itemize
Reading status information, such as the USB speed and the state of the GPIF,
\end_layout

\begin_layout Itemize
Reading and writing the HPIA and HPIC registers in the DSP, and setting
 up the transaction count for HPID reads,
\end_layout

\begin_layout Itemize
Initiating HPI reset and HINT interrupts for communications with the DSP.
\end_layout

\begin_layout Section
Simulation of Thermal Response
\end_layout

\begin_layout Standard
A low-pass filter with a single pole gives an exponentially decaying impulse
 response.
 Consider
\begin_inset Formula \[
h_{k}=C\exp\left(-\omega_{1}kT\right)\]

\end_inset

whose 
\begin_inset Formula $z$
\end_inset

 transform is
\begin_inset Formula \[
\sum_{k=0}^{\infty}h_{k}z^{-k}=C\sum_{k=0}^{\infty}\left[z\exp\left(\omega_{1}T\right)\right]^{-k}=\frac{C}{1-\left[z\exp\left(\omega_{1}T\right)\right]^{-1}}=\frac{C}{1-\exp\left(-\omega_{1}T\right)z^{-1}}\]

\end_inset

 The response at zero frequency 
\begin_inset Formula $\left(z=1\right)$
\end_inset

 is unity if we choose 
\begin_inset Formula $C=1-\exp\left(-\omega_{1}T\right).$
\end_inset

 Writing 
\begin_inset Formula $\alpha$
\end_inset

 for 
\begin_inset Formula $\exp\left(-\omega_{1}T\right),$
\end_inset

 we see that the single pole low-pass filter with unit gain is:
\begin_inset Formula \[
H\left(z\right)=\frac{1-\alpha}{1-\alpha z^{-1}}\]

\end_inset


\end_layout

\begin_layout Standard
In order to represent a system with the sum of a slow and a fast response,
 characterized by parameters 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 respectively and with amplitudes 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, consider
\begin_inset Formula \[
H\left(z\right)=A\left(\frac{1-\alpha}{1-\alpha z^{-1}}\right)^{m}+B\left(\frac{1-\beta}{1-\beta z^{-1}}\right)^{n}\]

\end_inset

where 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 may be chosen to control the degree of differentiability of the step response
 at the origin.
 For simplicity in the simulation, suppose that 
\begin_inset Formula $m=n=2,$
\end_inset

 so that
\begin_inset Formula \begin{eqnarray*}
H\left(z\right) & = & A\left(\frac{1-\alpha}{1-\alpha z^{-1}}\right)^{2}+B\left(\frac{1-\beta}{1-\beta z^{-1}}\right)^{2}\\
 & = & \frac{A\left(1-\alpha\right)^{2}}{1-2\alpha z^{-1}+\alpha^{2}z^{-2}}+\frac{B\left(1-\beta\right)^{2}}{1-2\beta z^{-1}+\beta^{2}z^{-2}}\\
 & = & \frac{A\left(1-\alpha\right)^{2}\left[1-2\beta z^{-1}+\beta^{2}z^{-2}\right]+B\left(1-\beta\right)^{2}\left[1-2\alpha z^{-1}+\alpha^{2}z^{-2}\right]}{\left[1-2\alpha z^{-1}+\alpha^{2}z^{-2}\right]\left[1-2\beta z^{-1}+\beta^{2}z^{-2}\right]}\\
 & = & \frac{\left[A\left(1-\alpha\right)^{2}+B\left(1-\beta\right)^{2}\right]-2\left[A\left(1-\alpha\right)^{2}\beta+B\alpha\left(1-\beta\right)^{2}\right]z^{-1}+\left[A\left(1-\alpha\right)^{2}\beta^{2}+B\alpha^{2}\left(1-\beta\right)^{2}\right]z^{-2}}{1-2\left(\alpha+\beta\right)z^{-1}+\left(\alpha^{2}+4\alpha\beta+\beta^{2}\right)z^{-2}-2\alpha\beta\left(\alpha+\beta\right)z^{-3}+\alpha^{2}\beta^{2}z^{-4}}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Section
Implementation of Digital Filter
\end_layout

\begin_layout Standard
The digital filter implementation is based on that used in the scipy.signal
 library, and has the block diagram shown (for a second order filter), where
 it is assumed that 
\begin_inset Formula $a_{0}=1.$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename iirFilter.eps
	height 2in

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Topology of second-order digital filter
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Starting from the right-hand side, the input to the first memory element
 is
\begin_inset Formula \[
b_{2}X-a_{2}Y.\]

\end_inset

The input to the next memory element is then
\begin_inset Formula \[
b_{1}X-a_{1}Y+z^{-1}\left(b_{2}X-a_{2}Y\right),\]

\end_inset

and the equation satisfied by the network is
\begin_inset Formula \[
Y=b_{0}X+z^{-1}\left[b_{1}X-a_{1}Y+z^{-1}\left(b_{2}X-a_{2}Y\right)\right].\]

\end_inset

Rearranging this yields
\begin_inset Formula \[
\left(1+a_{1}z^{-1}+a_{2}z^{-2}\right)Y=\left(b_{0}+b_{1}z^{-1}+b_{2}z^{-2}\right)X\]

\end_inset

which is of the required form for implementing the filter.
\end_layout

\begin_layout Standard
The algorithm involves maintaining a single vector 
\begin_inset Formula $z$
\end_inset

 with 
\begin_inset Formula $n$
\end_inset

 elements, labeled 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $n-1$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the larger of the degrees of the numerator and denominator.
 Initially, all the elements of 
\begin_inset Formula $z$
\end_inset

 are set to zero, and at the 
\begin_inset Formula $m$
\end_inset

'th sampling time, when the input is 
\begin_inset Formula $x_{m},$
\end_inset

 we compute
\begin_inset Formula \[
y_{m}=b_{0}x_{m}+z_{0}\]

\end_inset

and then successively update the components of 
\begin_inset Formula $z$
\end_inset

 as follows:
\begin_inset Formula \begin{eqnarray*}
z_{0} & \leftarrow & z_{1}+b_{1}x_{m}-a_{1}y_{m}\\
z_{1} & \leftarrow & z_{2}+b_{2}x_{m}-a_{2}y_{m}\\
 & \dots\\
z_{n-1} & \leftarrow & b_{n}x_{m}-a_{n}y_{m}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Section
State-Space Representation of a Discrete Linear Time-Invariant System
\end_layout

\begin_layout Standard
A discrete linear time-invariant system has the canonical representation
\begin_inset Formula \[
\left(\begin{array}{c}
\mathbf{x}\left[n+1\right]\\
y\left[n\right]\end{array}\right)=\left(\begin{array}{cc}
\boldsymbol{\Phi} & \boldsymbol{\Gamma}\\
\mathbf{C} & D\end{array}\right)\left(\begin{array}{c}
\mathbf{x}\left[n\right]\\
u\left[n\right]\end{array}\right)\]

\end_inset

where we shall suppose that the input 
\begin_inset Formula $u$
\end_inset

 and output 
\begin_inset Formula $y$
\end_inset

 are one-dimensional.
 If we wish this to represent the digital filter whose response is
\begin_inset Formula \[
\sum a_{k}y_{n-k}=\sum b_{l}u_{n-l}\]

\end_inset

where we may assume without loss of generality that 
\begin_inset Formula $a_{0}=1,$
\end_inset

 there are two principal ways of doing this.
 The first is based on the filter topology given above.
 If the outputs of the delay elements at time 
\begin_inset Formula $n$
\end_inset

 are 
\begin_inset Formula $x_{1}\left[n\right]$
\end_inset

, 
\begin_inset Formula $x_{2}\left[n\right]$
\end_inset

, 
\begin_inset Formula $...,$
\end_inset

 it is not difficult to see that (for the case of the fourth order filter):
\begin_inset Formula \[
\left(\begin{array}{c}
x_{1}\left[n+1\right]\\
x_{2}\left[n+1\right]\\
x_{3}\left[n+1\right]\\
x_{4}\left[n+1\right]\\
y\left[n\right]\end{array}\right)=\left(\begin{array}{ccccc}
-a_{1} & 1 & 0 & 0 & b_{1}-a_{1}b_{0}\\
-a_{2} & 0 & 1 & 0 & b_{2}-a_{2}b_{0}\\
-a_{3} & 0 & 0 & 1 & b_{3}-a_{3}b_{0}\\
-a_{4} & 0 & 0 & 0 & b_{4}-a_{4}b_{0}\\
1 & 0 & 0 & 0 & b_{0}\end{array}\right)\left(\begin{array}{c}
x_{1}\left[n\right]\\
x_{2}\left[n\right]\\
x_{3}\left[n\right]\\
x_{4}\left[n\right]\\
u\left[n\right]\end{array}\right)\]

\end_inset

which leads to the identification
\begin_inset Formula \[
\boldsymbol{\Phi}=\left(\begin{array}{cccc}
-a_{1} & 1 & 0 & 0\\
-a_{2} & 0 & 1 & 0\\
-a_{3} & 0 & 0 & 1\\
-a_{4} & 0 & 0 & 0\end{array}\right)\qquad\boldsymbol{\Gamma}=\left(\begin{array}{c}
b_{1}-a_{1}b_{0}\\
b_{2}-a_{2}b_{0}\\
b_{3}-a_{3}b_{0}\\
b_{4}-a_{4}b_{0}\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathbf{C}=\left(\begin{array}{cccc}
1 & 0 & 0 & 0\end{array}\right)\qquad D=b_{0}\]

\end_inset


\end_layout

\begin_layout Standard
The second is based on the canonical form of the digital filter.
 The resulting matrices in this case are
\begin_inset Formula \[
\boldsymbol{\Phi}=\left(\begin{array}{cccc}
-a_{1} & -a_{2} & -a_{3} & -a_{4}\\
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\end{array}\right)\qquad\boldsymbol{\Gamma}=\left(\begin{array}{c}
1\\
0\\
0\\
0\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathbf{C}=\left(\begin{array}{cccc}
b_{1}-a_{1}b_{0} & b_{2}-a_{2}b_{0} & b_{3}-a_{3}b_{0} & b_{4}-a_{4}b_{0}\end{array}\right)\qquad D=b_{0}\]

\end_inset

which are just the transposes of the matrices for the other topology.
\end_layout

\begin_layout Subsection
Cascading state-space systems
\end_layout

\begin_layout Standard
If we cascade together two systems
\begin_inset Formula \[
\left(\begin{array}{c}
\mathbf{x}_{1}\left[n+1\right]\\
y_{1}\left[n\right]\end{array}\right)=\left(\begin{array}{cc}
\boldsymbol{\Phi}_{1} & \boldsymbol{\Gamma}_{1}\\
\mathbf{C}_{1} & D_{1}\end{array}\right)\left(\begin{array}{c}
\mathbf{x}_{1}\left[n\right]\\
u_{1}\left[n\right]\end{array}\right)\]

\end_inset

and
\begin_inset Formula \[
\left(\begin{array}{c}
\mathbf{x}_{2}\left[n+1\right]\\
y_{2}\left[n\right]\end{array}\right)=\left(\begin{array}{cc}
\boldsymbol{\Phi}_{2} & \boldsymbol{\Gamma}_{2}\\
\mathbf{C}_{2} & D_{2}\end{array}\right)\left(\begin{array}{c}
\mathbf{x}_{2}\left[n\right]\\
u_{2}\left[n\right]\end{array}\right)\]

\end_inset

where 
\begin_inset Formula $u_{2}\left[n\right]=y_{1}\left[n\right],$
\end_inset

 we may define a composite state vector whose components include both those
 of 
\begin_inset Formula $\mathbf{x}_{1}$
\end_inset

 and 
\begin_inset Formula $\mathbf{x}_{2}.$
\end_inset


\begin_inset Formula \[
\left(\begin{array}{c}
\mathbf{x}_{1}\left[n+1\right]\\
\mathbf{x}_{2}\left[n+1\right]\\
y_{2}\left[n\right]\end{array}\right)=\left(\begin{array}{ccc}
\boldsymbol{\Phi}_{1} & \mathbf{0} & \boldsymbol{\Gamma}_{1}\\
\boldsymbol{\Gamma}_{2}\mathbf{C}_{1} & \boldsymbol{\Phi}_{2} & \boldsymbol{\Gamma}_{2}D{}_{1}\\
D_{2}\mathbf{C}_{1} & \mathbf{C}_{2} & D_{2}D_{1}\end{array}\right)\left(\begin{array}{c}
\mathbf{x}_{1}\left[n\right]\\
\mathbf{x}_{2}\left[n\right]\\
u_{1}\left[n\right]\end{array}\right)\]

\end_inset

This leads to the composition rule:
\begin_inset Formula \[
\boldsymbol{\Phi}=\left(\begin{array}{cc}
\boldsymbol{\Phi}_{1} & \mathbf{0}\\
\boldsymbol{\Gamma}_{2}\mathbf{C}_{1} & \boldsymbol{\Phi}_{2}\end{array}\right)\qquad\boldsymbol{\Gamma}=\left(\begin{array}{c}
\boldsymbol{\Gamma}_{1}\\
\boldsymbol{\Gamma}_{2}D_{1}\end{array}\right)\qquad\mathbf{C}=\left(\begin{array}{cc}
D_{2}\mathbf{C}_{1} & \mathbf{C}_{2}\end{array}\right)\qquad D=D_{2}D_{1}\]

\end_inset


\end_layout

\begin_layout Subsection
Applying feedback around a state-space system
\end_layout

\begin_layout Standard
Consider using a second system 
\begin_inset Formula $S_{2}$
\end_inset

 to apply feedback around the first system 
\begin_inset Formula $S_{1}$
\end_inset

, whose output is 
\begin_inset Formula $y,$
\end_inset

 so that the input of 
\begin_inset Formula $S_{2}$
\end_inset

 is 
\begin_inset Formula $y,$
\end_inset

 and the input to 
\begin_inset Formula $S_{1}$
\end_inset

 is 
\begin_inset Formula $r\left[n\right]-f\left[n\right]$
\end_inset

 where 
\begin_inset Formula $f\left[n\right]$
\end_inset

 is the output of 
\begin_inset Formula $S_{2},$
\end_inset

 i.e.,
\begin_inset Formula \[
\left(\begin{array}{c}
\mathbf{x}_{1}\left[n+1\right]\\
y\left[n\right]\end{array}\right)=\left(\begin{array}{cc}
\boldsymbol{\Phi}_{1} & \boldsymbol{\Gamma}_{1}\\
\mathbf{C}_{1} & D_{1}\end{array}\right)\left(\begin{array}{c}
\mathbf{x}_{1}\left[n\right]\\
r\left[n\right]-f\left[n\right]\end{array}\right)\]

\end_inset

and
\begin_inset Formula \[
\left(\begin{array}{c}
\mathbf{x}_{2}\left[n+1\right]\\
f\left[n\right]\end{array}\right)=\left(\begin{array}{cc}
\boldsymbol{\Phi}_{2} & \boldsymbol{\Gamma}_{2}\\
\mathbf{C}_{2} & D_{2}\end{array}\right)\left(\begin{array}{c}
\mathbf{x}_{2}\left[n\right]\\
y\left[n\right]\end{array}\right)\]

\end_inset

We wish to combine these systems and write
\begin_inset Formula \[
\left(\begin{array}{c}
\mathbf{x}_{1}\left[n+1\right]\\
\mathbf{x}_{2}\left[n+1\right]\\
y\left[n\right]\end{array}\right)=\left(\begin{array}{cc}
\boldsymbol{\Phi} & \boldsymbol{\Gamma}\\
\mathbf{C} & D\end{array}\right)\left(\begin{array}{c}
\mathbf{x}_{1}\left[n\right]\\
\mathbf{x}_{2}\left[n\right]\\
r\left[n\right]\end{array}\right)\]

\end_inset

From 
\begin_inset Formula $y\left[n\right]=\mathbf{C}_{1}\mathbf{x}_{1}\left[n\right]+D_{1}r\left[n\right]-D_{1}f\left[n\right]$
\end_inset

 and 
\begin_inset Formula $f\left[n\right]=\mathbf{C}_{2}\mathbf{x}_{2}\left[n\right]+D_{2}y\left[n\right]$
\end_inset

, we see that 
\begin_inset Formula \[
y\left[n\right]=\left(1+D_{1}D_{2}\right)^{-1}\left(\begin{array}{ccc}
\mathrm{C}_{1} & -D_{1}\mathbf{C}_{2} & D_{1}\end{array}\right)\left(\begin{array}{c}
\mathbf{x}_{1}\left[n\right]\\
\mathbf{x}_{2}\left[n\right]\\
r\left[n\right]\end{array}\right)\]

\end_inset

and 
\begin_inset Formula \[
f\left[n\right]=\left\{ \left(\begin{array}{ccc}
\mathbf{0} & \mathbf{C}_{2} & 0\end{array}\right)+D_{2}\left(1+D_{1}D_{2}\right)^{-1}\left(\begin{array}{ccc}
\mathrm{C}_{1} & -D_{1}\mathbf{C}_{2} & D_{1}\end{array}\right)\right\} \left(\begin{array}{c}
\mathbf{x}_{1}\left[n\right]\\
\mathbf{x}_{2}\left[n\right]\\
r\left[n\right]\end{array}\right)\]

\end_inset

So
\begin_inset Formula \[
\left(\begin{array}{c}
\mathbf{x}_{1}\left[n+1\right]\\
\mathbf{x}_{2}\left[n+1\right]\\
y\left[n\right]\end{array}\right)=\left\{ \left(\begin{array}{ccc}
\boldsymbol{\Phi}_{1} & -\boldsymbol{\Gamma}_{1}\mathbf{C}_{2} & \boldsymbol{\Gamma}_{1}\\
0 & \boldsymbol{\Phi}_{2} & 0\\
0 & 0 & 0\end{array}\right)+\left(\begin{array}{c}
-\boldsymbol{\Gamma}_{1}D_{2}\\
\boldsymbol{\Gamma}_{2}\\
1\end{array}\right)\left(1+D_{1}D_{2}\right)^{-1}\left(\begin{array}{ccc}
\mathrm{C}_{1} & -D_{1}\mathbf{C}_{2} & D_{1}\end{array}\right)\right\} \left(\begin{array}{c}
\mathbf{x}_{1}\left[n\right]\\
\mathbf{x}_{2}\left[n\right]\\
r\left[n\right]\end{array}\right)\]

\end_inset

From which we see that
\begin_inset Formula \[
\boldsymbol{\Phi=}\left(\begin{array}{cc}
\boldsymbol{\Phi}_{1} & -\boldsymbol{\Gamma}_{1}\mathbf{C}_{2}\\
0 & \boldsymbol{\Phi}_{2}\end{array}\right)+\left(\begin{array}{c}
-\boldsymbol{\Gamma}_{1}D_{2}\\
\boldsymbol{\Gamma}_{2}\end{array}\right)\left(1+D_{1}D_{2}\right)^{-1}\left(\begin{array}{cc}
\mathrm{C}_{1} & -D_{1}\mathbf{C}_{2}\end{array}\right)\]

\end_inset


\begin_inset Formula \[
\boldsymbol{\Gamma}=\left(\begin{array}{c}
\boldsymbol{\Gamma}_{1}\\
0\end{array}\right)+\left(\begin{array}{c}
-\boldsymbol{\Gamma}_{1}D_{2}\\
\boldsymbol{\Gamma}_{2}\end{array}\right)\left(1+D_{1}D_{2}\right)^{-1}D_{1}\]

\end_inset


\begin_inset Formula \[
\mathbf{C}=\left(1+D_{1}D_{2}\right)^{-1}\left(\begin{array}{cc}
\mathrm{C}_{1} & -D_{1}\mathbf{C}_{2}\end{array}\right)\]

\end_inset

and
\begin_inset Formula \[
D=\left(1+D_{1}D_{2}\right)^{-1}D_{1}\]

\end_inset


\end_layout

\begin_layout Standard
If the second system is the identity, the above simplifies to
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\boldsymbol{\Phi=}\boldsymbol{\Phi}_{1}-\boldsymbol{\Gamma}_{1}\left(1+D_{1}\right)^{-1}\mathbf{\mathrm{C}}_{1}\]

\end_inset


\begin_inset Formula \[
\boldsymbol{\Gamma}=\boldsymbol{\Gamma}_{1}\left(1+D_{1}\right)^{-1}\]

\end_inset


\begin_inset Formula \[
\mathbf{C}=\left(1+D_{1}\right)^{-1}\mathrm{\mathbf{C}}_{1}\]

\end_inset


\end_layout

\begin_layout Standard
and
\begin_inset Formula \[
D=\left(1+D_{1}\right)^{-1}D_{1}\]

\end_inset


\end_layout

\begin_layout Section
Silverstone Firmware
\end_layout

\begin_layout Subsection
FPGA
\end_layout

\begin_layout Subsubsection
Files
\end_layout

\begin_layout Description
GPIO_block.vhd Handles general purpose I/O lines on FPGA, making them accessible
 from the MCU.
 Implements PWM.
\end_layout

\begin_layout Description
DSP_block.vhd Handles EMIF of DSP for accessing ringdown buffers in SRAM
\end_layout

\begin_layout Description
MCU_block.vhd Handles EMIF of MCU for accessing different blocks in the FPGA:
 GPIO, RAI, RDI, SEQ, SIO and WLM.
\end_layout

\begin_layout Description
RAI_block.vhd Arbitrates between requests to SRAM between RBD (ringdown/backscatt
er ADC), WLM, MCU and DSP.
\end_layout

\begin_layout Description
RDI_block.vhd Controls the high speed ringdown and backscatter ADCs and writes
 their data to SRAM.
\end_layout

\begin_layout Description
Sequencer_block.vhd Ringdown sequencer and tuner waveform generator.
\end_layout

\begin_layout Description
Serial_ADC_IF.vhd Supports serial ADC
\end_layout

\begin_layout Description
Serial_DAC_IF.vhd Supports serial DAC
\end_layout

\begin_layout Description
Serial_Switch_IF.vhd Supports serial switches
\end_layout

\begin_layout Description
SIO_Block.vhd Controls all serial ADCs and DACs, making them accessible to
 the MCU.
\end_layout

\begin_layout Description
top_block.vhd Top level block
\end_layout

\begin_layout Description
top_io.vhd Logical to physical polarity conversion, etc.
\end_layout

\begin_layout Description
top_io_map.vhd Physical pinout definition layer
\end_layout

\begin_layout Description
wbm.vhd Wallace-Booth multiplier
\end_layout

\begin_layout Description
WLM_Block.vhd WLM output processing and laser wavelength locking 
\end_layout

\begin_layout Subsection
MCU
\end_layout

\begin_layout Subsubsection
Periodic Function Manager
\end_layout

\begin_layout Description
CAL_downloadTimeout_PRD
\end_layout

\begin_layout Description
CLOCK_update_PRD
\end_layout

\begin_layout Description
DIAG_updateTime_PRD
\end_layout

\begin_layout Description
HTRCNTRL_stateMachine_PRD
\end_layout

\begin_layout Description
KEEPALIVE_PRD
\end_layout

\begin_layout Description
LedBlink_PRD
\end_layout

\begin_layout Description
LSRICNTRL_stateMachine_PRD
\end_layout

\begin_layout Description
RDCNTRL_stateMachine_PRD
\end_layout

\begin_layout Description
RDDATA_schemeDownloadTimeout_PRD
\end_layout

\begin_layout Description
SENTRY_check_PRD
\end_layout

\begin_layout Subsubsection
Tasks
\end_layout

\begin_layout Description
COMM_rxTask
\end_layout

\begin_layout Description
DASCNTRL_stateMachine
\end_layout

\begin_layout Description
IOMGR_fastGroup
\end_layout

\begin_layout Description
IOMGR_mediumGroup
\end_layout

\begin_layout Description
IOMGR_slowGroup
\end_layout

\begin_layout Description
MAILBOX_mcuReceive
\end_layout

\begin_layout Description
SPECTCNTRL_abortTsk
\end_layout

\begin_layout Description
SPECTCNTRL_rdCompleteTsk
\end_layout

\begin_layout Description
TESTEX_execute
\end_layout

\begin_layout Description
TRANSPORT_txTask
\end_layout

\begin_layout Description
WATCHDOG_refreshTSK
\end_layout

\begin_layout Description
XSVF_task
\end_layout

\begin_layout Description
SPECTCNTRL_stateMachine
\end_layout

\begin_layout Description
TMPCNTRL_update
\end_layout

\begin_layout Description
SPECTCNTRL_rdTimeoutTask
\end_layout

\begin_layout Subsubsection
Files
\end_layout

\begin_layout Description
analogif.c Analog interface card support
\end_layout

\begin_layout Description
cal.c Manages calibration tables for frequency based schemes (obsolete) and
 laser based schemes.
 Frequency based schemes involve converting between wavenumber and ratio,
 and between wavenumber and laser temperature.
 For laser based schemes, the DAS is unaware of wavenumbers, but deals only
 with normalized WLM angles and laser temperatures which are specified by
 the host.
 The DAS only needs to convert normalized WLM angles to ratio multipliers,
 based on the current etalon temperature.
\end_layout

\begin_layout Description
clock.c Handles the CLOCK_TICKS and CLOCK_RESET register for millisecond
 clock.
\end_layout

\begin_layout Description
comm1.c Low-level USB communications code which handles 64-byte fragments
\end_layout

\begin_layout Description
config.c Implements configuration storage management in non-volatile memory
\end_layout

\begin_layout Description
conversion.c Implements conversion of thermistor measurements to temperatures,
 pressure sensor data to pressure, TEC current and voltage monitor outputs
 to physical units, laser current and voltage monitor outputs to physical
 units.
\end_layout

\begin_layout Description
crc.c Calculates CRC-32 and CRC-16 checksums.
\end_layout

\begin_layout Description
csl_i2c.c Supports I2C communications from MCU.
\end_layout

\begin_layout Description
csl_mcbsp.c Supports communications with MCBSP interface for USB communication.
\end_layout

\begin_layout Description
dascntrl.c Copies code between MCU and flash, copies code from flash to DSP,
 boots DSP, initializes hardware and 
\begin_inset Quotes eld
\end_inset

applications
\begin_inset Quotes erd
\end_inset

: SENTRY, RDDATA, SPECTCNTRL, TMPCNTRL, RDCNTRL, LSRICNTRL, HTRCNTRL, VLVCNTRL,
 CAL, DASTEMP, TESTEX, KEEPALIVE, CLOCK, WATCHDOG.
\end_layout

\begin_layout Description
dastemp.c Wakes up each second to send DAS temperature (read by sensor on
 DSP I2C bus) to the MCU.
\end_layout

\begin_layout Description
diag.c Maintains minimum / maximum hold registers and event counter registers
 and stores them periodically in non-volatile memory.
\end_layout

\begin_layout Description
dispatch.c Calls appropriate routines in response to register reads, register
 writes, memory region reads and writes.
\end_layout

\begin_layout Description
display.c Handles the front panel display.
\end_layout

\begin_layout Description
ds1747.c Handles real-time clock chip.
\end_layout

\begin_layout Description
dspgpio.c Allows access to DSP GPIO lines from MCU.
\end_layout

\begin_layout Description
dspsys.c Configure DSP system registers (PLL, EMIF configuration, etc) from
 MCU.
\end_layout

\begin_layout Description
edma.c Allows access to DSP EDMA controller parameter tables from MCU.
\end_layout

\begin_layout Description
eeprom.c Allows access to I2C EEPROM devices from MCU.
\end_layout

\begin_layout Description
epmgr.c EEPROM manager.
\end_layout

\begin_layout Description
fifo.c Maintains FIFO structures for diagnostics.
\end_layout

\begin_layout Description
flash.c Supports AMD flash memory.
\end_layout

\begin_layout Description
fpga.c Interface between MCU and FPGA registers.
\end_layout

\begin_layout Description
gud7000.c Noritake front panel display driver.
\end_layout

\begin_layout Description
hpi.c Routines to support DSP Host Port Interface.
\end_layout

\begin_layout Description
htrcntrl.c Heater control application.
\end_layout

\begin_layout Description
hwversion.c Checks hardware version of DAS board.
\end_layout

\begin_layout Description
i2c.c I2C support routines.
\end_layout

\begin_layout Description
iomgr.c Dispatches functions for collecting data used by controllers and
 storage of these data to the streaming queue, dispatches functions which
 apply the control outputs, and dispatches the controller functions.
 The application operates at three frequencies, fast, medium and slow.
 Each input, output and controller can be assigned to one of these rates.
\end_layout

\begin_layout Description
keepalive.c This is responsible for resetting the MCU if its timer is not
 reset before it times out.
\end_layout

\begin_layout Description
lsricntrl.c Laser current controller application.
\end_layout

\begin_layout Description
mailbox.c Supports mailbox functions for MCU and DSP communications.
\end_layout

\begin_layout Description
mcbsp.c Initializes the 6713 MCBSP interface.
\end_layout

\begin_layout Description
memtest.c Memory test routines.
\end_layout

\begin_layout Description
pid.c PID controller routines.
\end_layout

\begin_layout Description
rdcntrl.c Ringdown controller which implements a state machine controlling
 the ringdown sequencer.
 Manages transition between ramp and dither modes, writing the tuner waveform
 generator parameters to the FPGA.
 Supports both cavity length tuning and laser current tuning.
 Deals with ringdown timeouts.
 Allows setting of laser current locking parameters (PID gains, precontrol
 duration, frequency locking window etc.)
\end_layout

\begin_layout Description
rddata.c Manages transferring ringdown data and ringdown capture buffer data
 to the ringdown results queue and manages transfers from the ringdown results
 queue to the host.
 Handles latest loss register for bacth mode triggering based on loss.
 Deals with setting of ringdown fitting registers.
 Manages downloading of schemes.
\end_layout

\begin_layout Description
reset.c Allows resetting of DSP, FPGA, flash memory, USB and display.
\end_layout

\begin_layout Description
rtc.c Interface for MAXIM DS1747 nonvolatile timekeeping RAM.
\end_layout

\begin_layout Description
sentry.c Responsible for shutting down system if any data signals it is monitorin
g goes outside allowed ranges.
\end_layout

\begin_layout Description
spectcntrl.c Performs a wavelength or laser temperature scan by stepping
 through a scheme file.
 The spectrum controller is informed by the ringdown handler when the dwell
 count for a scheme row is reached.
 Note that dwells of zero are allowed for just setting the laser temperature.
\end_layout

\begin_layout Description
spin.c Waits for a specified number of microseconds in a tight loop.
\end_layout

\begin_layout Description
stream.c Transfers a timed stream of data to the host for sensors.
\end_layout

\begin_layout Description
syshooks.c Halts the processor on serious error.
\end_layout

\begin_layout Description
taskmgr.c Manages tasks on the MCU, allowing processor statistics for each
 to be examined.
\end_layout

\begin_layout Description
test.c Test routines.
\end_layout

\begin_layout Description
testex.c Test executive for memory testing.
\end_layout

\begin_layout Description
tmpcntrl.c Temperature control routines.
\end_layout

\begin_layout Description
transport.c Handles assembly and disassembly of USB commands and responses
 into fragments which are transferred using comm.c.
\end_layout

\begin_layout Description
vlvcntrl.c Valve control for proportional and solenoid valves.
\end_layout

\begin_layout Description
watchdog.c Tests for and recovers from MCU or DSP hogging processor.
 A low priority watchdog refresh task runs every 100ms to reset a hardware
 watchdog timer and watchdog bark timer.
 The hardware watchdog timer times out in 167ms and resets the MCU.
 The watchdog bark timer generates an interrupt if the timer is not reset
 for 125ms.
 Five successive barks causes the timeout to be logged and the MCU to be
 reset.
\end_layout

\begin_layout Description
xsvf.c Support for compressed serial vector format files for programming
 the FPGA.
\end_layout

\begin_layout Subsection
DSP
\end_layout

\begin_layout Subsubsection
Periodic Function Manager
\end_layout

\begin_layout Description
DASTEMP_update_PRD
\end_layout

\begin_layout Description
DSPWATCHDOG_refresh_PRD
\end_layout

\begin_layout Subsubsection
Files
\end_layout

\begin_layout Description
cal.c Manages calibration tables for frequency based schemes (obsolete) and
 laser based schemes.
\end_layout

\begin_layout Description
conversion.c Implements conversion of thermistor measurements to temperatures,
 pressure sensor data to pressure, TEC current and voltage monitor outputs
 to physical units, laser current and voltage monitor outputs to physical
 units.
\end_layout

\begin_layout Description
crc.c Calculates CRC-32 and CRC-16 checksums.
\end_layout

\begin_layout Description
dastemp.c Wakes up each second to send DAS temperature (read by sensor on
 DSP I2C bus) to the MCU.
\end_layout

\begin_layout Description
ds1631.c Maxim/Dallas thermometer routines.
\end_layout

\begin_layout Description
dspwatchdog.c Sends refresh mailbox message to MCU watchdog application.
\end_layout

\begin_layout Description
eeprom.c Support Atmel I2C EEPROMs.
\end_layout

\begin_layout Description
epmgr.c EEPROM manager.
\end_layout

\begin_layout Description
gpio.c General purpose I/O line handler.
\end_layout

\begin_layout Description
i2c.c I2C bus handler.
\end_layout

\begin_layout Description
interrupt.c routines to map interrupt lines, enable and disable interrupts.
\end_layout

\begin_layout Description
mailbox.c DSP side of mailbox communications with MCU.
\end_layout

\begin_layout Description
main.c Mainline which initializes applications on the DSP.
\end_layout

\begin_layout Description
memory.c Opens EDMA channel
\end_layout

\begin_layout Description
peripherals.c Initializes I2C
\end_layout

\begin_layout Description
rddata.c Organize ringdown data onto the ringdown results stream for transfer
 to host.
\end_layout

\begin_layout Description
rdfitting.c Performs exponential fitting of ringdowns.
\end_layout

\begin_layout Description
rdhandler.c Sequences ringdowns on DSP side.
 Manages interrupts for ringdown occurrence and EDMA transfer of data.
 Keeps count of ringdowns and informs the spectrum controller when the dwell
 countt is reached.
\end_layout

\begin_layout Description
rdproc.c Calculates wavelength monitor information at time of ringdown from
 capture buffer, applying etalon temperature correction as necessary.
\end_layout

\begin_layout Description
sharedmem.c Reserves memory space on the DSP.
\end_layout

\begin_layout Description
syscntrl.c Routines for setting PLL when DSP is started.
\end_layout

\begin_layout Section
Software Architecture
\end_layout

\begin_layout Standard
The instrument contains a digital signal processor (DSP) and field programmable
 logic array (FPGA) which are interfaced to the host computer via a USB
 interface.
 The USB interface is provided by a Cypress FX2 controller which contains
 an eight-bit microprocessor.
 All the software and firmware for the instrument are downloaded from the
 host via the USB interface on power-up.
\end_layout

\begin_layout Standard
Initially, the Cypress FX2 only supports a minimal set of USB commands,
 and enumerates as an unprogrammed device.
 The default VID is 0x4B4 and the default PID is 0x8613, but these may be
 changed by using a small EEPROM.
 When the host recognizes the unprogrammed USB controller, it sends the
 code to the device via the routine 
\family typewriter
loadUsbIfCode
\family default
 and waits for 
\end_layout

\begin_layout Standard

\family typewriter
analyzerUsb.c
\end_layout

\begin_layout Description

\family typewriter
analyzerUsbIf.py
\family default
 contains the 
\family typewriter
AnalyzerUsb
\family default
 class which represents a USB connection between the host and the USB controller
 at a specific VID and PID.
 Methods of this class are used to perform various functions such as programming
 the USB controller, programming the DSP and programming the FPGA.
\end_layout

\begin_layout Description

\family typewriter
registers.c 
\family default
code for DSP to read and write to registers in internal memory.
\end_layout

\begin_layout Section
DSP Tasks
\end_layout

\begin_layout Enumerate
Temperature PID control of the following:
\end_layout

\begin_deeper
\begin_layout Enumerate
Up to four lasers, or up to three lasers and one SOA
\end_layout

\begin_layout Enumerate
Warm box
\end_layout

\begin_layout Enumerate
Hot box
\end_layout

\begin_layout Standard
Each controller implements control to a setpoint, continuous sweeping between
 a minimum and maximum temperature at a specified rate, and the generation
 of a pseudorandom binary sequence for characterizing the properties of
 the system.
 The temperatures are recorded using thermistors connected to 24 bit ADCs
 which are connected to the DSP via I2C interfaces.
 
\end_layout

\begin_layout Standard
The output of each controller connects to the TECs via a pulse-width modulated
 power supply.
 It is only necessary for the DSP to write the control output to a FPGA
 register, since the FPGA is responsible for generating the PWM signal.
\end_layout

\begin_layout Standard
For each laser, a temperature offset may be added to the looked up scheme
 temperature before it is used as the setpoint, to allow for drifts in the
 temperature-frequency relation.
\end_layout

\begin_layout Standard
Each control loop supports the ability to turn off the TEC if the temperature
 at a secondary thermistor exceeds a certain value (typically, this would
 be the warm box or hot box heatsink).
 Once the temperature at the secondary thermistor falls below that value,
 normal control resumes.
\end_layout

\begin_layout Standard
The control output to each TEC may be modified by the addition of a quantity
 proportional to the difference between the current temperature and the
 external temperature.
 This is a feed-forward mechanism which attempts to reduce the sensitivity
 of the system to ambient temperature fluctuations.
\end_layout

\end_deeper
\begin_layout Enumerate
Pressure control of proportional valves
\end_layout

\begin_layout Enumerate
Control of solenoid valves
\end_layout

\begin_layout Enumerate
Streaming of sensor data:
\end_layout

\begin_deeper
\begin_layout Enumerate
Temperatures of up to four lasers
\end_layout

\begin_layout Enumerate
Temperatures of cavity, hot box heatsink, etalon, warm box, warm box heatsink
\end_layout

\begin_layout Enumerate
Wavelength monitor photodiode outputs
\end_layout

\begin_layout Enumerate
Ambient and cavity pressures
\end_layout

\begin_layout Standard
The sensor data stream are stored as a queue of data, 
\end_layout

\end_deeper
\begin_layout Enumerate
Obeying a sequence of schemes, switching between them without any deadtime.
\end_layout

\begin_layout Enumerate
Ringdown fitting
\end_layout

\begin_layout Enumerate
Calculation of temperature and pressure corrected wavelength monitor angle
\end_layout

\begin_layout Enumerate
Batch mode processing on basis of measured concentrations
\end_layout

\begin_layout Enumerate
Generation of PZT waveform
\end_layout

\begin_layout Enumerate
Generation of desired laser frequency waveform (or corrected WLM angle setpoint)
 for locking
\end_layout

\begin_layout Enumerate
Sentries
\end_layout

\begin_layout Enumerate
Watchdog and keepalive handling
\end_layout

\begin_layout Enumerate
Diagnostics reporting
\end_layout

\begin_layout Enumerate
Self-test
\end_layout

\begin_layout Subsection
DSP Periodic Tasks
\end_layout

\begin_layout Enumerate
Write out all control outputs from registers
\end_layout

\begin_layout Enumerate
Read all sensor inputs into shadow registers
\end_layout

\begin_layout Enumerate
Run controllers to generate next output
\end_layout

\begin_layout Standard
Consider using fast, medium and slow periods:
\end_layout

\begin_layout Enumerate
5Hz for laser temperature and pressure control
\end_layout

\begin_layout Enumerate
1Hz for sentries
\end_layout

\begin_layout Enumerate
0.2Hz for hot box and warm box temperature control
\end_layout

\begin_layout Standard
Read all I2C ADC sensors at 5Hz and update shadow registers.
 We can then do averaging if necessary.
 Laser TEC current tellback is multiplexed between lasers.
\end_layout

\begin_layout Subsubsection
Implementation of Periodic Tasks on DSP
\end_layout

\begin_layout Standard
Tasks are organized into groups of operations.
 Each operation consists of an opcode which specifies what is to be performed
 and a list of operands, which is typically the set of software registers
 that are involved in the operation.
 For example, applying a conversion function to a thermistor resistance
 to convert it into a temperature may involve an operation such as:
\end_layout

\begin_layout LyX-Code
resistanceToTemperature(
\end_layout

\begin_layout LyX-Code
    "LASER1_RESISTANCE_REGISTER",
\end_layout

\begin_layout LyX-Code
    "CONVERSION_LASER1_THERM_CONSTA_REGISTER",
\end_layout

\begin_layout LyX-Code
    "CONVERSION_LASER1_THERM_CONSTB_REGISTER",
\end_layout

\begin_layout LyX-Code
    "CONVERSION_LASER1_THERM_CONSTC_REGISTER",         
\end_layout

\begin_layout LyX-Code
    "LASER1_TEMPERATURE_REGISTER")
\end_layout

\begin_layout Standard
An opcode is assigned to 
\family typewriter
resistanceToTemperature
\family default
 and the registers are the operands.
 Any number of operations may be concatenated to form a group.
 The end of a group is marked by an operation with a zero opcode.
 Each group of operations is assigned a priority and a period, which determine
 when the operations will be performed.
\end_layout

\begin_layout Standard
The current time is a stored in a 40-bit long integer, and counts up in
 100ms increments.
 This gives a time before overflow of 3500 years.
 The period is an integer associated with the group.
 The group is scheduled to be run whenever the current time is a multiple
 of the period.
 When several groups are scheduled to be run at the same time, their execution
 order is determined by the priority.
 All operations in groups with numerically lower priority values are executed
 before operations with higher values.
\end_layout

\begin_layout Standard
By using a system of priorities, we can place all control outputs at one
 priority, sensor inputs at another priority, controllers at a third priority
 and so on.
\end_layout

\begin_layout Subsection
Communication between Host and DSP
\end_layout

\begin_layout Standard
Communications between the host and the DSP take place via a region of memory,
 which is typically placed in the 192 kbyte internal memory area of the
 DSP (byte addresses 0 through 0x2FFFF).
 The host can access DSP memory through HPI commands, but care must be taken
 to maintain cache coherency since HPI accesses occur asynchronously with
 the DSP and such accesses do not necessarily update the DSP cache.
\end_layout

\begin_layout Standard
The communications memory region is divided into 4 byte chunks, each of
 which occupies a 
\begin_inset Quotes eld
\end_inset

register
\begin_inset Quotes erd
\end_inset

.
 Registers are numbered sequentially from zero to 0x3F00, for a total of
 16128 registers.
 The address of register 
\family typewriter
regNum
\family default
 is 
\family typewriter
REG_BASE + 4*regNum
\family default
, and the data occupy the four bytes starting at this address, with the
 data stored in little-endian format.
\end_layout

\begin_layout Standard
The host is free to read from the register area at any time.
 Due to the way the HPI code is organized the USB driver, it is necessary
 to transfer multiples of four bytes at a time, and these accesses must
 be aligned on addresses which are divisible by four.
\end_layout

\begin_layout Standard
The DSP writes to the register area via an interface routine which ensures
 that the data are written back from the cache to memory.
 This is only necessary if the communications area is implemented in external
 memory, as the cache controller takes care of maintaining coherence between
 the L1D cache and internal memory.
\end_layout

\begin_layout Standard
Note: Some DSP routines gain access to the register area by reference, so
 that register values may be changed without calling writeRegister.
 An auxiliary routine writebackRegisters is provided to allow a set of registers
 to be written back from the cache to memory.
 This should be called by an interface routine which has information about
 which registers may have been updated.
 The parameters to writebackRegisters are an array of register indices and
 the number of registers to be written back.
\end_layout

\begin_layout Standard
When the host needs to write to the register area, it does so indirectly
 using a host HPI write region which is located at HOST_BASE and which is
 distinct from the register area.
 After doing the HPI write, the host signals a DSPINT which executes a routine
 that causes the DSP to perform the required writes to the register area.
 In this way, only the DSP is allowed to write into the register area, keeping
 the cache coherent.
\end_layout

\begin_layout Subsection
Sensor stream and ringdown 
\begin_inset Quotes eld
\end_inset

queues
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Some data collected by the DAS has to be communicated to the host.
 These data may be generated on a prescribed schedule (such as the sensor
 data, collected at regular intervals), or may arrive at irregular times
 (such as the ringdown data).
 Since the USB protocol only allows transfers to be initiated from the host
 computer, it is necessary to have the driver on the host retrieve the data
 from the DAS.
 Within the DAS, the data has to be enqueued to cope with the fact that
 the retrieval takes place asynchronously with the generation.
\end_layout

\begin_layout Standard
A complication arises in that the driver may not necessarily be executing
 for a period.
 Since this does not stop the data collection in the DAS, it is possible
 for the buffers to fill up and for data to be lost.
 The following method is used to buffer data in the DAS so that it may be
 retrieved by the host using only host reads.
\end_layout

\begin_layout Subsection
Format of sensor data
\end_layout

\begin_layout Subsection
Format of a ringdown result
\end_layout

\begin_layout Description

\family typewriter
lockValue 
\family default
Wavelength monitor angle (corrected for etalon temperature) at ringdown
\end_layout

\begin_layout Description

\family typewriter
ratio1 
\family default
Wavelength monitor ratio 1 at ringdown
\end_layout

\begin_layout Description

\family typewriter
ratio2 
\family default
Wavelength monitor ratio 2 at ringdown
\end_layout

\begin_layout Description

\family typewriter
correctedAbsorbance
\family default
 Loss including backscatter correction
\end_layout

\begin_layout Description

\family typewriter
uncorrectedAbsorbance
\family default
 Loss without backscatter correction
\end_layout

\begin_layout Description

\family typewriter
tunerValue
\family default
 Tuner waveform at time of ringdown
\end_layout

\begin_layout Description

\family typewriter
pztValue
\family default
 PZT value at time of ringdown
\end_layout

\begin_layout Description

\family typewriter
laserSelect 
\family default
Active laser
\end_layout

\begin_layout Description

\family typewriter
fitStatus
\family default
 status from exponential fit
\end_layout

\begin_layout Description

\family typewriter
schemeStatus
\family default
 scheme status
\end_layout

\begin_layout Description

\family typewriter
schemeTableIndex
\family default
 which scheme is being used
\end_layout

\begin_layout Description

\family typewriter
count 
\family default
flag affected by increment field in subscheme id
\end_layout

\begin_layout Description

\family typewriter
subschemeId 
\family default
subscheme id
\end_layout

\begin_layout Description

\family typewriter
schemeRow 
\family default
row in scheme file for this ringdown
\end_layout

\begin_layout Description

\family typewriter
fineLaserCurrent 
\family default
fine laser current value for this ringdown
\end_layout

\begin_layout Description

\family typewriter
lockSetpoint 
\family default
Wavelength monitor angle (corrected for etalon temperature) targetted
\end_layout

\begin_layout Description

\family typewriter
time 
\family default
timestamp
\end_layout

\begin_layout Standard
The timestamp must be the last 
\end_layout

\begin_layout Section
FPGA Tasks
\end_layout

\begin_layout Enumerate
Reading fast ADCs and putting data into ringdown memory
\end_layout

\begin_layout Enumerate
SPI interface to DACs
\end_layout

\begin_layout Enumerate
Generating PZT waveform
\end_layout

\begin_layout Enumerate
Generating laser current waveform
\end_layout

\begin_layout Enumerate
Assembling ringdown capture information
\end_layout

\begin_layout Enumerate
Implementing laser frequency locking
\end_layout

\begin_layout Enumerate
Sequencing ringdown
\end_layout

\begin_layout Subsection
FPGA Registers
\end_layout

\end_body
\end_document
