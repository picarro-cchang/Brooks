<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="stan@picarro-com.20150609175653.1"><vh>@clean src/main/python/Tools/Release/release_original.py</vh>
<v t="stan@picarro-com.20150609175653.2"><vh>release declarations</vh></v>
<v t="stan@picarro-com.20150609175653.3"><vh>class StdoutLogger</vh>
<v t="stan@picarro-com.20150609175653.4"><vh>__init__</vh></v>
<v t="stan@picarro-com.20150609175653.5"><vh>set_quiet</vh></v>
<v t="stan@picarro-com.20150609175653.6"><vh>write</vh></v>
<v t="stan@picarro-com.20150609175653.7"><vh>flush</vh></v>
<v t="stan@picarro-com.20150609175653.8"><vh>close</vh></v>
<v t="stan@picarro-com.20150609175653.9"><vh>__del__</vh></v>
</v>
<v t="stan@picarro-com.20150609175653.10"><vh>class StderrLogger</vh>
<v t="stan@picarro-com.20150609175653.11"><vh>__init__</vh></v>
<v t="stan@picarro-com.20150609175653.12"><vh>write</vh></v>
<v t="stan@picarro-com.20150609175653.13"><vh>flush</vh></v>
<v t="stan@picarro-com.20150609175653.14"><vh>close</vh></v>
<v t="stan@picarro-com.20150609175653.15"><vh>__del__</vh></v>
</v>
<v t="stan@picarro-com.20150609175653.16"><vh>class Logger</vh>
<v t="stan@picarro-com.20150609175653.17"><vh>__init__</vh></v>
<v t="stan@picarro-com.20150609175653.18"><vh>set_quiet</vh></v>
<v t="stan@picarro-com.20150609175653.19"><vh>__del__</vh></v>
</v>
<v t="stan@picarro-com.20150609175653.20"><vh>LogErr</vh></v>
<v t="stan@picarro-com.20150609175653.21"><vh>_buildDoneMsg</vh></v>
<v t="stan@picarro-com.20150609175653.22"><vh>_printSummary</vh></v>
<v t="stan@picarro-com.20150609175653.23"><vh>runCommand</vh></v>
<v t="stan@picarro-com.20150609175653.24"><vh>getGitBranch</vh></v>
<v t="stan@picarro-com.20150609175653.25"><vh>handleRemoveReadonly</vh></v>
<v t="stan@picarro-com.20150609175653.26"><vh>makeExe</vh></v>
<v t="stan@picarro-com.20150609175653.27"><vh>_promoteStagedRelease</vh></v>
<v t="stan@picarro-com.20150609175653.28"><vh>_copyBuildAndInstallers</vh></v>
<v t="stan@picarro-com.20150609175653.29"><vh>_branchFromRepo</vh></v>
<v t="stan@picarro-com.20150609175653.30"><vh>_generateReleaseVersion</vh></v>
<v t="stan@picarro-com.20150609175653.31"><vh>_buildExes</vh></v>
<v t="stan@picarro-com.20150609175653.32"><vh>_tagRepository</vh></v>
<v t="stan@picarro-com.20150609175653.33"><vh>_tagCommonConfig</vh></v>
<v t="stan@picarro-com.20150609175653.34"><vh>_tagAppInstrConfigs</vh></v>
<v t="stan@picarro-com.20150609175653.35"><vh>_makeLocalConfig</vh></v>
<v t="stan@picarro-com.20150609175653.36"><vh>_createGitConfigVersionFile</vh></v>
<v t="stan@picarro-com.20150609175653.37"><vh>_setGitConfigVer</vh></v>
<v t="stan@picarro-com.20150609175653.38"><vh>_compileInstallers</vh></v>
<v t="stan@picarro-com.20150609175653.39"><vh>_verAsString</vh></v>
<v t="stan@picarro-com.20150609175653.40"><vh>_verAsNumString</vh></v>
<v t="stan@picarro-com.20150609175653.41"><vh>_verAsUINumString</vh></v>
<v t="stan@picarro-com.20150609175653.42"><vh>main</vh></v>
</v>
<v t="stan@picarro-com.20150529101713.1"><vh>Setting up build environment</vh>
<v t="stan@picarro-com.20150529101736.1"><vh>VirtualEnv</vh></v>
</v>
<v t="sze.20150327093644.2"><vh>Proposed tree structure</vh>
<v t="sze.20150327144536.1"><vh>config</vh>
<v t="sze.20150327145041.1"><vh>AppConfigBase</vh></v>
<v t="sze.20150327145048.1"><vh>InstrConfigBase</vh></v>
<v t="sze.20150327144553.1"><vh>CommonConfig</vh></v>
<v t="sze.20150327144708.1"><vh>CFADS</vh>
<v t="sze.20150327144713.1"><vh>AppConfig</vh></v>
<v t="sze.20150327144717.1"><vh>InstrConfig</vh></v>
</v>
<v t="sze.20150327144638.1"><vh>AEDS</vh>
<v t="sze.20150327144644.1"><vh>AppConfig</vh></v>
<v t="sze.20150327144651.1"><vh>InstrConfig</vh></v>
</v>
</v>
<v t="sze.20150327094108.1"><vh>src</vh>
<v t="sze.20150327114556.1"><vh>main</vh>
<v t="stan@picarro-com.20150612091639.1"><vh>python</vh>
<v t="stan@picarro-com.20150612091900.1"><vh>Firmware</vh>
<v t="stan@picarro-com.20150612091900.2"><vh>ArduinoSystemMonitor</vh></v>
<v t="stan@picarro-com.20150612091900.3"><vh>CypresssUSB</vh></v>
<v t="stan@picarro-com.20150612091900.4"><vh>Docs</vh></v>
<v t="stan@picarro-com.20150612091900.5"><vh>DSP</vh></v>
<v t="stan@picarro-com.20150612091900.6"><vh>FX2Devel</vh></v>
<v t="stan@picarro-com.20150612091900.7"><vh>MyHDL</vh></v>
<v t="stan@picarro-com.20150612091900.8"><vh>Peripherals</vh></v>
<v t="stan@picarro-com.20150612091900.9"><vh>Schemes</vh></v>
<v t="stan@picarro-com.20150612091900.10"><vh>Utilities</vh></v>
<v t="stan@picarro-com.20150612091900.11"><vh>xml</vh></v>
</v>
<v t="stan@picarro-com.20150612091820.1"><vh>Host</vh>
<v t="stan@picarro-com.20150612091820.2"><vh>ActiveFileManager</vh></v>
<v t="stan@picarro-com.20150612091820.3"><vh>AlarmmSystem</vh></v>
<v t="stan@picarro-com.20150612091820.4"><vh>Archiver</vh></v>
<v t="stan@picarro-com.20150612091820.5"><vh>autogen</vh></v>
<v t="stan@picarro-com.20150612091820.6"><vh>CommandInterface</vh></v>
<v t="stan@picarro-com.20150612091820.7"><vh>Common</vh></v>
<v t="stan@picarro-com.20150612091820.8"><vh>ConfigManager</vh></v>
<v t="stan@picarro-com.20150612091820.9"><vh>ControlBridge</vh></v>
<v t="stan@picarro-com.20150612091820.10"><vh>Controller</vh></v>
<v t="stan@picarro-com.20150612091820.11"><vh>DataLogger</vh></v>
<v t="stan@picarro-com.20150612091820.12"><vh>DataManager</vh></v>
<v t="stan@picarro-com.20150612091820.13"><vh>DataManagerToDatabase</vh></v>
<v t="stan@picarro-com.20150612091820.14"><vh>DatViewer</vh></v>
<v t="stan@picarro-com.20150612091820.15"><vh>Doctests</vh></v>
<v t="stan@picarro-com.20150612091820.16"><vh>Driver</vh></v>
<v t="stan@picarro-com.20150612091820.17"><vh>ElectricalIntterface</vh></v>
<v t="stan@picarro-com.20150612091820.18"><vh>EventLogWatcher</vh></v>
<v t="stan@picarro-com.20150612091820.19"><vh>EventManager</vh></v>
<v t="stan@picarro-com.20150612091820.20"><vh>FileEraser</vh></v>
<v t="stan@picarro-com.20150612091820.21"><vh>Fitter</vh></v>
<v t="stan@picarro-com.20150612091820.22"><vh>FlowController</vh></v>
<v t="stan@picarro-com.20150612091820.23"><vh>HardwareTesting</vh></v>
<v t="stan@picarro-com.20150612091820.24"><vh>InstMgr</vh></v>
<v t="stan@picarro-com.20150612091820.25"><vh>newHeadline</vh></v>
<v t="stan@picarro-com.20150612091820.26"><vh>IPV</vh></v>
<v t="stan@picarro-com.20150612091820.27"><vh>LockWorkstation</vh></v>
<v t="stan@picarro-com.20150612091820.28"><vh>LogicBoardTest</vh></v>
<v t="stan@picarro-com.20150612091820.29"><vh>MeasSystem</vh></v>
<v t="stan@picarro-com.20150612091820.30"><vh>MobileKit</vh></v>
<v t="stan@picarro-com.20150612091820.31"><vh>PeakAnalyzer</vh></v>
<v t="stan@picarro-com.20150612091820.32"><vh>PeriphIntrf</vh></v>
<v t="stan@picarro-com.20150612091820.33"><vh>QuickGui</vh></v>
<v t="stan@picarro-com.20150612091820.34"><vh>RDFrequencyConverter</vh></v>
<v t="stan@picarro-com.20150612091820.35"><vh>rdReprocessor</vh></v>
<v t="stan@picarro-com.20150612091820.36"><vh>ReadExtSensor</vh></v>
<v t="stan@picarro-com.20150612091820.37"><vh>SampleManager</vh></v>
<v t="stan@picarro-com.20150612091820.38"><vh>Sensors</vh></v>
<v t="stan@picarro-com.20150612091820.39"><vh>SpectrumCollector</vh></v>
<v t="stan@picarro-com.20150612091820.40"><vh>SpectrumMaker</vh></v>
<v t="stan@picarro-com.20150612091820.41"><vh>Supervisor</vh></v>
<v t="stan@picarro-com.20150612091820.42"><vh>SupervisorZMQ</vh></v>
<v t="stan@picarro-com.20150612091820.43"><vh>Tests</vh></v>
<v t="stan@picarro-com.20150612091820.44"><vh>Utilities</vh></v>
<v t="stan@picarro-com.20150612091820.45"><vh>ValveSequencer</vh></v>
<v t="stan@picarro-com.20150612091820.46"><vh>WebClient</vh></v>
<v t="stan@picarro-com.20150612091820.47"><vh>WebServer</vh></v>
</v>
</v>
<v t="sze.20150327114611.1"><vh>scripts</vh></v>
</v>
<v t="sze.20150327114631.1"><vh>unittest</vh>
<v t="sze.20150327114803.1"><vh>python</vh></v>
</v>
</v>
</v>
<v t="sze.20150527173055.1"><vh>Current tree structure</vh>
<v t="sze.20150527173110.1"><vh>AddOns</vh>
<v t="sze.20150527174434.1"><vh>AIAutosampler</vh></v>
<v t="sze.20150527174443.1"><vh>SoilPostProcessor</vh></v>
<v t="sze.20150527174450.1"><vh>SSIM</vh></v>
</v>
<v t="sze.20150527173116.1"><vh>Assets</vh>
<v t="sze.20150527174602.1"><vh>icons</vh></v>
<v t="sze.20150527174606.1"><vh>Python25</vh></v>
<v t="sze.20150527174610.1"><vh>Python27</vh></v>
</v>
<v t="sze.20150527173120.1"><vh>Config</vh>
<v t="sze.20150527174620.1"><vh>CommonConfig</vh></v>
<v t="sze.20150527174631.1"><vh>FEDS</vh></v>
</v>
<v t="sze.20150527173123.1"><vh>Firmware</vh>
<v t="sze.20150527174330.1"><vh>ArduinoSystemMonitor</vh></v>
<v t="sze.20150527174340.1"><vh>CypresssUSB</vh></v>
<v t="sze.20150527174346.1"><vh>Docs</vh></v>
<v t="sze.20150527174351.1"><vh>DSP</vh></v>
<v t="sze.20150527174354.1"><vh>FX2Devel</vh></v>
<v t="sze.20150527174359.1"><vh>MyHDL</vh></v>
<v t="sze.20150527174404.1"><vh>Peripherals</vh></v>
<v t="sze.20150527174409.1"><vh>Schemes</vh></v>
<v t="sze.20150527174415.1"><vh>Utilities</vh></v>
<v t="sze.20150527174419.1"><vh>xml</vh></v>
</v>
<v t="sze.20150527173129.1"><vh>Host</vh>
<v t="sze.20150527173225.1"><vh>ActiveFileManager</vh></v>
<v t="sze.20150527173250.1"><vh>AlarmmSystem</vh></v>
<v t="sze.20150527173256.1"><vh>Archiver</vh></v>
<v t="sze.20150527173259.1"><vh>autogen</vh></v>
<v t="sze.20150527173303.1"><vh>CommandInterface</vh></v>
<v t="sze.20150527173311.1"><vh>Common</vh></v>
<v t="sze.20150527173317.1"><vh>ConfigManager</vh></v>
<v t="sze.20150527173324.1"><vh>ControlBridge</vh></v>
<v t="sze.20150527173331.1"><vh>Controller</vh></v>
<v t="sze.20150527173335.1"><vh>DataLogger</vh></v>
<v t="sze.20150527173340.1"><vh>DataManager</vh></v>
<v t="sze.20150527173344.1"><vh>DataManagerToDatabase</vh></v>
<v t="sze.20150527173353.1"><vh>DatViewer</vh></v>
<v t="sze.20150527173400.1"><vh>Doctests</vh></v>
<v t="sze.20150527173405.1"><vh>Driver</vh></v>
<v t="sze.20150527173408.1"><vh>ElectricalIntterface</vh></v>
<v t="sze.20150527173416.1"><vh>EventLogWatcher</vh></v>
<v t="sze.20150527173426.1"><vh>EventManager</vh></v>
<v t="sze.20150527173430.1"><vh>FileEraser</vh></v>
<v t="sze.20150527173445.1"><vh>Fitter</vh></v>
<v t="sze.20150527173447.1"><vh>FlowController</vh></v>
<v t="sze.20150527173454.1"><vh>HardwareTesting</vh></v>
<v t="sze.20150527173500.1"><vh>InstMgr</vh></v>
<v t="sze.20150527173505.1"><vh>newHeadline</vh></v>
<v t="sze.20150527173505.2"><vh>IPV</vh></v>
<v t="sze.20150527173510.1"><vh>LockWorkstation</vh></v>
<v t="sze.20150527173518.1"><vh>LogicBoardTest</vh></v>
<v t="sze.20150527173532.1"><vh>MeasSystem</vh></v>
<v t="sze.20150527173540.1"><vh>MobileKit</vh></v>
<v t="sze.20150527173546.1"><vh>PeakAnalyzer</vh></v>
<v t="sze.20150527173552.1"><vh>PeriphIntrf</vh></v>
<v t="sze.20150527173559.1"><vh>QuickGui</vh></v>
<v t="sze.20150527173603.1"><vh>RDFrequencyConverter</vh></v>
<v t="sze.20150527173613.1"><vh>rdReprocessor</vh></v>
<v t="sze.20150527173620.1"><vh>ReadExtSensor</vh></v>
<v t="sze.20150527173629.1"><vh>SampleManager</vh></v>
<v t="sze.20150527173640.1"><vh>Sensors</vh></v>
<v t="sze.20150527173646.1"><vh>SpectrumCollector</vh></v>
<v t="sze.20150527173653.1"><vh>SpectrumMaker</vh></v>
<v t="sze.20150527173704.1"><vh>Supervisor</vh></v>
<v t="sze.20150527173710.1"><vh>SupervisorZMQ</vh></v>
<v t="sze.20150527173728.1"><vh>Tests</vh></v>
<v t="sze.20150527173732.1"><vh>Utilities</vh></v>
<v t="sze.20150527173739.1"><vh>ValveSequencer</vh></v>
<v t="sze.20150527173753.1"><vh>WebClient</vh></v>
<v t="sze.20150527173805.1"><vh>WebServer</vh></v>
</v>
<v t="sze.20150527173131.1"><vh>MobileKit</vh>
<v t="sze.20150527174947.1"><vh>AnalyzerServer</vh></v>
<v t="sze.20150527174957.1"><vh>app</vh></v>
<v t="sze.20150527175001.1"><vh>MobileKitSetup</vh></v>
<v t="sze.20150527175008.1"><vh>MobileKitSetupNew</vh></v>
<v t="sze.20150527175016.1"><vh>NodeReportGen</vh></v>
<v t="sze.20150527175022.1"><vh>P3DataViewer</vh></v>
<v t="sze.20150527175028.1"><vh>ReportGen</vh></v>
<v t="sze.20150527175033.1"><vh>ReportGenOld</vh></v>
<v t="sze.20150527175038.1"><vh>Scripts</vh></v>
<v t="sze.20150527175043.1"><vh>Testing</vh></v>
<v t="sze.20150527175049.1"><vh>Tests</vh></v>
<v t="sze.20150527175052.1"><vh>Utilities</vh></v>
<v t="sze.20150527175056.1"><vh>ViewServer</vh></v>
<v t="sze.20150527175104.1"><vh>WeatherStation</vh></v>
</v>
<v t="sze.20150527173138.1"><vh>p3</vh>
<v t="sze.20150527174924.1"><vh>investigator</vh></v>
<v t="sze.20150527174931.1"><vh>tests</vh></v>
</v>
<v t="sze.20150527173143.1"><vh>PlumeScanner</vh></v>
<v t="sze.20150527173151.1"><vh>ReportGenOnLinuxServer</vh>
<v t="sze.20150527174900.1"><vh>ReportGen</vh></v>
</v>
<v t="sze.20150527173209.1"><vh>sqa</vh></v>
<v t="sze.20150527173213.1"><vh>Tools</vh>
<v t="sze.20150527174709.1"><vh>Data</vh></v>
<v t="sze.20150527174714.1"><vh>Release</vh></v>
<v t="sze.20150527174718.1"><vh>Scripts</vh></v>
<v t="sze.20150527174722.1"><vh>Special</vh></v>
<v t="sze.20150527174725.1"><vh>Win7MigrationTools</vh></v>
</v>
<v t="sze.20150527173218.1"><vh>Vendor</vh>
<v t="sze.20150527174805.1"><vh>AppliedInstruments</vh></v>
<v t="sze.20150527174813.1"><vh>FTDI</vh></v>
<v t="sze.20150527174817.1"><vh>IBASE</vh></v>
<v t="sze.20150527174820.1"><vh>inpout</vh></v>
<v t="sze.20150527174824.1"><vh>libusb</vh></v>
<v t="sze.20150527174828.1"><vh>Microsoft</vh></v>
</v>
</v>
<v t="sze.20150527175358.1"><vh>Versioning of Host, Firmware and Configurations</vh>
<v t="stan@picarro-com.20150612091536.1"><vh>Current versioning method</vh></v>
</v>
<v t="sze.20150616212829.1"><vh>Versioning of AddOns</vh></v>
<v t="sze.20150527185824.1"><vh>Build script</vh>
<v t="stan@picarro-com.20150623223923.1"><vh>Properties for PyBuilder</vh></v>
<v t="stan@picarro-com.20150610192902.1" a="E"><vh>@clean build.py</vh>
<v t="stan@picarro-com.20150610192913.1"><vh>build declarations</vh></v>
<v t="stan@picarro-com.20150624185413.1"><vh>handle_types</vh></v>
<v t="stan@picarro-com.20150624100735.1"><vh>initialize</vh></v>
<v t="stan@picarro-com.20150610192913.2"><vh>setup_buildenv</vh></v>
<v t="stan@picarro-com.20150610192913.3"><vh>write_setup_script</vh></v>
<v t="stan@picarro-com.20150610192913.4"><vh>build_binary_distribution</vh></v>
<v t="stan@picarro-com.20150623221216.1"><vh>run_py2exe</vh></v>
<v t="stan@picarro-com.20150610193301.1"><vh>compile_sources</vh></v>
<v t="stan@picarro-com.20150610192913.5"><vh>publish</vh></v>
<v t="stan@picarro-com.20150624184236.1"><vh>make_installers</vh></v>
</v>
<v t="stan@picarro-com.20150529220322.6"><vh>_getBuildVersion</vh></v>
<v t="stan@picarro-com.20150529220159.1"><vh>@clean src/main/python/Host/PicarroExeSetup.py</vh>
<v t="stan@picarro-com.20150529220322.1"><vh>PicarroExeSetup declarations</vh></v>
<v t="stan@picarro-com.20150529220322.2"><vh>_getPythonVersion</vh></v>
<v t="stan@picarro-com.20150529220322.3"><vh>_getPythonSubVersion</vh></v>
<v t="stan@picarro-com.20150529220322.4"><vh>_getOsType</vh></v>
<v t="stan@picarro-com.20150529220322.5"><vh>_runBatFile</vh></v>
<v t="stan@picarro-com.20150529220322.6"></v>
<v t="stan@picarro-com.20150529220322.7"><vh>_getBuildType</vh></v>
<v t="stan@picarro-com.20150529220322.8"><vh>runCommand</vh></v>
<v t="stan@picarro-com.20150529220322.9"><vh>_getGitBranch</vh></v>
<v t="stan@picarro-com.20150529220322.10"><vh>_getTimeIso8601Str</vh></v>
<v t="stan@picarro-com.20150529220322.11"><vh>_getTimeStr</vh></v>
<v t="stan@picarro-com.20150529220322.12"><vh>_createGitVersionPythonFile</vh></v>
<v t="stan@picarro-com.20150529220322.13"><vh>class Target</vh>
<v t="stan@picarro-com.20150529220322.14"><vh>__init__</vh></v>
</v>
</v>
<v t="stan@picarro-com.20150609110503.1"><vh>@clean src/main/python/Host/buildHost.py</vh>
<v t="stan@picarro-com.20150609110523.1"><vh>buildHost declarations</vh></v>
<v t="stan@picarro-com.20150609110523.2"><vh>_getOsType</vh></v>
<v t="stan@picarro-com.20150609110523.3"><vh>_generateBuildVersion</vh></v>
<v t="stan@picarro-com.20150609110523.5"><vh>_verAsNumString</vh></v>
<v t="stan@picarro-com.20150609110523.4"><vh>_verAsString</vh></v>
<v t="stan@picarro-com.20150609110523.6"><vh>buildExes</vh></v>
<v t="stan@picarro-com.20150609110523.7"><vh>main</vh></v>
</v>
<v t="stan@picarro-com.20150529220127.1"><vh>Original setup.py</vh>
<v t="stan@picarro-com.20150529220127.2"><vh>setup declarations</vh></v>
</v>
</v>
<v t="stan@picarro-com.20150609180605.1"><vh>The release script (release.py)</vh>
<v t="stan@picarro-com.20150609175614.30"><vh>_buildExes</vh></v>
<v t="stan@picarro-com.20150609175614.25"><vh>makeExe</vh>
<v t="stan@picarro-com.20150609181355.1"><vh>&lt;&lt;get osType&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609181559.1"><vh>&lt;&lt;validate opts.product&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609181647.1"><vh>&lt;&lt;validate opts.osType (only valid with --make-official)&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609181817.1"><vh>&lt;&lt;validate opts.archiveOnly&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609182004.1"><vh>&lt;&lt;warn about deprecated opts.dryRun&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609182127.1"><vh>&lt;&lt;handle skip cloning options&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609182315.1"><vh>&lt;&lt;validate opts.buildExes&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609182529.1"><vh>&lt;&lt;check git branch matches command line option&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609182658.1"><vh>&lt;&lt;get productFamily and time to generate logging filename&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150609182831.1"><vh>&lt;&lt;check for product and version configuration JSON files&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610155655.1"><vh>&lt;&lt;get product configuration info&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610155754.1"><vh>&lt;&lt;handle selection of instrument types to build&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610155915.1"><vh>&lt;&lt;determine config repos needed&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610160202.1"><vh>&lt;&lt;deal with official vs non-official builds&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610160254.1"><vh>&lt;&lt;print summary and ask for confirmation&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610160638.1"><vh>&lt;&lt;start logger and write out summary&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610161008.1"><vh>&lt;&lt;handle opts.local&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610161157.1"><vh>&lt;&lt;handle opts.dryRun&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610161256.1"><vh>&lt;&lt;handle promotion of official release&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610161404.1"><vh>&lt;&lt;save version config file&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610161628.1"><vh>&lt;&lt;commit and push new verion number back to git if necessary&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610161655.1"><vh>&lt;&lt;clone repos required&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610161802.1"><vh>&lt;&lt;build executables&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610162024.1"><vh>&lt;&lt;clone bzr config repos&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610162228.1"><vh>&lt;&lt;config Git repositaries&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610162410.1"><vh>&lt;&lt;create Installers if required&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610162552.1"><vh>&lt;&lt;handle tagging of repository&gt;&gt;</vh></v>
<v t="stan@picarro-com.20150610163917.1"><vh>&lt;&lt;copy build and installers&gt;&gt;</vh></v>
</v>
<v t="stan@picarro-com.20150609175614.29"><vh>_generateReleaseVersion</vh></v>
<v t="stan@picarro-com.20150609175614.38"><vh>_verAsString</vh></v>
<v t="stan@picarro-com.20150609175614.39"><vh>_verAsNumString</vh></v>
<v t="stan@picarro-com.20150609175614.40"><vh>_verAsUINumString</vh></v>
</v>
<v t="stan@picarro-com.20150609175513.1"><vh>@clean src/main/python/Tools/Release/release.py</vh>
<v t="stan@picarro-com.20150609175614.1"><vh>release declarations</vh></v>
<v t="stan@picarro-com.20150609175614.2"><vh>class StdoutLogger</vh>
<v t="stan@picarro-com.20150609175614.3"><vh>__init__</vh></v>
<v t="stan@picarro-com.20150609175614.4"><vh>set_quiet</vh></v>
<v t="stan@picarro-com.20150609175614.5"><vh>write</vh></v>
<v t="stan@picarro-com.20150609175614.6"><vh>flush</vh></v>
<v t="stan@picarro-com.20150609175614.7"><vh>close</vh></v>
<v t="stan@picarro-com.20150609175614.8"><vh>__del__</vh></v>
</v>
<v t="stan@picarro-com.20150609175614.9"><vh>class StderrLogger</vh>
<v t="stan@picarro-com.20150609175614.10"><vh>__init__</vh></v>
<v t="stan@picarro-com.20150609175614.11"><vh>write</vh></v>
<v t="stan@picarro-com.20150609175614.12"><vh>flush</vh></v>
<v t="stan@picarro-com.20150609175614.13"><vh>close</vh></v>
<v t="stan@picarro-com.20150609175614.14"><vh>__del__</vh></v>
</v>
<v t="stan@picarro-com.20150609175614.15"><vh>class Logger</vh>
<v t="stan@picarro-com.20150609175614.16"><vh>__init__</vh></v>
<v t="stan@picarro-com.20150609175614.17"><vh>set_quiet</vh></v>
<v t="stan@picarro-com.20150609175614.18"><vh>__del__</vh></v>
</v>
<v t="stan@picarro-com.20150609175614.19"><vh>LogErr</vh></v>
<v t="stan@picarro-com.20150609175614.20"><vh>_buildDoneMsg</vh></v>
<v t="stan@picarro-com.20150609175614.21"><vh>_printSummary</vh></v>
<v t="stan@picarro-com.20150609175614.22"><vh>runCommand</vh></v>
<v t="stan@picarro-com.20150609175614.23"><vh>getGitBranch</vh></v>
<v t="stan@picarro-com.20150609175614.24"><vh>handleRemoveReadonly</vh></v>
<v t="stan@picarro-com.20150609175614.25"></v>
<v t="stan@picarro-com.20150609175614.26"><vh>_promoteStagedRelease</vh></v>
<v t="stan@picarro-com.20150609175614.27"><vh>_copyBuildAndInstallers</vh></v>
<v t="stan@picarro-com.20150609175614.28"><vh>_branchFromRepo</vh></v>
<v t="stan@picarro-com.20150609175614.29"></v>
<v t="stan@picarro-com.20150609175614.30"></v>
<v t="stan@picarro-com.20150609175614.31"><vh>_tagRepository</vh></v>
<v t="stan@picarro-com.20150609175614.32"><vh>_tagCommonConfig</vh></v>
<v t="stan@picarro-com.20150609175614.33"><vh>_tagAppInstrConfigs</vh></v>
<v t="stan@picarro-com.20150609175614.34"><vh>_makeLocalConfig</vh></v>
<v t="stan@picarro-com.20150609175614.35"><vh>_createGitConfigVersionFile</vh></v>
<v t="stan@picarro-com.20150609175614.36"><vh>_setGitConfigVer</vh></v>
<v t="stan@picarro-com.20150609175614.37"><vh>_compileInstallers</vh></v>
<v t="stan@picarro-com.20150609175614.38"></v>
<v t="stan@picarro-com.20150609175614.39"></v>
<v t="stan@picarro-com.20150609175614.40"></v>
<v t="stan@picarro-com.20150609175614.41"><vh>main</vh></v>
</v>
<v t="sze.20150528150419.1"><vh>Running py2exe on application in two directories</vh>
<v t="sze.20150528151615.1"><vh>setup.py</vh></v>
<v t="sze.20150528151728.1"><vh>App1/app1.py</vh></v>
<v t="sze.20150528151713.1"><vh>App2/app2.py</vh></v>
</v>
<v t="stan@picarro-com.20150531164144.1"><vh>Problems with py2exe when importing modules from the same directory</vh>
<v t="stan@picarro-com.20150531172203.1"><vh>@clean find_local_imports.py</vh></v>
</v>
<v t="stan@picarro-com.20150609133908.1"><vh>Learning doit</vh>
<v t="stan@picarro-com.20150609133916.1"><vh>@clean dodo.py</vh>
<v t="stan@picarro-com.20150622142233.1"><vh>_verAsNumString</vh></v>
<v t="stan@picarro-com.20150622142251.1"><vh>_verAsString</vh></v>
<v t="stan@picarro-com.20150622171115.1"><vh>_remove_python_version_files</vh></v>
<v t="stan@picarro-com.20150622174109.1"><vh>run_command</vh></v>
<v t="stan@picarro-com.20150622135659.1"><vh>task_make_sources_from_xml</vh></v>
<v t="stan@picarro-com.20150622135727.1"><vh>task_compile_fitutils</vh></v>
<v t="stan@picarro-com.20150622135802.1"><vh>task_compile_cluster_analyzer</vh></v>
<v t="stan@picarro-com.20150622135818.1"><vh>task_compile_swathP</vh></v>
<v t="stan@picarro-com.20150622135912.1"><vh>task_compile_fastLomb</vh></v>
<v t="stan@picarro-com.20150622135925.1"><vh>task_compile_sources</vh></v>
<v t="stan@picarro-com.20150622135949.1"><vh>task_build_hostexe</vh></v>
<v t="stan@picarro-com.20150622140041.1"><vh>task_make_release</vh></v>
</v>
<v t="stan@picarro-com.20150609134842.1"><vh>Using a python action</vh></v>
</v>
<v t="stan@picarro-com.20150621191519.1"><vh>Creating an official release with PyBuilder</vh></v>
<v t="stan@picarro-com.20150624094139.1"><vh>Running ISS installer</vh>
<v t="stan@picarro-com.20150624094645.1"><vh>@clean src\main\python\Tools\Release\g2000_win7.json</vh></v>
<v t="stan@picarro-com.20150624095237.1"><vh>Handling the g2000_win7.json file</vh>
<v t="stan@picarro-com.20150609182831.1"></v>
<v t="stan@picarro-com.20150610155754.1"></v>
<v t="stan@picarro-com.20150610155915.1"></v>
<v t="stan@picarro-com.20150610155655.1"></v>
<v t="stan@picarro-com.20150610160202.1"></v>
</v>
<v t="stan@picarro-com.20150609175614.37"></v>
<v t="stan@picarro-com.20150609175614.27"></v>
</v>
<v t="stan@picarro-com.20150624001144.1"><vh>Recovered Nodes</vh>
<v t="stan@picarro-com.20150624001144.2"><vh>Recovered node "_getBuildVersion" from PicarroExeSetup.py</vh>
<v t="stan@picarro-com.20150624001144.3"><vh>old:_getBuildVersion</vh></v>
<v t="stan@picarro-com.20150624001144.4"><vh>new:_getBuildVersion</vh></v>
</v>
<v t="stan@picarro-com.20150624001144.5"><vh>Recovered node "_getBuildType" from PicarroExeSetup.py</vh>
<v t="stan@picarro-com.20150624001144.6"><vh>old:_getBuildType</vh></v>
<v t="stan@picarro-com.20150624001144.7"><vh>new:_getBuildType</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="stan@picarro-com.20150529101713.1"></t>
<t tx="stan@picarro-com.20150529101736.1">http://doughellmann.com/2015/04/28/virtualenvwrapper-4-5-1-enhancements-to-virtualenv.html

pip install virtualenvwrapper-win

conemu.github.io for an Ansi console


rmvirtualenv # To remove 
set WORKON_HOME C:\temp

mkvirtualenv --system-site-packages host_build
call workon host_build
setprojectdir C:\GitHub\host-reorg
add2virtualenv C:\GitHub\host-reorg
cdproject
pip install pybuilder


call workon host_build
cdproject
add2virtualenv Host

</t>
<t tx="stan@picarro-com.20150529220127.1">@language python
@tabwidth -4
@others
</t>
<t tx="stan@picarro-com.20150529220127.2">from distutils.core import setup
import py2exe
import os
import sys

if __name__ == "__main__":
    # Get the current dir. Expect that we are in the Host folder.
    curDirPath = os.getcwd()
    curDir = os.path.split(curDirPath)[1]

    # Windows dirs are not case-sensitive. 
    # Logic will need to be changed slightly to support OSes that have case-sensitive directory names.
    if curDir.lower() != "host":
        print "Not running in expected folder 'Host'!"
        sys.exit(1)
    
    # Set the PYTHONPATH environment variable so the current folder tree is used to
    # pull local libraries from.
    parentDir = os.path.normpath(os.path.join(curDirPath, ".."))
    firmwareDir = os.path.normpath(os.path.join(curDirPath, "..", "Firmware"))
    
    # for a sanity check -- not needed in PYTHONPATH as the parent dir will already be there
    commonDir = os.path.join(parentDir, "Host", "Common")
    
    # folders must exist
    folders = [parentDir, commonDir, firmwareDir]
    for folder in folders:
        print "folder=", folder
        if not os.path.isdir(folder):
            print "Expected folder '%s' does not exist!", folder
            sys.exit(1)

    sys.path.insert(1,firmwareDir)
    sys.path.insert(1,parentDir)

    consoleList = [
        "Archiver/Archiver.py",
        "RDFrequencyConverter/RDFrequencyConverter.py",
        "SpectrumCollector/SpectrumCollector.py",
        "Driver/Driver.py",
        "EventManager/EventManager.py",
        "Supervisor/Supervisor.py",
    ]
    
    exclusionList = ["Tkconstants", "Tkinter", "tcl", '_gtkagg', '_tkagg', '_agg2', '_cairo', '_cocoaagg',
                    '_fltkagg', '_gtk', '_gtkcairo', ]

    inclusionList = ["encodings.*",
                     "tables.*"]

    dllexclusionList = ['libgdk-win32-2.0-0.dll', 'libgobject-2.0-0.dll', "mswsock.dll", "powrprof.dll" ]

    packageList = ["email"]
    
    setup(version = "0.0.1",
          description = "Sample applications",
          name = "Test Build",
          options = dict(py2exe = dict(compressed = 1,
                                       optimize = 1,
                                       # bundle_files = 1,
                                       excludes = exclusionList,
                                       includes = inclusionList,
                                       dll_excludes = dllexclusionList,
                                       packages = packageList)
                         ),
          # targets to build...
          console = consoleList,
          zipfile = "lib/share"
    )
</t>
<t tx="stan@picarro-com.20150529220159.1">@language python
@tabwidth -4
@others
# The manifest will be inserted as resource into test_wx.exe.  This
# gives the controls the Windows XP appearance (if run on XP ;-)
#
# Another option would be to store it in a file named
# test_wx.exe.manifest, and copy it with the data_files option into
# the dist-dir.
#

cDep = ""
if version[0] == 2 and version[1] &gt; 5:
    cDep = """
&lt;dependency&gt;
    &lt;dependentAssembly&gt;
        &lt;assemblyIdentity
            type="win32"
            name="Microsoft.VC90.CRT"
            version="9.0.21022.8"
            processorArchitecture="X86"
            publicKeyToken="1fc8b3b9a1e18e3b"
            language="*"
        /&gt;
    &lt;/dependentAssembly&gt;
&lt;/dependency&gt;
    """
manifest_template = '''
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt;
&lt;assemblyIdentity
  version="5.0.0.0"
  processorArchitecture="x86"
  name="%%(prog)s"
  type="win32"
/&gt;
&lt;description&gt;%%(prog)s Program&lt;/description&gt;
&lt;dependency&gt;
  &lt;dependentAssembly&gt;
    &lt;assemblyIdentity
      type="win32"
      name="Microsoft.Windows.Common-Controls"
      version="6.0.0.0"
      processorArchitecture="X86"
      publicKeyToken="6595b64144ccf1df"
      language="*"
    /&gt;
  &lt;/dependentAssembly&gt;
&lt;/dependency&gt;
%s
&lt;/assembly&gt;
''' % (cDep,)
RT_MANIFEST = 24
Controller = Target(description = "Controller", # used for the versioninfo resource
                    script = "Controller/Controller.py", # what to build
                    other_resources = [(RT_MANIFEST,
                                        1,
                                        manifest_template % dict(prog="Controller")
                                        )],
                    icon_resources = [(5, "Utilities/SupervisorLauncher/Picarro_icon.ico")],
                    dest_base = "Controller"
                    )

#ControllerBuildStation = Target(description = "ControllerBuildStation", # used for the versioninfo resource
#                    script = "ControllerBuildStation/ControllerBuildStation.py", # what to build
#                    other_resources = [(RT_MANIFEST,
#                                        1,
#                                        manifest_template % dict(prog="ControllerBuildStation")
#                                        )],
#                    ##    icon_resources = [(0, "icon.ico")],
#                    dest_base = "ControllerBuildStation"
#                    )

QuickGui = Target(description = "QuickGui", # used for the versioninfo resource
                    script = "QuickGui/QuickGui.py", # what to build
                    other_resources = [(RT_MANIFEST,
                                        1,
                                        manifest_template % dict(prog="QuickGui")
                                        )],
                    icon_resources = [(5, "Utilities/SupervisorLauncher/Picarro_icon.ico")],
                    dest_base = "QuickGui"
                    )

Fitter = Target(description = "Fitter", # used for the versioninfo resource
                    script = "Fitter/Fitter.py", # what to build
                    other_resources = [(RT_MANIFEST,
                                        1,
                                        manifest_template % dict(prog="Fitter")
                                        )],
                    icon_resources = [(5, "Utilities/SupervisorLauncher/Picarro_icon.ico")],
                    dest_base = "Fitter"
                    )

Coordinator = Target(description = "Coordinator", # used for the versioninfo resource
                    script = "Coordinator/Coordinator.py", # what to build
                    other_resources = [(RT_MANIFEST,
                                        1,
                                        manifest_template % dict(prog="Coordinator")
                                        )],
                    icon_resources = [(5, "Utilities/SupervisorLauncher/Picarro_icon.ico")],
                    dest_base = "Coordinator"
                    )

deltaCorrProcessor = Target(description = "DeltaCorrProcessor", # used for the versioninfo resource
                    script = "Coordinator/DeltaCorrProcessor.py", # what to build
                    other_resources = [(RT_MANIFEST,
                                        1,
                                        manifest_template % dict(prog="deltaCorrProcessor")
                                        )],
                    icon_resources = [(5, "Utilities/SupervisorLauncher/Picarro_icon.ico")],
                    dest_base = "DeltaCorrProcessor"
                    )

dilutionCorrProcessor = Target(description = "DilutionCorrProcessor", # used for the versioninfo resource
                    script = "Coordinator/DilutionCorrProcessor.py", # what to build
                    other_resources = [(RT_MANIFEST,
                                        1,
                                        manifest_template % dict(prog="dilutionCorrProcessor")
                                        )],
                    icon_resources = [(5, "Utilities/SupervisorLauncher/Picarro_icon.ico")],
                    dest_base = "DilutionCorrProcessor"
                    )

supervisorLauncher = Target(description = "SupervisorLauncher", # used for the versioninfo resource
                    script = "Utilities/SupervisorLauncher/SupervisorLauncher.py", # what to build
                    other_resources = [(RT_MANIFEST,
                                        1,
                                        manifest_template % dict(prog="supervisorLauncher")
                                        )],
                    icon_resources = [(5, "Utilities/SupervisorLauncher/Picarro_icon.ico")],
                    dest_base = "SupervisorLauncher"
                    )

# End of special controller setup stuff (except to use controller below)
################################################################

# simple check to save us from potential problems using paths in Picarro.pth
if "PYTHONPATH" not in os.environ:
    print "PYTHONPATH is not set in environment, potential exists for pulling local libs from wrong dir."
    print "Run 'python buildHost.py' instead to build Host apps from the command line."
    sys.exit(1)


pythonVer = _getPythonVersion()
pythonSubVer = _getPythonSubVersion()
osType = _getOsType()

versionNum, versionStr = _getBuildVersion()
buildTypeStr = _getBuildType()

# And now to the main setup routine...
#
# The following lists and tuples are common to both Python 2.5 and 2.7 builds. If any
# require customization, they must be moved and maintained separately under the if statements below.
exclusionList = ["Tkconstants", "Tkinter", "tcl", '_gtkagg', '_tkagg', '_agg2', '_cairo', '_cocoaagg',
                '_fltkagg', '_gtk', '_gtkcairo', ]

inclusionList = ["email",
                 "email.iterators",
                 "email.generator",
                 "email.mime.audio",
                 "email.mime.multipart",
                 "email.mime.image",
                 "email.mime.text",
                 "email.mime.base",
                 "scipy.interpolate",
                 "scipy.misc",
                 "sip",
                 "matplotlib.backends",
                 "matplotlib.backends.backend_wxagg",
                 "matplotlib.backends.backend_qt4agg",
                 "matplotlib.figure",
                 "pylab",
                 "numpy",
                 "configobj",
                 "encodings.*",
                 "tables.*"]

dllexclusionList = ['libgdk-win32-2.0-0.dll', 'libgobject-2.0-0.dll', "mswsock.dll", "powrprof.dll" ]

hex_images = glob.glob("../Firmware/CypressUSB/Drivers/*.*")
hex_images = hex_images + [ "../Firmware/CypressUSB/analyzer/analyzerUsb.hex",
                            "../Firmware/DSP/src/Debug/dspMain.hex",
                            "../Firmware/MyHDL/Spartan3/top_io_map.bit"]

cypressDriverDirs = ["amd64", "ia64", "license/libusb0", "x86"]

data_files = [(".", ["EventManager/Warning_16x16_32.ico",
                   "EventManager/Info_16x16_32.ico",
                   "EventManager/Critical_16x16_32.ico",
                   "QuickGui/LEDgreen.ico",
                   "QuickGui/LEDgreen2.ico",
                   "QuickGui/LEDoff.ico",
                   "QuickGui/LEDoff2.ico",
                   "QuickGui/LEDred2.ico",
                   "QuickGui/logo.png",
                   "Fitter/fitutils.pyd",
                   "Fitter/cluster_analyzer.pyd",
                   "Utilities/SupervisorLauncher/Check.png",
                   "Utilities/SupervisorLauncher/alarm.png",
                   "Utilities/SupervisorLauncher/Cancel.ico",
                   "Utilities/SupervisorLauncher/Controller_icon.ico",
                   "Utilities/SupervisorLauncher/Diagnostics_icon.ico",
                   "Utilities/SupervisorLauncher/EnviroSense.ico",
                   "Utilities/SupervisorLauncher/Integration_icon.ico",
                   "Utilities/SupervisorLauncher/Picarro_icon.ico",
                   "Utilities/SupervisorLauncher/Utilities_icon.ico",
                   "PeriphIntrf/Serial2Socket.exe",
                   #"../repoBzrVer.py",
                   ]),
            (r'mpl-data', glob.glob(r'C:\%s\Lib\site-packages\matplotlib\mpl-data\*.*' % pyDirname)),
            # Because matplotlibrc does not have an extension, glob does not find it (at least I think that's why)
            # So add it manually here:
            (r'mpl-data', [r'C:\%s\Lib\site-packages\matplotlib\mpl-data\matplotlibrc' % pyDirname]),
            (r'mpl-data\images',glob.glob(r'C:\%s\Lib\site-packages\matplotlib\mpl-data\images\*.*' % pyDirname)),
            (r'mpl-data\fonts',glob.glob(r'C:\%s\Lib\site-packages\matplotlib\mpl-data\fonts\*.*' % pyDirname)),
            ("Images", hex_images),
            ("static", glob.glob(r'Utilities\BackpackServer\static\*.*')),
            ("templates", glob.glob(r'Utilities\BackpackServer\templates\*.*'))
            ]
for d in cypressDriverDirs:
    data_files.append(("Images/%s"%d, glob.glob("../Firmware/CypressUSB/Drivers/" + "%s/*.*" %d)))

if osType == "winxp":
    data_files.append("../Vendor/inpout/winxp/inpout32.dll")
elif osType == "win7":
    data_files.append("../Vendor/inpout/win7/Win32/inpout32.dll")
else:
    print "Failed to include inpout32.dll in build, OS is not supported! (osType='%s')" % osType
    sys.exit(1)


consoleList = [
    "ActiveFileManager/ActiveFileManager.py",
    "RDFrequencyConverter/RDFrequencyConverter.py",
    "SpectrumCollector/SpectrumCollector.py",
    "ValveSequencer/ValveSequencer.py",
    "AlarmSystem/AlarmSystem.py",
    "Archiver/Archiver.py",
    "CommandInterface/CommandInterface.py",
    "Common/SchemeProcessor.py",
    "DataLogger/DataLogger.py",
    "DataManager/DataManager.py",
    "Driver/Driver.py",
    "ElectricalInterface/ElectricalInterface.py",
    "EventLogWatcher/EventLogWatcher.py",
    "EventManager/EventManager.py",
    "InstMgr/InstMgr.py",
    "FileEraser/FileEraser.py",
    "MeasSystem/MeasSystem.py",
    "SampleManager/SampleManager.py",
    "Supervisor/Supervisor.py",
    "ReadExtSensor/ReadExtSensor.py",
    "WebServer/server.py",
    "rdReprocessor/rdReprocessor.py",
    "SpectrumMaker/SpectrumMaker.py",
    "SpectrumMaker/SupervisorAnalyzer.py",
    "Utilities/RemoteAccess/RemoteAccess.py",
    "Utilities/IntegrationTool/IntegrationTool.py",
    "Utilities/IntegrationBackup/IntegrationBackup.py",
    "Utilities/FlowController/FlowController.py",
    "Utilities/Restart/ResetAnalyzer.py",
    "Utilities/Restart/RestoreStartup.py",
    "Utilities/Restart/RtcAlarmOff.py",
    "Utilities/ReadMemUsage/ReadMemUsage.py",
    "Utilities/BackpackServer/backpackServer.py",
    "Utilities/RestartSupervisor/RestartSupervisor.py",
    "Utilities/ProgramVariableGainRdd/programRdd.py",
    'Utilities/KillRestartSupervisor/KillRestartSupervisor.py',
    "MfgUtilities/CalibrateSystem.py",
    "MfgUtilities/CalibrateFsr.py",
    "MfgUtilities/AdjustWlmOffset.py",
    "MfgUtilities/ExamineRawRD.py",
    "MfgUtilities/ExamineRDCount.py",
    "MfgUtilities/LaserLockPrbs.py",
    "MfgUtilities/LaserPidPrbs.py",
    "MfgUtilities/MakeWarmBoxCalFile.py",
    "MfgUtilities/MakeWarmBoxCal_NoWlm.py",
    "MfgUtilities/MakeWlmFile1.py",
    "MfgUtilities/WriteLaserEeprom.py",
    "MfgUtilities/MakeNoWlmFile.py",
    "MfgUtilities/WriteWlmEeprom.py",
    "MfgUtilities/DumpEeproms.py",
    "MfgUtilities/MakeCalFromEeproms.py",
    "MfgUtilities/FindWlmOffset.py",
    "MfgUtilities/SaveData.py",
    "MfgUtilities/SaveRaw.py",
    "MfgUtilities/TestClient.py",
    "MfgUtilities/ThresholdStats.py",
    "MfgUtilities/CheckLaserCal.py",
    Fitter,
    "ConfigMonitor/ConfigMonitor.py",
    "PeriphIntrf/RunSerial2Socket.py",
    'LockWorkstation/LockWorkstation.py'
]

windowsList = [
    QuickGui, 
    Coordinator,
    Controller,
    deltaCorrProcessor, 
    dilutionCorrProcessor,
    "Common/StopSupervisor.py",
    "IPV/IPV.py",
    "IPV/IPVLicense.py",
    "Utilities/DiagDataCollector/DiagDataCollector.py",
    supervisorLauncher,
    "Utilities/SupervisorLauncher/HostStartup.py",
    "Utilities/CoordinatorLauncher/CoordinatorLauncher.py",
    "Utilities/FluxSwitcher/FluxScheduler.py",
    "Utilities/FluxSwitcher/FluxSwitcherGui.py",
    "Utilities/ValveDisplay/ValveDisplay.py",
    "Utilities/InstrEEPROMAccess/InstrEEPROMAccess.py",
    "Utilities/DataRecal/DataRecal.py",
    "Utilities/SetupTool/SetupTool.py",
    "Utilities/PicarroKML/PicarroKML.py",
    "Utilities/ReadGPSWS/ReadGPSWS.py",
    "Utilities/PeriphModeSwitcher/PeriphModeSwitcher.py",
    "Utilities/RecipeEditor/RecipeEditor.py",
    "Utilities/ConfigManager/ConfigManager.py",
    "Utilities/AircraftValveSwitcher/AircraftValveSwitcher.py",
]

# Generate git repo version file. Filename is a carryover from when we used
# bzr to archive our sources, is an import lib used in Driver.py for version info.
#verFilePath = os.path.normpath(os.path.join(os.path.dirname(__file__), '..', 'repoBzrVer.py'))
#branchName = _getGitBranch(os.path.dirname(os.getcwd()))

#ret = _createGitVersionPythonFile(verFilePath, buildTypeStr, branchName)

#if ret != 0:
#    print "Error creating git config file '%s'" % verFilePath
#    sys.exit(1)

"""
# old bzr method - incredibly it worked (somewhat) on git dirs
with open(os.path.join(os.path.dirname(__file__), '..',
                       'repoBzrVer.py'), 'w') as fp:
    subprocess.Popen(['bzr.exe', 'version-info', '--python'], stdout=fp).wait()
"""

# Generate internal build version
with open(os.path.join(os.path.dirname(__file__), 'Common',
                       'setup_version.py'), 'w') as fp:
    fp.writelines(
        ["# autogenerated by PicarroExeSetup.py, %s\n" % time.asctime(),
         "\n",
         "def versionString():\n",
         "    return '%s %s'\n" % (buildTypeStr, versionStr) ])


description = "Picarro CRDS %s" % versionStr

productName = "Picarro CRDS"
if buildTypeStr != "":
    productName = "Picarro CRDS (%s)" % buildTypeStr


if pythonVer == "2.5":
    # only packageList differs for Python 2.5 and 2.7
    packageList = ["simplejson", "werkzeug","flask","jinja2","email"]

    setup(version = versionNum,
      description = description,
      name = productName,
      options = dict(py2exe = dict(compressed = 1,
                                   optimize = 1,
                                   bundle_files = 1,
                                   excludes = exclusionList,
                                   includes = inclusionList,
                                   dll_excludes = dllexclusionList,
                                   packages = packageList)
                     ),
      # targets to build...
      console = consoleList,
      windows = windowsList,
      data_files = data_files
)

elif pythonVer == "2.7":
    import zmq
    os.environ["PATH"] += os.path.pathsep + os.path.split(zmq.__file__)[0]

    packageList = ["werkzeug","jinja2","email"]

    # no bundle_files, specify zipfile
    setup(version = versionNum,
          description = description,
          name = productName,
          options = dict(py2exe = dict(compressed = 1,
                                       optimize = 1,
                                       # bundle_files = 1,
                                       excludes = exclusionList,
                                       includes = inclusionList,
                                       dll_excludes = dllexclusionList,
                                       packages = packageList)
                         ),
          # targets to build...
          console = consoleList,
          windows = windowsList,
          data_files = data_files,
          zipfile = "lib/share"
    )

else:
    print "Unsupported Python version %s" % pythonVer
    sys.exit(1)
</t>
<t tx="stan@picarro-com.20150529220322.1">"""
Copyright 2006-2014 Picarro Inc.

A disutils script that uses py2exe to build Win32 executables for the
Host platform.

Bails if PYTHONPATH is unset, to ensure Picarro.pth is being overridden
so Picarro libs are pulled from the proper dir (primitive check, could
be smarter)

Usage: python PicarroExeSetup py2exe

Notes: Use python buildHost.py from the command line, which sets up
       the environment for this script.
#
# File History:
# 2013-10-30 sze  Remove bundle=1, and write files to lib subdirectory
# 2014-01-14 tw   Support builds in both Python 2.5 and 2.7 so can bring
#                 this file into older release branches. Primitive check
#                 for PYTHONPATH to help ensure local libs pulled from
#                 current tree.
"""

from __future__ import with_statement

from distutils.core import setup
import py2exe
import sys
import glob
import time
import subprocess
import os.path
import platform

from Host.Common import OS
from Host.Common import version as hostVersion

version = sys.version_info
pyDirname = "Python%d%d" % (version[0],version[1])

sys.stderr = sys.stdout

</t>
<t tx="stan@picarro-com.20150529220322.10">def _getTimeIso8601Str(t):
    """
    Build a string for time in ISO 8601 format. Unfortunately none of the Python libs do this
    so requires a little work.

    Result looks like this: 2014-04-21 14:12:09 -0700

    Arguments:
                t    seconds past the epoch, UTC (returned by time.time())
    """
    if time.localtime(t).tm_isdst == 1:
        # currently in Daylight Savings Time
        # negate time as return val is seconds west of GMT
        tdiff = -time.altzone
    else:
        # Standard Time
        tdiff = -time.timezone

    # compute time difference from UTC in HHMM (e.g. -0700 for PDT)
    hr = tdiff / (3600)
    minutes = (tdiff - (hr * 3600)) / 60
    strDiff = "%+03d%02d" % (hr, minutes)

    timeStr = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(t))
    return timeStr + " " + strDiff


</t>
<t tx="stan@picarro-com.20150529220322.11">def _getTimeStr(t):
    #
    return time.strftime("%Y-%m-%d %H:%M:%S %Z", time.localtime(t))


</t>
<t tx="stan@picarro-com.20150529220322.12">def _createGitVersionPythonFile(filepath, buildTypeStr, branchName):
    # get git log info to be stored in version.ini
    #
    # revno is short SHA1 value
    revno, stdout_value = runCommand("git.exe log -1 --pretty=format:%h")

    if stdout_value is not None:
        print "Error '%s' getting revno" % stdout_value
        return 1

    # last modify date
    lastModDate, stdout_value = runCommand("git.exe log -1 --pretty=format:%ai")

    if stdout_value is not None:
        print "Error '%s' getting lastModDate" % stdout_value
        return 1

    # build a revision_id string so it is a similar format to the bzr output
    #
    #   last modify date, UNIX timestamp
    tval, stdout_value = runCommand("git.exe log -1 --pretty=format:%at")
    #print "UNIX timestamp tval=", tval

    if stdout_value is not None:
        print "Error '%s' getting tval" % stdout_value
        return 1

    #   convert to YYYYMMDDHHMMSS string
    tm = time.gmtime(float(tval))
    #print "tm=", tm

    tmStr = time.strftime("%Y%m%d%H%M%S", tm)

    #   last mod author email
    emailStr, stdout_value = runCommand("git.exe log -1 --pretty=format:%ae")

    if stdout_value is not None:
        print "Error '%s' getting emailStr" % stdout_value
        return 1

    #  full SHA1
    idStr, stdout_value = runCommand("git.exe log -1 --pretty=format:%H")

    if stdout_value is not None:
        print "Error '%s' getting idStr (SHA1)" % stdout_value
        return 1

    revision_id = emailStr + "-" + tmStr + "-" + idStr

    # write the version.ini file
    with open(filepath, 'w') as fp:
        curTime = time.time()

        # build time string, with timezone offset from GMT in HHMM
        buildTimeStr = _getTimeIso8601Str(curTime)

        # build time string, with timezone name text
        #buildTimeStr = _getTimeStr(curTime)

        fp.writelines(
            ["# autogenerated by PicarroExeSetup.py, %s\n" % time.asctime(time.localtime(curTime)),
             "\n",
             "version_info = {'branch_nick': '%s',\n" % branchName,
             " 'build_date': '%s',\n" % buildTimeStr,
             " 'clean': None,\n",
             " 'date': '%s',\n" % lastModDate,
             " 'revision_id': '%s',\n" % revision_id,
             " 'revno': '%s'}\n" % revno,
             "\n",
             "revisions = {}\n",
             "\n",
             "file_revisions = {}\n",
             "\n",
             "if __name__ == '__main__':\n",
             "    print 'revision: %(revno)s' % version_info\n",
             "    print 'nick: %(branch_nick)s' % version_info\n",
             "    print 'revision id: %(revision_id)s' % version_info\n\n"
             ])

    # return with no errors
    return 0


</t>
<t tx="stan@picarro-com.20150529220322.13">################################################################
# Start of a pile of special setup with the sole purpose
# of making the wxPython apps look like Windows-native
#
class Target:
    @others
</t>
<t tx="stan@picarro-com.20150529220322.14">def __init__(self, **kw):
    self.__dict__.update(kw)
</t>
<t tx="stan@picarro-com.20150529220322.2">def _getPythonVersion():
    """
    Returns a string such as "2.5" or 2.7"
    """
    pythonVer = sys.version_info
    return str(pythonVer[0]) + "." + str(pythonVer[1])


</t>
<t tx="stan@picarro-com.20150529220322.3">def _getPythonSubVersion():
    """
    Returns a string such as "2.7.3"
    """
    pythonVer = sys.version_info
    return str(pythonVer[0]) + "." + str(pythonVer[1]) + "." + str(pythonVer[2])


</t>
<t tx="stan@picarro-com.20150529220322.4">def _getOsType():
    osType = platform.uname()[2]

    if osType == '7':
        osType = 'win7'
    elif osType == 'XP':
        osType = 'winxp'
    else:
        osType = 'unknown'
        print "Unexpected OS type!"

    return osType


</t>
<t tx="stan@picarro-com.20150529220322.5">def _runBatFile(batComponent, batFilename, batDir):
    """
    Runs a Windows .bat file to build a component. Arguments:
      batComponent   name of component being built (e.g., fitutils.pyd)
      batFilename    Windows .bat filename to execute
      batDir         folder containing the .bat file (can be relative to current dir)
    """
    print "building %s using %s" % (batComponent, batFilename)

    # this saves off current folder and restores it when done
    with OS.chdir(batDir):
        if not os.path.isfile(batFilename):
            print "Batch file '%s' does not exist in folder '%s'!" % (batFilename, batDir)
            sys.exit(1)

        retCode = subprocess.Popen([batFilename]).wait()

        if retCode != 0:
            print "Error building %s, retCode=%d, batFilename=%s" % (batComponent, retCode, batFilename)
            sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150529220322.6">def _getBuildVersion():
    try:
        # First look for release_version which is generated by
        # release.py
        from Host.Common import release_version as buildVersion
        versionNum = buildVersion.versionNumString()
        versionStr = buildVersion.versionString()
        print "Release version: %s" % versionStr
    except Exception, e:
        # Next try build_version which is generated by
        # buildHost.py (command line script for internal builds)
        try:
            from Host import build_version as buildVersion
            versionNum = buildVersion.versionNumString()
            versionStr = buildVersion.versionString()
            print "Setup version: %s" % versionStr
        except Exception, e:
            # use default
            versionNum = "0.0.0.0"
            versionStr = "0.0.0.0 (unknown)"
            print "Release or setup version not found, using: %s" % versionStr

    return versionNum, versionStr


</t>
<t tx="stan@picarro-com.20150529220322.7">def _getBuildType():
    try:
        # First look for release_version which is generated by
        # release.py
        from Host.Common import release_version as buildVersion
        buildTypeStr = buildVersion.buildType()
        print "Release build type: %s" % buildTypeStr
    except Exception, e:
        try:
            # Not found, try setup_version (generated by buildHost.py
            # during internal builds)
            from Host import build_version as buildVersion
            buildTypeStr = buildVersion.buildType()
            #print "Setup build type: %s" % buildTypeStr

            # Internal build, includes last git check-in SHA1
            # returns "Internal (&lt;SHA1&gt;)"
            print "Setup build type: %s" % buildTypeStr

        except Exception, e:
            # Should never get here...
            buildTypeStr = "DEVELOPMENT"
            print "Release or setup version build type not found, using: %s" % buildTypeStr

    return buildTypeStr


</t>
<t tx="stan@picarro-com.20150529220322.8">def runCommand(command):
    """
    Run a command line command so we can capture its output.
    """
    #print "runCommand: '%s'" % command
    p = subprocess.Popen(command,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)

    stdout_value, stderr_value = p.communicate()
    # print "stdout:", repr(stdout_value)
    return stdout_value, stderr_value


</t>
<t tx="stan@picarro-com.20150529220322.9">def _getGitBranch(gitDir):
    """
    Get the git branch that the gitDir is currently set to.
    """
    #print "gitDir=%s" % gitDir

    curBranch = ""

    if not os.path.isdir(gitDir):
        print "'%s' is not a directory!" % gitDir
        return curBranch

    # save off the current dir so we can get back to it when we're done
    saveDir = os.getcwd()

    # change to the git dir
    #print "cd to '%s'" % gitDir
    os.chdir(gitDir)
    #print "current dir is now '%s'" % os.getcwd()

    # run "git branch" and parse stdout for it -- the current branch name begins with a "* "
    command = "git branch"
    stdout_value, stderr_value = runCommand(command)

    branches = stdout_value.splitlines()
    for branch in branches:
        #print branch
        if branch[0] == "*" and branch[1] == " ":
            curBranch = branch[2:].rstrip("\r\n")
            #print "curBranch='%s'" % curBranch
            break

    #print "currentDir='%s'" % os.getcwd()

    # reset to the original dir
    os.chdir(saveDir)

    return curBranch


</t>
<t tx="stan@picarro-com.20150531164144.1">A problem arises when an import is made from a file in the same directory. Suppose that in the directory App1 we have the following files.

**&lt;mod1.py&gt;**
VERSION = "1.2.3"

**&lt;main.py&gt;**
import mod1

print mod1.VERSION

Then if we run main.py, it will correctly find mod1 and import the module. However, if we use py2exe and turn App1/main.py into main.exe, this will not be able to import mod1, since mod1 is not on the python path during the compilation. This is why we have in the past had to append App1 to the python path in setup.py.
i
It is preferable to change main.py so that it makes an absolute import of the form

import App1.mod1 as mod1

and to ensure that there is an __init.py__ in the folder.

This problem will arise especially with GUI applications using wxGlade where the autogenerated Python GUI file is imported and subclassed, unless the absolute path to this GUI file is specified.

We need to write a utility that finds all imports of files in the local directory. These may be of the form

import mod1 -&gt; import App1.mod1 as mod1
from mod1.xxx.yyy import zzz -&gt; from App1.mod1.xxx.yyy import zzz




</t>
<t tx="stan@picarro-com.20150531172203.1">import glob
import os
import re
import shutil
import sys

re1 = re.compile("(import\s+((\w*)(\.\w*)*)(\s+(as\s+\w*))?)")
re2 = re.compile("(from\s+((\w*)(\.\w*)*))\s+import\s+(.*)")
def analyze_local(filename, mod_names, pkg_path):
    init = True
    dir_name = os.path.dirname(filename)
    result = []    
    with file(filename,"r") as fp:
        for ln, line in enumerate(fp):
            match1 = re1.search(line)
            match2 = re2.search(line)
            if match2:
                if match2.group(3) in mod_names:
                    if init:
                        print filename
                        init = False
                    print "  %4d: %s" % (ln+1, line.rstrip())
                    new_line = line.replace(match2.group(1), match2.group(1).replace(match2.group(2),pkg_path + "." + match2.group(2)))
                    result.append("%s" % new_line.rstrip())
                else:
                    result.append("%s" % line.rstrip())
            elif match1:
                if match1.group(3) in mod_names:
                    if init:
                        print filename
                        init = False
                    print "  %4d: %s" % (ln+1, line.rstrip())
                    if match1.group(6): # as clause present
                        new_line = line.replace(match1.group(1), match1.group(1).replace(match1.group(2),pkg_path + "." + match1.group(2)))
                    else: 
                        new_line = line.replace(match1.group(1), match1.group(1).replace(match1.group(2),pkg_path + "." + match1.group(2)) 
                                                + " as " + match1.group(2))
                    result.append("%s" % new_line.rstrip())
                else:
                    result.append("%s" % line.rstrip())
            else:
                result.append("%s" % line.rstrip())
    return "\n".join(result)

                    
                    
if __name__ == "__main__":
    for root, dirs,files in os.walk(r'src\Host'):
        py_files = glob.glob(os.path.join(root,"*.py"))
        mod_names = [os.path.split(fname)[-1][:-3] for fname in py_files]
        pkg_path = ".".join(root.split(os.path.sep)[1:])
        for name in files:
            if name.endswith('py'):
                py_file = os.path.join(root, name)                
                with file("temp.py", "w") as fp:
                    fp.write(analyze_local(py_file, mod_names, pkg_path))
                shutil.copyfile("temp.py", py_file)
</t>
<t tx="stan@picarro-com.20150609110503.1">@language python
@tabwidth -4
@others
if __name__ == "__main__":
    main()
</t>
<t tx="stan@picarro-com.20150609110523.1"># buildHost.py
#
# Set up the build environment and build Host components. Use this
# for building Host from the command line.
#
# This executes python PicarroExeSetup.py py2exe and ensures PYTHONPATH is properly
# set to pull local libs from its own folder tree instead of what is
# in Picarro.pth.
#
# This script can be run from a cmd window. PicarroExeSetup.py should NOT be run
# from a cmd window unless PYTHONPATH or Picarro.pth is pointing to this tree.
# Otherwise, there is the risk of pulling Picarro libs from the wrong folder
# into the build.

import os
import sys
import subprocess
import textwrap
import time
import platform

from optparse import OptionParser


try:
    import simplejson as json
except ImportError:
    import json

versionConfig = "version.json"

VERSION = {}


</t>
<t tx="stan@picarro-com.20150609110523.2">def _getOsType():
    """ Returns 'win7', 'winxp' or 'unknown'. """
    
    osType = platform.uname()[2]

    if osType == '7':
        osType = 'win7'
    elif osType == 'XP':
        osType = 'winxp'
    else:
        osType = 'unknown'
        print "Unexpected OS type!"
        sys.exit(1)

    return osType
    
</t>
<t tx="stan@picarro-com.20150609110523.3">def _generateBuildVersion(product, osType, ver):
    """
    Create a file ('build_version.py') containing the version metadata used 
    for building the executables
    """
    
    contents = textwrap.dedent("""\
    # autogenerated by buildHost.py, %s
    
    def versionString():
        return '%s'
    
    def versionNumString():
        return '%s'
    
    def buildType():
        return 'INTERNAL'
    """)
        
    with open('build_version.py', 'w') as fp:
        fp.write(contents % (
            time.asctime(),
            _verAsString(product, ver, osType),
            _verAsNumString(ver)
        ))
</t>
<t tx="stan@picarro-com.20150609110523.4">def _verAsString(product, ver, osType=None):
    """
    Convert a version dict into a human-readable string.
    """

    number = _verAsNumString(ver)

    if osType is not None:
        return "%s-%s-%s" % (product, osType, number)
    else:
        return "%s-%s" % (product, number)


</t>
<t tx="stan@picarro-com.20150609110523.5">def _verAsNumString(ver):
    """
    Convert a version dict into a string of numbers in this format:
        &lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;.&lt;build&gt;
    """
    number = "%(major)s.%(minor)s.%(revision)s.%(build)s" % ver
    return number




</t>
<t tx="stan@picarro-com.20150609110523.6">def buildExes():
    # Get the current dir. Expect that we are in the Host folder.
    curDirPath = os.getcwd()
    curDir = os.path.split(curDirPath)[1]

    # Windows dirs are not case-sensitive.
    # Logic will need to be changed slightly to support OSes that have case-sensitive directory names.
    if curDir.lower() != "host":
        print "Not running in expected folder 'Host'!"
        sys.exit(1)

    # Set the PYTHONPATH environment variable so the current folder tree is used to
    # pull local libraries from.
    parentDir = os.path.normpath(os.path.join(curDirPath, ".."))
    firmwareDir = os.path.normpath(os.path.join(curDirPath, "..", "Firmware"))

    # for a sanity check -- not needed in PYTHONPATH as the parent dir will already be there
    commonDir = os.path.join(parentDir, "Host", "Common")

    # folders must exist
    folders = [parentDir, commonDir, firmwareDir]
    for folder in folders:
        print "folder=", folder
        if not os.path.isdir(folder):
            print "Expected folder '%s' does not exist!", folder
            sys.exit(1)

    buildEnv = dict(os.environ)
    buildEnv.update({'PYTHONPATH' : "%s;%s" %(parentDir, firmwareDir)})

    # run "python PicarroExeSetup.py py2exe"
    retCode = subprocess.call(['python.exe', 'PicarroExeSetup.py', 'py2exe'], env=buildEnv)

    if retCode != 0:
            print "Error building Host. retCode=%d" % retCode
            sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609110523.7">def main():
    usage = """
%prog [options]

Builds a local HostExe.
"""

    parser = OptionParser(usage=usage)

    # default is g2000, so fetch version number from g2000_version.json
    parser.add_option('--product', dest='product', metavar='PRODUCT',
                      default='g2000',
                      help=('The product to use the JSON version number from '
                            'for an internal build. Default is "g2000".'))

    options, _ = parser.parse_args()

    versionConfig = options.product + "_version.json"

    # folder containing version file
    versionConfig = os.path.normpath(os.path.join(os.getcwd(), "..", "Tools", "Release", versionConfig))

    # construct json filename from the product
    # get version from the json file
    with open(versionConfig, 'r') as ver:
            VERSION.update(json.load(ver))

    # use the OS type to construct a product name for the version
    # this script is for internal builds only so tacking on
    # 'internal' in the product name
    osType = _getOsType()
    product = "%s-INTERNAL" % options.product

    if not os.path.exists('build_version.py'):
        _generateBuildVersion(product, osType, VERSION)

    # build the executables
    buildExes()


</t>
<t tx="stan@picarro-com.20150609133908.1"></t>
<t tx="stan@picarro-com.20150609133916.1">import json
import os
import pprint
import subprocess
import sys
import textwrap
import time
from doit.tools import check_timestamp_unchanged

RELEASE_VERSION_FILE = ('src', 'main', 'python', 'Host', 'Common', 'release_version.py')
INTERNAL_VERSION_FILE = ('src', 'main', 'python', 'Host', 'build_version.py')


@others
</t>
<t tx="stan@picarro-com.20150609134842.1">def task_hello():
    def python_hello(times, text, targets):
        with open(targets[0],"a") as output:
            output.write(times * text)
    
    return {
        'actions' : [(python_hello, [3, "py!\n"])],
        'targets' : ["hello.txt"]
    }
</t>
<t tx="stan@picarro-com.20150609175513.1">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    main()
</t>
<t tx="stan@picarro-com.20150609175614.1">"""
Copyright 2012-2013 Picarro Inc.

Replacement for makeExe.bat.
"""

from __future__ import with_statement

import os
import sys
import shutil
import subprocess
#import pprint
import re
import time
import os.path
import stat
import platform
import errno

from distutils import dir_util
from optparse import OptionParser

#pylint: disable=F0401
try:
    import simplejson as json
except ImportError:
    import json
#pylint: enable=F0401

from Host.Common import OS


# Pull these out into a configuration file.
SANDBOX_DIR = 'c:/temp/sandbox'

REPO_BASE = 'https://github.com/picarro/host.git'

ISCC = 'c:/program files/Inno Setup 5/ISCC.exe'
ISCC_WIN7 = 'c:/program files (x86)/Inno Setup 5/ISCC.exe'
INSTALLER_SCRIPTS_DIR = 'InstallerScripts'

RESOURCE_DIR = ('s:/CRDS/SoftwareReleases/G2000Projects/G2000_PrepareInstaller/'
                'Resources')

CONFIGS = {}
INSTALLER_SIGNATURES = {}
CONFIG_REPOS = {}

CONFIG_BASE = 's:/CrdsRepositoryNew/trunk/G2000/Config'
COMMON_CONFIG = os.path.join(CONFIG_BASE, 'CommonConfig')

VERSION = {}
VERSION_TEMPLATE = ("[Version]\\nrevno = {revno}\\ndate = {date}\\n"
                    "revision_id = {revision_id}")

# Where Manufacturing looks for installers and
# HostExe/AnalyzerServerExe upgrades.
#MFG_DISTRIB_BASE = 'r:/G2000_HostSoftwareInstallers'
DISTRIB_BASE = 's:/CRDS/CRD Engineering/Software/G2000/Installer'

# For dry-run testing
#TEST_MFG_DISTRIB_BASE = 'c:/temp/tools/release/mfg_distrib_base'
#TEST_DISTRIB_BASE = 'c:/temp/tools/release/distrib_base'

# Where new releases are put for testing.
#STAGING_MFG_DISTRIB_BASE = 'r:/G2000_HostSoftwareInstallers_Staging'
STAGING_DISTRIB_BASE = 's:/CRDS/CRD Engineering/Software/G2000/Installer_Staging'


</t>
<t tx="stan@picarro-com.20150609175614.10">def __init__(self, f):
    self.stderr = sys.stderr
    self.log = f
    sys.stderr = self

</t>
<t tx="stan@picarro-com.20150609175614.11">def write(self, message):
    self.stderr.write(message)
    self.log.write(message)
    
</t>
<t tx="stan@picarro-com.20150609175614.12">def flush(self):
    self.log.flush()
    self.stderr.flush()

</t>
<t tx="stan@picarro-com.20150609175614.13">def close(self):
    #print "StderrLogger::close()"
    #print "   self.stderr=", self.stderr

    if self.stderr is not None:
        sys.stderr = self.stderr
        self.stderr = None

</t>
<t tx="stan@picarro-com.20150609175614.14">def __del__(self):
    pass
    #print "StderrLogger::__del__()"
    #self.close()


</t>
<t tx="stan@picarro-com.20150609175614.15">class Logger(object):
    @others
</t>
<t tx="stan@picarro-com.20150609175614.16">def __init__(self, filename, quiet=False):
    self.log = open(filename, "w")
    self.stdoutLogger = StdoutLogger(self.log, quiet)
    self.stderrLogger = StderrLogger(self.log)

</t>
<t tx="stan@picarro-com.20150609175614.17">def set_quiet(self, quiet):
    if self.stdoutLogger is not None:
        self.stdoutLogger.set_quiet(quiet)

</t>
<t tx="stan@picarro-com.20150609175614.18">def __del__(self):
    if self.log is not None:
        self.log.close()
        self.log = None


</t>
<t tx="stan@picarro-com.20150609175614.19">def LogErr(message):
    sys.stderr.write(message)
    sys.stderr.write("\n")


</t>
<t tx="stan@picarro-com.20150609175614.2"># for logging stdout and stderr to a log file
class StdoutLogger(object):
    @others
</t>
<t tx="stan@picarro-com.20150609175614.20">def _buildDoneMsg(message, startSec, logfile):
    """
    Output the ending time, elapsed time, and a build completed message
    """
    print "Build script end: %s" % time.strftime("%Y/%m/%d %H:%M:%S %p", time.localtime())

    if startSec is not None:
        # we don't really care about fractional seconds
        elapsed = int(time.time() - startSec)

        hours = elapsed / 3600
        seconds = elapsed % 3600
        minutes = seconds / 60
        seconds = seconds % 60

        print "Elapsed time: %d hours, %d min, %d sec" % (hours, minutes, seconds)

    if logfile is not None:
        print ""
        print "logfile           =", logfile
        print ""

    print "******** %s COMPLETE ********" % message


</t>
<t tx="stan@picarro-com.20150609175614.21">def _printSummary(opts, osType, logfile, productFamily, productConfigs, versionConfig,
                  cloneAllRepos=True,
                  cloneConfigRepo=True,
                  bzrConfigsNeeded=True,
                  cloneHostRepo=True):
    print ""
    print "product           =", opts.product
    print "branch            =", opts.branch
    print "OS type           =", osType
    print "productFamily     =", productFamily
    print "productConfigs    =", productConfigs
    print "versionConfig     =", versionConfig

    if not opts.makeOfficial:
        print "version           = %s.%s.%s.%s" % (VERSION['major'], VERSION['minor'], VERSION['revision'], VERSION['build'])

        if opts.createTag:
            print "create tags       =", "YES"
        else:
            print "create tags       =", "NO"

        if opts.createInstallers:
            print "create installers =", "YES"
        else:
            print "create installers =", "NO"

        tmpConfigs = []
        for c in CONFIGS:
            tmpConfigs.append(c)
        tmpConfigs.sort()

        fFirst = True
        for c in tmpConfigs:
            if fFirst is True:
                print "configs           = %-6s  repo = %s" % (c, CONFIG_REPOS[c])
                fFirst = False
            else:
                print "                    %-6s  repo = %s" % (c, CONFIG_REPOS[c])

        if opts.local:
            print ""
            print "local build       =", "YES"

            if cloneAllRepos:
                print "clone all repos   =", "YES"
            else:
                print "clone all repos   =", "NO"

            if cloneHostRepo:
                print "  clone host repo (git)    =", "YES"
            else:
                print "  clone host repo (git)    =", "NO"

            if cloneConfigRepo:
                if bzrConfigsNeeded is True:
                    print "  clone config repos (bzr) =", "YES"
                else:
                    # will override cloning bzr since not needed
                    print "  clone config repos (bzr) =", "NO (not used)"
            else:
                print "  clone config repos (bzr) =", "NO"

            if opts.buildExes:
                print "build exes        =", "YES"
            else:
                print "build exes        =", "NO"

        else:
            print ""
            print "local build       =", "NO"

        #print "  MFG_DISTRIB_BASE         =", MFG_DISTRIB_BASE
        print "  DISTRIB_BASE             =", DISTRIB_BASE
        #print "  STAGING_MFG_DISTRIB_BASE =", STAGING_MFG_DISTRIB_BASE
        print "  STAGING_DISTRIB_BASE     =", STAGING_DISTRIB_BASE
        print ""

        # Note: local and dryRun cannot be used together, already bailed above if they were
        if opts.dryRun:
            print "dry run           =", "YES"
            #print "  targetMfgDistribBase =", TEST_MFG_DISTRIB_BASE
            #print "  targetDistribBase    =", TEST_DISTRIB_BASE
        else:
            print "dry run           =", "NO"
            #print "  targetMfgDistribBase =", MFG_DISTRIB_BASE
            print "  targetDistribBase    =", DISTRIB_BASE

    else:
        # no version for promoting to release, it picks up whatever installer versions
        # are in the staging area and copies them to the release area
        print ""
        print "make-official     =", "YES"

        if opts.local:
            print "local build       =", "YES"
        else:
            print "local build       =", "NO"

        if opts.archiveOnly:
            print "archive only      =", "YES"
        else:
            print "archive only      =", "NO"

        if opts.buildTypes is None:
            print "build types       = all"
        else:
            print "build types       =", opts.buildTypes

        tmpConfigs = []
        for c in CONFIGS:
            tmpConfigs.append(c)
        tmpConfigs.sort()

        print "configs           =", tmpConfigs[0]
        for c in tmpConfigs[1:]:
            print "                   ", c

        print "  STAGING_DISTRIB_BASE     =", STAGING_DISTRIB_BASE
        print "   DISTRIB_BASE            =", DISTRIB_BASE

    print ""
    print "logfile           =", logfile


</t>
<t tx="stan@picarro-com.20150609175614.22">def runCommand(command):
    """
    Run a command line command so we can capture its output.
    """
    #print "runCommand: '%s'" % command
    p = subprocess.Popen(command,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)

    stdout_value, stderr_value = p.communicate()
    # print "stdout:", repr(stdout_value)
    return stdout_value, stderr_value


</t>
<t tx="stan@picarro-com.20150609175614.23">def getGitBranch(gitDir):
    """
    Get the git branch that the gitDir is currently set to.
    """
    #print "gitDir=%s" % gitDir

    curBranch = ""

    if not os.path.isdir(gitDir):
        LogErr("'%s' is not a directory!" % gitDir)
        return curBranch

    # save off the current dir so we can get back to it when we're done
    saveDir = os.getcwd()

    # change to the git dir
    #print "cd to '%s'" % gitDir
    os.chdir(gitDir)
    #print "current dir is now '%s'" % os.getcwd()

    # run "git branch" and parse stdout for it -- the current branch name begins with a "* "
    command = "git branch"
    stdout_value, stderr_value = runCommand(command)

    branches = stdout_value.splitlines()
    for branch in branches:
        #print branch
        if branch[0] == "*" and branch[1] == " ":
            curBranch = branch[2:].rstrip("\r\n")
            #print "curBranch='%s'" % curBranch
            break

    #print "currentDir='%s'" % os.getcwd()

    # reset to the original dir
    os.chdir(saveDir)

    return curBranch


</t>
<t tx="stan@picarro-com.20150609175614.24">def handleRemoveReadonly(func, path, exc):
    """
    Error handler for shutil.rmtree().

    If the error is due to an access error (read-only file),
    it attempts to add write permission and then retries.

    If the error is for another reason it re-raises the error.

    Reference: http://stackoverflow.com/questions/1213706/what-user-do-python-scripts-run-as-in-windows/1214935#1214935

    On Unix, will also need to ensure the parent dir is writeable, see the above web page.

    Usage : shutil.rmtree(path, ignore_errors=False, onerror=handleRemoveReadonly)
    """
    excvalue = exc[1]

    if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:
        print "File '%s' is read-only, making it writeable so it can be deleted." % path
        os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO) # 0777
        func(path)
    else:
        # some other error, bubble it up
        print "handleRemoveReadonly: path=%s  errno=%s" % (path, str(excvalue.errno))
        raise


</t>
<t tx="stan@picarro-com.20150609175614.25">###############################################################################

def makeExe(opts):
    """
    Make a HostExe release from a clean checkout.
    """
    &lt;&lt;get osType&gt;&gt;
    # -------- validate some of the arguments --------
    &lt;&lt;validate opts.product&gt;&gt;
    &lt;&lt;validate opts.osType (only valid with --make-official)&gt;&gt;
    &lt;&lt;validate opts.archiveOnly&gt;&gt;
    &lt;&lt;warn about deprecated opts.dryRun&gt;&gt;
    &lt;&lt;handle skip cloning options&gt;&gt;
    &lt;&lt;validate opts.buildExes&gt;&gt;
    &lt;&lt;check git branch matches command line option&gt;&gt;
    &lt;&lt;get productFamily and time to generate logging filename&gt;&gt;
    
    # -------- validate JSON files --------
    &lt;&lt;check for product and version configuration JSON files&gt;&gt;
    &lt;&lt;get product configuration info&gt;&gt;
    &lt;&lt;handle selection of instrument types to build&gt;&gt;
    &lt;&lt;determine config repos needed&gt;&gt;
    # -------- prepare build options --------
    &lt;&lt;deal with official vs non-official builds&gt;&gt;
    &lt;&lt;print summary and ask for confirmation&gt;&gt;
    # -------- start of build --------
    &lt;&lt;start logger and write out summary&gt;&gt;
    &lt;&lt;handle opts.local&gt;&gt;
    &lt;&lt;handle opts.dryRun&gt;&gt;
    &lt;&lt;handle promotion of official release&gt;&gt;
    &lt;&lt;save version config file&gt;&gt;
    &lt;&lt;commit and push new verion number back to git if necessary&gt;&gt;
    &lt;&lt;clone repos required&gt;&gt;
    _generateReleaseVersion(productFamily, VERSION)

    &lt;&lt;build executables&gt;&gt;
    &lt;&lt;clone bzr config repos&gt;&gt;
    &lt;&lt;config Git repositaries&gt;&gt;
    &lt;&lt;create Installers if required&gt;&gt;
    &lt;&lt;handle tagging of repository&gt;&gt;
    &lt;&lt;copy build and installers&gt;&gt;
    _buildDoneMsg("BUILD", startSec, logfile)


</t>
<t tx="stan@picarro-com.20150609175614.26">def _promoteStagedRelease(types=None,
                          #mfgDistribBase=None,
                          distribBase=None,
                          versionConfig=None,
                          product=None,
                          osType=None,
                          archiveOnly=False):
    """
    Move the existing staged release to an official directory.
    CONFIGS already contains the types to promote.
    """

    # build a sorted list to handle alphabetically
    configTypes = []
    for c in CONFIGS:
        configTypes.append(c)
    configTypes.sort()

    """
    print "_promoteStagedRelease:"
    print "  types=", types
    #print "  mfgDistribBase=", mfgDistribBase
    print "  distribBase=", distribBase
    print "  versionConfig=", versionConfig
    print "  product=", product
    print "  osType=", osType
    print ""
    print "CONFIGS=", CONFIGS
    print "configTypes=", configTypes
    print "STAGING_DISTRIB_BASE=", STAGING_DISTRIB_BASE
    print ""
    """

    print "promoting staged software to release:"

    for c in configTypes:
        # target parent dir for the installer, e.g.:
        #   S:\CRDS\CRD Engineering\Software\G2000\Installer\g2000_win7\CFADS
        targetDir = os.path.join(distribBase, c)

        # staging dir (source dir for installer)
        stagingDir = os.path.join(STAGING_DISTRIB_BASE, c)

        # delete the existing Current folder since its contents will be
        # replaced with the new installer (if not only archiving)
        currentDir = os.path.join(targetDir, 'Current')
        archiveDir = os.path.join(targetDir, 'Archive')

        if archiveOnly is False:
            if os.path.isdir(currentDir):
                shutil.rmtree(currentDir, ignore_errors=False, onerror=handleRemoveReadonly)

            # create the Current folder
            if not os.path.isdir(currentDir):
                os.makedirs(currentDir)

        # always create the Archive dir if it doesn't exist
        if not os.path.isdir(archiveDir):
            os.makedirs(archiveDir)

        # get a list of all the files in the staging dir (doesn't include . or ..)
        # only one file is expected to be in the folder
        fileList = os.listdir(stagingDir)
        assert len(fileList) == 1

        # validation: filename must begin with 'setup_', has .exe extension
        installer = fileList[0]
        assert installer.lower().find('setup_') == 0
        assert installer.lower().endswith('.exe')

        # copy the installer from the staging folder to both Archive and Current
        print "  staged from: '%s'" % os.path.join(stagingDir, installer)
        print "   to Archive: '%s'" % os.path.join(archiveDir, installer)

        # call copy2() to preserve the modify date (copyfile() does not)
        shutil.copy2(os.path.join(stagingDir, installer),
                     os.path.join(archiveDir, installer))

        if archiveOnly is False:
            print "   to Current: '%s'" % os.path.join(currentDir, installer)

            shutil.copy2(os.path.join(stagingDir, installer),
                         os.path.join(currentDir, installer))

        print ""


</t>
<t tx="stan@picarro-com.20150609175614.27">def _copyBuildAndInstallers(versionConfig, product, osType, ver, customBuild=False):
    """
    Move the installers and the two compiled exe directories to their
    staging location so other people can find them.
    """

    # For handling things alphabetically
    configTypes = []
    for c in CONFIGS:
        configTypes.append(c)
    configTypes.sort()

    # Clean the previously staged version.
    #

    # If this a custom build (only specific installers not everything), then
    # we cannot wipe out the entire staging area
    if customBuild is False:
        try:
            #shutil.rmtree(STAGING_MFG_DISTRIB_BASE, ignore_errors=False, onerror=handleRemoveReadonly)
            shutil.rmtree(STAGING_DISTRIB_BASE, ignore_errors=False, onerror=handleRemoveReadonly)
        except OSError:
            # Okay if these directories don't already exist.
            pass
    else:
        # remove only trees for the specific instrument types that were built
        for c in configTypes:
            treeBase = os.path.normpath(os.path.join(STAGING_DISTRIB_BASE, c))
            print "treeBase=", treeBase

            try:
                shutil.rmtree(treeBase, ignore_errors=False, onerror=handleRemoveReadonly)
            except OSError:
                # Okay if these directories don't already exist.
                pass

    """
    # Not copying the build exes to the R: drive anymore...
    # Too easy for Mfg. to abuse this by copying over the exe dirs and
    # config files without running an installer.
    # HostExe
    hostExeDir = os.path.join(STAGING_MFG_DISTRIB_BASE, 'HostExe')

    if os.path.isdir(hostExeDir):
        os.rmdir(hostExeDir)
    assert not os.path.isdir(hostExeDir)
    os.makedirs(hostExeDir)

    dir_util.copy_tree(os.path.join(SANDBOX_DIR, 'host', 'Host', 'dist'),
                       hostExeDir)

    # AnalyzerServerExe
    analyzerServerExe = os.path.join(STAGING_MFG_DISTRIB_BASE,
                                     'AnalyzerServerExe')

    if os.path.isdir(analyzerServerExe):
        os.rmdir(analyzerServerExe)
    assert not os.path.isdir(analyzerServerExe)
    os.makedirs(analyzerServerExe)

    dir_util.copy_tree(os.path.join(SANDBOX_DIR, 'host', 'MobileKit', 'dist'),
                       analyzerServerExe)
    """

    # Copy the individual installers and update the shortcuts that are
    # used by manufacturing.
    for c in configTypes:
        installer = "setup_%s_%s_%s.exe" % (c, CONFIGS[c],
                                            _verAsString(product, ver))
        targetDir = os.path.join(STAGING_DISTRIB_BASE, c)

        if not os.path.isdir(targetDir):
            os.makedirs(targetDir)

        shutil.copyfile(os.path.join(SANDBOX_DIR, 'Installers', installer),
                        os.path.join(targetDir, installer))

        # put a copy of the version file in the installer staging folder
        # (do we really need it? we're no longer dropping the version # from
        # the installer filename, could be a sanity check for the promote
        # to official)
        #shutil.copyfile(versionConfig, os.path.join(targetDir, versionConfig))

    # no longer saving the JSON file with the build number as
    # the installer filenames always contain the version (not renamed anymore),
    # version is baked into the installer exe as well as the
    # individual host app executables previously built
    #shutil.copyfile(versionConfig,
    #                os.path.join(STAGING_DISTRIB_BASE, versionConfig))


</t>
<t tx="stan@picarro-com.20150609175614.28">def _branchFromRepo(branch):
    """
    Branch the named repository into the sandbox.
    """

    if os.path.exists(SANDBOX_DIR):
        print "Removing previous sandbox at '%s'." % SANDBOX_DIR

        # First fix up the permissions on some pesky .idx and .pack files
        # If they exist, they are read-only and shutil.rmtree() will bail
        packFolder = os.path.join(SANDBOX_DIR, 'host', '.git', 'objects', 'pack')

        if os.path.isdir(packFolder):
            packFiles = os.listdir(packFolder)

            for f in packFiles:
                # fix up permissions
                print "chmod(%s)" % os.path.join(packFolder, f)
                os.chmod(os.path.join(packFolder, f),
                         stat.S_IREAD | stat.S_IWRITE)

        # now remove the sandbox tree
        print "Removing sandbox tree '%s'." % SANDBOX_DIR

        # sometimes this fails with the following error:
        #    WindowsError: [Error 145] The directory is not empty: 'c:/temp/sandbox'
        # I think it takes a little time for things to settle after the chmod above
        # so make a second attempt after a short wait
        try:
            shutil.rmtree(SANDBOX_DIR, ignore_errors=False, onerror=handleRemoveReadonly)
        except:
            print "rmtree failed! sleep(5) and attempt shutil.rmtree one more time"
            time.sleep(5)
            shutil.rmtree(SANDBOX_DIR, ignore_errors=False, onerror=handleRemoveReadonly)

        print "Sandbox tree removed."

    print "Creating sandbox tree '%s'." % SANDBOX_DIR
    os.makedirs(SANDBOX_DIR)
    print "Sandbox tree creation done."
    os.makedirs(os.path.join(SANDBOX_DIR, 'Installers'))

    print "Clone git repo '%s'" % REPO_BASE
    with OS.chdir(SANDBOX_DIR):
        retCode = subprocess.call(['git.exe',
                                   'clone',
                                   REPO_BASE])

        if retCode != 0:
            LogErr("Error cloning '%s', retCode=%d" % (REPO_BASE, retCode))
            sys.exit(retCode)

        print "Check out git branch '%s'." % branch
        with OS.chdir(os.path.join(SANDBOX_DIR, 'host')):
            retCode = subprocess.call(['git.exe',
                                       'checkout',
                                       branch])

            if retCode != 0:
                LogErr("Error checking out 'origin/%s', retCode=%d." % (branch, retCode))
                sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175614.29">def _generateReleaseVersion(product, ver):
    """
    Create the version metadata used by the executables and update the
    pretty version string.
    """

    with OS.chdir(os.path.join(SANDBOX_DIR, 'host')):
        with open(os.path.join('Host', 'Common',
                               'release_version.py'), 'w') as fp:
            fp.writelines(
                ["# autogenerated by release.py, %s\n" % time.asctime(),
                 "\n",
                 "def versionString():\n",
                 "    return '%s'\n" % _verAsString(product, ver),
                 "\n",
                 "def versionNumString():\n",
                 "    return '%s'\n" % _verAsNumString(ver),
                 "\n",
                 "def buildType():\n",
                 "    return ''\n",
                 "\n"])


</t>
<t tx="stan@picarro-com.20150609175614.3">def __init__(self, f, quiet=False):
    self.terminal = sys.stdout
    self.log = f
    sys.stdout = self
    self.quiet = quiet

</t>
<t tx="stan@picarro-com.20150609175614.30">def _buildExes():
    """
    Build host executables.
    """

    buildEnv = dict(os.environ)
    buildEnv.update({'PYTHONPATH' : "%s;%s" %
                    (os.path.join(SANDBOX_DIR, 'host'),
                    os.path.join(SANDBOX_DIR, 'host', 'Firmware')
                    )})

    # MobileKit must be built first since the HostExe build will copy
    with OS.chdir(os.path.join(SANDBOX_DIR, 'host', 'MobileKit')):
        retCode = subprocess.call(['python.exe', 'setup.py', 'py2exe'],
                                  env=buildEnv)

        if retCode != 0:
            LogErr("Error building MobileKit. retCode=%d" % retCode)
            sys.exit(retCode)

    with OS.chdir(os.path.join(SANDBOX_DIR, 'host', 'Host')):
        retCode = subprocess.call(['python.exe', 'PicarroExeSetup.py',
                                   'py2exe'],
                                   env=buildEnv)

        if retCode != 0:
            LogErr("Error building Host. retCode=%d" % retCode)
            sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175614.31">def _tagRepository(product, ver):
    """
    Tags the repository
    """

    print ""
    print "Tagging repository..."

    tagName = _verAsString(product, ver)
    print "  git tag -a %s -m \"Version %s\"" % (tagName, tagName)

    retCode = subprocess.call(['git.exe',
                               'tag',
                               '-a',
                               tagName,
                               '-m',
                               "Version %s" % tagName])

    if retCode != 0:
        LogErr("Error tagging repository. retCode=%d  tagName='%s'" % (retCode, tagName))
        sys.exit(retCode)

    print "  git push origin %s" % tagName
    retCode = subprocess.call(['git.exe',
                               'push',
                               'origin',
                               tagName])

    if retCode != 0:
        LogErr("Error pushing tag to repository. retCode=%d  tagName='%s'" % (retCode, tagName))
        sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175614.32">def _tagCommonConfig(product, ver):
    retCode = subprocess.call(['bzr.exe', 'tag', "--directory=%s" %
                               COMMON_CONFIG, _verAsString(product, ver)])

    if retCode != 0:
        LogErr("Error tagging CommonConfig as '%s'. retCode=%d." % (_verAsString(product, ver), retCode))
        sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175614.33">def _tagAppInstrConfigs(product, ver):
    """
    Tag the AppConfig and InstrConfig repos for each variant. Unlike
    tagOnly.bat, on which this routine is based, we will _not_ also
    tag the config branches in the sandbox. The branches in the
    sandbox will have common ancestor revisions with the master repos
    on S:. If you need the revision of a tag look at the master repo
    on S:. Eventually this will all be moot once we merge the
    configurations into the main repo.
    """

    with OS.chdir(SANDBOX_DIR):
        # tag configs alphabetically by instrument type (nicety for monitoring build progress)
        configTypes = []
        for c in CONFIGS:
            configTypes.append(c)
        configTypes.sort()

        for c in configTypes:
            configBase = os.path.join(CONFIG_BASE, "%sTemplates" % c)

            retCode = subprocess.call(['bzr.exe', 'tag',
                                       "--directory=%s" %
                                       os.path.join(configBase, 'AppConfig'),
                                       _verAsString(product, ver)])

            if retCode != 0:
                LogErr("Error tagging '%s' AppConfig as '%s', retCode=%d." % \
                    (c, _verAsString(product, ver)), retCode)
                sys.exit(retCode)

            retCode = subprocess.call(['bzr.exe', 'tag',
                                       "--directory=%s" %
                                       os.path.join(configBase, 'InstrConfig'),
                                       _verAsString(product, ver)])

            if retCode != 0:
                LogErr("Error tagging '%s' InstrConfig as '%s', retCode=%d." % \
                    (c, _verAsString(product, ver)), retCode)
                sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175614.34">def _makeLocalConfig():
    """
    Adds physical copies of all of the configuration file repositories to the
    sandbox and generates the required version.ini file.
    """

    # get configs alphabetically by instrument type (nicety for monitoring build progress)
    # include only analyzer types using bzr repo for the configs
    configTypes = []
    for c in CONFIGS:
        if CONFIG_REPOS[c] == "bzr":
            configTypes.append(c)
    configTypes.sort()

    if len(configTypes) == 0:
        # cloning repos only if configs for at least one analyzer from bzr
        # NB: makeExe() logic shouldn't be calling this at all...
        print "_makeLocalConfig: no configs from bzr, skipping cloning"
        return

    with OS.chdir(SANDBOX_DIR):
        print "_makeLocalConfig: current dir='%s'" % os.getcwd()

        configDir = os.path.normpath(COMMON_CONFIG)
        print "subprocess.call([bzr.exe, branch, %s, CommonConfig])" % configDir
        retCode = subprocess.call(['bzr.exe', 'branch', configDir, "CommonConfig"])

        if retCode != 0:
            LogErr("Error cloning CommonConfig. retCode=%d" % retCode)
            sys.exit(retCode)

        with open(os.path.join('CommonConfig', 'version.ini'), 'w') as fp:
            print "subprocess.call([bzr.exe, version-info, CommonConfig, --custom --template=%s])" % VERSION_TEMPLATE
            retCode = subprocess.call(['bzr.exe', 'version-info',
                                       'CommonConfig', '--custom',
                                       "--template=%s" % VERSION_TEMPLATE],
                                       stdout=fp)

            if retCode != 0:
                LogErr("Error generating version.ini for CommonConfig. retCode=%d" % retCode)
                sys.exit(retCode)

        for c in configTypes:
            print "Getting configs for '%s'" % c
            os.mkdir(c)
            with OS.chdir(c):
                # clone AppConfig branch
                templatesPath = os.path.normpath(os.path.join(CONFIG_BASE, "%sTemplates" % c,'AppConfig'))
                print "subprocess.call([bzr.exe, branch, %s, AppConfig])" % templatesPath

                retCode = subprocess.call(['bzr.exe', 'branch',
                                           templatesPath,
                                           'AppConfig'])

                if retCode != 0:
                    LogErr("Error cloning '%s' AppConfig. retCode=%d" % (c, retCode))
                    sys.exit(retCode)

                # get AppConfig version
                with open(os.path.join('AppConfig', 'version.ini'), 'w') as fp:
                    print "subprocess.call([bzr.exe, version-info, AppConfig, --custom --template=%s])" % VERSION_TEMPLATE

                    retCode = subprocess.call(['bzr.exe', 'version-info',
                                               'AppConfig', '--custom',
                                               "--template=%s" %
                                               VERSION_TEMPLATE],
                                               stdout=fp)

                    if retCode != 0:
                        LogErr("Error generating '%s' AppConfig version.ini. retCode=%d" % (c, retCode))
                        sys.exit(retCode)

                # clone InstrConfig branch
                templatesPath = os.path.join(CONFIG_BASE, "%sTemplates" % c,'InstrConfig')
                print "subprocess.call([bzr.exe, branch, %s, InstrConfig])" % templatesPath

                retCode = subprocess.call(['bzr.exe', 'branch',
                                           os.path.join(CONFIG_BASE,
                                                        "%sTemplates" % c,
                                                        'InstrConfig'),
                                                        'InstrConfig'])
                if retCode != 0:
                    LogErr("Error cloning '%s' InstrConfig. retCode=%d" % (c, retCode))
                    sys.exit(retCode)

                # get InstrConfig version
                with open(os.path.join('InstrConfig', 'version.ini'), 'w') as fp:
                    print "subprocess.call([bzr.exe, version-info, InstrConfig, --custom --template=%s])" % VERSION_TEMPLATE

                    retCode = subprocess.call(['bzr.exe', 'version-info',
                                               'InstrConfig', '--custom',
                                               "--template=%s" %
                                               VERSION_TEMPLATE],
                                               stdout=fp)

                    if retCode != 0:
                        LogErr("Error generating '%s' InstrConfig version.ini. retCode=%d" % (c, retCode))
                        sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175614.35">def _createGitConfigVersionFile(configDir, ver, branchName):
    # get git log info to be stored in version.ini
    #
    # revno is short SHA1 value
    revno, stdout_value = runCommand("git.exe log -1 --pretty=format:%h")

    if stdout_value is not None:
        LogErr("Error '%s' getting revno" % stdout_value)
        return 1

    # last modify date
    lastModDate, stdout_value = runCommand("git.exe log -1 --pretty=format:%ai")

    if stdout_value is not None:
        LogErr("Error '%s' getting lastModDate" % stdout_value)
        return 1

    # build a revision_id string so it is a similar format to the bzr output
    #
    #   last modify date, UNIX timestamp
    tval, stdout_value = runCommand("git.exe log -1 --pretty=format:%at")
    #print "UNIX timestamp tval=", tval

    if stdout_value is not None:
        LogErr("Error '%s' getting tval" % stdout_value)
        return 1

    #   convert to YYYYMMDDHHMMSS string
    tm = time.gmtime(float(tval))
    #print "tm=", tm

    tmStr = time.strftime("%Y%m%d%H%M%S", tm)

    #   last mod author email
    emailStr, stdout_value = runCommand("git.exe log -1 --pretty=format:%ae")

    if stdout_value is not None:
        LogErr("Error '%s' getting emailStr" % stdout_value)
        return 1

    #  full SHA1
    idStr, stdout_value = runCommand("git.exe log -1 --pretty=format:%H")

    if stdout_value is not None:
        LogErr("Error '%s' getting idStr (SHA1)" % stdout_value)
        return 1

    revision_id = emailStr + "-" + tmStr + "-" + idStr

    # write the version.ini file
    with open(os.path.join(configDir, "version.ini"), 'w') as fp:
        fp.writelines(
            ["# autogenerated by release.py, %s\n" % time.asctime(),
             "\n",
             "[Version]\n",
             "revno = %s\n" % revno,
             "date = %s\n" % lastModDate,
             "revision_id = %s\n" % revision_id,
             "build_ver = %s\n" % _verAsNumString(ver)
             ])

        # include branch nickname if caller passed it in
        if branchName is not None:
            fp.writelines(
                ["branch_nick = %s\n" % branchName])

    # return with no errors
    return 0


</t>
<t tx="stan@picarro-com.20150609175614.36">def _setGitConfigVer(createTag, product, ver):
    """
    Generates the required version.ini files for git configs.
    """

    # handle configs alphabetically by instrument type (nicety for monitoring build progress)
    # include only analyzer types using git repo for the configs
    configTypes = []
    for c in CONFIGS:
        if CONFIG_REPOS[c] == "git":
            configTypes.append(c)
    configTypes.sort()

    if len(configTypes) == 0:
        # create version.ini files only if configs for at least one analyzer from git
        # Note: makeExe() logic shouldn't be calling this at all...
        print "_setGitConfigVer: no configs from git, skipping create config version"
        return

    print "Creating version.ini for git configs"

    branchName = getGitBranch(os.path.join(SANDBOX_DIR, "host"))

    # cd to the parent dir for git output (can really be anywhere in the branch)
    with OS.chdir(os.path.join(SANDBOX_DIR, "host")):
        configParentDir = os.path.normpath(os.path.join(SANDBOX_DIR, "host", "Config"))

        # version.ini for CommonConfig
        ret = _createGitConfigVersionFile(os.path.join(configParentDir, 'CommonConfig'),
                                          ver, branchName)

        if ret != 0:
            LogErr("Error creating version.ini for CommonConfig")
            sys.exit(1)

        for c in configTypes:
            # version.ini for analyzer types using git repo for configs
            ret = _createGitConfigVersionFile(os.path.join(configParentDir, c, "AppConfig"),
                                              ver, branchName)

            if ret != 0:
                LogErr("Error creating version.ini for AppConfig for %s" % c)
                sys.exit(1)

            ret = _createGitConfigVersionFile(os.path.join(configParentDir, c, "InstrConfig"),
                                              ver, branchName)

            if ret != 0:
                LogErr("Error creating version.ini for InstrConfig for %s" % c)
                sys.exit(1)


</t>
<t tx="stan@picarro-com.20150609175614.37">def _compileInstallers(product, osType, ver):
    """
    Compiles the installers for each variant. The original runCompInstallers.bat
    used Compil32.exe, but if we use ISCC.exe we should be able to bypass the
    requirement that each .iss file have its version string updated manually.
    """

    # build alphabetically by instrument type (nicety for monitoring build progress)
    configTypes = []
    for c in CONFIGS:
        configTypes.append(c)
    configTypes.sort()

    # save off the current dir to build a path to the installer dir
    currentDir = os.getcwd()

    for c in configTypes:
        print "Compiling '%s'..." % c

        isccApp = ISCC

        if osType == 'win7':
            isccApp = ISCC_WIN7

        # Note: .iss files are coming from a subfolder under this release.py dir,
        #        NOT the sandbox tree.
        #
        # Build a fully qualified path for the scripts folder, so ISCC can find
        # the include files (can't find them using a relative path here).
        installScriptDir = os.path.join(currentDir, INSTALLER_SCRIPTS_DIR)
        setupFilePath = "%s\\setup_%s_%s.iss" % (installScriptDir, c, CONFIGS[c])

        repo = CONFIG_REPOS[c]
        if repo == "git":
            # config files in git are in host\Config under the sandbox folder
            configDir = os.path.normpath(os.path.join(SANDBOX_DIR, "host", "Config"))
        elif repo == "bzr":
            # bzr configs are under the sandbox folder
            configDir = SANDBOX_DIR
        else:
            LogErr("Invalid repo '%s' for %s" % (repo, c))
            sys.exit(1)

        print "building from '%s'" % setupFilePath

        # Write the installerSignature.txt file into the sandbox config folder for this
        # analyzer type.
        sigLine = INSTALLER_SIGNATURES[c]
        sigFilePath = os.path.normpath(os.path.join(configDir, c, "installerSignature.txt"))
        f = open(sigFilePath, "w")
        f.write(sigLine)
        f.close()

        # Notes:
        #
        # installerVersion: must be of the form x.x.x.x, for baking version number
        #                   into setup_xxx.exe metadata (for Explorer properties)
        # hostVersion:      e.g., g2000_win7-x.x.x-x, displayed in the installer UI
        # productVersion:   used for displaying Product version in Explorer properties
        currentYear = time.strftime("%Y")

        args = [isccApp, "/dinstallerType=%s" % c,
                "/dhostVersion=%s" % _verAsString(product, ver),
                "/dinstallerVersion=%s" % _verAsNumString(ver),
                "/dproductVersion=%s" % _verAsUINumString(ver),
                "/dproductYear=%s" % currentYear,
                "/dresourceDir=%s" % RESOURCE_DIR,
                "/dsandboxDir=%s" % SANDBOX_DIR,
                "/dconfigDir=%s" % configDir,
                "/dcommonName=%s" % CONFIGS[c],
                "/v9",
                "/O%s" % os.path.abspath(os.path.join(SANDBOX_DIR,
                                                        'Installers')),
                setupFilePath]

        print subprocess.list2cmdline(args)
        print "current dir='%s'" % os.getcwd()

        retCode = subprocess.call(args)

        if retCode != 0:
            LogErr("Error building '%s' installer, retCode=%d." % (c, retCode))
            sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175614.38">def _verAsString(product, ver, osType=None):
    """
    Convert a version dict into a human-readable string.
    """

    number = "%(major)s.%(minor)s.%(revision)s-%(build)s" % ver

    if osType is not None:
        return "%s-%s-%s" % (product, osType, number)
    else:
        return "%s-%s" % (product, number)


</t>
<t tx="stan@picarro-com.20150609175614.39">def _verAsNumString(ver):
    """
    Convert a version dict into a string of numbers in this format:
        &lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;.&lt;build&gt;
    """

    number = "%(major)s.%(minor)s.%(revision)s.%(build)s" % ver
    return number


</t>
<t tx="stan@picarro-com.20150609175614.4">def set_quiet(self, quiet):
    self.quiet = quiet

</t>
<t tx="stan@picarro-com.20150609175614.40">def _verAsUINumString(ver):
    """
    Convert a version dict into a string of numbers in this format
    for user-facing info:
        &lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;-&lt;build&gt;
    """

    number = "%(major)s.%(minor)s.%(revision)s-%(build)s" % ver
    return number


</t>
<t tx="stan@picarro-com.20150609175614.41">def main():
    usage = """
%prog [options]

Builds a new release of HostExe, AnalyzerServerExe and all installers.
"""

    parser = OptionParser(usage=usage)
    parser.add_option('-v', '--version', dest='version', metavar='VERSION',
                      default=None, help=('Specify a version for this release '
                                          'and tag it as such in the '
                                          'repository.'))
    parser.add_option('--skip-tag', dest='createTag', action='store_false',
                      default=True, help=('Skip creating a tag, even if a '
                                          'version # is specified.'))
    parser.add_option('--skip-installers', dest='createInstallers',
                      action='store_false', default=True,
                      help=('Skip creating installers.'))
    parser.add_option('--make-official', dest='makeOfficial',
                      action='store_true', default=False,
                      help=('Promote the current release in staging to the '
                            'official distribution channels.'))
    parser.add_option('--types', dest='buildTypes',
                      default=None, help=('Comma-delimited list of analyzer types to build or '
                                          'types to move from staging to the official release '
                                          'area. If the list starts with a "!" every type but those '
                                          'in the list will be built or moved.'))

    # options for --make-official only
    parser.add_option('--ostype', dest='osType',
                      default=None, help=('OS type for promoting the current release to release.'
                                          'Valid arguments are win7 or winxp. Only allowed with the '
                                          '--make-official option.'))

    parser.add_option('--archive', dest='archiveOnly',
                      action='store_true', default=False,
                      help=('When promoting staged to release, copy installers to the Archive folder '
                            'but don\'t copy them to Current. '
                            'Only allowed with the --make-official option.'))

    parser.add_option('--dry-run', dest='dryRun', default=False,
                      action='store_true',
                      help=('Only works with --make-official. Tests the move '
                            'to staging by using a temporary directory as the '
                            'target.'))

    parser.add_option('--product', dest='product', metavar='PRODUCT',
                      default=None, help=('The product line to generate the '
                                          'release for. This option is required.'))
    parser.add_option('--branch', dest='branch', metavar='BRANCH',
                      default='master', help=('The remote branch from which the '
                                              'release is built.'))

    parser.add_option('--no-confirm', dest='skipConfirm',
                      action='store_true', default=False,
                      help=('Don\'t ask for confirmation of build settings before '
                            'proceeding with the build.'))
    parser.add_option('--debug-local', dest='local',
                      action='store_true', default=False,
                      help=('Use local C: drive in place of R: or S: for '
                            'build destination paths. Useful for debugging this build '
                            'script. This option cannot be used in combination with --dry-run.'))

    parser.add_option('--debug-skip-all-clone', dest='cloneAllRepos', action='store_false',
                      default=True, help=('Skip cloning all repositories. The sandbox '
                                          'must already exist from a prior build. Intended '
                                          'for use with --debug-local. Useful for quick '
                                          'testing of minor changes or debugging this build script.'))

    parser.add_option('--debug-skip-host-clone', dest='cloneHostRepo', action='store_false',
                      default=True, help=('Skip cloning the git host repository. The sandbox git repo '
                                          'must already exist from a prior build. Intended '
                                          'for use with --debug-local. Useful for quick '
                                          'testing of minor changes or debugging this build script.'))

    parser.add_option('--debug-skip-config-clone', dest='cloneConfigRepo', action='store_false',
                      default=True, help=('Skip cloning the bzr config repositories. The sandbox repos '
                                          'must already exist from a prior build. Intended '
                                          'for use with --debug-local. Useful for quick '
                                          'testing of minor changes or debugging this build script.'))

    parser.add_option('--debug-skip-exe', dest='buildExes', action='store_false',
                      default=True, help=('Skip building the executables. The sandbox and executables '
                                          'must already exist from a prior build. Intended '
                                          'for use with --debug-local. Useful for quick '
                                          'testing of minor changes or debugging this build script.'))
    parser.add_option('--logfile', dest='logfile', default=None,
                      help=('Use this option to specify a filename for logging '
                            'output from stdout and stderr. A default filename is '
                            'generated using the product, branch, and current time if '
                            'no filename is specified.'))
    parser.add_option('--debug-quiet', dest='debugQuiet',
                      action='store_true', default=False,
                      help=('Only output from stderr is directed to the console. '
                            'The logfile will always contain output from both '
                            'stdout and stderr.'))

    options, _ = parser.parse_args()

    if not options.cloneAllRepos:
        # turn off cloning host and configs repos if cloning all is turned off
        options.cloneHostRepo = False
        options.cloneConfigRepo = False

    elif not options.cloneHostRepo or not options.cloneConfigRepo:
        # if cloning either (or both) host or configs repos is off, not cloning all repos
        options.cloneAllRepos = False

    makeExe(options)


</t>
<t tx="stan@picarro-com.20150609175614.5">def write(self, message):
    if not self.quiet:
        self.terminal.write(message)
    self.log.write(message)
    
</t>
<t tx="stan@picarro-com.20150609175614.6">def flush(self):
    self.log.flush()
    if not self.quiet:
        self.terminal.flush()

</t>
<t tx="stan@picarro-com.20150609175614.7">def close(self):
    #print "StdoutLogger::close()"
    if self.terminal is not None:
        sys.stdout = self.terminal
        self.terminal = None

</t>
<t tx="stan@picarro-com.20150609175614.8">def __del__(self):
    #print "StdoutLogger::__del__()"
    pass


</t>
<t tx="stan@picarro-com.20150609175614.9">class StderrLogger(object):
    @others
</t>
<t tx="stan@picarro-com.20150609175653.1">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    main()
</t>
<t tx="stan@picarro-com.20150609175653.10">class StderrLogger(object):
    @others
</t>
<t tx="stan@picarro-com.20150609175653.11">def __init__(self, f):
    self.stderr = sys.stderr
    self.log = f
    sys.stderr = self

</t>
<t tx="stan@picarro-com.20150609175653.12">def write(self, message):
    self.stderr.write(message)
    self.log.write(message)
    
</t>
<t tx="stan@picarro-com.20150609175653.13">def flush(self):
    self.log.flush()
    self.stderr.flush()

</t>
<t tx="stan@picarro-com.20150609175653.14">def close(self):
    #print "StderrLogger::close()"
    #print "   self.stderr=", self.stderr

    if self.stderr is not None:
        sys.stderr = self.stderr
        self.stderr = None

</t>
<t tx="stan@picarro-com.20150609175653.15">def __del__(self):
    pass
    #print "StderrLogger::__del__()"
    #self.close()


</t>
<t tx="stan@picarro-com.20150609175653.16">class Logger(object):
    @others
</t>
<t tx="stan@picarro-com.20150609175653.17">def __init__(self, filename, quiet=False):
    self.log = open(filename, "w")
    self.stdoutLogger = StdoutLogger(self.log, quiet)
    self.stderrLogger = StderrLogger(self.log)

</t>
<t tx="stan@picarro-com.20150609175653.18">def set_quiet(self, quiet):
    if self.stdoutLogger is not None:
        self.stdoutLogger.set_quiet(quiet)

</t>
<t tx="stan@picarro-com.20150609175653.19">def __del__(self):
    if self.log is not None:
        self.log.close()
        self.log = None


</t>
<t tx="stan@picarro-com.20150609175653.2">"""
Copyright 2012-2013 Picarro Inc.

Replacement for makeExe.bat.
"""

from __future__ import with_statement

import os
import sys
import shutil
import subprocess
#import pprint
import re
import time
import os.path
import stat
import platform
import errno

from distutils import dir_util
from optparse import OptionParser

#pylint: disable=F0401
try:
    import simplejson as json
except ImportError:
    import json
#pylint: enable=F0401

from Host.Common import OS


# Pull these out into a configuration file.
SANDBOX_DIR = 'c:/temp/sandbox'

REPO_BASE = 'https://github.com/picarro/host.git'

ISCC = 'c:/program files/Inno Setup 5/ISCC.exe'
ISCC_WIN7 = 'c:/program files (x86)/Inno Setup 5/ISCC.exe'
INSTALLER_SCRIPTS_DIR = 'InstallerScripts'

RESOURCE_DIR = ('s:/CRDS/SoftwareReleases/G2000Projects/G2000_PrepareInstaller/'
                'Resources')

CONFIGS = {}
INSTALLER_SIGNATURES = {}
CONFIG_REPOS = {}

CONFIG_BASE = 's:/CrdsRepositoryNew/trunk/G2000/Config'
COMMON_CONFIG = os.path.join(CONFIG_BASE, 'CommonConfig')

VERSION = {}
VERSION_TEMPLATE = ("[Version]\\nrevno = {revno}\\ndate = {date}\\n"
                    "revision_id = {revision_id}")

# Where Manufacturing looks for installers and
# HostExe/AnalyzerServerExe upgrades.
#MFG_DISTRIB_BASE = 'r:/G2000_HostSoftwareInstallers'
DISTRIB_BASE = 's:/CRDS/CRD Engineering/Software/G2000/Installer'

# For dry-run testing
#TEST_MFG_DISTRIB_BASE = 'c:/temp/tools/release/mfg_distrib_base'
#TEST_DISTRIB_BASE = 'c:/temp/tools/release/distrib_base'

# Where new releases are put for testing.
#STAGING_MFG_DISTRIB_BASE = 'r:/G2000_HostSoftwareInstallers_Staging'
STAGING_DISTRIB_BASE = 's:/CRDS/CRD Engineering/Software/G2000/Installer_Staging'


</t>
<t tx="stan@picarro-com.20150609175653.20">def LogErr(message):
    sys.stderr.write(message)
    sys.stderr.write("\n")


</t>
<t tx="stan@picarro-com.20150609175653.21">def _buildDoneMsg(message, startSec, logfile):
    """
    Output the ending time, elapsed time, and a build completed message
    """
    print "Build script end: %s" % time.strftime("%Y/%m/%d %H:%M:%S %p", time.localtime())

    if startSec is not None:
        # we don't really care about fractional seconds
        elapsed = int(time.time() - startSec)

        hours = elapsed / 3600
        seconds = elapsed % 3600
        minutes = seconds / 60
        seconds = seconds % 60

        print "Elapsed time: %d hours, %d min, %d sec" % (hours, minutes, seconds)

    if logfile is not None:
        print ""
        print "logfile           =", logfile
        print ""

    print "******** %s COMPLETE ********" % message


</t>
<t tx="stan@picarro-com.20150609175653.22">def _printSummary(opts, osType, logfile, productFamily, productConfigs, versionConfig,
                  cloneAllRepos=True,
                  cloneConfigRepo=True,
                  bzrConfigsNeeded=True,
                  cloneHostRepo=True):
    print ""
    print "product           =", opts.product
    print "branch            =", opts.branch
    print "OS type           =", osType
    print "productFamily     =", productFamily
    print "productConfigs    =", productConfigs
    print "versionConfig     =", versionConfig

    if not opts.makeOfficial:
        print "version           = %s.%s.%s.%s" % (VERSION['major'], VERSION['minor'], VERSION['revision'], VERSION['build'])

        if opts.createTag:
            print "create tags       =", "YES"
        else:
            print "create tags       =", "NO"

        if opts.createInstallers:
            print "create installers =", "YES"
        else:
            print "create installers =", "NO"

        tmpConfigs = []
        for c in CONFIGS:
            tmpConfigs.append(c)
        tmpConfigs.sort()

        fFirst = True
        for c in tmpConfigs:
            if fFirst is True:
                print "configs           = %-6s  repo = %s" % (c, CONFIG_REPOS[c])
                fFirst = False
            else:
                print "                    %-6s  repo = %s" % (c, CONFIG_REPOS[c])

        if opts.local:
            print ""
            print "local build       =", "YES"

            if cloneAllRepos:
                print "clone all repos   =", "YES"
            else:
                print "clone all repos   =", "NO"

            if cloneHostRepo:
                print "  clone host repo (git)    =", "YES"
            else:
                print "  clone host repo (git)    =", "NO"

            if cloneConfigRepo:
                if bzrConfigsNeeded is True:
                    print "  clone config repos (bzr) =", "YES"
                else:
                    # will override cloning bzr since not needed
                    print "  clone config repos (bzr) =", "NO (not used)"
            else:
                print "  clone config repos (bzr) =", "NO"

            if opts.buildExes:
                print "build exes        =", "YES"
            else:
                print "build exes        =", "NO"

        else:
            print ""
            print "local build       =", "NO"

        #print "  MFG_DISTRIB_BASE         =", MFG_DISTRIB_BASE
        print "  DISTRIB_BASE             =", DISTRIB_BASE
        #print "  STAGING_MFG_DISTRIB_BASE =", STAGING_MFG_DISTRIB_BASE
        print "  STAGING_DISTRIB_BASE     =", STAGING_DISTRIB_BASE
        print ""

        # Note: local and dryRun cannot be used together, already bailed above if they were
        if opts.dryRun:
            print "dry run           =", "YES"
            #print "  targetMfgDistribBase =", TEST_MFG_DISTRIB_BASE
            #print "  targetDistribBase    =", TEST_DISTRIB_BASE
        else:
            print "dry run           =", "NO"
            #print "  targetMfgDistribBase =", MFG_DISTRIB_BASE
            print "  targetDistribBase    =", DISTRIB_BASE

    else:
        # no version for promoting to release, it picks up whatever installer versions
        # are in the staging area and copies them to the release area
        print ""
        print "make-official     =", "YES"

        if opts.local:
            print "local build       =", "YES"
        else:
            print "local build       =", "NO"

        if opts.archiveOnly:
            print "archive only      =", "YES"
        else:
            print "archive only      =", "NO"

        if opts.buildTypes is None:
            print "build types       = all"
        else:
            print "build types       =", opts.buildTypes

        tmpConfigs = []
        for c in CONFIGS:
            tmpConfigs.append(c)
        tmpConfigs.sort()

        print "configs           =", tmpConfigs[0]
        for c in tmpConfigs[1:]:
            print "                   ", c

        print "  STAGING_DISTRIB_BASE     =", STAGING_DISTRIB_BASE
        print "   DISTRIB_BASE            =", DISTRIB_BASE

    print ""
    print "logfile           =", logfile


</t>
<t tx="stan@picarro-com.20150609175653.23">def runCommand(command):
    """
    Run a command line command so we can capture its output.
    """
    #print "runCommand: '%s'" % command
    p = subprocess.Popen(command,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)

    stdout_value, stderr_value = p.communicate()
    # print "stdout:", repr(stdout_value)
    return stdout_value, stderr_value


</t>
<t tx="stan@picarro-com.20150609175653.24">def getGitBranch(gitDir):
    """
    Get the git branch that the gitDir is currently set to.
    """
    #print "gitDir=%s" % gitDir

    curBranch = ""

    if not os.path.isdir(gitDir):
        LogErr("'%s' is not a directory!" % gitDir)
        return curBranch

    # save off the current dir so we can get back to it when we're done
    saveDir = os.getcwd()

    # change to the git dir
    #print "cd to '%s'" % gitDir
    os.chdir(gitDir)
    #print "current dir is now '%s'" % os.getcwd()

    # run "git branch" and parse stdout for it -- the current branch name begins with a "* "
    command = "git branch"
    stdout_value, stderr_value = runCommand(command)

    branches = stdout_value.splitlines()
    for branch in branches:
        #print branch
        if branch[0] == "*" and branch[1] == " ":
            curBranch = branch[2:].rstrip("\r\n")
            #print "curBranch='%s'" % curBranch
            break

    #print "currentDir='%s'" % os.getcwd()

    # reset to the original dir
    os.chdir(saveDir)

    return curBranch


</t>
<t tx="stan@picarro-com.20150609175653.25">def handleRemoveReadonly(func, path, exc):
    """
    Error handler for shutil.rmtree().

    If the error is due to an access error (read-only file),
    it attempts to add write permission and then retries.

    If the error is for another reason it re-raises the error.

    Reference: http://stackoverflow.com/questions/1213706/what-user-do-python-scripts-run-as-in-windows/1214935#1214935

    On Unix, will also need to ensure the parent dir is writeable, see the above web page.

    Usage : shutil.rmtree(path, ignore_errors=False, onerror=handleRemoveReadonly)
    """
    excvalue = exc[1]

    if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:
        print "File '%s' is read-only, making it writeable so it can be deleted." % path
        os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO) # 0777
        func(path)
    else:
        # some other error, bubble it up
        print "handleRemoveReadonly: path=%s  errno=%s" % (path, str(excvalue.errno))
        raise


</t>
<t tx="stan@picarro-com.20150609175653.26">###############################################################################

def makeExe(opts):
    """
    Make a HostExe release from a clean checkout.
    """

    # get OS type so we can construct a filename for the JSON config file (e.g., g2000_win7.json)
    # and the log file
    # returns 'XP' (WinXP) or '7' (Win7)
    osType = platform.uname()[2]

    if osType == '7':
        osType = 'win7'
    elif osType == 'XP':
        osType = 'winxp'
    else:
        osType = 'unknown'
        print "Unexpected OS type!"
        sys.exit(1)

    # -------- validate some of the arguments --------
    # product argument is required
    if opts.product is None:
        LogErr("--product option is required!")
        sys.exit(1)

    # osType argument only allowed with --make-official (promote to release)
    if opts.osType is not None:
        if opts.makeOfficial is False:
            LogErr("--ostype must be used with --make-official!")
            sys.exit(1)

        # only win7 or winxp are valid
        if opts.osType == 'win7' or opts.osType == 'winxp':
            osType = opts.osType
        else:
            LogErr("Invalid --ostype argument, must be win7 or winxp!")
            sys.exit(1)

    if opts.archiveOnly is True:
        if opts.makeOfficial is False:
            LogErr("--archive must be used with --make-official!")
            sys.exit(1)

    archiveOnly = opts.archiveOnly

    # --dry-run has been replaced with --debug-local
    # (maybe change --debug-local to --dry-run? main difference is that
    # output folder paths are more closely replicated by --debug-local
    # by just replacing the drive letter with C for the local drive)
    if opts.dryRun:
        print "--dry-run not supported, use --debug-local instead!"
        sys.exit(1)

    if opts.local and opts.dryRun:
        LogErr("--local and --dry-run options cannot be used together!")
        sys.exit(1)

    # Note: opts.cloneAllRepos was set to False if skipping either host or config clones
    if not opts.cloneAllRepos and not opts.local:
        print ""
        print "--debug-skip-all-clone, --debug-skip-host-clone, and"
        print "--debug-skip-config-clone options are intended to be"
        print "used with --debug-local. Be sure to checkout the appropriate"
        print "git branch in the sandbox and perform a 'git pull' in it before continuing."
        print ""
        response = raw_input("Are you sure you want to continue? Y or N: ")

        if response == "Y" or response == "y":
            print "Y typed, continuing"
        else:
            print "Build canceled"
            sys.exit(0)
        
        #LogErr("--debug-skip-all-clone, --debug-skip-host-clone, and --debug-skip-config-clone options are allowed only with --debug-local option!")
        #sys.exit(1)

    # save off clone options
    cloneAllRepos = opts.cloneAllRepos
    cloneConfigRepo = opts.cloneConfigRepo
    cloneHostRepo = opts.cloneHostRepo

    if not opts.buildExes and not opts.local:
        LogErr("--debug-skip-exe is allowed only with --local option!")
        sys.exit(1)

    # get the branch for this script that is executing
    branchScriptCur = getGitBranch(os.getcwd())

    # If building, current branch _must_ match the branch command line option
    # If promoting staged to released, not as critical since copying files, so
    # alert the developer (who may want to bail if script is out of date and
    # release folder structure has changed)
    if not opts.makeOfficial:
        if opts.branch != branchScriptCur:
            LogErr("current git branch must be same as build target branch!")
            sys.exit(1)
    else:
        if opts.branch != branchScriptCur:
            print "Current git branch (%s) should be same as build target branch (%s)!" % (branchScriptCur, opts.branch)

            # Prompt developer and all --make-official to continue
            inStr = raw_input("Proceed with --make-official option (Y or N)? ")
            inStr = inStr.lower()

            # User typed something other than y or Y, bail
            if inStr != 'y':
                sys.exit(1)


    # productFamily incorporates the product and OS type ('g2000_win7' for example)
    productFamily = "%s_%s" % (opts.product, osType)

    # for timing builds and default log filename 
    startSec = time.time()
    startTime = time.localtime()

    # construct a logging filename
    if opts.logfile is not None:
        logfile = opts.logfile
    else:
        logfile = "%s_log_%s" % (productFamily, time.strftime("%Y%m%d_%H%M%S.log", startTime))

    # -------- validate JSON files --------

    productConfigs = "%s_%s.json" % (opts.product, osType)
    versionConfig = "%s_version.json" % opts.product

    if not os.path.isfile(productConfigs):
        LogErr("%s is missing!" % productConfigs)
        sys.exit(1)

    if not os.path.isfile(versionConfig):
        LogErr("%s is missing!" % versionConfig)
        sys.exit(1)

    configInfo = {}

    with open(productConfigs, 'r') as prods:
        configInfo.update(json.load(prods))

    # win7 g2000 builds have categories in the JSON file but winxp g2000 and mobile don't currently.
    # override the hard-coded dir
    global INSTALLER_SCRIPTS_DIR
    global CONFIGS
    global CONFIG_REPOS

    # updated JSON file format is required ()
    INSTALLER_SCRIPTS_DIR = configInfo["installerScriptsDir"]
    buildInfo = configInfo["buildTypes"]

    # CONFIGS is a dict containing analyzer types and species
    # CONFIG_REPOS is a dict containing analyzer types and repo for configs (either
    #   "bzr" or "git", default is "bzr")
    # INSTALLER_SIGNATURES is another dict containing analyzer types and installer signature text
    # if --types option was used, buildInfo will include only the wanted build types
    buildTypesSpecific = False     # default to all build types from JSON file

    if opts.buildTypes is not None:
        # only building specific types
        buildTypesSpecific = True
        negate = False
        typesList = None
        types = opts.buildTypes

        if types[0] == '!':
            negate = True
            typesList = types[1:].split(',')
        else:
            typesList = types.split(',')

        #print "typesList=", typesList

        for item in buildInfo:
            addItem = False

            # negate=True: ignore item if in typesList
            if negate is True and item not in typesList:
                addItem = True

            # negate=False: include item only if in typesList
            elif negate is False and item in typesList:
                addItem = True

            if addItem is True:
                itemDict = buildInfo[item]
                CONFIGS[item] = itemDict["species"]
                INSTALLER_SIGNATURES[item] = itemDict["installerSignature"]
                CONFIG_REPOS[item] = itemDict.get("configRepo", "bzr")

    else:
        # building all types
        for item in buildInfo:
            itemDict = buildInfo[item]
            CONFIGS[item] = itemDict["species"]
            INSTALLER_SIGNATURES[item] = itemDict["installerSignature"]
            CONFIG_REPOS[item] = itemDict.get("configRepo", "bzr")

    #print "CONFIGS=", CONFIGS
    #print ""
    #print "INSTALLER_SIGNATURES=", INSTALLER_SIGNATURES

    # determine config repos needed
    bzrConfigsNeeded = False
    gitConfigsNeeded = False

    for c in CONFIG_REPOS:
        if CONFIG_REPOS[c] == "bzr":
            bzrConfigsNeeded = True
        elif CONFIG_REPOS[c] == "git":
            gitConfigsNeeded = True

    # -------- prepare build options --------

    # version to be built
    changedVersion = True

    #global MFG_DISTRIB_BASE, STAGING_MFG_DISTRIB_BASE
    global DISTRIB_BASE, STAGING_DISTRIB_BASE
    global STAGING_DISTRIB_BASE
    #global TEST_MFG_DISTRIB_BASE, TEST_DISTRIB_BASE

    if not opts.makeOfficial:
        # version
        with open(versionConfig, 'r') as ver:
            VERSION.update(json.load(ver))

        if opts.version:
            m = re.compile(r'(\d+)\.(\d+)\.(\d+)').search(opts.version)
            VERSION['major'] = m.group(1)
            VERSION['minor'] = m.group(2)
            VERSION['revision'] = m.group(3)
            VERSION['build'] = '0'
        else:
            # For local builds, don't bother to bump the version number
            if opts.local is True:
                VERSION['build'] = "%s" % int(VERSION['build'])
                changedVersion = False

            else:
                # Bump the build number if we are continuing with the previous version.
                VERSION['build'] = "%s" % (int(VERSION['build']) + 1)

        if opts.local:
            # use C:\ for local build destination folder paths
            #MFG_DISTRIB_BASE = 'C' + MFG_DISTRIB_BASE[1:]
            DISTRIB_BASE  = 'C' + DISTRIB_BASE [1:]
            #STAGING_MFG_DISTRIB_BASE = 'C' + STAGING_MFG_DISTRIB_BASE[1:]
            STAGING_DISTRIB_BASE = 'C' + STAGING_DISTRIB_BASE[1:]

        # append productFamily to paths (it's something like "g2000_win7")
        #MFG_DISTRIB_BASE = "/".join([MFG_DISTRIB_BASE, productFamily])
        DISTRIB_BASE = "/".join([DISTRIB_BASE, productFamily])
        #STAGING_MFG_DISTRIB_BASE = "/".join([STAGING_MFG_DISTRIB_BASE, productFamily])
        STAGING_DISTRIB_BASE = "/".join([STAGING_DISTRIB_BASE, productFamily])

        #TEST_MFG_DISTRIB_BASE = "/".join([TEST_MFG_DISTRIB_BASE, productFamily])
        #TEST_DISTRIB_BASE = "/".join([TEST_DISTRIB_BASE, productFamily])

    else:
        if opts.local:
            # use C:\ for local build destination folder paths
            DISTRIB_BASE  = 'C' + DISTRIB_BASE [1:]
            STAGING_DISTRIB_BASE = 'C' + STAGING_DISTRIB_BASE[1:]

        # append product to paths used for make-official option
        DISTRIB_BASE = "/".join([DISTRIB_BASE, productFamily])
        STAGING_DISTRIB_BASE = "/".join([STAGING_DISTRIB_BASE, productFamily])

    # print summary of build info so user can review it
    _printSummary(opts, osType, logfile, productFamily, productConfigs, versionConfig,
                  cloneAllRepos=cloneAllRepos,
                  cloneConfigRepo=cloneConfigRepo,
                  bzrConfigsNeeded=bzrConfigsNeeded,
                  cloneHostRepo=cloneHostRepo)

    # ask user for build confirmation before proceeding
    if not opts.skipConfirm:
        print ""
        response = raw_input("OK to continue? Y or N: ")

        if response == "Y" or response == "y":
            print "Y typed, continuing"
        else:
            print "Build canceled"
            sys.exit(0)

    # -------- start of build --------
    #
    # init logging to stdout and stderr
    logger = Logger(logfile, quiet=False)

    # output the start time
    print "Build script start: %s" % time.strftime("%Y/%m/%d %H:%M:%S %p", startTime)

    # reiterate the build summary so it is saved in the log
    _printSummary(opts, osType, logfile, productFamily, productConfigs, versionConfig,
                  cloneAllRepos=cloneAllRepos,
                  cloneConfigRepo=cloneConfigRepo,
                  bzrConfigsNeeded=bzrConfigsNeeded,
                  cloneHostRepo=cloneHostRepo)

    # if bzr repos not needed, fix up clone repo settings
    if bzrConfigsNeeded is False:
        cloneAllRepos = False
        cloneConfigRepo = False

    # set the quiet flag if option set
    logger.set_quiet(opts.debugQuiet)

    # --local: modify base paths for testing on local C: drive
    #
    # we're no longer writing anything to the following R drive folders:
    #   MFG_DISTRIB_BASE            R:/G2000_HostSoftwareInstallers
    #   STAGING_MFG_DISTRIB_BASE    R:/G2000_HostSoftwareInstallers_Staging
    #
    if opts.local:
        # make sure dirs exist on the local drive
        #if not os.path.exists(MFG_DISTRIB_BASE):
        #    os.makedirs(MFG_DISTRIB_BASE)

        if not os.path.exists(DISTRIB_BASE):
            os.makedirs(DISTRIB_BASE)

        #if not os.path.exists(STAGING_MFG_DISTRIB_BASE):
            #os.makedirs(STAGING_MFG_DISTRIB_BASE)

        if not os.path.exists(STAGING_DISTRIB_BASE):
            os.makedirs(STAGING_DISTRIB_BASE)

    if opts.dryRun:
        print "--dry-run feature not implemented, aborting!"
        sys.exit(1)


        """
        targetMfgDistribBase = TEST_MFG_DISTRIB_BASE
        targetDistribBase = TEST_DISTRIB_BASE

        # TODO: only remove the dir itself so we don't lose everything
        #       I haven't been using --dry-run so ignoring for now. tw
        if os.path.isdir(targetMfgDistribBase):
            shutil.rmtree(targetMfgDistribBase, ignore_errors=False, onerror=handleRemoveReadonly)

        if os.path.isdir(targetDistribBase):
            shutil.rmtree(targetDistribBase, ignore_errors=False, onerror=handleRemoveReadonly)

        os.makedirs(targetMfgDistribBase)
        os.makedirs(targetDistribBase)

        for c in CONFIGS:
            os.makedirs(os.path.join(targetDistribBase, c, 'Archive'))
            os.makedirs(os.path.join(targetDistribBase, c, 'Current'))
        """

    else:
        #targetMfgDistribBase = MFG_DISTRIB_BASE
        #targetMfgDistribBase = None
        targetDistribBase = DISTRIB_BASE

    if opts.makeOfficial:
        # promote the release installers and return
        _promoteStagedRelease(types=opts.buildTypes,
                              #mfgDistribBase=targetMfgDistribBase,
                              distribBase=targetDistribBase,
                              versionConfig=versionConfig,
                              product=productFamily,
                              osType=osType,
                              archiveOnly=archiveOnly)

        _buildDoneMsg("MAKE-OFFICIAL", startSec, logfile)
        return

    with open(versionConfig, 'w') as ver:
        json.dump(VERSION, ver)

    # Commit and push new version number if it was changed
    if changedVersion is True:
        print "git.exe add %s" % versionConfig
        retCode = subprocess.call(['git.exe',
                                   'add',
                                   versionConfig])

        if retCode != 0:
            LogErr('Error staging new version metadata in local repo, retCode=%d.' % retCode)
            sys.exit(1)

        print "git.exe commit -m release.py version update (%s)." % _verAsString(productFamily, VERSION)
        retCode = subprocess.call(['git.exe',
                                   'commit',
                                   '-m',
                                   "release.py version update (%s)." % _verAsString(productFamily, VERSION)])

        if retCode != 0:
            LogErr('Error committing new version metadata to local repo, retCode=%d.' % retCode)
            sys.exit(1)

        print "git.exe push"
        retCode = subprocess.call(['git.exe',
                                   'push'])

        if retCode != 0:
            LogErr('Error pushing new version metadata to repo, retCode=%d.' % retCode)

    else:
        print "Version number was not changed, skipping update version metadata in local repo."

    if cloneAllRepos or cloneHostRepo:
        _branchFromRepo(opts.branch)
    else:
        print "Skipping cloning of Git repo."

        # do a quick test for existence of the sandbox dir (won't ensure build integrity though)
        if not os.path.exists(SANDBOX_DIR):
            LogErr("Sandbox directory containing repos does not exist!")
            sys.exit(1)

    _generateReleaseVersion(productFamily, VERSION)

    if opts.buildExes:
        _buildExes()
    else:
        print "Skipping building executables"

        # quick test for existence of sandbox dir and dist folders
        if not os.path.exists(SANDBOX_DIR):
            LogErr("Sandbox directory containing repos does not exist!")
            sys.exit(1)

        exeDir = os.path.join(SANDBOX_DIR, "host", "Host", "dist")
        if not os.path.exists(exeDir):
            LogErr("'%s' does not exist!" % exeDir)
            sys.exit(1)

        exeDir = os.path.join(SANDBOX_DIR, "host", "MobileKit", "dist")
        if not os.path.exists(exeDir):
            LogErr("'%s' does not exist!" % exeDir)
            sys.exit(1)

    # XXX This is likely superfluous once the configuration files have
    # been merged into the main repository.
    if cloneAllRepos or cloneConfigRepo:
        if bzrConfigsNeeded is True:
            _makeLocalConfig()
        else:
            print "Bzr configs not used by installers, skipping cloning of Bzr repos"
    else:
        print "Skipping cloning of Bzr config repos"

    # If any configs in git repository, create version.ini files for them
    if gitConfigsNeeded is True:
        _setGitConfigVer(opts.createTag, productFamily, VERSION)

    if opts.createInstallers:
        _compileInstallers(productFamily, osType, VERSION)
    else:
        print "Skipping creating the installers."

    if opts.createTag:
        _tagRepository(productFamily, VERSION)

        # Only tag bzr repos if they were used.
        # These should be removed when we finish merging the
        # configuration file directories into the repository.
        if bzrConfigsNeeded is True:
            _tagCommonConfig(productFamily, VERSION)
            _tagAppInstrConfigs(productFamily, VERSION)
    else:
        print "Skipping tagging of the repository."

    # Copy both HostExe and AnalyzerServerExe for non-installer upgrades.
    _copyBuildAndInstallers(versionConfig, productFamily, osType, VERSION, customBuild=buildTypesSpecific)

    _buildDoneMsg("BUILD", startSec, logfile)


</t>
<t tx="stan@picarro-com.20150609175653.27">def _promoteStagedRelease(types=None,
                          #mfgDistribBase=None,
                          distribBase=None,
                          versionConfig=None,
                          product=None,
                          osType=None,
                          archiveOnly=False):
    """
    Move the existing staged release to an official directory.
    CONFIGS already contains the types to promote.
    """

    # build a sorted list to handle alphabetically
    configTypes = []
    for c in CONFIGS:
        configTypes.append(c)
    configTypes.sort()

    """
    print "_promoteStagedRelease:"
    print "  types=", types
    #print "  mfgDistribBase=", mfgDistribBase
    print "  distribBase=", distribBase
    print "  versionConfig=", versionConfig
    print "  product=", product
    print "  osType=", osType
    print ""
    print "CONFIGS=", CONFIGS
    print "configTypes=", configTypes
    print "STAGING_DISTRIB_BASE=", STAGING_DISTRIB_BASE
    print ""
    """

    print "promoting staged software to release:"

    for c in configTypes:
        # target parent dir for the installer, e.g.:
        #   S:\CRDS\CRD Engineering\Software\G2000\Installer\g2000_win7\CFADS
        targetDir = os.path.join(distribBase, c)

        # staging dir (source dir for installer)
        stagingDir = os.path.join(STAGING_DISTRIB_BASE, c)

        # delete the existing Current folder since its contents will be
        # replaced with the new installer (if not only archiving)
        currentDir = os.path.join(targetDir, 'Current')
        archiveDir = os.path.join(targetDir, 'Archive')

        if archiveOnly is False:
            if os.path.isdir(currentDir):
                shutil.rmtree(currentDir, ignore_errors=False, onerror=handleRemoveReadonly)

            # create the Current folder
            if not os.path.isdir(currentDir):
                os.makedirs(currentDir)

        # always create the Archive dir if it doesn't exist
        if not os.path.isdir(archiveDir):
            os.makedirs(archiveDir)

        # get a list of all the files in the staging dir (doesn't include . or ..)
        # only one file is expected to be in the folder
        fileList = os.listdir(stagingDir)
        assert len(fileList) == 1

        # validation: filename must begin with 'setup_', has .exe extension
        installer = fileList[0]
        assert installer.lower().find('setup_') == 0
        assert installer.lower().endswith('.exe')

        # copy the installer from the staging folder to both Archive and Current
        print "  staged from: '%s'" % os.path.join(stagingDir, installer)
        print "   to Archive: '%s'" % os.path.join(archiveDir, installer)

        # call copy2() to preserve the modify date (copyfile() does not)
        shutil.copy2(os.path.join(stagingDir, installer),
                     os.path.join(archiveDir, installer))

        if archiveOnly is False:
            print "   to Current: '%s'" % os.path.join(currentDir, installer)

            shutil.copy2(os.path.join(stagingDir, installer),
                         os.path.join(currentDir, installer))

        print ""


</t>
<t tx="stan@picarro-com.20150609175653.28">def _copyBuildAndInstallers(versionConfig, product, osType, ver, customBuild=False):
    """
    Move the installers and the two compiled exe directories to their
    staging location so other people can find them.
    """

    # For handling things alphabetically
    configTypes = []
    for c in CONFIGS:
        configTypes.append(c)
    configTypes.sort()

    # Clean the previously staged version.
    #

    # If this a custom build (only specific installers not everything), then
    # we cannot wipe out the entire staging area
    if customBuild is False:
        try:
            #shutil.rmtree(STAGING_MFG_DISTRIB_BASE, ignore_errors=False, onerror=handleRemoveReadonly)
            shutil.rmtree(STAGING_DISTRIB_BASE, ignore_errors=False, onerror=handleRemoveReadonly)
        except OSError:
            # Okay if these directories don't already exist.
            pass
    else:
        # remove only trees for the specific instrument types that were built
        for c in configTypes:
            treeBase = os.path.normpath(os.path.join(STAGING_DISTRIB_BASE, c))
            print "treeBase=", treeBase

            try:
                shutil.rmtree(treeBase, ignore_errors=False, onerror=handleRemoveReadonly)
            except OSError:
                # Okay if these directories don't already exist.
                pass

    """
    # Not copying the build exes to the R: drive anymore...
    # Too easy for Mfg. to abuse this by copying over the exe dirs and
    # config files without running an installer.
    # HostExe
    hostExeDir = os.path.join(STAGING_MFG_DISTRIB_BASE, 'HostExe')

    if os.path.isdir(hostExeDir):
        os.rmdir(hostExeDir)
    assert not os.path.isdir(hostExeDir)
    os.makedirs(hostExeDir)

    dir_util.copy_tree(os.path.join(SANDBOX_DIR, 'host', 'Host', 'dist'),
                       hostExeDir)

    # AnalyzerServerExe
    analyzerServerExe = os.path.join(STAGING_MFG_DISTRIB_BASE,
                                     'AnalyzerServerExe')

    if os.path.isdir(analyzerServerExe):
        os.rmdir(analyzerServerExe)
    assert not os.path.isdir(analyzerServerExe)
    os.makedirs(analyzerServerExe)

    dir_util.copy_tree(os.path.join(SANDBOX_DIR, 'host', 'MobileKit', 'dist'),
                       analyzerServerExe)
    """

    # Copy the individual installers and update the shortcuts that are
    # used by manufacturing.
    for c in configTypes:
        installer = "setup_%s_%s_%s.exe" % (c, CONFIGS[c],
                                            _verAsString(product, ver))
        targetDir = os.path.join(STAGING_DISTRIB_BASE, c)

        if not os.path.isdir(targetDir):
            os.makedirs(targetDir)

        shutil.copyfile(os.path.join(SANDBOX_DIR, 'Installers', installer),
                        os.path.join(targetDir, installer))

        # put a copy of the version file in the installer staging folder
        # (do we really need it? we're no longer dropping the version # from
        # the installer filename, could be a sanity check for the promote
        # to official)
        #shutil.copyfile(versionConfig, os.path.join(targetDir, versionConfig))

    # no longer saving the JSON file with the build number as
    # the installer filenames always contain the version (not renamed anymore),
    # version is baked into the installer exe as well as the
    # individual host app executables previously built
    #shutil.copyfile(versionConfig,
    #                os.path.join(STAGING_DISTRIB_BASE, versionConfig))


</t>
<t tx="stan@picarro-com.20150609175653.29">def _branchFromRepo(branch):
    """
    Branch the named repository into the sandbox.
    """

    if os.path.exists(SANDBOX_DIR):
        print "Removing previous sandbox at '%s'." % SANDBOX_DIR

        # First fix up the permissions on some pesky .idx and .pack files
        # If they exist, they are read-only and shutil.rmtree() will bail
        packFolder = os.path.join(SANDBOX_DIR, 'host', '.git', 'objects', 'pack')

        if os.path.isdir(packFolder):
            packFiles = os.listdir(packFolder)

            for f in packFiles:
                # fix up permissions
                print "chmod(%s)" % os.path.join(packFolder, f)
                os.chmod(os.path.join(packFolder, f),
                         stat.S_IREAD | stat.S_IWRITE)

        # now remove the sandbox tree
        print "Removing sandbox tree '%s'." % SANDBOX_DIR

        # sometimes this fails with the following error:
        #    WindowsError: [Error 145] The directory is not empty: 'c:/temp/sandbox'
        # I think it takes a little time for things to settle after the chmod above
        # so make a second attempt after a short wait
        try:
            shutil.rmtree(SANDBOX_DIR, ignore_errors=False, onerror=handleRemoveReadonly)
        except:
            print "rmtree failed! sleep(5) and attempt shutil.rmtree one more time"
            time.sleep(5)
            shutil.rmtree(SANDBOX_DIR, ignore_errors=False, onerror=handleRemoveReadonly)

        print "Sandbox tree removed."

    print "Creating sandbox tree '%s'." % SANDBOX_DIR
    os.makedirs(SANDBOX_DIR)
    print "Sandbox tree creation done."
    os.makedirs(os.path.join(SANDBOX_DIR, 'Installers'))

    print "Clone git repo '%s'" % REPO_BASE
    with OS.chdir(SANDBOX_DIR):
        retCode = subprocess.call(['git.exe',
                                   'clone',
                                   REPO_BASE])

        if retCode != 0:
            LogErr("Error cloning '%s', retCode=%d" % (REPO_BASE, retCode))
            sys.exit(retCode)

        print "Check out git branch '%s'." % branch
        with OS.chdir(os.path.join(SANDBOX_DIR, 'host')):
            retCode = subprocess.call(['git.exe',
                                       'checkout',
                                       branch])

            if retCode != 0:
                LogErr("Error checking out 'origin/%s', retCode=%d." % (branch, retCode))
                sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175653.3"># for logging stdout and stderr to a log file
class StdoutLogger(object):
    @others
</t>
<t tx="stan@picarro-com.20150609175653.30">def _generateReleaseVersion(product, ver):
    """
    Create the version metadata used by the executables and update the
    pretty version string.
    """

    with OS.chdir(os.path.join(SANDBOX_DIR, 'host')):
        with open(os.path.join('Host', 'Common',
                               'release_version.py'), 'w') as fp:
            fp.writelines(
                ["# autogenerated by release.py, %s\n" % time.asctime(),
                 "\n",
                 "def versionString():\n",
                 "    return '%s'\n" % _verAsString(product, ver),
                 "\n",
                 "def versionNumString():\n",
                 "    return '%s'\n" % _verAsNumString(ver),
                 "\n",
                 "def buildType():\n",
                 "    return ''\n",
                 "\n"])


</t>
<t tx="stan@picarro-com.20150609175653.31">def _buildExes():
    """
    Build host executables.
    """

    buildEnv = dict(os.environ)
    buildEnv.update({'PYTHONPATH' : "%s;%s" %
                    (os.path.join(SANDBOX_DIR, 'host'),
                    os.path.join(SANDBOX_DIR, 'host', 'Firmware')
                    )})

    # MobileKit must be built first since the HostExe build will copy
    with OS.chdir(os.path.join(SANDBOX_DIR, 'host', 'MobileKit')):
        retCode = subprocess.call(['python.exe', 'setup.py', 'py2exe'],
                                  env=buildEnv)

        if retCode != 0:
            LogErr("Error building MobileKit. retCode=%d" % retCode)
            sys.exit(retCode)

    with OS.chdir(os.path.join(SANDBOX_DIR, 'host', 'Host')):
        retCode = subprocess.call(['python.exe', 'PicarroExeSetup.py',
                                   'py2exe'],
                                   env=buildEnv)

        if retCode != 0:
            LogErr("Error building Host. retCode=%d" % retCode)
            sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175653.32">def _tagRepository(product, ver):
    """
    Tags the repository
    """

    print ""
    print "Tagging repository..."

    tagName = _verAsString(product, ver)
    print "  git tag -a %s -m \"Version %s\"" % (tagName, tagName)

    retCode = subprocess.call(['git.exe',
                               'tag',
                               '-a',
                               tagName,
                               '-m',
                               "Version %s" % tagName])

    if retCode != 0:
        LogErr("Error tagging repository. retCode=%d  tagName='%s'" % (retCode, tagName))
        sys.exit(retCode)

    print "  git push origin %s" % tagName
    retCode = subprocess.call(['git.exe',
                               'push',
                               'origin',
                               tagName])

    if retCode != 0:
        LogErr("Error pushing tag to repository. retCode=%d  tagName='%s'" % (retCode, tagName))
        sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175653.33">def _tagCommonConfig(product, ver):
    retCode = subprocess.call(['bzr.exe', 'tag', "--directory=%s" %
                               COMMON_CONFIG, _verAsString(product, ver)])

    if retCode != 0:
        LogErr("Error tagging CommonConfig as '%s'. retCode=%d." % (_verAsString(product, ver), retCode))
        sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175653.34">def _tagAppInstrConfigs(product, ver):
    """
    Tag the AppConfig and InstrConfig repos for each variant. Unlike
    tagOnly.bat, on which this routine is based, we will _not_ also
    tag the config branches in the sandbox. The branches in the
    sandbox will have common ancestor revisions with the master repos
    on S:. If you need the revision of a tag look at the master repo
    on S:. Eventually this will all be moot once we merge the
    configurations into the main repo.
    """

    with OS.chdir(SANDBOX_DIR):
        # tag configs alphabetically by instrument type (nicety for monitoring build progress)
        configTypes = []
        for c in CONFIGS:
            configTypes.append(c)
        configTypes.sort()

        for c in configTypes:
            configBase = os.path.join(CONFIG_BASE, "%sTemplates" % c)

            retCode = subprocess.call(['bzr.exe', 'tag',
                                       "--directory=%s" %
                                       os.path.join(configBase, 'AppConfig'),
                                       _verAsString(product, ver)])

            if retCode != 0:
                LogErr("Error tagging '%s' AppConfig as '%s', retCode=%d." % \
                    (c, _verAsString(product, ver)), retCode)
                sys.exit(retCode)

            retCode = subprocess.call(['bzr.exe', 'tag',
                                       "--directory=%s" %
                                       os.path.join(configBase, 'InstrConfig'),
                                       _verAsString(product, ver)])

            if retCode != 0:
                LogErr("Error tagging '%s' InstrConfig as '%s', retCode=%d." % \
                    (c, _verAsString(product, ver)), retCode)
                sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175653.35">def _makeLocalConfig():
    """
    Adds physical copies of all of the configuration file repositories to the
    sandbox and generates the required version.ini file.
    """

    # get configs alphabetically by instrument type (nicety for monitoring build progress)
    # include only analyzer types using bzr repo for the configs
    configTypes = []
    for c in CONFIGS:
        if CONFIG_REPOS[c] == "bzr":
            configTypes.append(c)
    configTypes.sort()

    if len(configTypes) == 0:
        # cloning repos only if configs for at least one analyzer from bzr
        # NB: makeExe() logic shouldn't be calling this at all...
        print "_makeLocalConfig: no configs from bzr, skipping cloning"
        return

    with OS.chdir(SANDBOX_DIR):
        print "_makeLocalConfig: current dir='%s'" % os.getcwd()

        configDir = os.path.normpath(COMMON_CONFIG)
        print "subprocess.call([bzr.exe, branch, %s, CommonConfig])" % configDir
        retCode = subprocess.call(['bzr.exe', 'branch', configDir, "CommonConfig"])

        if retCode != 0:
            LogErr("Error cloning CommonConfig. retCode=%d" % retCode)
            sys.exit(retCode)

        with open(os.path.join('CommonConfig', 'version.ini'), 'w') as fp:
            print "subprocess.call([bzr.exe, version-info, CommonConfig, --custom --template=%s])" % VERSION_TEMPLATE
            retCode = subprocess.call(['bzr.exe', 'version-info',
                                       'CommonConfig', '--custom',
                                       "--template=%s" % VERSION_TEMPLATE],
                                       stdout=fp)

            if retCode != 0:
                LogErr("Error generating version.ini for CommonConfig. retCode=%d" % retCode)
                sys.exit(retCode)

        for c in configTypes:
            print "Getting configs for '%s'" % c
            os.mkdir(c)
            with OS.chdir(c):
                # clone AppConfig branch
                templatesPath = os.path.normpath(os.path.join(CONFIG_BASE, "%sTemplates" % c,'AppConfig'))
                print "subprocess.call([bzr.exe, branch, %s, AppConfig])" % templatesPath

                retCode = subprocess.call(['bzr.exe', 'branch',
                                           templatesPath,
                                           'AppConfig'])

                if retCode != 0:
                    LogErr("Error cloning '%s' AppConfig. retCode=%d" % (c, retCode))
                    sys.exit(retCode)

                # get AppConfig version
                with open(os.path.join('AppConfig', 'version.ini'), 'w') as fp:
                    print "subprocess.call([bzr.exe, version-info, AppConfig, --custom --template=%s])" % VERSION_TEMPLATE

                    retCode = subprocess.call(['bzr.exe', 'version-info',
                                               'AppConfig', '--custom',
                                               "--template=%s" %
                                               VERSION_TEMPLATE],
                                               stdout=fp)

                    if retCode != 0:
                        LogErr("Error generating '%s' AppConfig version.ini. retCode=%d" % (c, retCode))
                        sys.exit(retCode)

                # clone InstrConfig branch
                templatesPath = os.path.join(CONFIG_BASE, "%sTemplates" % c,'InstrConfig')
                print "subprocess.call([bzr.exe, branch, %s, InstrConfig])" % templatesPath

                retCode = subprocess.call(['bzr.exe', 'branch',
                                           os.path.join(CONFIG_BASE,
                                                        "%sTemplates" % c,
                                                        'InstrConfig'),
                                                        'InstrConfig'])
                if retCode != 0:
                    LogErr("Error cloning '%s' InstrConfig. retCode=%d" % (c, retCode))
                    sys.exit(retCode)

                # get InstrConfig version
                with open(os.path.join('InstrConfig', 'version.ini'), 'w') as fp:
                    print "subprocess.call([bzr.exe, version-info, InstrConfig, --custom --template=%s])" % VERSION_TEMPLATE

                    retCode = subprocess.call(['bzr.exe', 'version-info',
                                               'InstrConfig', '--custom',
                                               "--template=%s" %
                                               VERSION_TEMPLATE],
                                               stdout=fp)

                    if retCode != 0:
                        LogErr("Error generating '%s' InstrConfig version.ini. retCode=%d" % (c, retCode))
                        sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175653.36">def _createGitConfigVersionFile(configDir, ver, branchName):
    # get git log info to be stored in version.ini
    #
    # revno is short SHA1 value
    revno, stdout_value = runCommand("git.exe log -1 --pretty=format:%h")

    if stdout_value is not None:
        LogErr("Error '%s' getting revno" % stdout_value)
        return 1

    # last modify date
    lastModDate, stdout_value = runCommand("git.exe log -1 --pretty=format:%ai")

    if stdout_value is not None:
        LogErr("Error '%s' getting lastModDate" % stdout_value)
        return 1

    # build a revision_id string so it is a similar format to the bzr output
    #
    #   last modify date, UNIX timestamp
    tval, stdout_value = runCommand("git.exe log -1 --pretty=format:%at")
    #print "UNIX timestamp tval=", tval

    if stdout_value is not None:
        LogErr("Error '%s' getting tval" % stdout_value)
        return 1

    #   convert to YYYYMMDDHHMMSS string
    tm = time.gmtime(float(tval))
    #print "tm=", tm

    tmStr = time.strftime("%Y%m%d%H%M%S", tm)

    #   last mod author email
    emailStr, stdout_value = runCommand("git.exe log -1 --pretty=format:%ae")

    if stdout_value is not None:
        LogErr("Error '%s' getting emailStr" % stdout_value)
        return 1

    #  full SHA1
    idStr, stdout_value = runCommand("git.exe log -1 --pretty=format:%H")

    if stdout_value is not None:
        LogErr("Error '%s' getting idStr (SHA1)" % stdout_value)
        return 1

    revision_id = emailStr + "-" + tmStr + "-" + idStr

    # write the version.ini file
    with open(os.path.join(configDir, "version.ini"), 'w') as fp:
        fp.writelines(
            ["# autogenerated by release.py, %s\n" % time.asctime(),
             "\n",
             "[Version]\n",
             "revno = %s\n" % revno,
             "date = %s\n" % lastModDate,
             "revision_id = %s\n" % revision_id,
             "build_ver = %s\n" % _verAsNumString(ver)
             ])

        # include branch nickname if caller passed it in
        if branchName is not None:
            fp.writelines(
                ["branch_nick = %s\n" % branchName])

    # return with no errors
    return 0


</t>
<t tx="stan@picarro-com.20150609175653.37">def _setGitConfigVer(createTag, product, ver):
    """
    Generates the required version.ini files for git configs.
    """

    # handle configs alphabetically by instrument type (nicety for monitoring build progress)
    # include only analyzer types using git repo for the configs
    configTypes = []
    for c in CONFIGS:
        if CONFIG_REPOS[c] == "git":
            configTypes.append(c)
    configTypes.sort()

    if len(configTypes) == 0:
        # create version.ini files only if configs for at least one analyzer from git
        # Note: makeExe() logic shouldn't be calling this at all...
        print "_setGitConfigVer: no configs from git, skipping create config version"
        return

    print "Creating version.ini for git configs"

    branchName = getGitBranch(os.path.join(SANDBOX_DIR, "host"))

    # cd to the parent dir for git output (can really be anywhere in the branch)
    with OS.chdir(os.path.join(SANDBOX_DIR, "host")):
        configParentDir = os.path.normpath(os.path.join(SANDBOX_DIR, "host", "Config"))

        # version.ini for CommonConfig
        ret = _createGitConfigVersionFile(os.path.join(configParentDir, 'CommonConfig'),
                                          ver, branchName)

        if ret != 0:
            LogErr("Error creating version.ini for CommonConfig")
            sys.exit(1)

        for c in configTypes:
            # version.ini for analyzer types using git repo for configs
            ret = _createGitConfigVersionFile(os.path.join(configParentDir, c, "AppConfig"),
                                              ver, branchName)

            if ret != 0:
                LogErr("Error creating version.ini for AppConfig for %s" % c)
                sys.exit(1)

            ret = _createGitConfigVersionFile(os.path.join(configParentDir, c, "InstrConfig"),
                                              ver, branchName)

            if ret != 0:
                LogErr("Error creating version.ini for InstrConfig for %s" % c)
                sys.exit(1)


</t>
<t tx="stan@picarro-com.20150609175653.38">def _compileInstallers(product, osType, ver):
    """
    Compiles the installers for each variant. The original runCompInstallers.bat
    used Compil32.exe, but if we use ISCC.exe we should be able to bypass the
    requirement that each .iss file have its version string updated manually.
    """

    # build alphabetically by instrument type (nicety for monitoring build progress)
    configTypes = []
    for c in CONFIGS:
        configTypes.append(c)
    configTypes.sort()

    # save off the current dir to build a path to the installer dir
    currentDir = os.getcwd()

    for c in configTypes:
        print "Compiling '%s'..." % c

        isccApp = ISCC

        if osType == 'win7':
            isccApp = ISCC_WIN7

        # Note: .iss files are coming from a subfolder under this release.py dir,
        #        NOT the sandbox tree.
        #
        # Build a fully qualified path for the scripts folder, so ISCC can find
        # the include files (can't find them using a relative path here).
        installScriptDir = os.path.join(currentDir, INSTALLER_SCRIPTS_DIR)
        setupFilePath = "%s\\setup_%s_%s.iss" % (installScriptDir, c, CONFIGS[c])

        repo = CONFIG_REPOS[c]
        if repo == "git":
            # config files in git are in host\Config under the sandbox folder
            configDir = os.path.normpath(os.path.join(SANDBOX_DIR, "host", "Config"))
        elif repo == "bzr":
            # bzr configs are under the sandbox folder
            configDir = SANDBOX_DIR
        else:
            LogErr("Invalid repo '%s' for %s" % (repo, c))
            sys.exit(1)

        print "building from '%s'" % setupFilePath

        # Write the installerSignature.txt file into the sandbox config folder for this
        # analyzer type.
        sigLine = INSTALLER_SIGNATURES[c]
        sigFilePath = os.path.normpath(os.path.join(configDir, c, "installerSignature.txt"))
        f = open(sigFilePath, "w")
        f.write(sigLine)
        f.close()

        # Notes:
        #
        # installerVersion: must be of the form x.x.x.x, for baking version number
        #                   into setup_xxx.exe metadata (for Explorer properties)
        # hostVersion:      e.g., g2000_win7-x.x.x-x, displayed in the installer UI
        # productVersion:   used for displaying Product version in Explorer properties
        currentYear = time.strftime("%Y")

        args = [isccApp, "/dinstallerType=%s" % c,
                "/dhostVersion=%s" % _verAsString(product, ver),
                "/dinstallerVersion=%s" % _verAsNumString(ver),
                "/dproductVersion=%s" % _verAsUINumString(ver),
                "/dproductYear=%s" % currentYear,
                "/dresourceDir=%s" % RESOURCE_DIR,
                "/dsandboxDir=%s" % SANDBOX_DIR,
                "/dconfigDir=%s" % configDir,
                "/dcommonName=%s" % CONFIGS[c],
                "/v9",
                "/O%s" % os.path.abspath(os.path.join(SANDBOX_DIR,
                                                        'Installers')),
                setupFilePath]

        print subprocess.list2cmdline(args)
        print "current dir='%s'" % os.getcwd()

        retCode = subprocess.call(args)

        if retCode != 0:
            LogErr("Error building '%s' installer, retCode=%d." % (c, retCode))
            sys.exit(retCode)


</t>
<t tx="stan@picarro-com.20150609175653.39">def _verAsString(product, ver, osType=None):
    """
    Convert a version dict into a human-readable string.
    """

    number = "%(major)s.%(minor)s.%(revision)s-%(build)s" % ver

    if osType is not None:
        return "%s-%s-%s" % (product, osType, number)
    else:
        return "%s-%s" % (product, number)


</t>
<t tx="stan@picarro-com.20150609175653.4">def __init__(self, f, quiet=False):
    self.terminal = sys.stdout
    self.log = f
    sys.stdout = self
    self.quiet = quiet

</t>
<t tx="stan@picarro-com.20150609175653.40">def _verAsNumString(ver):
    """
    Convert a version dict into a string of numbers in this format:
        &lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;.&lt;build&gt;
    """

    number = "%(major)s.%(minor)s.%(revision)s.%(build)s" % ver
    return number


</t>
<t tx="stan@picarro-com.20150609175653.41">def _verAsUINumString(ver):
    """
    Convert a version dict into a string of numbers in this format
    for user-facing info:
        &lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;-&lt;build&gt;
    """

    number = "%(major)s.%(minor)s.%(revision)s-%(build)s" % ver
    return number


</t>
<t tx="stan@picarro-com.20150609175653.42">def main():
    usage = """
%prog [options]

Builds a new release of HostExe, AnalyzerServerExe and all installers.
"""

    parser = OptionParser(usage=usage)
    parser.add_option('-v', '--version', dest='version', metavar='VERSION',
                      default=None, help=('Specify a version for this release '
                                          'and tag it as such in the '
                                          'repository.'))
    parser.add_option('--skip-tag', dest='createTag', action='store_false',
                      default=True, help=('Skip creating a tag, even if a '
                                          'version # is specified.'))
    parser.add_option('--skip-installers', dest='createInstallers',
                      action='store_false', default=True,
                      help=('Skip creating installers.'))
    parser.add_option('--make-official', dest='makeOfficial',
                      action='store_true', default=False,
                      help=('Promote the current release in staging to the '
                            'official distribution channels.'))
    parser.add_option('--types', dest='buildTypes',
                      default=None, help=('Comma-delimited list of analyzer types to build or '
                                          'types to move from staging to the official release '
                                          'area. If the list starts with a "!" every type but those '
                                          'in the list will be built or moved.'))

    # options for --make-official only
    parser.add_option('--ostype', dest='osType',
                      default=None, help=('OS type for promoting the current release to release.'
                                          'Valid arguments are win7 or winxp. Only allowed with the '
                                          '--make-official option.'))

    parser.add_option('--archive', dest='archiveOnly',
                      action='store_true', default=False,
                      help=('When promoting staged to release, copy installers to the Archive folder '
                            'but don\'t copy them to Current. '
                            'Only allowed with the --make-official option.'))

    parser.add_option('--dry-run', dest='dryRun', default=False,
                      action='store_true',
                      help=('Only works with --make-official. Tests the move '
                            'to staging by using a temporary directory as the '
                            'target.'))

    parser.add_option('--product', dest='product', metavar='PRODUCT',
                      default=None, help=('The product line to generate the '
                                          'release for. This option is required.'))
    parser.add_option('--branch', dest='branch', metavar='BRANCH',
                      default='master', help=('The remote branch from which the '
                                              'release is built.'))

    parser.add_option('--no-confirm', dest='skipConfirm',
                      action='store_true', default=False,
                      help=('Don\'t ask for confirmation of build settings before '
                            'proceeding with the build.'))
    parser.add_option('--debug-local', dest='local',
                      action='store_true', default=False,
                      help=('Use local C: drive in place of R: or S: for '
                            'build destination paths. Useful for debugging this build '
                            'script. This option cannot be used in combination with --dry-run.'))

    parser.add_option('--debug-skip-all-clone', dest='cloneAllRepos', action='store_false',
                      default=True, help=('Skip cloning all repositories. The sandbox '
                                          'must already exist from a prior build. Intended '
                                          'for use with --debug-local. Useful for quick '
                                          'testing of minor changes or debugging this build script.'))

    parser.add_option('--debug-skip-host-clone', dest='cloneHostRepo', action='store_false',
                      default=True, help=('Skip cloning the git host repository. The sandbox git repo '
                                          'must already exist from a prior build. Intended '
                                          'for use with --debug-local. Useful for quick '
                                          'testing of minor changes or debugging this build script.'))

    parser.add_option('--debug-skip-config-clone', dest='cloneConfigRepo', action='store_false',
                      default=True, help=('Skip cloning the bzr config repositories. The sandbox repos '
                                          'must already exist from a prior build. Intended '
                                          'for use with --debug-local. Useful for quick '
                                          'testing of minor changes or debugging this build script.'))

    parser.add_option('--debug-skip-exe', dest='buildExes', action='store_false',
                      default=True, help=('Skip building the executables. The sandbox and executables '
                                          'must already exist from a prior build. Intended '
                                          'for use with --debug-local. Useful for quick '
                                          'testing of minor changes or debugging this build script.'))
    parser.add_option('--logfile', dest='logfile', default=None,
                      help=('Use this option to specify a filename for logging '
                            'output from stdout and stderr. A default filename is '
                            'generated using the product, branch, and current time if '
                            'no filename is specified.'))
    parser.add_option('--debug-quiet', dest='debugQuiet',
                      action='store_true', default=False,
                      help=('Only output from stderr is directed to the console. '
                            'The logfile will always contain output from both '
                            'stdout and stderr.'))

    options, _ = parser.parse_args()

    if not options.cloneAllRepos:
        # turn off cloning host and configs repos if cloning all is turned off
        options.cloneHostRepo = False
        options.cloneConfigRepo = False

    elif not options.cloneHostRepo or not options.cloneConfigRepo:
        # if cloning either (or both) host or configs repos is off, not cloning all repos
        options.cloneAllRepos = False

    makeExe(options)


</t>
<t tx="stan@picarro-com.20150609175653.5">def set_quiet(self, quiet):
    self.quiet = quiet

</t>
<t tx="stan@picarro-com.20150609175653.6">def write(self, message):
    if not self.quiet:
        self.terminal.write(message)
    self.log.write(message)
    
</t>
<t tx="stan@picarro-com.20150609175653.7">def flush(self):
    self.log.flush()
    if not self.quiet:
        self.terminal.flush()

</t>
<t tx="stan@picarro-com.20150609175653.8">def close(self):
    #print "StdoutLogger::close()"
    if self.terminal is not None:
        sys.stdout = self.terminal
        self.terminal = None

</t>
<t tx="stan@picarro-com.20150609175653.9">def __del__(self):
    #print "StdoutLogger::__del__()"
    pass


</t>
<t tx="stan@picarro-com.20150609180605.1">Function _buildExes:

1. Set up PYTHONPATH to include host and host\Firmware
2. Build MobileKit directory for Surveyor P3100
3. Build using PicarroExeSetup.py

Usage:
release.py [options]

Builds a new release of HostExe, AnalyzerServerExe and all installers.


Options:
  -h, --help            show this help message and exit
  -v VERSION, --version=VERSION
                        Specify a version for this release and tag it as such
                        in the repository.
  --skip-tag            Skip creating a tag, even if a version # is specified.
  --skip-installers     Skip creating installers.
  --make-official       Promote the current release in staging to the official
                        distribution channels.
  --types=BUILDTYPES    Comma-delimited list of analyzer types to build or
                        types to move from staging to the official release
                        area. If the list starts with a "!" every type but
                        those in the list will be built or moved.
  --ostype=OSTYPE       OS type for promoting the current release to
                        release.Valid arguments are win7 or winxp. Only
                        allowed with the --make-official option.
  --archive             When promoting staged to release, copy installers to
                        the Archive folder but don't copy them to Current.
                        Only allowed with the --make-official option.
  --dry-run             Only works with --make-official. Tests the move to
                        staging by using a temporary directory as the target.
  --product=PRODUCT     The product line to generate the release for. This
                        option is required.
  --branch=BRANCH       The remote branch from which the release is built.
  --no-confirm          Don't ask for confirmation of build settings before
                        proceeding with the build.
  --debug-local         Use local C: drive in place of R: or S: for build
                        destination paths. Useful for debugging this build
                        script. This option cannot be used in combination with
                        --dry-run.
  --debug-skip-all-clone
                        Skip cloning all repositories. The sandbox must
                        already exist from a prior build. Intended for use
                        with --debug-local. Useful for quick testing of minor
                        changes or debugging this build script.
  --debug-skip-host-clone
                        Skip cloning the git host repository. The sandbox git
                        repo must already exist from a prior build. Intended
                        for use with --debug-local. Useful for quick testing
                        of minor changes or debugging this build script.
  --debug-skip-config-clone
                        Skip cloning the bzr config repositories. The sandbox
                        repos must already exist from a prior build. Intended
                        for use with --debug-local. Useful for quick testing
                        of minor changes or debugging this build script.
  --debug-skip-exe      Skip building the executables. The sandbox and
                        executables must already exist from a prior build.
                        Intended for use with --debug-local. Useful for quick
                        testing of minor changes or debugging this build
                        script.
  --logfile=LOGFILE     Use this option to specify a filename for logging
                        output from stdout and stderr. A default filename is
                        generated using the product, branch, and current time
                        if no filename is specified.
  --debug-quiet         Only output from stderr is directed to the console.
                        The logfile will always contain output from both
                        stdout and stderr.
</t>
<t tx="stan@picarro-com.20150609181355.1"># get OS type so we can construct a filename for the JSON config file (e.g., g2000_win7.json)
# and the log file
# returns 'XP' (WinXP) or '7' (Win7)
osType = platform.uname()[2]

if osType == '7':
    osType = 'win7'
elif osType == 'XP':
    osType = 'winxp'
else:
    osType = 'unknown'
    print "Unexpected OS type!"
    sys.exit(1)
</t>
<t tx="stan@picarro-com.20150609181559.1"># product argument is required
if opts.product is None:
    LogErr("--product option is required!")
    sys.exit(1)
</t>
<t tx="stan@picarro-com.20150609181647.1"># osType argument only allowed with --make-official (promote to release)
if opts.osType is not None:
    if opts.makeOfficial is False:
        LogErr("--ostype must be used with --make-official!")
        sys.exit(1)

    # only win7 or winxp are valid
    if opts.osType == 'win7' or opts.osType == 'winxp':
        osType = opts.osType
    else:
        LogErr("Invalid --ostype argument, must be win7 or winxp!")
        sys.exit(1)
</t>
<t tx="stan@picarro-com.20150609181817.1">if opts.archiveOnly is True:
    if opts.makeOfficial is False:
        LogErr("--archive must be used with --make-official!")
        sys.exit(1)

archiveOnly = opts.archiveOnly
</t>
<t tx="stan@picarro-com.20150609182004.1"># --dry-run has been replaced with --debug-local
# (maybe change --debug-local to --dry-run? main difference is that
# output folder paths are more closely replicated by --debug-local
# by just replacing the drive letter with C for the local drive)
if opts.dryRun:
    print "--dry-run not supported, use --debug-local instead!"
    sys.exit(1)

if opts.local and opts.dryRun:
    LogErr("--local and --dry-run options cannot be used together!")
    sys.exit(1)
</t>
<t tx="stan@picarro-com.20150609182127.1"># Note: opts.cloneAllRepos was set to False if skipping either host or config clones
if not opts.cloneAllRepos and not opts.local:
    print ""
    print "--debug-skip-all-clone, --debug-skip-host-clone, and"
    print "--debug-skip-config-clone options are intended to be"
    print "used with --debug-local. Be sure to checkout the appropriate"
    print "git branch in the sandbox and perform a 'git pull' in it before continuing."
    print ""
    response = raw_input("Are you sure you want to continue? Y or N: ")

    if response == "Y" or response == "y":
        print "Y typed, continuing"
    else:
        print "Build canceled"
        sys.exit(0)
    
    #LogErr("--debug-skip-all-clone, --debug-skip-host-clone, and --debug-skip-config-clone options are allowed only with --debug-local option!")
    #sys.exit(1)

# save off clone options
cloneAllRepos = opts.cloneAllRepos
cloneConfigRepo = opts.cloneConfigRepo
cloneHostRepo = opts.cloneHostRepo
</t>
<t tx="stan@picarro-com.20150609182315.1">if not opts.buildExes and not opts.local:
    LogErr("--debug-skip-exe is allowed only with --local option!")
    sys.exit(1)
</t>
<t tx="stan@picarro-com.20150609182529.1"># get the branch for this script that is executing
branchScriptCur = getGitBranch(os.getcwd())

# If building, current branch _must_ match the branch command line option
# If promoting staged to released, not as critical since copying files, so
# alert the developer (who may want to bail if script is out of date and
# release folder structure has changed)
if not opts.makeOfficial:
    if opts.branch != branchScriptCur:
        LogErr("current git branch must be same as build target branch!")
        sys.exit(1)
else:
    if opts.branch != branchScriptCur:
        print "Current git branch (%s) should be same as build target branch (%s)!" % (branchScriptCur, opts.branch)

        # Prompt developer and all --make-official to continue
        inStr = raw_input("Proceed with --make-official option (Y or N)? ")
        inStr = inStr.lower()

        # User typed something other than y or Y, bail
        if inStr != 'y':
            sys.exit(1)
</t>
<t tx="stan@picarro-com.20150609182658.1"># productFamily incorporates the product and OS type ('g2000_win7' for example)
productFamily = "%s_%s" % (opts.product, osType)

# for timing builds and default log filename 
startSec = time.time()
startTime = time.localtime()

# construct a logging filename
if opts.logfile is not None:
    logfile = opts.logfile
else:
    logfile = "%s_log_%s" % (productFamily, time.strftime("%Y%m%d_%H%M%S.log", startTime))
</t>
<t tx="stan@picarro-com.20150609182831.1">productConfigs = "%s_%s.json" % (opts.product, osType)
versionConfig = "%s_version.json" % opts.product

if not os.path.isfile(productConfigs):
    LogErr("%s is missing!" % productConfigs)
    sys.exit(1)

if not os.path.isfile(versionConfig):
    LogErr("%s is missing!" % versionConfig)
    sys.exit(1)
</t>
<t tx="stan@picarro-com.20150610155655.1">configInfo = {}

with open(productConfigs, 'r') as prods:
    configInfo.update(json.load(prods))

# win7 g2000 builds have categories in the JSON file but winxp g2000 and mobile don't currently.
# override the hard-coded dir
global INSTALLER_SCRIPTS_DIR
global CONFIGS
global CONFIG_REPOS

# updated JSON file format is required ()
INSTALLER_SCRIPTS_DIR = configInfo["installerScriptsDir"]
buildInfo = configInfo["buildTypes"]

# CONFIGS is a dict containing analyzer types and species
# CONFIG_REPOS is a dict containing analyzer types and repo for configs (either
#   "bzr" or "git", default is "git")
# INSTALLER_SIGNATURES is another dict containing analyzer types and installer signature text
# if --types option was used, buildInfo will include only the wanted build types
buildTypesSpecific = False     # default to all build types from JSON file
</t>
<t tx="stan@picarro-com.20150610155754.1">if opts.buildTypes is not None:
    # only building specific types
    buildTypesSpecific = True
    negate = False
    typesList = None
    types = opts.buildTypes

    if types[0] == '!':
        negate = True
        typesList = types[1:].split(',')
    else:
        typesList = types.split(',')

    #print "typesList=", typesList

    for item in buildInfo:
        addItem = False

        # negate=True: ignore item if in typesList
        if negate is True and item not in typesList:
            addItem = True

        # negate=False: include item only if in typesList
        elif negate is False and item in typesList:
            addItem = True

        if addItem is True:
            itemDict = buildInfo[item]
            CONFIGS[item] = itemDict["species"]
            INSTALLER_SIGNATURES[item] = itemDict["installerSignature"]
            CONFIG_REPOS[item] = itemDict.get("configRepo", "git")

else:
    # building all types
    for item in buildInfo:
        itemDict = buildInfo[item]
        CONFIGS[item] = itemDict["species"]
        INSTALLER_SIGNATURES[item] = itemDict["installerSignature"]
        CONFIG_REPOS[item] = itemDict.get("configRepo", "git")

#print "CONFIGS=", CONFIGS
#print ""
#print "INSTALLER_SIGNATURES=", INSTALLER_SIGNATURES
</t>
<t tx="stan@picarro-com.20150610155915.1"># determine config repos needed
bzrConfigsNeeded = False
gitConfigsNeeded = False

for c in CONFIG_REPOS:
    if CONFIG_REPOS[c] == "bzr":
        bzrConfigsNeeded = True
    elif CONFIG_REPOS[c] == "git":
        gitConfigsNeeded = True
</t>
<t tx="stan@picarro-com.20150610160202.1"># version to be built
changedVersion = True

#global MFG_DISTRIB_BASE, STAGING_MFG_DISTRIB_BASE
global DISTRIB_BASE, STAGING_DISTRIB_BASE
global STAGING_DISTRIB_BASE
#global TEST_MFG_DISTRIB_BASE, TEST_DISTRIB_BASE

if not opts.makeOfficial:
    # version
    with open(versionConfig, 'r') as ver:
        VERSION.update(json.load(ver))

    if opts.version:
        m = re.compile(r'(\d+)\.(\d+)\.(\d+)').search(opts.version)
        VERSION['major'] = m.group(1)
        VERSION['minor'] = m.group(2)
        VERSION['revision'] = m.group(3)
        VERSION['build'] = '0'
    else:
        # For local builds, don't bother to bump the version number
        if opts.local is True:
            VERSION['build'] = "%s" % int(VERSION['build'])
            changedVersion = False

        else:
            # Bump the build number if we are continuing with the previous version.
            VERSION['build'] = "%s" % (int(VERSION['build']) + 1)

    if opts.local:
        # use C:\ for local build destination folder paths
        #MFG_DISTRIB_BASE = 'C' + MFG_DISTRIB_BASE[1:]
        DISTRIB_BASE  = 'C' + DISTRIB_BASE [1:]
        #STAGING_MFG_DISTRIB_BASE = 'C' + STAGING_MFG_DISTRIB_BASE[1:]
        STAGING_DISTRIB_BASE = 'C' + STAGING_DISTRIB_BASE[1:]

    # append productFamily to paths (it's something like "g2000_win7")
    #MFG_DISTRIB_BASE = "/".join([MFG_DISTRIB_BASE, productFamily])
    DISTRIB_BASE = "/".join([DISTRIB_BASE, productFamily])
    #STAGING_MFG_DISTRIB_BASE = "/".join([STAGING_MFG_DISTRIB_BASE, productFamily])
    STAGING_DISTRIB_BASE = "/".join([STAGING_DISTRIB_BASE, productFamily])

    #TEST_MFG_DISTRIB_BASE = "/".join([TEST_MFG_DISTRIB_BASE, productFamily])
    #TEST_DISTRIB_BASE = "/".join([TEST_DISTRIB_BASE, productFamily])

else:
    if opts.local:
        # use C:\ for local build destination folder paths
        DISTRIB_BASE  = 'C' + DISTRIB_BASE [1:]
        STAGING_DISTRIB_BASE = 'C' + STAGING_DISTRIB_BASE[1:]

    # append product to paths used for make-official option
    DISTRIB_BASE = "/".join([DISTRIB_BASE, productFamily])
    STAGING_DISTRIB_BASE = "/".join([STAGING_DISTRIB_BASE, productFamily])
</t>
<t tx="stan@picarro-com.20150610160254.1"># print summary of build info so user can review it
_printSummary(opts, osType, logfile, productFamily, productConfigs, versionConfig,
              cloneAllRepos=cloneAllRepos,
              cloneConfigRepo=cloneConfigRepo,
              bzrConfigsNeeded=bzrConfigsNeeded,
              cloneHostRepo=cloneHostRepo)

# ask user for build confirmation before proceeding
if not opts.skipConfirm:
    print ""
    response = raw_input("OK to continue? Y or N: ")

    if response == "Y" or response == "y":
        print "Y typed, continuing"
    else:
        print "Build canceled"
        sys.exit(0)
</t>
<t tx="stan@picarro-com.20150610160638.1">#
# init logging to stdout and stderr
logger = Logger(logfile, quiet=False)

# output the start time
print "Build script start: %s" % time.strftime("%Y/%m/%d %H:%M:%S %p", startTime)

# reiterate the build summary so it is saved in the log
_printSummary(opts, osType, logfile, productFamily, productConfigs, versionConfig,
              cloneAllRepos=cloneAllRepos,
              cloneConfigRepo=cloneConfigRepo,
              bzrConfigsNeeded=bzrConfigsNeeded,
              cloneHostRepo=cloneHostRepo)
              
# if bzr repos not needed, fix up clone repo settings
if bzrConfigsNeeded is False:
    cloneAllRepos = False
    cloneConfigRepo = False

# set the quiet flag if option set
logger.set_quiet(opts.debugQuiet)

          
</t>
<t tx="stan@picarro-com.20150610161008.1"># --local: modify base paths for testing on local C: drive
#
# we're no longer writing anything to the following R drive folders:
#   MFG_DISTRIB_BASE            R:/G2000_HostSoftwareInstallers
#   STAGING_MFG_DISTRIB_BASE    R:/G2000_HostSoftwareInstallers_Staging
#
if opts.local:
    # make sure dirs exist on the local drive
    #if not os.path.exists(MFG_DISTRIB_BASE):
    #    os.makedirs(MFG_DISTRIB_BASE)

    if not os.path.exists(DISTRIB_BASE):
        os.makedirs(DISTRIB_BASE)

    #if not os.path.exists(STAGING_MFG_DISTRIB_BASE):
        #os.makedirs(STAGING_MFG_DISTRIB_BASE)

    if not os.path.exists(STAGING_DISTRIB_BASE):
        os.makedirs(STAGING_DISTRIB_BASE)

</t>
<t tx="stan@picarro-com.20150610161157.1">if opts.dryRun:
    print "--dry-run feature not implemented, aborting!"
    sys.exit(1)


    """
    targetMfgDistribBase = TEST_MFG_DISTRIB_BASE
    targetDistribBase = TEST_DISTRIB_BASE

    # TODO: only remove the dir itself so we don't lose everything
    #       I haven't been using --dry-run so ignoring for now. tw
    if os.path.isdir(targetMfgDistribBase):
        shutil.rmtree(targetMfgDistribBase, ignore_errors=False, onerror=handleRemoveReadonly)

    if os.path.isdir(targetDistribBase):
        shutil.rmtree(targetDistribBase, ignore_errors=False, onerror=handleRemoveReadonly)

    os.makedirs(targetMfgDistribBase)
    os.makedirs(targetDistribBase)

    for c in CONFIGS:
        os.makedirs(os.path.join(targetDistribBase, c, 'Archive'))
        os.makedirs(os.path.join(targetDistribBase, c, 'Current'))
    """

else:
    #targetMfgDistribBase = MFG_DISTRIB_BASE
    #targetMfgDistribBase = None
    targetDistribBase = DISTRIB_BASE

</t>
<t tx="stan@picarro-com.20150610161256.1">if opts.makeOfficial:
    # promote the release installers and return
    _promoteStagedRelease(types=opts.buildTypes,
                          #mfgDistribBase=targetMfgDistribBase,
                          distribBase=targetDistribBase,
                          versionConfig=versionConfig,
                          product=productFamily,
                          osType=osType,
                          archiveOnly=archiveOnly)

    _buildDoneMsg("MAKE-OFFICIAL", startSec, logfile)
    return

</t>
<t tx="stan@picarro-com.20150610161404.1">with open(versionConfig, 'w') as ver:
    json.dump(VERSION, ver)

</t>
<t tx="stan@picarro-com.20150610161628.1"># Commit and push new version number if it was changed
if changedVersion is True:
    print "git.exe add %s" % versionConfig
    retCode = subprocess.call(['git.exe',
                               'add',
                               versionConfig])

    if retCode != 0:
        LogErr('Error staging new version metadata in local repo, retCode=%d.' % retCode)
        sys.exit(1)

    print "git.exe commit -m release.py version update (%s)." % _verAsString(productFamily, VERSION)
    retCode = subprocess.call(['git.exe',
                               'commit',
                               '-m',
                               "release.py version update (%s)." % _verAsString(productFamily, VERSION)])

    if retCode != 0:
        LogErr('Error committing new version metadata to local repo, retCode=%d.' % retCode)
        sys.exit(1)

    print "git.exe push"
    retCode = subprocess.call(['git.exe',
                               'push'])

    if retCode != 0:
        LogErr('Error pushing new version metadata to repo, retCode=%d.' % retCode)

else:
    print "Version number was not changed, skipping update version metadata in local repo."

</t>
<t tx="stan@picarro-com.20150610161655.1">if cloneAllRepos or cloneHostRepo:
    _branchFromRepo(opts.branch)
else:
    print "Skipping cloning of Git repo."

    # do a quick test for existence of the sandbox dir (won't ensure build integrity though)
    if not os.path.exists(SANDBOX_DIR):
        LogErr("Sandbox directory containing repos does not exist!")
        sys.exit(1)

</t>
<t tx="stan@picarro-com.20150610161802.1">if opts.buildExes:
    _buildExes()
else:
    print "Skipping building executables"

    # quick test for existence of sandbox dir and dist folders
    if not os.path.exists(SANDBOX_DIR):
        LogErr("Sandbox directory containing repos does not exist!")
        sys.exit(1)

    exeDir = os.path.join(SANDBOX_DIR, "host", "Host", "dist")
    if not os.path.exists(exeDir):
        LogErr("'%s' does not exist!" % exeDir)
        sys.exit(1)

    exeDir = os.path.join(SANDBOX_DIR, "host", "MobileKit", "dist")
    if not os.path.exists(exeDir):
        LogErr("'%s' does not exist!" % exeDir)
        sys.exit(1)

</t>
<t tx="stan@picarro-com.20150610162024.1"># XXX This is likely superfluous once the configuration files have
# been merged into the main repository.
if cloneAllRepos or cloneConfigRepo:
    if bzrConfigsNeeded is True:
        _makeLocalConfig()
    else:
        print "Bzr configs not used by installers, skipping cloning of Bzr repos"
else:
    print "Skipping cloning of Bzr config repos"

</t>
<t tx="stan@picarro-com.20150610162228.1"># If any configs in git repository, create version.ini files for them
if gitConfigsNeeded is True:
    _setGitConfigVer(opts.createTag, productFamily, VERSION)

</t>
<t tx="stan@picarro-com.20150610162410.1">if opts.createInstallers:
    _compileInstallers(productFamily, osType, VERSION)
else:
    print "Skipping creating the installers."

</t>
<t tx="stan@picarro-com.20150610162552.1">if opts.createTag:
    _tagRepository(productFamily, VERSION)

    # Only tag bzr repos if they were used.
    # These should be removed when we finish merging the
    # configuration file directories into the repository.
    if bzrConfigsNeeded is True:
        _tagCommonConfig(productFamily, VERSION)
        _tagAppInstrConfigs(productFamily, VERSION)
else:
    print "Skipping tagging of the repository."

</t>
<t tx="stan@picarro-com.20150610163917.1"># Copy both HostExe and AnalyzerServerExe for non-installer upgrades.
_copyBuildAndInstallers(versionConfig, productFamily, osType, VERSION, customBuild=buildTypesSpecific)

</t>
<t tx="stan@picarro-com.20150610192902.1">@language python
@tabwidth -4
@others
</t>
<t tx="stan@picarro-com.20150610192913.1">import json
import os
import pprint

from pybuilder.core import after, before, use_plugin, init, task
from pybuilder.errors import BuildFailedException

import shutil
import subprocess
import sys
import time

ISCC_WIN7 = 'c:/program files (x86)/Inno Setup 5/ISCC.exe'
INSTALLER_SCRIPTS_DIR = ('src', 'main', 'python', 'Tools', 'Release', 'InstallerScriptsWin7') 

use_plugin("python.core")
use_plugin("python.unittest")
use_plugin("python.install_dependencies")
# use_plugin("python.flake8")
# use_plugin("python.coverage")

default_task = "publish"

</t>
<t tx="stan@picarro-com.20150610192913.2">
@after("prepare")
def setup_buildenv(project, logger):
    official = project.get_property("official", False)
    product = project.get_property("product", "g2000")

    reports_dir = project.expand_path("$dir_reports")
    if not os.path.exists(reports_dir):
        os.mkdir(reports_dir)
    output_file_path = os.path.join(reports_dir, "setup_buildenv")

    logger.info("Setting up build environment")
    cmd = ["doit", "make_release", "--product", product]
    if official:
        cmd.append(["--official"])
    with open(output_file_path, "w") as output_file:
        process = subprocess.Popen(cmd,
                                   stdout=output_file,
                                   stderr=output_file,
                                   shell=False)
        return_code = process.wait()
        if return_code != 0:
            raise BuildFailedException("Error while executing make_release")
</t>
<t tx="stan@picarro-com.20150610192913.3">def write_setup_script(project, logger):
    setup_script = project.expand_path("$dir_dist/Host/setup.py")
    logger.info("Writing setup.py as %s", setup_script)
    shutil.copyfile("testSetup.py", setup_script)
    os.chmod(setup_script, 0o755)

</t>
<t tx="stan@picarro-com.20150610192913.4">def build_binary_distribution(project, logger):
    reports_dir = project.expand_path("$dir_reports/distutils")
    if not os.path.exists(reports_dir):
        os.mkdir(reports_dir)

    setup_script = project.expand_path("$dir_dist/Host/buildHost.py")

    logger.info("Building binary distribution in %s",
                project.expand_path("$dir_dist"))

    command = "buildHost"
    logger.debug("Executing buildHost.py")
    output_file_path = os.path.join(reports_dir, command)
    with open(output_file_path, "w") as output_file:
        commands = [sys.executable, setup_script]
        process = subprocess.Popen(commands,
                                   cwd=project.expand_path("$dir_dist/Host"),
                                   stdout=output_file,
                                   stderr=output_file,
                                   shell=False)
        return_code = process.wait()
        if return_code != 0:
            raise BuildFailedException(
                "Error while executing setup command %s, see %s for details" % (command, output_file_path))
    shutil.move(project.expand_path("$dir_dist/Host/dist"),project.expand_path("$dir_dist/HostExe"))
</t>
<t tx="stan@picarro-com.20150610192913.5">@task
def publish(project, logger):
    pass
</t>
<t tx="stan@picarro-com.20150610193301.1">@task
def compile_sources(project, logger):
    reports_dir = project.expand_path("$dir_reports/compile_sources")
    if not os.path.exists(reports_dir):
        os.mkdir(reports_dir)
    output_file_path = os.path.join(reports_dir, "compile_sources")
    with open(output_file_path, "w") as output_file:
        process = subprocess.Popen(["doit", "compile_sources"],
                                   stdout=output_file,
                                   stderr=output_file,
                                   shell=False)
        return_code = process.wait()
        if return_code != 0:
            raise BuildFailedException("Error while executing compile_sources")
            
</t>
<t tx="stan@picarro-com.20150612091536.1">1. PicarroExeSetup.py produces a file repoBzrVer.py which it places in \target\dist\Host-version. This is obtained from Git. It is used by the Driver to fill out             

versionDict["host version id"] = repoBzrVer['revision_id']
versionDict["host version no"] = repoBzrVer['revno']
versionDict["src version id"] = repoBzrVer['revision_id']
versionDict["src version no"] = repoBzrVer['revno']

PicarroExeSetup.py also produces Host/Common/setup_version.py and fills up the version strings in the executables via the call to py2exe.
Info for setup_version.py comes Host/Common/release_version or from Host/build_version.py (via buildHost.py). The Product name (also set by PicarroExeSetup in py2exe) contains the buildTypeStr which is computed as follows:

    try:
        # First look for release_version which is generated by
        # release.py
        import release_version as buildVersion
        buildTypeStr = buildVersion.buildType()
        print "Release build type: %s" % buildTypeStr
    except Exception, e:
        try:
            # Not found, try setup_version (generated by buildHost.py
            # during internal builds)
            #import build_version as buildVersion
            #buildTypeStr = buildVersion.buildType()
            #print "Setup build type: %s" % buildTypeStr

            # Internal build, includes last git check-in SHA1
            # returns "Internal (&lt;SHA1&gt;)"
            buildTypeStr = hostVersion.versionString()
            print "Setup build type: %s" % buildTypeStr

        except Exception, e:
            # Should never get here...
            buildTypeStr = "DEVELOPMENT"
            print "Release or setup version build type not found, using: %s" % buildTypeStr

    return buildTypeStr




This is not present when we run the Python code.



2. A file build_version.py is placed in the Host directory by buildHost.py. This is similar to
    release_version except for the INTERNAL string

3. A file release_version.py is placed in the Host/Common directory by relase.py




In Host/Common/version.py there is code to get a version string from Git. This is used by Driver from the code:

try:
    # Release build
    from Host.Common import release_version as version
except ImportError:
    try:
        # Internal build
        from Host.Common import setup_version as version
    except ImportError:
        # Internal dev
        from Host.Common import version



When we run an internally-built exe version:



**&lt;reoBzrVersion.py&gt;**

# autogenerated by PicarroExeSetup.py, Thu Jun 11 23:45:18 2015

version_info = {'branch_nick': 'feature/Sze/usePybuilder',
 'build_date': '2015-06-11 23:45:18 -0700',
 'clean': None,
 'date': '2015-06-09 23:54:49 -0700',
 'revision_id': 'stan@picarro.com-20150610065449-37f105b4faf011500b66571618efa44dac096a11',
 'revno': '37f105b'}

revisions = {}

file_revisions = {}

if __name__ == '__main__':
    print 'revision: %(revno)s' % version_info
    print 'nick: %(branch_nick)s' % version_info
    print 'revision id: %(revision_id)s' % version_info

**&lt;build_version.py&gt;**
# autogenerated by buildHost.py, Mon Jun 08 13:55:16 2015

def versionString():
    return 'g2000-INTERNAL-win7-1.5.0-29'

def versionNumString():
    return '1.5.0.29'

def buildType():
    return 'INTERNAL'
    
**&lt;setup_version.py&gt;**
# autogenerated by PicarroExeSetup.py, Mon Jun 08 13:55:33 2015

def versionString():
    return 'Internal (37ea77af2a7b072e4814767e82b47a4e42153900)'
    
    
How are version numbers displayed?
==================================
1. In the SupervisorLauncher
2. In the Controller
3. In the QuickGui
4. In the executable file properties

1. SupervisorLauncher: in HostStartup.py, we find

try:
    # Release build
    from Host.Common import release_version as version
except ImportError:
    try:
        # Internal build
        from Host.Common import setup_version as version
    except ImportError:
        # Internal dev
        from Host.Common import version

2. Controller:    
Calls Driver.allVersions. 

appVer, instrVer and commonVer can be set indirectly via keys in the Driver.ini file. 

[Files]
appVer = ../../version.ini
instrVer = ../../../InstrConfig/version.ini


    def allVersions(self):
        versionDict = {}
        versionDict["interface"] = interface.interface_version
        import pprint
        Log("version = %s" % pprint.pformat(version))
        versionDict["host release"] = version.versionString()
        if repoBzrVer:
            versionDict["host version id"] = repoBzrVer['revision_id']
            versionDict["host version no"] = repoBzrVer['revno']
            versionDict["src version id"] = repoBzrVer['revision_id']
            versionDict["src version no"] = repoBzrVer['revno']
        try:
            versionDict["config - app version no"] = self.ver["appVer"]
            versionDict["config - instr version no"] = self.ver["instrVer"]
            versionDict["config - common version no"] = self.ver["commonVer"]
        except Exception, err:
            print err
        return versionDict

Within the Driver, this is the code that fetches the version numbers from the configuration directories. co["Version"]["revno"] is the relevent field. The configuration files in AppConfig, InstrConfig and CommonConfig are set up by release.py.

The function _setGitConfigVer in release.py creates the version.ini files. It calls _createGitConfigVersionFile for each of the three config folders.

        # Get appConfig and instrConfig version number
        self.ver = {}
        for ver in ["appVer", "instrVer", "commonVer"]:
            try:
                fPath = os.path.join(basePath, self.config["Files"][ver])
                co = CustomConfigObj(fPath)
                self.ver[ver] = co["Version"]["revno"]
            except Exception, err:
                print err
                self.ver[ver] = "N/A"

        
3. QuickGui:
Calls Driver.allVersions()
</t>
<t tx="stan@picarro-com.20150612091639.1"></t>
<t tx="stan@picarro-com.20150612091820.1"></t>
<t tx="stan@picarro-com.20150612091820.10"></t>
<t tx="stan@picarro-com.20150612091820.11"></t>
<t tx="stan@picarro-com.20150612091820.12"></t>
<t tx="stan@picarro-com.20150612091820.13"></t>
<t tx="stan@picarro-com.20150612091820.14"></t>
<t tx="stan@picarro-com.20150612091820.15"></t>
<t tx="stan@picarro-com.20150612091820.16"></t>
<t tx="stan@picarro-com.20150612091820.17"></t>
<t tx="stan@picarro-com.20150612091820.18"></t>
<t tx="stan@picarro-com.20150612091820.19"></t>
<t tx="stan@picarro-com.20150612091820.2"></t>
<t tx="stan@picarro-com.20150612091820.20"></t>
<t tx="stan@picarro-com.20150612091820.21"></t>
<t tx="stan@picarro-com.20150612091820.22"></t>
<t tx="stan@picarro-com.20150612091820.23"></t>
<t tx="stan@picarro-com.20150612091820.24"></t>
<t tx="stan@picarro-com.20150612091820.25"></t>
<t tx="stan@picarro-com.20150612091820.26"></t>
<t tx="stan@picarro-com.20150612091820.27"></t>
<t tx="stan@picarro-com.20150612091820.28"></t>
<t tx="stan@picarro-com.20150612091820.29"></t>
<t tx="stan@picarro-com.20150612091820.3"></t>
<t tx="stan@picarro-com.20150612091820.30"></t>
<t tx="stan@picarro-com.20150612091820.31"></t>
<t tx="stan@picarro-com.20150612091820.32"></t>
<t tx="stan@picarro-com.20150612091820.33"></t>
<t tx="stan@picarro-com.20150612091820.34"></t>
<t tx="stan@picarro-com.20150612091820.35"></t>
<t tx="stan@picarro-com.20150612091820.36"></t>
<t tx="stan@picarro-com.20150612091820.37"></t>
<t tx="stan@picarro-com.20150612091820.38"></t>
<t tx="stan@picarro-com.20150612091820.39"></t>
<t tx="stan@picarro-com.20150612091820.4"></t>
<t tx="stan@picarro-com.20150612091820.40"></t>
<t tx="stan@picarro-com.20150612091820.41"></t>
<t tx="stan@picarro-com.20150612091820.42"></t>
<t tx="stan@picarro-com.20150612091820.43"></t>
<t tx="stan@picarro-com.20150612091820.44"></t>
<t tx="stan@picarro-com.20150612091820.45"></t>
<t tx="stan@picarro-com.20150612091820.46"></t>
<t tx="stan@picarro-com.20150612091820.47"></t>
<t tx="stan@picarro-com.20150612091820.5"></t>
<t tx="stan@picarro-com.20150612091820.6"></t>
<t tx="stan@picarro-com.20150612091820.7"></t>
<t tx="stan@picarro-com.20150612091820.8"></t>
<t tx="stan@picarro-com.20150612091820.9"></t>
<t tx="stan@picarro-com.20150612091900.1"></t>
<t tx="stan@picarro-com.20150612091900.10"></t>
<t tx="stan@picarro-com.20150612091900.11"></t>
<t tx="stan@picarro-com.20150612091900.2"></t>
<t tx="stan@picarro-com.20150612091900.3"></t>
<t tx="stan@picarro-com.20150612091900.4"></t>
<t tx="stan@picarro-com.20150612091900.5"></t>
<t tx="stan@picarro-com.20150612091900.6"></t>
<t tx="stan@picarro-com.20150612091900.7"></t>
<t tx="stan@picarro-com.20150612091900.8"></t>
<t tx="stan@picarro-com.20150612091900.9"></t>
<t tx="stan@picarro-com.20150621191519.1">Use cases
=========
1. Given a version number or a git commit hash and a set of product types, rebuild an installer with the precise code.

2. Having made some changes to the host code and made a commit, make an internal build so that we can do regression testing and check that nothing has been broken. This should be possible from any branch since we may have multiple projects by different developers making changes.

i.e. the build server should be able to make a build at any time - these should simply be tagged by the Git commit hash. There may be version numbers left in the source directories which will populate some of the version number fields when these are requested.

3. After having changed a configuration, make sure that all future installers will make use of the new configuration, and ensure that the version number of the configuration is updated when a change is made.

4. Make official releases.

Keep a file with commit hashes and build numbers. We can always reconstruct a build by fetching this commit. How do we track config version numbers?

Should the utilities that do the builds live in the same repository? Do we always use the latest build scripts or the ones that were in use at the time the code was written?

There are a set of tagged commits from which it is safe to build official distributions.

What if we have a master_G2000, a master_MidIR and a master_Surveyor branch?



N.B. For configuration files, e.g. config/CFADS/AppConfig, there is a version.ini file in that directory which specifies a git commit hash, e.g. 8908a30d. This is the commit which should contain the specified configuration. If we issue the commands

git diff 8908a30d -- dirname
git ls-files -- others with-tree=8908a30d dirname

there should be no changes. It is not permissible to check in a new configuration if these commands indicate there have been changes. If a change has been made, it is necessary to update the version information first before committing the change.


Alternatively, we check with the latest commit to see if there are any changes in the configuration directories. If there are, we must create a new version.ini file with an updated version number.

git diff --summary Config\CFADS
 delete mode 100644 Config/CFADS/AppConfig/Schemes/_CFADS_CO2_Fast_nocal_v2.sch

git ls-files --others Config\CFADS
Config/CFADS/AppConfig/Schemes/_CFADS_CO2_Fast_nocal_v2a.sch




What happens if I specify a commit number - does that give a branch as well?
e.g. cf32d63 21-May-2014 15:06 mobile_win7-2.0.0-1

git reset --hard
git clean -f -d
git checkout cf32d63

&gt; git status
HEAD detached at cf32d63
nothing to commit, working directory clean

There is no branch information for the working tree at this point. If we want to turn this into a branch
 
If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b new_branch_name

In order to switch to another branch, we can use, e.g.,

git checkout feature/sze/usePybuilder




version
product

branch
build-type: release or internal

pyb_ release -P branch="feature/sze/usePybuilder" -P version="1.2.3.4" -P types="AADS,CFADS" 
-P hash="a343082bd3"


1. Need to make sure that the correct branch is checked out from GitHub


Fetching a specific file from a commit using Git and write it to stdout. Note the use of /

git show d11a469:Host/Common/Averager.py



TODO:
a) Checkout a specific commit or branch from git and force working tree to be consistent with that branch
b) Compute hash of a directory subtree and record results in an INI file. Perform check to see if anything has changed in that directory
c) Look at tracking dependencies for entire host project



 </t>
<t tx="stan@picarro-com.20150622135659.1">def task_make_sources_from_xml():
    python_scripts_dir = os.path.join(os.path.dirname(sys.executable))
    src_dir = os.path.join('src','main','python','Firmware','xml')
    python_dir = os.path.join('src','main','python','Host','autogen')
    usb_dir = os.path.join('src','main','python','Firmware','CypressUSB','autogen')
    dsp_dir = os.path.join('src','main','python','Firmware','DSP','autogen')
    return {
        'actions':[
            r'cd %s &amp;&amp; python xmldom1.py' % (src_dir,),
        ],
        'targets':[os.path.join(python_dir,fname) for fname in ['interface.py', 'usbdefs.py']] + \
                  [os.path.join(usb_dir,fname) for fname in ['usbdefs.h', 'usbdefs.inc']] + \
                  [os.path.join(dsp_dir,fname) for fname in ['dspAutogen.c', 'dspAutogen.h', 'interface.h']],
        'file_dep':[os.path.join(src_dir,fname) for fname in ['interface.xml', 'Interface.dtd', 'ParameterPages.xml']],
        'clean': True
    }</t>
<t tx="stan@picarro-com.20150622135727.1">def task_compile_fitutils():
    python_scripts_dir = os.path.join(os.path.dirname(sys.executable))
    src_dir = os.path.join('src','main','python','Host','Fitter')
    f2py = os.path.join(python_scripts_dir, 'f2py.py')
    return {
        'actions':[
            r'cd %s &amp;&amp; if exist fitutils.pyd del fitutils.pyd' % src_dir,
            r'cd %s &amp;&amp; python %s -c -m fitutils fitutils.f --compiler=mingw32' % (src_dir, f2py),
        ],
        'targets':[os.path.join(src_dir,'fitutils.pyd')],
        'file_dep':[os.path.join(src_dir,'fitutils.f')],
        'clean':True
    }</t>
<t tx="stan@picarro-com.20150622135802.1">def task_compile_cluster_analyzer():
    python_scripts_dir = os.path.join(os.path.dirname(sys.executable))
    src_dir = os.path.join('src','main','python','Host','Fitter')
    return {
        'actions':[
            r'cd %s &amp;&amp; if exist cluster_analyzer.pyd del cluster_analyzer.pyd' % (src_dir,),
            r'cd %s &amp;&amp; python setup.py build_src build_ext --inplace -c mingw32' % (src_dir,),
            r'cd %s &amp;&amp; del cluster_analyzermodule.c' % (src_dir,),
            r'cd %s &amp;&amp; rd/s/q build' % (src_dir,)
        ],
        'targets':[os.path.join(src_dir,'cluster_analyzer.pyd')],
        'file_dep':[os.path.join(src_dir,fname) for fname in ['cluster_analyzer.c', 'cluster_analyzer.h']],
        'clean':True
    }</t>
<t tx="stan@picarro-com.20150622135818.1">def task_compile_swathP():
    python_scripts_dir = os.path.join(os.path.dirname(sys.executable))
    src_dir = os.path.join('src','main','python','Host','Common')
    f2py = os.path.join(python_scripts_dir, 'f2py.py')
    return {
        'actions':[
            r'cd %s &amp;&amp; if exist swathP.pyd del swathP.pyd' % src_dir,
            r'cd %s &amp;&amp; python %s swathP.pyf swathP.c -c --compiler=mingw32' % (src_dir, f2py),
        ],
        'targets':[os.path.join(src_dir,'swathP.pyd')],
        'file_dep':[os.path.join(src_dir,fname) for fname in ['swathP.c', 'swathP.pyf']],
        'clean':True
    }</t>
<t tx="stan@picarro-com.20150622135912.1">def task_compile_fastLomb():
    python_scripts_dir = os.path.join(os.path.dirname(sys.executable))
    src_dir = os.path.join('src','main','python','Host','Utilities','SuperBuildStation')
    return {
        'actions':[
            r'cd %s &amp;&amp; if exist fastLomb.pyd del fastLomb.pyd' % (src_dir,),
            r'cd %s &amp;&amp; setup.py build_src build_ext --inplace -c mingw32' % (src_dir,),
            r'cd %s &amp;&amp; del fastLombmodule.c' % (src_dir,),
            r'cd %s &amp;&amp; rd/s/q build' % (src_dir,)
        ],
        'targets':[os.path.join(src_dir,'fastLomb.pyd')],
        'file_dep':[os.path.join(src_dir,fname) for fname in ['fastLomb.c', 'fastLomb.pyf']],
        'clean':True
    }</t>
<t tx="stan@picarro-com.20150622135925.1">def task_compile_sources():
    return {'actions': None,
            'task_dep': ['make_sources_from_xml', 'compile_fitutils', 'compile_cluster_analyzer', 'compile_swathP', 'compile_fastLomb']}</t>
<t tx="stan@picarro-com.20150622135949.1">def task_build_hostexe():
    return {'actions': [r'cd %(build_dir)s &amp;&amp; python buildHost.py'],
            'task_dep': ['compile_sources'],
            'params':[{'name':'build_dir', 'long':'build_dir', 'default':'.'}],
            'verbosity': 2
    }</t>
<t tx="stan@picarro-com.20150622140041.1">def task_make_release():
    src_dir = os.path.join('versions')
    dest_dir = os.path.join('src', 'main', 'python', 'Host', 'Common')

    def python_make_release(product, targets, official):
        contents = textwrap.dedent("""\
        # autogenerated by PyBuilder / doit, %s
        
        def versionString():
            return '%s'
        
        def versionNumString():
            return '%s'
        
        def buildType():
            # Empty string indicates official release
            return '%s'
        """)
        src_file = os.path.join(src_dir, "%s_version.json" % product)
        git_hash, stdout_value = run_command("git.exe log -1 --pretty=format:%H")
        ver = {"git_hash":git_hash[:8]}

        target = os.path.join(*RELEASE_VERSION_FILE) if official else os.path.join(*INTERNAL_VERSION_FILE)
        with open(src_file,"r") as inp:
            ver.update(json.load(inp))
        with open(target,"w") as outp:
            outp.write(contents % (time.asctime(), _verAsString(product, ver), _verAsNumString(ver), '' if official else 'INTERNAL'))
    
    return {'actions':[(_remove_python_version_files,), (python_make_release,)],
            'params':[{'name':'product', 'long':'product', 'default':'g2000'},
                      {'name':'official', 'long':'official', 'type':bool, 'default':False}],
    }</t>
<t tx="stan@picarro-com.20150622142233.1">def _verAsNumString(ver):
    """
    Convert a version dict into a string of numbers in this format:
        &lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;.&lt;build&gt;
    """
    number = "%(major)s.%(minor)s.%(revision)s.%(build)s" % ver
    return number</t>
<t tx="stan@picarro-com.20150622142251.1">def _verAsString(product, ver, osType=None):
    """
    Convert a version dict into a human-readable string.
    """
    number = _verAsNumString(ver)
    if osType is not None:
        return "%s-%s-%s (%s)" % (product, osType, number, ver["git_hash"])
    else:
        return "%s-%s (%s)" % (product, number, ver["git_hash"])</t>
<t tx="stan@picarro-com.20150622171115.1">def _remove_python_version_files():
    try:
        os.remove(os.path.join(*RELEASE_VERSION_FILE))
    except WindowsError:
        pass
    try:
        os.remove(os.path.join(*INTERNAL_VERSION_FILE))
    except WindowsError:
        pass</t>
<t tx="stan@picarro-com.20150622174109.1">def run_command(command):
    """
    Run a command line command so we can capture its output.
    """
    p = subprocess.Popen(command,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    stdout_value, stderr_value = p.communicate()
    return stdout_value, stderr_value</t>
<t tx="stan@picarro-com.20150623221216.1">@before("publish")
def run_py2exe(project, logger):
    logger.info("Running py2exe in %s", project.expand_path("$dir_dist"))
    reports_dir = project.expand_path("$dir_reports")
    if not os.path.exists(reports_dir):
        os.mkdir(reports_dir)
    output_file_path = os.path.join(reports_dir, "build_hostexe")
    with open(output_file_path, "w") as output_file:
        process = subprocess.Popen(["doit", "build_hostexe", "--build_dir", "%s" % project.expand_path("$dir_dist/Host")],
                                   stdout=output_file,
                                   stderr=output_file,
                                   shell=False)
        return_code = process.wait()
        if return_code != 0:
            raise BuildFailedException("Error while executing run_py2exe/build_hostexe")

    shutil.move(project.expand_path("$dir_dist/Host/dist"),project.expand_path("$dir_dist/HostExe"))
    
    </t>
<t tx="stan@picarro-com.20150623223923.1">product: String specifying product for which installer is to be made
default: g2000

official: Boolean specifying if an official or an internal release is required
default: False</t>
<t tx="stan@picarro-com.20150624001144.1"></t>
<t tx="stan@picarro-com.20150624001144.2">(uncached) stan@picarro-com.20150529220322.6
Diff...
  def _getBuildVersion():
      try:
          # First look for release_version which is generated by
          # release.py
          from Host.Common import release_version as buildVersion
-         versionNum = buildVersion.versionNumString()
-         versionStr = buildVersion.versionString()
?            ----
+         verStr = buildVersion.versionNumString()
?                                      +++
-         print "Release version: %s" % versionStr
?                                          ----
+         print "Release version: %s" % verStr
      except Exception, e:
          # Next try build_version which is generated by
          # buildHost.py (command line script for internal builds)
          try:
-             from Host import build_version as buildVersion
?            ----------
+             import build_version as buildVersion
-             versionNum = buildVersion.versionNumString()
-             versionStr = buildVersion.versionString()
?                ----
+             verStr = buildVersion.versionNumString()
?                                          +++
-             print "Setup version: %s" % versionStr
?                                            ----
+             print "Setup version: %s" % verStr
          except Exception, e:
              # use default
-             versionNum = "0.0.0.0"
?                ^^^^^^^    ^
+             verStr = "1.0.0.0"
?                ^^^    ^
-             versionStr = "0.0.0.0 (unknown)"
-             print "Release or setup version not found, using: %s" % versionStr
?                                                                        ----
+             print "Release or setup version not found, using: %s" % verStr
  
-     return versionNum, versionStr
+     return verStr
  
  
</t>
<t tx="stan@picarro-com.20150624001144.3">def _getBuildVersion():
    try:
        # First look for release_version which is generated by
        # release.py
        from Host.Common import release_version as buildVersion
        verStr = buildVersion.versionNumString()
        print "Release version: %s" % verStr
    except Exception, e:
        # Next try build_version which is generated by
        # buildHost.py (command line script for internal builds)
        try:
            import build_version as buildVersion
            verStr = buildVersion.versionNumString()
            print "Setup version: %s" % verStr
        except Exception, e:
            # use default
            verStr = "1.0.0.0"
            print "Release or setup version not found, using: %s" % verStr

    return verStr


</t>
<t tx="stan@picarro-com.20150624001144.4">def _getBuildVersion():
    try:
        # First look for release_version which is generated by
        # release.py
        from Host.Common import release_version as buildVersion
        versionNum = buildVersion.versionNumString()
        versionStr = buildVersion.versionString()
        print "Release version: %s" % versionStr
    except Exception, e:
        # Next try build_version which is generated by
        # buildHost.py (command line script for internal builds)
        try:
            from Host import build_version as buildVersion
            versionNum = buildVersion.versionNumString()
            versionStr = buildVersion.versionString()
            print "Setup version: %s" % versionStr
        except Exception, e:
            # use default
            versionNum = "0.0.0.0"
            versionStr = "0.0.0.0 (unknown)"
            print "Release or setup version not found, using: %s" % versionStr

    return versionNum, versionStr


</t>
<t tx="stan@picarro-com.20150624001144.5">(uncached) stan@picarro-com.20150529220322.7
Diff...
  def _getBuildType():
      try:
          # First look for release_version which is generated by
          # release.py
-         from Host.Common import release_version as buildVersion
?        -----------------
+         import release_version as buildVersion
          buildTypeStr = buildVersion.buildType()
          print "Release build type: %s" % buildTypeStr
      except Exception, e:
          try:
              # Not found, try setup_version (generated by buildHost.py
              # during internal builds)
-             from Host import build_version as buildVersion
?             ^^^^^^^^^^
+             #import build_version as buildVersion
?             ^
-             buildTypeStr = buildVersion.buildType()
+             #buildTypeStr = buildVersion.buildType()
?             +
              #print "Setup build type: %s" % buildTypeStr
  
              # Internal build, includes last git check-in SHA1
              # returns "Internal (&lt;SHA1&gt;)"
+             buildTypeStr = hostVersion.buildType()
              print "Setup build type: %s" % buildTypeStr
  
          except Exception, e:
              # Should never get here...
              buildTypeStr = "DEVELOPMENT"
              print "Release or setup version build type not found, using: %s" % buildTypeStr
  
      return buildTypeStr
  
  
</t>
<t tx="stan@picarro-com.20150624001144.6">def _getBuildType():
    try:
        # First look for release_version which is generated by
        # release.py
        import release_version as buildVersion
        buildTypeStr = buildVersion.buildType()
        print "Release build type: %s" % buildTypeStr
    except Exception, e:
        try:
            # Not found, try setup_version (generated by buildHost.py
            # during internal builds)
            #import build_version as buildVersion
            #buildTypeStr = buildVersion.buildType()
            #print "Setup build type: %s" % buildTypeStr

            # Internal build, includes last git check-in SHA1
            # returns "Internal (&lt;SHA1&gt;)"
            buildTypeStr = hostVersion.buildType()
            print "Setup build type: %s" % buildTypeStr

        except Exception, e:
            # Should never get here...
            buildTypeStr = "DEVELOPMENT"
            print "Release or setup version build type not found, using: %s" % buildTypeStr

    return buildTypeStr


</t>
<t tx="stan@picarro-com.20150624001144.7">def _getBuildType():
    try:
        # First look for release_version which is generated by
        # release.py
        from Host.Common import release_version as buildVersion
        buildTypeStr = buildVersion.buildType()
        print "Release build type: %s" % buildTypeStr
    except Exception, e:
        try:
            # Not found, try setup_version (generated by buildHost.py
            # during internal builds)
            from Host import build_version as buildVersion
            buildTypeStr = buildVersion.buildType()
            #print "Setup build type: %s" % buildTypeStr

            # Internal build, includes last git check-in SHA1
            # returns "Internal (&lt;SHA1&gt;)"
            print "Setup build type: %s" % buildTypeStr

        except Exception, e:
            # Should never get here...
            buildTypeStr = "DEVELOPMENT"
            print "Release or setup version build type not found, using: %s" % buildTypeStr

    return buildTypeStr


</t>
<t tx="stan@picarro-com.20150624094139.1"></t>
<t tx="stan@picarro-com.20150624094645.1">@language unknown_language
{
    "buildTypes": {
        "AEDS": {
            "species": "NH3",
            "installerSignature": "AEDS"
        },

        "BFADS": {
            "species": "H2S_CH4",
            "installerSignature": "BFADS"
        },

        "CBDS": {
            "species": "iCO2",
            "installerSignature": "CBDS"
        },

        "CFADS": {
            "species": "CO2_CH4_H2O",
            "installerSignature": "CFADS"
        },

        "CFBDS": {
            "species": "Flux",
            "installerSignature": "CFBDS"
        },

        "CFDDS": {
            "species": "CO2_CH4_Flight",
            "installerSignature": "CFDDS"
        },

        "CFEDS": {
            "species": "iCO2_iCH4",
            "installerSignature": "CFEDS"
        },

        "CFFDS": {
            "species": "iCO2_CH4",
            "installerSignature": "CFFDS"
        },

        "CFGDS": {
            "species": "iCO2",
            "installerSignature": "CFGDS"
        },

        "CFHADS": {
            "species": "SuperFlux",
            "installerSignature": "CFHADS"
        },

        "CFHDS": {
            "species": "iCO2",
            "installerSignature": "CFHDS",
            "comment": "for NEON"
        },

        "CFIDS": {
            "species": "iCO2_iCH4",
            "installerSignature": "CFIDS"
        },

        "CFJDS": {
            "species": "High_Conc_iCH4_DCH3_i13CH4",
            "installerSignature": "CFJDS"
        },

        "CFKADS": {
            "species": "4Species",
            "installerSignature": "CFKADS"
        },

        "CFKBDS": {
            "species": "4Species_Flight",
            "installerSignature": "CFKBDS"
        },

        "CHADS": {
            "species": "i13CO2_iHDO",
            "installerSignature": "CHADS"
        },

        "CKADS": {
            "species": "CO2_CO_H2O",
            "installerSignature": "CKADS"
        },

        "FCDS": {
            "species": "iCH4",
            "installerSignature": "FCDS"
        },

        "HBDS": {
            "species": "iH2O",
            "installerSignature": "HBDS"
        },

        "HIDS": {
            "species": "iH2O",
            "installerSignature": "HIDS"
        },

        "HKDS": {
            "species": "iH2O",
            "installerSignature": "HKDS"
        },

        "JFAADS": {
            "species": "5Species",
            "installerSignature": "JFAADS",
            "comment": "species are N2O_CH4_CO2_NH3_H2O"
        },

        "MADS": {
            "species": "HF",
            "installerSignature": "MADS"
        },

        "NBDS": {
            "species": "H2O2",
            "installerSignature": "NBDS"
        }

    },

    "installerScriptsDir": "InstallerScriptsWin7"
}
</t>
<t tx="stan@picarro-com.20150624095237.1">N.B. opt.buildTypes is set by:

parser.add_option('--types', dest='buildTypes',
                  default=None, help=('Comma-delimited list of analyzer types to build or '
                                      'types to move from staging to the official release '
                                      'area. If the list starts with a "!" every type but those '
                                      'in the list will be built or moved.'))
</t>
<t tx="stan@picarro-com.20150624100735.1">@init
def initialize(project, logger):
    # official removes "INTERNAL" from version number
    official = project.get_property("official", "False")
    official = official.lower() in ("yes", "true", "t", "1")
    # product specifies which installer to produce, currently supported values are g2000
    product = project.get_property("product", "g2000")
    # types is a comma separated list of installers to create or to exclude (if preceeded by !)
    #  Default is to include all types
    types = project.get_property("types", "!")
    
    version_file = os.path.join("versions","%s_version.json" % product)
    with open(version_file,"r") as inp:
        ver = json.load(inp)
        project.name = product
        project.version = ("%s.%s.%s.%s%s" % 
            (ver["major"], ver["minor"], ver["revision"], ver["build"], "" if official else "-INTERNAL" ))
        project.set_property('installer_version',"%s.%s.%s.%s" % (ver["major"], ver["minor"], ver["revision"], ver["build"]))
    # Need to set the directory into which the output distribution is placed        
    project.set_property('dir_dist','$dir_target/dist/%s-%s' % (project.name, project.version))
    
    types_file = os.path.join("versions","%s_types.json" % product)
    with open(types_file,"r") as inp:
        config_info = json.load(inp)
    types_to_build = handle_types(types, config_info['buildTypes'], logger)
        
    project.set_property('types_to_build', types_to_build)
    project.set_property('config_info', config_info['buildTypes'])
        
    
</t>
<t tx="stan@picarro-com.20150624184236.1">@task
def make_installers(project, logger):
    config_info = project.get_property('config_info')
    sandbox_dir = project.expand_path('$dir_source_main_python')
    resource_dir = project.expand_path('$dir_dist/Installers')
    dist_dir = project.expand_path('$dir_dist') 
    reports_dir = project.expand_path("$dir_reports")
    logger.info("Reports_dir: %s" % reports_dir)
    if not os.path.exists(reports_dir):
        os.mkdir(reports_dir)
    output_file_path = os.path.join(reports_dir, "make_installers")

    for installer_type in project.get_property('types_to_build'):
        species = config_info[installer_type]['species']
        iss_filename = "setup_%s_%s.iss" % (installer_type, species)
        setup_file_path = os.path.join(*(INSTALLER_SCRIPTS_DIR + (iss_filename,)))
        logger.info("Building from %s" % setup_file_path)
        config_dir = os.path.join(os.getcwd(),'Config')
        #
        # Build a fully qualified path for the scripts folder, so ISCC can find
        # the include files (can't find them using a relative path here)
        # Notes:
        #
        # installerVersion: must be of the form x.x.x.x, for baking version number
        #                   into setup_xxx.exe metadata (for Explorer properties)
        # hostVersion:      e.g., g2000_win7-x.x.x-x, displayed in the installer UI
        # productVersion:   used for displaying Product version in Explorer properties
        current_year = time.strftime("%Y")
        logger.info('Project version: %s' % project.version)
        args = [ISCC_WIN7, "/dinstallerType=%s" % installer_type,
                "/dhostVersion=%s" % project.version,
                "/dinstallerVersion=%s" % project.get_property('installer_version'),
                "/dproductVersion=%s" % project.version,
                "/dproductYear=%s" % current_year,
                "/dsandboxDir=%s" % sandbox_dir,
                "/dconfigDir=%s" % config_dir,
                "/dcommonName=%s" % species,
                "/ddistDir=%s" % dist_dir,
                "/v9",
                "/O%s" % resource_dir,
                setup_file_path]
                
        output_file_path = os.path.join(reports_dir, "make_installers")
        with open(output_file_path, "a") as output_file:
            process = subprocess.Popen(args,
                                       stdout=output_file,
                                       stderr=output_file,
                                       shell=False)
            return_code = process.wait()
            if return_code != 0:
                raise BuildFailedException("Error while making installer for %s" % installer_type)
                sys.exit(retCode)
</t>
<t tx="stan@picarro-com.20150624185413.1">def handle_types(types, build_info, logger=None):
    types = types.strip()
    negate = (types[0] == "!")
    types_list = (types[1:] if negate else types).split(',') 
    types_list = [item.strip() for item in types_list]

    types_to_build = []
    for item in sorted(build_info.keys()):
        if negate:
            if item not in types_list:
                types_to_build.append(item)
        else:
            if item in types_list:
                types_to_build.append(item)
    if logger:
        logger.info("Installer types to build: %s" % ", ".join(types_to_build))
        
    return types_to_build
</t>
<t tx="sze.20150327093644.2"></t>
<t tx="sze.20150327094108.1"></t>
<t tx="sze.20150327114556.1"></t>
<t tx="sze.20150327114611.1"></t>
<t tx="sze.20150327114631.1"></t>
<t tx="sze.20150327114803.1"></t>
<t tx="sze.20150327144536.1"></t>
<t tx="sze.20150327144553.1"></t>
<t tx="sze.20150327144638.1"></t>
<t tx="sze.20150327144644.1"></t>
<t tx="sze.20150327144651.1"></t>
<t tx="sze.20150327144708.1"></t>
<t tx="sze.20150327144713.1"></t>
<t tx="sze.20150327144717.1"></t>
<t tx="sze.20150327145041.1"></t>
<t tx="sze.20150327145048.1"></t>
<t tx="sze.20150527173055.1"></t>
<t tx="sze.20150527173110.1"></t>
<t tx="sze.20150527173116.1"></t>
<t tx="sze.20150527173120.1"></t>
<t tx="sze.20150527173123.1"></t>
<t tx="sze.20150527173129.1"></t>
<t tx="sze.20150527173131.1"></t>
<t tx="sze.20150527173138.1"></t>
<t tx="sze.20150527173143.1"></t>
<t tx="sze.20150527173151.1"></t>
<t tx="sze.20150527173209.1"></t>
<t tx="sze.20150527173213.1"></t>
<t tx="sze.20150527173218.1"></t>
<t tx="sze.20150527173225.1"></t>
<t tx="sze.20150527173250.1"></t>
<t tx="sze.20150527173256.1"></t>
<t tx="sze.20150527173259.1"></t>
<t tx="sze.20150527173303.1"></t>
<t tx="sze.20150527173311.1"></t>
<t tx="sze.20150527173317.1"></t>
<t tx="sze.20150527173324.1"></t>
<t tx="sze.20150527173331.1"></t>
<t tx="sze.20150527173335.1"></t>
<t tx="sze.20150527173340.1"></t>
<t tx="sze.20150527173344.1"></t>
<t tx="sze.20150527173353.1"></t>
<t tx="sze.20150527173400.1"></t>
<t tx="sze.20150527173405.1"></t>
<t tx="sze.20150527173408.1"></t>
<t tx="sze.20150527173416.1"></t>
<t tx="sze.20150527173426.1"></t>
<t tx="sze.20150527173430.1"></t>
<t tx="sze.20150527173445.1"></t>
<t tx="sze.20150527173447.1"></t>
<t tx="sze.20150527173454.1"></t>
<t tx="sze.20150527173500.1"></t>
<t tx="sze.20150527173505.1"></t>
<t tx="sze.20150527173505.2"></t>
<t tx="sze.20150527173510.1"></t>
<t tx="sze.20150527173518.1"></t>
<t tx="sze.20150527173532.1"></t>
<t tx="sze.20150527173540.1"></t>
<t tx="sze.20150527173546.1"></t>
<t tx="sze.20150527173552.1"></t>
<t tx="sze.20150527173559.1"></t>
<t tx="sze.20150527173603.1"></t>
<t tx="sze.20150527173613.1"></t>
<t tx="sze.20150527173620.1"></t>
<t tx="sze.20150527173629.1"></t>
<t tx="sze.20150527173640.1"></t>
<t tx="sze.20150527173646.1"></t>
<t tx="sze.20150527173653.1"></t>
<t tx="sze.20150527173704.1"></t>
<t tx="sze.20150527173710.1"></t>
<t tx="sze.20150527173728.1"></t>
<t tx="sze.20150527173732.1"></t>
<t tx="sze.20150527173739.1"></t>
<t tx="sze.20150527173753.1"></t>
<t tx="sze.20150527173805.1"></t>
<t tx="sze.20150527174330.1"></t>
<t tx="sze.20150527174340.1"></t>
<t tx="sze.20150527174346.1"></t>
<t tx="sze.20150527174351.1"></t>
<t tx="sze.20150527174354.1"></t>
<t tx="sze.20150527174359.1"></t>
<t tx="sze.20150527174404.1"></t>
<t tx="sze.20150527174409.1"></t>
<t tx="sze.20150527174415.1"></t>
<t tx="sze.20150527174419.1"></t>
<t tx="sze.20150527174434.1"></t>
<t tx="sze.20150527174443.1"></t>
<t tx="sze.20150527174450.1"></t>
<t tx="sze.20150527174602.1"></t>
<t tx="sze.20150527174606.1"></t>
<t tx="sze.20150527174610.1"></t>
<t tx="sze.20150527174620.1"></t>
<t tx="sze.20150527174631.1"></t>
<t tx="sze.20150527174709.1"></t>
<t tx="sze.20150527174714.1"></t>
<t tx="sze.20150527174718.1"></t>
<t tx="sze.20150527174722.1"></t>
<t tx="sze.20150527174725.1"></t>
<t tx="sze.20150527174805.1"></t>
<t tx="sze.20150527174813.1"></t>
<t tx="sze.20150527174817.1"></t>
<t tx="sze.20150527174820.1"></t>
<t tx="sze.20150527174824.1"></t>
<t tx="sze.20150527174828.1"></t>
<t tx="sze.20150527174900.1"></t>
<t tx="sze.20150527174924.1"></t>
<t tx="sze.20150527174931.1"></t>
<t tx="sze.20150527174947.1"></t>
<t tx="sze.20150527174957.1"></t>
<t tx="sze.20150527175001.1"></t>
<t tx="sze.20150527175008.1"></t>
<t tx="sze.20150527175016.1"></t>
<t tx="sze.20150527175022.1"></t>
<t tx="sze.20150527175028.1"></t>
<t tx="sze.20150527175033.1"></t>
<t tx="sze.20150527175038.1"></t>
<t tx="sze.20150527175043.1"></t>
<t tx="sze.20150527175049.1"></t>
<t tx="sze.20150527175052.1"></t>
<t tx="sze.20150527175056.1"></t>
<t tx="sze.20150527175104.1"></t>
<t tx="sze.20150527175358.1">Want to be able to have manufacturing fire off a build for a specified analyzer type. This should get the latest 

1) host code
2) firmware (DSP, FPGA, USB)
3) configuration files

Each must be identified in such a way that we can reconstruct the installer from the overall version string.
We could update/maintain a table which specifies for each type of analyzer, which versions are may be used to make the installer.
We want an automated way of checking during build time if a set of code will run successfully on the hardware.


</t>
<t tx="sze.20150527185824.1">PyBuilder Tasks
Tasks found for project "Host":
                           clean - Cleans the generated output.
                 compile_sources - Compiles source files that need compilation.
                                   depends on tasks: prepare
      install_build_dependencies - Installs all build dependencies specified in the build descriptor
            install_dependencies - Installs all (both runtime and build) dependencies specified in the build descriptor
    install_runtime_dependencies - Installs all runtime dependencies specified in the build descriptor
               list_dependencies - Displays all dependencies the project requires
                         package - Packages the application. Package a python application.
                                   depends on tasks: run_unit_tests
                         prepare - Prepares the project for building.
                         publish - Publishes the project. 
                                   depends on tasks: verify
           run_integration_tests - Runs integration tests on the packaged application.
                                   depends on tasks: package
                  run_unit_tests - Runs all unit tests. Runs unit tests based on Python's unittest module
                                   depends on tasks: compile_sources
                          verify - Verifies the project and possibly integration tests.
                                   depends on tasks: run_integration_tests
                                   
prepare &gt; compile_sources &gt; run_unit_tests &gt; package &gt; run_integration_tests &gt; verify &gt; publish                                   




['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_build_dependencies', '_files_to_install', '_install_dependencies', '_manifest_include', '_manifest_included_files', '_package_data', '_properties', 'author', 'authors', 'basedir', 'build_dependencies', 'build_depends_on', 'build_depends_on_requirements', 'default_task', 'dependencies', 'depends_on', 'depends_on_requirements', 'description', 'expand', 'expand_path', 'files_to_install', 'get_mandatory_property', 'get_property', 'has_property', 'home_page', 'include_file', 'install_file', 'license', 'list_modules', 'list_packages', 'list_scripts', 'manifest_included_files', 'name', 'package_data', 'properties', 'set_property', 'set_property_if_unset', 'summary', 'url', 'validate', 'validate_dependencies', 'version', 'write_report']


{'dir_target': 'target', 
u'unittest_module_glob': u'*_tests', 
'verbose': False, 
'dir_logs': '$dir_target/logs', 
'dir_source_main_python': 'Host', 
'dir_dist_scripts': 'scripts', 
'basedir': 'C:\\GitHub\\host-reorg', 
'install_dependencies_upgrade': False, 
'dir_install_logs': '$dir_logs/install_dependencies', 
'dir_dist': '$dir_target/dist/Host-1.0.dev0', 
u'unittest_test_method_prefix': None, 
'install_dependencies_index_url': None, 
u'dir_source_unittest_python': 'unittest', 
'install_dependencies_local_mapping': {}, 
'dir_source_main_scripts': 'scripts', 
'dir_reports': '$dir_target/reports', 
'install_dependencies_extra_index_url': None, 
u'unittest_file_suffix': None}

buildHost.py
------------

In Tools/Release: "g2000" and "mobile" are examples of the "product"

When called from buildHost, the string "-INTERNAL" is appended to the product.
 
g2000_version.json
    {"major": "1", "build": "29", "minor": "5", "revision": "0"}
    
mobile_version.json
    {"major": "1", "build": "14", "minor": "0", "revision": "0"}
    

This generates a file called build_version.py, an example of which is shown below.
The OS type is obtained from the computer which runs the build script.

# autogenerated by buildHost.py, Wed Jun 10 17:24:15 2015

def versionString():
    return 'g2000-INTERNAL-win7-1.5.0.29'

def versionNumString():
    return '1.5.0.29'

def buildType():
    return 'INTERNAL'
    
The function _getBuildVersion (cloned below from PicarroExeSetup.py) uses either versionString
from this file or the versionString generated from Host.Common.release_version which is generated
by release.py


from Host.Common import release_version as buildVersion


The supervisor launcher uses the following to determine the version

try:
    # Release build
    from Host.Common import release_version as version
except ImportError:
    try:
        # Internal build
        from Host.Common import setup_version as version
    except ImportError:
        # Internal dev
        from Host.Common import version
        
        
The file Host.Common.version 

"""
Copyright 2012 Picarro Inc.

A non-release version string containing enough information to track
the work back to the originating revision.
"""

import subprocess


def versionString():
    """
    We purposely don't cache the non-official version since it could
    change during active development. This should never be invoked
    from a compiled (py2exe) app since it won't be in a repository.
    """

    p = subprocess.Popen(['git.exe', 'log', '-1',
                          '--pretty=format:%H'], stdout=subprocess.PIPE)

    ver = "Internal (%s)" % p.communicate()[0]

    return ver        </t>
<t tx="sze.20150528150419.1">The following produces exe files which execute correctly, even though the Python path is not set up to point to the individual directories

</t>
<t tx="sze.20150528151615.1">@language python
from distutils.core import setup
import py2exe

consoleList = [
    "App1/app1.py",
    "App2/app2.py"
]

setup(version = "0.0.1",
      description = "Sample applications",
      name = "Application Pair",
      options = dict(py2exe = dict(compressed = 1,
                                   optimize = 1)),
      # targets to build...
      console = consoleList,
      zipfile = "lib/share"
)
</t>
<t tx="sze.20150528151713.1">if __name__ == "__main__":
    print "Hello from app2"
</t>
<t tx="sze.20150528151728.1">if __name__ == "__main__":
    print "This is app1"</t>
<t tx="sze.20150616212829.1">Each AddOn has a release.py file</t>
</tnodes>
</leo_file>
