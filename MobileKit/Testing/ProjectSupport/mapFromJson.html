<!doctype html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>wkhtml2pdf Test</title>
</head>
<body>
    <div id="checkboxdiv" style="position:relative"></div>
    <div id="canvasesdiv" style="position:relative"></div>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript">

    var CSTATE = {
        baseData: null,
        contexts: [],
        maxLat: null,
        maxLng: null,
        minLat: null,
        minLng: null,
        mpp: null,
        nx: null,
        ny: null,
        padX: null,
        padY: null,
        xform: null
    };

    var CNSNT = {
        DTR: Math.PI/180.0,
        RTD: 180.0/Math.PI,
        EARTH_RADIUS: 6378100
    }

    function init() {
        var layer = 0;
        $.getJSON("baseData.0.json",function(baseData) {
            var regionParams = baseData[0];
            console.log(regionParams);
            for (var i=0; i<baseData[1].length; i++) {
                baseParams =
                baseData[1][i];
                var ip = baseParams[0];
                var mp = baseParams[1];
                CSTATE.minLng = mp[0];
                CSTATE.minLat = mp[1];
                CSTATE.maxLng = mp[2];
                CSTATE.maxLat = mp[3];
                CSTATE.nx = mp[4];
                CSTATE.ny = mp[5];
                CSTATE.padX = mp[6];
                CSTATE.padY = mp[7];
                CSTATE.xform = function (lng, lat) {
                    var x = Math.round(CSTATE.nx * (lng - CSTATE.minLng) / (CSTATE.maxLng - CSTATE.minLng));
                    var y = Math.round(CSTATE.ny * (lat - CSTATE.maxLat) / (CSTATE.minLat - CSTATE.maxLat));
                    return [x,y];
                };
                // Calculate meters per pixel
                var deltaLat = CNSNT.RTD / CNSNT.EARTH_RADIUS;
                var deltaLng = CNSNT.RTD / (CNSNT.EARTH_RADIUS * Math.cos(0.5 * (CSTATE.minLat + CSTATE.maxLat) * CNSNT.DTR));
                var mppx = (CSTATE.maxLng - CSTATE.minLng) / (deltaLng * CSTATE.nx);
                var mppy = (CSTATE.maxLat - CSTATE.minLat) / (deltaLat * CSTATE.ny);
                CSTATE.mpp = 0.5 * (mppx + mppy);

                var image = new Image();
                var maptype = ip.satellite ? "satellite" : "map";
                var params = { center: ip.meanLat.toFixed(6) + "," + ip.meanLng.toFixed(6),
                               zoom: ip.zoom, size: ip.mx + "x" + ip.my, scale: ip.scale,
                               maptype: maptype, sensor: false };
                var url = 'http://maps.googleapis.com/maps/api/staticmap?' + $.param(params);
                image.src = url;
                $(image).data("maptype",maptype);
                $(image).data("layer",++layer);
                image.onload = function () {
                    var ctx = document.createElement("canvas").getContext("2d");
                    ctx.canvas.height = this.height;
                    ctx.canvas.width = this.width;
                    ctx.drawImage(this,0,0);
                    addLayer(ctx.canvas,[CSTATE.padX, CSTATE.padY],$(this).data("layer"),$(this).data("maptype"));
                };
            }

            $.getJSON("pathData.json", function(data) {
                var paramsByLogname = data[0];
                var savedData = data[1];

                // Draw the vehicle path
                var ctx = document.createElement("canvas").getContext("2d");
                ctx.canvas.height = CSTATE.ny + 2 * CSTATE.padY;
                ctx.canvas.width  = CSTATE.nx + 2 * CSTATE.padX;

                for (var i=0; i<savedData.length; i++) {
                    var logs = savedData[i][0];
                    var savedPath = savedData[i][1];
                    var savedSwath = savedData[i][2];
                    for (var j=0; j<savedPath.length; j++) {
                        var pathLatLng = savedPath[j][0];
                        var pathColor = savedPath[j][1];
                        var latIndex = pathLatLng.keys.indexOf("GPS_ABS_LAT");
                        var lngIndex = pathLatLng.keys.indexOf("GPS_ABS_LONG");

                        ctx.lineWidth = 2;
                        ctx.strokeStyle = "rgba(" + pathColor[0] + "," + pathColor[1] + "," +
                                                    pathColor[2] + "," + pathColor[3] + ")";
                        var path = [];
                        for (var k=0; k<pathLatLng.data.length; k++) {
                            var lng = pathLatLng.data[k][lngIndex];
                            var lat = pathLatLng.data[k][latIndex];
                            var xy = CSTATE.xform(lng, lat);
                            var x = xy[0], y = xy[1];
                            if ( -CSTATE.padX <= x && x < CSTATE.nx+CSTATE.padX &&
                                 -CSTATE.padY <= y && y < CSTATE.ny+CSTATE.padY ) {
                                path.push([x,y]);
                            }
                            else {
                                if (path.length > 0) {
                                    ctx.beginPath();
                                    ctx.moveTo(path[0][0] + CSTATE.padX, path[0][1] + CSTATE.padY);
                                    for (var l=1; l<path.length; l++) {
                                        ctx.lineTo(path[l][0] + CSTATE.padX, path[l][1] + CSTATE.padY);
                                    }
                                    ctx.stroke();
                                    path = [];
                                }
                            }
                        }
                        if (path.length > 0) {
                            ctx.beginPath();
                            ctx.moveTo(path[0][0] + CSTATE.padX, path[0][1] + CSTATE.padY);
                            for (var l=1; l<path.length; l++) {
                                ctx.lineTo(path[l][0] + CSTATE.padX, path[l][1] + CSTATE.padY);
                            }
                            ctx.stroke();
                        }
                    }
                }
                addLayer(ctx.canvas,[0,0],++layer,"path");

                // Draw the swath
                var ctx = document.createElement("canvas").getContext("2d");
                ctx.canvas.height = CSTATE.ny + 2 * CSTATE.padY;
                ctx.canvas.width  = CSTATE.nx + 2 * CSTATE.padX;

                var inMap = function (xy) {
                    return ( -CSTATE.padX <= xy[0] && xy[0] < CSTATE.nx+CSTATE.padX &&
                             -CSTATE.padY <= xy[1] && xy[1] < CSTATE.ny+CSTATE.padY );
                };

                for (var i=0; i<savedData.length; i++) {
                    var logs = savedData[i][0];
                    var savedPath = savedData[i][1];
                    var savedSwath = savedData[i][2];
                    for (var j=0; j<savedSwath.length; j++) {
                        swath = savedSwath[j][0];
                        swathColor = savedSwath[j][1];

                        ctx.fillStyle = "rgba(" + swathColor[0] + "," + swathColor[1] + "," + swathColor[2] + ",0.4)";
                        ctx.strokeStyle = "rgba(" + swathColor[0] + "," + swathColor[1] + "," + swathColor[2] + ",0.5)";
                        ctx.lineWidth = 1;
                        var lastLng = null, lastLat = null;
                        var lastDeltaLng = null, lastDeltaLat = null;
                        for (var k=0; k<swath.GPS_ABS_LAT.length; k++) {
                            var lng = swath.GPS_ABS_LONG[k];
                            var lat = swath.GPS_ABS_LAT[k];
                            var deltaLng = swath.DELTA_LONG[k];
                            var deltaLat = swath.DELTA_LAT[k];
                            if (lastLng !== null) {
                                var noLastView = Math.abs(lastDeltaLat) < 1e-6 && Math.abs(lastDeltaLng) < 1e-6;
                                if (!noLastView) {
                                    var xy1 = CSTATE.xform(lastLng + lastDeltaLng, lastLat + lastDeltaLat);
                                    if (inMap(xy1)) {
                                        var xy2 = CSTATE.xform(lastLng, lastLat);
                                        if (inMap(xy2)) {
                                            var xy3 = CSTATE.xform(lng, lat);
                                            if (inMap(xy3)) {
                                                var xy4 = CSTATE.xform(lng + deltaLng, lat + deltaLat);
                                                if (inMap(xy4)) {
                                                    ctx.beginPath();
                                                    ctx.moveTo(CSTATE.padX + xy1[0], CSTATE.padY + xy1[1]);
                                                    ctx.lineTo(CSTATE.padX + xy2[0], CSTATE.padY + xy2[1]);
                                                    ctx.lineTo(CSTATE.padX + xy3[0], CSTATE.padY + xy3[1]);
                                                    ctx.lineTo(CSTATE.padX + xy4[0], CSTATE.padY + xy4[1]);
                                                    ctx.stroke();
                                                    ctx.fill();
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            lastLng = lng;
                            lastLat = lat;
                            lastDeltaLng = deltaLng;
                            lastDeltaLat = deltaLat;
                        }
                    }
                }
                addLayer(ctx.canvas,[0,0],++layer,"swath");
            });

            $.getJSON("markers.json",function(markers) {
                var pColors = markers[0];
                var pColor;
                var pCanvases = {};
                var peaks = markers[1];
                var mColors = markers[2];
                var markers = markers[3];
                var size = 1.0;

                // Draw the wind wedges

                var ctx = document.createElement("canvas").getContext("2d");
                ctx.canvas.height = CSTATE.ny + 2 * CSTATE.padY;
                ctx.canvas.width  = CSTATE.nx + 2 * CSTATE.padX;

                var latIndex = peaks.keys.indexOf("GPS_ABS_LAT");
                var lngIndex = peaks.keys.indexOf("GPS_ABS_LONG");
                var wedgeColorIndex = peaks.keys.indexOf("WEDGE_COLOR");
                var windDirMeanIndex = peaks.keys.indexOf("WIND_DIR_MEAN");
                var windSdevIndex = peaks.keys.indexOf("WIND_DIR_SDEV");

                for (var i=peaks.data.length-1; i>=0; i--) {
                    var lat = peaks.data[i][latIndex];
                    var lng = peaks.data[i][lngIndex];
                    var wedgeColor = peaks.data[i][wedgeColorIndex];
                    var windMean = peaks.data[i][windDirMeanIndex];
                    var windSdev = peaks.data[i][windSdevIndex];
                    var xy = CSTATE.xform(lng, lat);
                    var x = xy[0], y = xy[1];
                    if (wedgeColor) {
                        var radius = 50.0 / CSTATE.mpp;
                        var minBearing, maxBearing;
                        var c = colorTuple2Hex(wedgeColor);
                        if (typeof(windMean) === "number" && typeof(windSdev) === "number") {
                            if (windSdev < 90.0) {
                                var minBearing = windMean - Math.min(2*windSdev, 180.0);
                                var maxBearing = windMean + Math.min(2*windSdev, 180.0);
                                ctx.beginPath();
                                ctx.moveTo(x + CSTATE.padX, y + CSTATE.padY);
                                ctx.lineTo(x + CSTATE.padX + radius * Math.sin(CNSNT.DTR * minBearing),
                                           y + CSTATE.padY - radius * Math.cos(CNSNT.DTR * minBearing));
                                ctx.arc(x + CSTATE.padX, y + CSTATE.padY, radius,
                                        CNSNT.DTR*minBearing-0.5*Math.PI, CNSNT.DTR*maxBearing-0.5*Math.PI, false);
                                ctx.closePath();
                                ctx.fillStyle = "rgba(" + wedgeColor[0] + "," + wedgeColor[1] + "," + wedgeColor[2] + ",0.7)";
                                ctx.fill();
                                continue;
                            }
                        }
                        ctx.beginPath();
                        ctx.arc(x + CSTATE.padX, y + CSTATE.padY, radius, 0.0, 2*Math.PI);
                        ctx.fill();
                    }
                }
                addLayer(ctx.canvas,[0,0],++layer,"wedges");

                ctx = document.createElement("canvas").getContext("2d");
                ctx.canvas.height = CSTATE.ny + 2 * CSTATE.padY;
                ctx.canvas.width  = CSTATE.nx + 2 * CSTATE.padX;

                // Get the peaks in reverse rank order so they overlay correctly
                for (var i=0; i<pColors.length; i++) {
                    var c = colorTuple2Hex(pColors[i]);
                    pCanvases[c] = new Marker(size,"#"+c,"black");
                }

                for (var i=peaks.data.length-1; i>=0; i--) {
                    var peakMsg = peaks.data[i][peaks.keys.indexOf("TEXT")];
                    var lat = peaks.data[i][peaks.keys.indexOf("GPS_ABS_LAT")];
                    var lng = peaks.data[i][peaks.keys.indexOf("GPS_ABS_LONG")];
                    var peakColor = peaks.data[i][peaks.keys.indexOf("PEAK_COLOR")];
                    var xy = CSTATE.xform(lng, lat);
                    var x = xy[0], y = xy[1];
                    if (peakColor) {
                        var c = colorTuple2Hex(peakColor);
                        pCanvases[c].annotate(ctx, x+CSTATE.padX, y+CSTATE.padY, peakMsg, "bold 18px sans-serif", "black");
                    }
                }
                addLayer(ctx.canvas,[0,0],++layer,"peaks");
            });
        })
    }

    function dec2hex(i,nibbles) {
        // Convert unsigned integer to hexadecimal of specified length with zero padding
        return (i+Math.pow(2,4*nibbles)).toString(16).substr(-nibbles).toUpperCase();
    }

    function colorTuple2Hex(colors) {
        var hexStr = [];
        for (var i=0; i<colors.length; i++) {
            hexStr.push(dec2hex(colors[i],2));
        }
        return hexStr.join("");
    }

    function addLayer(source, padding, layer, caption) {
        // Add the image as a new layer in the collection of canvases which make up the
        //  composite map
        // Create the checkbox and canvas for this image in the DOM


        // Make sure the checkboxes are in order of layer number by inserting them appropriately
        var elem = '<input id="id_check' + layer +'" type="checkbox" checked="checked">' + caption +'</input>';
        var added = false;
        $("#checkboxdiv").children().each(function(index) {
            if (layer < $(this).data("layer")) {
                $(this).before(elem);
                added = true;
                return false;
            }
        });
        if (!added) $("#checkboxdiv").append(elem);

        $("#canvasesdiv").append('<canvas id="id_layer' + layer +
                                 '" style="z-index:' + layer +
                                 '; position:absolute; left:0px; top:0px;"></canvas>');
        $("#id_check" + layer).data("layer", layer);
        $("#id_layer" + layer).data("layer", layer);
        // Make checkbox toggle visibility of layer
        $("#id_check" + layer).click(function() {
            var $this = $(this);
            var layer = $this.data("layer");
            if ($this.is(":checked")) $("#id_layer" + layer).show();
            else $("#id_layer" + layer).hide();
        });
        var ctx = $("#id_layer"+layer)[0].getContext("2d");
        CSTATE.contexts.push(ctx);
        ctx.canvas.width = source.width + 2 * padding[0];
        ctx.canvas.height = source.height + 2 * padding[1];
        ctx.drawImage(source, padding[0], padding[1]);
    }

    var Marker = function(size,fillColor,strokeColor) {
        var ctx = document.createElement("canvas").getContext("2d");
        var b = 1.25 * size;
        var t = 2.0 * size;
        this.nx = 36 * size + 1;
        this.ny = 65 * size + 1;
        this.size = size;
        var r = 0.5 * (this.nx - 1 - t);
        var h = this.ny - 1 - t;
        var phi = Math.PI * 45.0/180.0;
        var theta = 0.5 * Math.PI - phi;
        var xoff = r + 0.5 * t;
        var yoff = r + 0.5 * t;
        var knot = (r - b * Math.sin(phi)) / Math.cos(phi);
        ctx.canvas.width = this.nx;
        ctx.canvas.height = this.ny;
        ctx.beginPath();
        ctx.lineWidth = t;
        ctx.strokeStyle = strokeColor;
        ctx.fillStyle = fillColor;
        ctx.translate(xoff, yoff);
        ctx.moveTo(-b, (h - r));
        ctx.quadraticCurveTo(-b, knot, -r * Math.sin(phi), r * Math.cos(phi));
        ctx.arc(0, 0, r, Math.PI - theta, theta, false);
        ctx.quadraticCurveTo(b, knot, b, (h - r));
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        this.canvas = ctx.canvas;
    }

    Marker.prototype.annotate = function(ctx, x, y, msg, font, textColor) {
        ctx.fillStyle = textColor;
        ctx.font = font;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.drawImage(this.canvas,x-18*this.size,y-65*this.size);
        ctx.fillText(msg,x,y-44.5*this.size);
    }

    $(init);
</script>
</body>
</html>
