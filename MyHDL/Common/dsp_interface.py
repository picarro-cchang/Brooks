from myhdl import *
from Host.autogen.interface import EMIF_ADDR_WIDTH, EMIF_DATA_WIDTH
from random import randrange

LOW, HIGH = bool(0), bool(1)
CLK_PERIOD = 20

t_State = enum("INIT","WRITE1","WRITE2","READ1","READ2","IDLE")

def Dsp_interface(clk,reset,addr,to_dsp,re,we,oe,ce,from_dsp,rdy,dsp_oe,
                  dsp_addr,dsp_data_out,dsp_data_in,dsp_wr):
    """Dsp_interface connects the asynchronous DSP EMIF interface to a synchronous interface
        used within the FPGA to access virtual registers and the ringdown memory
    
    clk         -- clock input
    reset       -- reset input
    addr        -- address from EMIF
    to_dsp      -- data to EMIF
    re          -- read enable strobe from EMIF
    we          -- write enable strobe from EMIF
    oe          -- output enable strobe from EMIF
    ce          -- chip enable strobe from EMIF
    from_dsp    -- data from EMIF
    rdy         -- ready signal to EMIF
    dsp_oe      -- output enable for controlling data direction to EMIF
    dsp_addr    -- address output latched from DSP
    dsp_data_out -- Output data from DSP, valid on rising edge of dsp_wr
    dsp_data_in -- Input data to DSP, generated by external logic in response to dsp_addr
    dsp_wr      -- Single cycle strobe used by external logic to save dsp_data_out 
    """

    # Metastability harden enable asynchronous signals from EMIF
    #  The clock edge may be chosen to add differing delays
    ce_h = Signal(LOW)
    we_h = Signal(LOW)
    re_h = Signal(LOW)
    
    @always(clk.posedge)
    def harden():
        ce_h.next = ce
        we_h.next = we
        re_h.next = re

    # The rdy signal to the EMIF indicates when the strobe should be removed, since
    #  the data are ready for reading, or have been written. Since the DSP clock is
    #  much faster than the FPGA clock, it is important that the rdy line be brought
    #  low immediately when ce is asserted. If we wait for the state machine to detect
    #  assertion of ce, the read or write cycle might actually go to completion before
    #  ready can be deasserted. We thus use combinational logic to derive rdy from the
    #  ce signal. Note that if ce is not asserted, the rdy line must go high.
    #
    #  At the end of a cycle (indicated by done_rd or done_wr), the rdy
    #  line goes high. Now, if we leave the rdy signal high for too long (e.g. one
    #  FPGA clock cycle), the next DSP cycle may start in that time. To fix this, the
    #  done_rd and done_wr signals must go down immediately when the appropriate
    #  strobe is deasserted. It is not possible to use ce to indicate the end of a 
    #  cycle, since the ce line may stay high if several cycles occur back-to-back.
    #  The make_done_rd and make_done_wr generators are designed to ensure that the 
    #  rdy signal is low when the next cycle begins. Separate done signals are needed.

    done_rd = Signal(LOW)
    done_wr = Signal(LOW)
    done_rd_d = Signal(LOW)
    done_wr_d = Signal(LOW)

    @always_comb
    def comb():
        dsp_oe.next = oe and ce
        rdy.next = (not ce) or done_rd or done_wr
        to_dsp.next = dsp_data_in 
        
    @always(clk.posedge,re.negedge)
    def make_done_rd():
        if re == 0:
            done_rd.next = LOW
        else:
            done_rd.next = done_rd_d

    @always(clk.posedge,we.negedge)
    def make_done_wr():
        if we == 0:
            done_wr.next = LOW
        else:
            done_wr.next = done_wr_d
    
    @instance
    def logic():
        dsp_addr_v = intbv(0)[EMIF_ADDR_WIDTH:]
        dsp_data_out_v = intbv(0)[EMIF_DATA_WIDTH:]
        dsp_wr_v = LOW
        done_rd_v = LOW
        done_wr_v = LOW
        state_v = t_State.INIT
        while True:
            yield clk.posedge,reset.posedge
            if reset:
                dsp_addr_v[:] = 0
                dsp_data_out_v[:] = 0
                dsp_wr_v = LOW
                done_rd_v = LOW
                done_wr_v = LOW
                state_v = t_State.INIT
            else:
                dsp_wr_v = LOW
                if state_v == t_State.INIT:
                    done_rd_v = LOW
                    done_wr_v = LOW
                    if ce_h:
                        dsp_addr_v[:] = addr
                        if re_h:
                            state_v = t_State.READ1
                        elif we_h:
                            state_v = t_State.WRITE1
                elif state_v == t_State.WRITE1:
                    dsp_data_out_v[:] = from_dsp 
                    dsp_wr_v = HIGH
                    done_wr_v = HIGH
                    state_v = t_State.WRITE2
                elif state_v == t_State.WRITE2:
                    if not we:
                        done_wr_v = LOW
                        state_v = t_State.IDLE
                elif state_v == t_State.READ1:
                    done_rd_v = HIGH
                    state_v = t_State.READ2
                elif state_v == t_State.READ2:
                    if not re:
                        done_rd_v = LOW
                        state_v = t_State.IDLE
                elif state_v == t_State.IDLE:
                    state_v = t_State.INIT

            # Assign the outputs to the DSP    
            dsp_addr.next = dsp_addr_v
            dsp_data_out.next = dsp_data_out_v
            dsp_wr.next = dsp_wr_v
            done_rd_d.next = done_rd_v
            done_wr_d.next = done_wr_v
                
    return logic, comb, harden, make_done_wr, make_done_rd


# The following parameters are the DSP asynchronous interface
# ECLK period 4ns (actually 4.44ns, since DSP clock is 225MHz)
ECLK_PERIOD = 4
WR_SETUP = 2*ECLK_PERIOD
WR_STROBE = 10*ECLK_PERIOD
WR_HOLD = 2*ECLK_PERIOD
RD_SETUP = 2*ECLK_PERIOD
TURN_AROUND = 10*ECLK_PERIOD # Time between memory accesses to different CE spaces
RD_STROBE = 10*ECLK_PERIOD
RD_HOLD = 2*ECLK_PERIOD
#
def bench():
    """Testbench for generating timing information for dsp EMIF interface"""
    eclk = Signal(LOW)
    clk = Signal(LOW)
    reset, re, we, oe, ce, rdy, dsp_wr,dsp_oe = [Signal(LOW) for i in range(8)]
    
    to_dsp = Signal(intbv(0)[EMIF_DATA_WIDTH:])
    from_dsp = Signal(intbv(0)[EMIF_DATA_WIDTH:])
    dsp_data_out = Signal(intbv(0)[EMIF_DATA_WIDTH:])
    dsp_data_in = Signal(intbv(0)[EMIF_DATA_WIDTH:])
    addr = Signal(intbv(0)[EMIF_ADDR_WIDTH:])
    dsp_addr = Signal(intbv(0)[EMIF_ADDR_WIDTH:])
    
    nloops = 400
    
    dut = Dsp_interface(clk,reset,addr,to_dsp,re,we,oe,ce,from_dsp,rdy,dsp_oe,dsp_addr,dsp_data_out,dsp_data_in,dsp_wr)

    @always(delay(ECLK_PERIOD//2))
    def eclock_gen():
        eclk.next = not eclk.next

    @always(delay(CLK_PERIOD//2))
    def clock_gen():
        clk.next = not clk.next
        
    def write_cycle(address,data):
        yield eclk.posedge
        ce.next = 1
        from_dsp.next = data
        addr.next = address
        yield(delay(WR_SETUP))
        we.next = 1
        yield(delay(WR_STROBE))
        while not rdy:
            yield eclk.posedge
        we.next = 0
        yield(delay(WR_HOLD))
        from_dsp.next = 0x0
        addr.next = 0x0
        ce.next = 0

    def read_cycle(address,expected_data):
        yield eclk.posedge
        ce.next = 1
        oe.next = 1
        addr.next = address
        yield(delay(RD_SETUP))
        re.next = 1
        yield(delay(RD_STROBE))
        while not rdy:
            yield eclk.posedge
        re.next = 0
        assert to_dsp == expected_data, "Read error: to_dsp = %x, expected_data = %x" % (to_dsp,expected_data)
        yield(delay(RD_HOLD))
        addr.next = 0x0
        ce.next = 0
        oe.next = 0

    def write_cycle_noce(address,data):
        yield eclk.posedge
        ce.next = 0
        from_dsp.next = data
        addr.next = address
        yield(delay(WR_SETUP))
        we.next = 1
        yield(delay(WR_STROBE))
        while not rdy:
            yield eclk.posedge
        we.next = 0
        yield(delay(WR_HOLD))
        from_dsp.next = 0x0
        addr.next = 0x0
        ce.next = 0

    def read_cycle_noce(address):
        yield eclk.posedge
        ce.next = 0
        oe.next = 1
        addr.next = address
        yield(delay(RD_SETUP))
        re.next = 1
        yield(delay(RD_STROBE))
        while not rdy:
            yield eclk.posedge
        re.next = 0
        yield(delay(RD_HOLD))
        addr.next = 0x0
        ce.next = 0
        oe.next = 0

        
    @instance
    def stimulus():
        for i in range(nloops):
            address = randrange(2**EMIF_ADDR_WIDTH)
            action = randrange(4)
            if action == 0:
                writeData = randrange(0x10000)
                yield write_cycle(address,writeData)
            if action == 1:
                writeData = randrange(0x10000)
                yield write_cycle_noce(address,writeData)
            if action == 2:
                readData = randrange(0x10000)
                dsp_data_in.next = readData
                yield read_cycle(address,readData)
            if action == 3:
                yield read_cycle_noce(address)
            yield delay(randrange(50))
        yield delay(20*CLK_PERIOD)
        raise StopSimulation
                
    @instance
    def monitor_write():
        while True:
            yield we.posedge
            data = from_dsp # Data that is to be written
            address = addr
            if ce:
                assert rdy==0, "RDY must be low at start of a write cycle"
                yield dsp_wr.posedge
                pulse_width = now()
                assert dsp_data_out == data, "DSP write cycle failed" 
                assert dsp_addr == address, "Incorrect write address"
                yield dsp_wr.negedge
                pulse_width = now()-pulse_width
                assert pulse_width == CLK_PERIOD, "Incorrect pulse width for dsp_wr"
            else:
                assert rdy==1, "RDY must be high if CE is deasserted"

    @instance
    def monitor_read():
        while True:
            yield re.posedge
            data = dsp_data_in # Data that is to be read
            address = addr
            if ce:
                assert rdy==0, "RDY must be low at start of a read cycle"
                yield re.negedge
                assert to_dsp == data, "DSP read failed" 
                assert dsp_addr == address, "Incorrect read address"
                assert dsp_oe == 1, "DSP OE incorrect"
            else:
                assert rdy==1, "RDY must be high if CE is deasserted"
        
    return eclock_gen, stimulus, monitor_write, monitor_read, dut, clock_gen
    
def test_bench():
    s = Simulation(traceSignals(bench))
    s.run()

def makeVHDL():
    eclk = Signal(LOW)
    clk = Signal(LOW)
    reset, re, we, oe, ce, rdy, dsp_wr, dsp_oe = [Signal(LOW) for i in range(8)]
    
    to_dsp = Signal(intbv(0)[EMIF_DATA_WIDTH:])
    from_dsp = Signal(intbv(0)[EMIF_DATA_WIDTH:])
    dsp_data_out = Signal(intbv(0)[EMIF_DATA_WIDTH:])
    dsp_data_in = Signal(intbv(0)[EMIF_DATA_WIDTH:])
    addr = Signal(intbv(0)[EMIF_ADDR_WIDTH:])
    dsp_addr = Signal(intbv(0)[EMIF_ADDR_WIDTH:])
    
    toVHDL(Dsp_interface,clk,reset,addr,to_dsp,re,we,oe,ce,from_dsp,rdy,dsp_oe,dsp_addr,dsp_data_out,dsp_data_in,dsp_wr)

if __name__ == "__main__":
    makeVHDL()
    test_bench()
    
     
