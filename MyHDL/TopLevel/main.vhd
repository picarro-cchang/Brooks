-- File: main.vhd
-- Generated by MyHDL 0.6
-- Date: Sat May 16 20:36:06 2009


package pck_main is

    type t_enum_t_State_1 is (
    INIT,
    WRITE1,
    WRITE2,
    READ1,
    READ2,
    IDLE
);
    type t_enum_t_State_2 is (
    IDLE,
    RESETTING,
    COLLECTING,
    DONE
);

end package pck_main;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_06.all;

use work.pck_main.all;

entity main is
    port (
        clk0: in std_logic;
        clk180: in std_logic;
        clk3f: in std_logic;
        clk3f180: in std_logic;
        clk_locked: in std_logic;
        reset: in std_logic;
        intronix: out unsigned(33 downto 0);
        fpga_led: out unsigned(3 downto 0);
        dsp_emif_we: in std_logic;
        dsp_emif_re: in std_logic;
        dsp_emif_oe: in std_logic;
        dsp_emif_ardy: out std_logic;
        dsp_emif_ea: in unsigned(19 downto 0);
        dsp_emif_din: out unsigned(31 downto 0);
        dsp_emif_dout: in unsigned(31 downto 0);
        dsp_emif_ddir: out std_logic;
        dsp_emif_be: in unsigned(3 downto 0);
        dsp_emif_ce: in unsigned(3 downto 0);
        dsp_eclk: in std_logic;
        lsr1_0: out std_logic;
        lsr1_1: out std_logic;
        lsr2_0: out std_logic;
        lsr2_1: out std_logic;
        lsr3_0: out std_logic;
        lsr3_1: out std_logic;
        lsr4_0: out std_logic;
        lsr4_1: out std_logic;
        i2c_rst0: out std_logic;
        i2c_rst1: out std_logic;
        i2c_scl0: in std_logic;
        i2c_sda0: in std_logic;
        i2c_scl1: in std_logic;
        i2c_sda1: in std_logic;
        rd_adc: in unsigned(15 downto 0);
        rd_adc_clk: out std_logic;
        rd_adc_oe: out std_logic;
        monitor: out std_logic;
        dsp_ext_int4: out std_logic;
        dsp_ext_int5: out std_logic;
        dsp_ext_int6: out std_logic;
        dsp_ext_int7: out std_logic
    );
end entity main;

architecture MyHDL of main is

signal addr_div: unsigned(4 downto 0);
signal dsp_data_in_laser2_pwm: unsigned(31 downto 0);
signal adc_clk: std_logic;
signal dsp_wr: std_logic;
signal addr_reset: std_logic;
signal ce2: std_logic;
signal laser4_pwm_out: std_logic;
signal dsp_data_in_laser4_pwm: unsigned(31 downto 0);
signal laser2_pwm_out: std_logic;
signal bank: std_logic;
signal arm: std_logic;
signal dsp_data_in_laser3_pwm: unsigned(31 downto 0);
signal param_we: std_logic;
signal meta: unsigned(15 downto 0);
signal wr_meta: unsigned(15 downto 0);
signal state: t_enum_t_State_2;
signal wr_data: unsigned(17 downto 0);
signal meta_we: std_logic;
signal param_addr: unsigned(5 downto 0);
signal laser3_pwm_inv_out: std_logic;
signal wr_param: unsigned(15 downto 0);
signal enable: std_logic;
signal dsp_data_out: unsigned(31 downto 0);
signal compare_result: std_logic;
signal dsp_data_in_laser1_pwm: unsigned(31 downto 0);
signal dsp_data_in_rdmemory: unsigned(31 downto 0);
signal laser2_pwm_inv_out: std_logic;
signal data_addr: unsigned(11 downto 0);
signal laser4_pwm_inv_out: std_logic;
signal laser3_pwm_out: std_logic;
signal divisor: unsigned(15 downto 0);
signal meta_addr: unsigned(11 downto 0);
signal dsp_addr: unsigned(19 downto 0);
signal dsp_data_in_rdcompare: unsigned(31 downto 0);
signal dsp_data_in: unsigned(31 downto 0);
signal laser1_pwm_out: std_logic;
signal counter: unsigned(27 downto 0);
signal data: unsigned(17 downto 0);
signal param: unsigned(15 downto 0);
signal laser1_pwm_inv_out: std_logic;
signal data_we: std_logic;
signal rdDataAddrGen_data_addr_i: unsigned(11 downto 0);
signal rdDataAddrGen_adc_clk_i: std_logic;
signal rdDataAddrGen_divider: unsigned(4 downto 0);
signal rdmemory_wr_dataA: unsigned(17 downto 0);
signal rdmemory_wr_paramA: unsigned(15 downto 0);
signal rdmemory_enB_data: std_logic;
signal rdmemory_param_addrB: unsigned(6 downto 0);
signal rdmemory_param_addrA: unsigned(6 downto 0);
signal rdmemory_enA_data: std_logic;
signal rdmemory_enB_param: std_logic;
signal rdmemory_meta_addrB: unsigned(12 downto 0);
signal rdmemory_meta_addrA: unsigned(12 downto 0);
signal rdmemory_rd_dataA: unsigned(17 downto 0);
signal rdmemory_enA_param: std_logic;
signal rdmemory_data_addrA: unsigned(12 downto 0);
signal rdmemory_data_addrB: unsigned(12 downto 0);
signal rdmemory_rd_metaA: unsigned(15 downto 0);
signal rdmemory_enA_meta: std_logic;
signal rdmemory_rd_paramA: unsigned(15 downto 0);
signal rdmemory_enB_meta: std_logic;
signal rdmemory_wr_metaA: unsigned(15 downto 0);
signal rdcompare_dsp_data_from_regs: unsigned(15 downto 0);
signal rdcompare_threshold: unsigned(15 downto 0);
signal rdcompare_rate_divisor: unsigned(15 downto 0);
signal laser4_pwm_temp: unsigned(8 downto 0);
signal laser4_pwm_pulse_width: unsigned(15 downto 0);
signal laser4_pwm_cs: unsigned(15 downto 0);
signal laser4_pwm_dither_cntr: unsigned(7 downto 0);
signal laser4_pwm_pwm: std_logic;
signal laser4_pwm_main_cntr: unsigned(7 downto 0);
signal laser3_pwm_temp: unsigned(8 downto 0);
signal laser3_pwm_pulse_width: unsigned(15 downto 0);
signal laser3_pwm_cs: unsigned(15 downto 0);
signal laser3_pwm_dither_cntr: unsigned(7 downto 0);
signal laser3_pwm_pwm: std_logic;
signal laser3_pwm_main_cntr: unsigned(7 downto 0);
signal laser2_pwm_temp: unsigned(8 downto 0);
signal laser2_pwm_pulse_width: unsigned(15 downto 0);
signal laser2_pwm_cs: unsigned(15 downto 0);
signal laser2_pwm_dither_cntr: unsigned(7 downto 0);
signal laser2_pwm_pwm: std_logic;
signal laser2_pwm_main_cntr: unsigned(7 downto 0);
signal laser1_pwm_temp: unsigned(8 downto 0);
signal laser1_pwm_pulse_width: unsigned(15 downto 0);
signal laser1_pwm_cs: unsigned(15 downto 0);
signal laser1_pwm_dither_cntr: unsigned(7 downto 0);
signal laser1_pwm_pwm: std_logic;
signal laser1_pwm_main_cntr: unsigned(7 downto 0);
signal dsp_interface_done_wr_d: std_logic;
signal dsp_interface_done_wr: std_logic;
signal dsp_interface_done_rd_d: std_logic;
signal dsp_interface_ce_h: std_logic;
signal dsp_interface_done_rd: std_logic;
signal dsp_interface_we_h: std_logic;
signal dsp_interface_re_h: std_logic;

begin


MAIN_RDCOMPARE_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        rdcompare_threshold <= "0000000000000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 94) then
                if to_boolean(dsp_wr) then
                    rdcompare_threshold <= resize(dsp_data_out, 16);
                end if;
                rdcompare_dsp_data_from_regs <= rdcompare_threshold;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 95) then
                if to_boolean(dsp_wr) then
                    rdcompare_rate_divisor <= resize(dsp_data_out, 16);
                end if;
                rdcompare_dsp_data_from_regs <= rdcompare_rate_divisor;
            else
                rdcompare_dsp_data_from_regs <= "0000000000000000";
            end if;
        else
            rdcompare_dsp_data_from_regs <= "0000000000000000";
        end if;
    end if;
end process MAIN_RDCOMPARE_LOGIC;


dsp_data_in_rdcompare <= resize(rdcompare_dsp_data_from_regs, 32);
compare_result <= to_std_logic(rd_adc > rdcompare_threshold);
divisor <= rdcompare_rate_divisor;


laser3_pwm_out <= laser3_pwm_pwm;
laser3_pwm_inv_out <= (laser3_pwm_pwm xor laser3_pwm_cs(1));
laser3_pwm_temp <= (resize(laser3_pwm_dither_cntr, 9) + laser3_pwm_pulse_width(8-1 downto 0));

MAIN_LASER3_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laser3_pwm_cs <= "0000000000000000";
        laser3_pwm_pulse_width <= "0000000000000000";
        laser3_pwm_main_cntr <= "00000000";
        laser3_pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 5) then
                if to_boolean(dsp_wr) then
                    laser3_pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser3_pwm <= resize(laser3_pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 6) then
                if to_boolean(dsp_wr) then
                    laser3_pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser3_pwm <= resize(laser3_pwm_pulse_width, 32);
            else
                dsp_data_in_laser3_pwm <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laser3_pwm <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laser3_pwm_cs(0)) then
            if (not to_boolean(laser3_pwm_cs(1))) then
                laser3_pwm_cs(0) <= '0';
            end if;
            laser3_pwm_pwm <= '0';
            if (laser3_pwm_main_cntr < laser3_pwm_pulse_width(16-1 downto (16 - 8))) then
                laser3_pwm_pwm <= '1';
            elsif (laser3_pwm_main_cntr = laser3_pwm_pulse_width(16-1 downto 8)) then
                if (laser3_pwm_temp >= 256) then
                    laser3_pwm_pwm <= '1';
                    laser3_pwm_cs(2) <= '1';
                    laser3_pwm_dither_cntr <= resize(laser3_pwm_temp - 256, 8);
                else
                    laser3_pwm_dither_cntr <= resize(laser3_pwm_temp, 8);
                end if;
            end if;
            laser3_pwm_main_cntr <= ((laser3_pwm_main_cntr + 1) mod 256);
        end if;
        laser3_pwm_cs(2) <= laser3_pwm_pwm;
    end if;
end process MAIN_LASER3_PWM_LOGIC;



dual_port_ram_2 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => rdmemory_enA_meta, wr_enableA => dsp_wr,
    addressA => rdmemory_meta_addrA, rd_dataA => rdmemory_rd_metaA, wr_dataA => rdmemory_wr_metaA,
    clockB => clk0, enableB => rdmemory_enB_meta, wr_enableB => meta_we,
    addressB => rdmemory_meta_addrB, rd_dataB => meta, wr_dataB => wr_meta
    );

MAIN_RDMEMORY_COMB: process (dsp_data_out, meta_addr, param_addr, rdmemory_rd_dataA, data_addr, rdmemory_rd_paramA, dsp_addr, rdmemory_rd_metaA, bank) is
    variable sel_meta: std_logic;
    variable sel_param: std_logic;
    variable sel_data: std_logic;
begin
    rdmemory_enB_data <= '1';
    sel_data := to_std_logic((dsp_addr(20-1 downto 12) = 4) or (dsp_addr(20-1 downto 12) = 0));
    rdmemory_data_addrA(12-1 downto 0) <= dsp_addr(12-1 downto 0);
    rdmemory_data_addrA(12) <= dsp_addr((12 + 2));
    rdmemory_enA_data <= sel_data;
    rdmemory_data_addrB(12-1 downto 0) <= data_addr;
    rdmemory_data_addrB(12) <= bank;
    rdmemory_wr_dataA <= dsp_data_out(18-1 downto 0);
    rdmemory_enB_meta <= '1';
    sel_meta := to_std_logic((dsp_addr(20-1 downto 12) = 5) or (dsp_addr(20-1 downto 12) = 1));
    rdmemory_meta_addrA(12-1 downto 0) <= dsp_addr(12-1 downto 0);
    rdmemory_meta_addrA(12) <= dsp_addr((12 + 2));
    rdmemory_enA_meta <= sel_meta;
    rdmemory_meta_addrB(12-1 downto 0) <= meta_addr;
    rdmemory_meta_addrB(12) <= bank;
    rdmemory_wr_metaA <= dsp_data_out(16-1 downto 0);
    rdmemory_enB_param <= '1';
    sel_param := to_std_logic((dsp_addr(20-1 downto 12) = 6) or (dsp_addr(20-1 downto 12) = 2));
    rdmemory_param_addrA(6-1 downto 0) <= dsp_addr(6-1 downto 0);
    rdmemory_param_addrA(6) <= dsp_addr((12 + 2));
    rdmemory_enA_param <= sel_param;
    rdmemory_param_addrB(6-1 downto 0) <= param_addr;
    rdmemory_param_addrB(6) <= bank;
    rdmemory_wr_paramA <= dsp_data_out(16-1 downto 0);
    if to_boolean(sel_data) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_dataA(18-1 downto 0), 32);
    elsif to_boolean(sel_meta) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_metaA(16-1 downto 0), 32);
    elsif to_boolean(sel_param) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_paramA(16-1 downto 0), 32);
    else
        dsp_data_in_rdmemory <= "00000000000000000000000000000000";
    end if;
end process MAIN_RDMEMORY_COMB;



dual_port_ram_3 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 7, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => rdmemory_enA_param, wr_enableA => dsp_wr,
    addressA => rdmemory_param_addrA, rd_dataA => rdmemory_rd_paramA, wr_dataA => rdmemory_wr_paramA,
    clockB => clk0, enableB => rdmemory_enB_param, wr_enableB => param_we,
    addressB => rdmemory_param_addrB, rd_dataB => param, wr_dataB => wr_param
    );



dual_port_ram_1 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 18)
    port map (
    clockA => clk0, enableA => rdmemory_enA_data, wr_enableA => dsp_wr,
    addressA => rdmemory_data_addrA, rd_dataA => rdmemory_rd_dataA, wr_dataA => rdmemory_wr_dataA,
    clockB => clk0, enableB => rdmemory_enB_data, wr_enableB => data_we,
    addressB => rdmemory_data_addrB, rd_dataB => data, wr_dataB => wr_data
    );

MAIN_DSP_INTERFACE_LOGIC: process (clk0, reset) is
    variable dsp_addr_v: unsigned(19 downto 0);
    variable done_rd_v: std_logic;
    variable dsp_wr_v: std_logic;
    variable dsp_data_out_v: unsigned(31 downto 0);
    variable done_wr_v: std_logic;
    variable state_v: t_enum_t_State_1;
begin
    if to_boolean(reset) then
        dsp_addr_v := "00000000000000000000";
        dsp_data_out_v := "00000000000000000000000000000000";
        dsp_wr_v := '0';
        done_rd_v := '0';
        done_wr_v := '0';
        state_v := INIT;
    elsif rising_edge(clk0) then
        dsp_wr_v := '0';
        case state_v is
            when INIT =>
                done_rd_v := '0';
                done_wr_v := '0';
                if to_boolean(dsp_interface_ce_h) then
                    dsp_addr_v := dsp_emif_ea;
                    if to_boolean(dsp_interface_re_h) then
                        state_v := READ1;
                    elsif to_boolean(dsp_interface_we_h) then
                        state_v := WRITE1;
                    end if;
                end if;
            when WRITE1 =>
                dsp_data_out_v := dsp_emif_dout;
                dsp_wr_v := '1';
                done_wr_v := '1';
                state_v := WRITE2;
            when WRITE2 =>
                if (not to_boolean(dsp_emif_we)) then
                    done_wr_v := '0';
                    state_v := IDLE;
                end if;
            when READ1 =>
                done_rd_v := '1';
                state_v := READ2;
            when READ2 =>
                if (not to_boolean(dsp_emif_re)) then
                    done_rd_v := '0';
                    state_v := IDLE;
                end if;
            when IDLE =>
                state_v := INIT;
        end case;
    end if;
    dsp_addr <= dsp_addr_v;
    dsp_data_out <= dsp_data_out_v;
    dsp_wr <= dsp_wr_v;
    dsp_interface_done_rd_d <= done_rd_v;
    dsp_interface_done_wr_d <= done_wr_v;
end process MAIN_DSP_INTERFACE_LOGIC;


dsp_emif_ddir <= to_std_logic(to_boolean(dsp_emif_oe) and to_boolean(ce2));
dsp_emif_ardy <= to_std_logic((not to_boolean(ce2)) or to_boolean(dsp_interface_done_rd) or to_boolean(dsp_interface_done_wr));
dsp_emif_din <= dsp_data_in;

MAIN_DSP_INTERFACE_HARDEN: process (clk0) is
begin
    if rising_edge(clk0) then
        dsp_interface_ce_h <= ce2;
        dsp_interface_we_h <= dsp_emif_we;
        dsp_interface_re_h <= dsp_emif_re;
    end if;
end process MAIN_DSP_INTERFACE_HARDEN;

MAIN_DSP_INTERFACE_MAKE_DONE_WR: process (clk0, dsp_emif_we) is
begin
    if (dsp_emif_we = '0') then
        dsp_interface_done_wr <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_wr <= dsp_interface_done_wr_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_WR;

MAIN_DSP_INTERFACE_MAKE_DONE_RD: process (clk0, dsp_emif_re) is
begin
    if (dsp_emif_re = '0') then
        dsp_interface_done_rd <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_rd <= dsp_interface_done_rd_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_RD;

MAIN_RDDATAADDRGEN_SEQ: process (clk0) is
begin
    if rising_edge(clk0) then
        data_we <= '0';
        rdDataAddrGen_adc_clk_i <= to_std_logic(not to_boolean(rdDataAddrGen_adc_clk_i));
        if to_boolean(addr_reset) then
            rdDataAddrGen_divider <= addr_div;
            rdDataAddrGen_data_addr_i <= "111111111111";
        elsif (to_boolean(enable) and to_boolean(rdDataAddrGen_adc_clk_i)) then
            if (rdDataAddrGen_divider = addr_div) then
                rdDataAddrGen_divider <= "00000";
                rdDataAddrGen_data_addr_i <= ((rdDataAddrGen_data_addr_i + 1) mod 4096);
                data_we <= '1';
            else
                rdDataAddrGen_divider <= ((rdDataAddrGen_divider + 1) mod 32);
            end if;
        end if;
    end if;
end process MAIN_RDDATAADDRGEN_SEQ;


adc_clk <= rdDataAddrGen_adc_clk_i;
data_addr <= rdDataAddrGen_data_addr_i;

MAIN_COMB: process (laser1_pwm_out, dsp_data_in_rdcompare, dsp_data_in_laser2_pwm, dsp_data_in_laser4_pwm, i2c_scl1, i2c_scl0, laser2_pwm_out, laser1_pwm_inv_out, dsp_emif_re, dsp_data_in_laser3_pwm, compare_result, laser3_pwm_inv_out, i2c_sda1, i2c_sda0, dsp_emif_oe, dsp_emif_we, dsp_data_in_laser1_pwm, dsp_data_in_rdmemory, clk0, adc_clk, reset, laser4_pwm_inv_out, laser2_pwm_inv_out, divisor, laser4_pwm_out, counter, dsp_emif_ce, laser3_pwm_out, rd_adc) is
begin
    dsp_data_in <= (dsp_data_in_laser1_pwm or dsp_data_in_laser2_pwm or dsp_data_in_laser3_pwm or dsp_data_in_laser4_pwm or dsp_data_in_rdcompare or dsp_data_in_rdmemory);
    ce2 <= dsp_emif_ce(2);
    intronix(16) <= laser1_pwm_out;
    intronix(17) <= laser1_pwm_inv_out;
    lsr1_0 <= laser1_pwm_out;
    lsr1_1 <= laser1_pwm_inv_out;
    intronix(18) <= laser2_pwm_out;
    intronix(19) <= laser2_pwm_inv_out;
    lsr2_0 <= laser2_pwm_out;
    lsr2_1 <= laser2_pwm_inv_out;
    intronix(20) <= laser3_pwm_out;
    intronix(21) <= laser3_pwm_inv_out;
    lsr3_0 <= laser3_pwm_out;
    lsr3_1 <= laser3_pwm_inv_out;
    intronix(22) <= laser4_pwm_out;
    intronix(23) <= laser4_pwm_inv_out;
    lsr4_0 <= laser4_pwm_out;
    lsr4_1 <= laser4_pwm_inv_out;
    intronix(24) <= dsp_emif_we;
    intronix(25) <= dsp_emif_oe;
    intronix(26) <= dsp_emif_re;
    intronix(27) <= dsp_emif_ce(2);
    intronix(32) <= compare_result;
    monitor <= compare_result;
    intronix(16-1 downto 0) <= rd_adc;
    rd_adc_clk <= adc_clk;
    rd_adc_oe <= '1';
    fpga_led <= counter(28-1 downto (28 - 4));
    i2c_rst0 <= reset;
    i2c_rst1 <= reset;
    intronix(28) <= i2c_scl0;
    intronix(29) <= i2c_sda0;
    intronix(30) <= i2c_scl1;
    intronix(31) <= i2c_sda1;
    intronix(33) <= clk0;
    bank <= '0';
    meta_addr <= "000000000000";
    wr_meta <= "0000000000000000";
    meta_we <= '0';
    param_addr <= "000000";
    wr_param <= "0000000000000000";
    param_we <= '0';
    wr_data <= resize(rd_adc, 18);
    addr_div <= divisor(5-1 downto 0);
    arm <= divisor(8);
    dsp_ext_int4 <= counter((28 - 4));
    dsp_ext_int5 <= '0';
    dsp_ext_int6 <= '0';
    dsp_ext_int7 <= '0';
end process MAIN_COMB;

MAIN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        counter <= "0000000000000000000000000000";
    elsif rising_edge(clk0) then
        counter <= (counter + 1);
        case state is
            when IDLE =>
                enable <= '0';
                addr_reset <= '0';
                if to_boolean(arm) then
                    state <= RESETTING;
                end if;
            when RESETTING =>
                enable <= '0';
                addr_reset <= '1';
                state <= COLLECTING;
            when COLLECTING =>
                enable <= '1';
                addr_reset <= '0';
                if ((data_addr = 4095) and to_boolean(data_we)) then
                    state <= DONE;
                end if;
            when DONE =>
                enable <= '0';
                addr_reset <= '0';
                if (not to_boolean(arm)) then
                    state <= IDLE;
                end if;
        end case;
    end if;
end process MAIN_LOGIC;


laser1_pwm_out <= laser1_pwm_pwm;
laser1_pwm_inv_out <= (laser1_pwm_pwm xor laser1_pwm_cs(1));
laser1_pwm_temp <= (resize(laser1_pwm_dither_cntr, 9) + laser1_pwm_pulse_width(8-1 downto 0));

MAIN_LASER1_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laser1_pwm_cs <= "0000000000000000";
        laser1_pwm_pulse_width <= "0000000000000000";
        laser1_pwm_main_cntr <= "00000000";
        laser1_pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 1) then
                if to_boolean(dsp_wr) then
                    laser1_pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser1_pwm <= resize(laser1_pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 2) then
                if to_boolean(dsp_wr) then
                    laser1_pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser1_pwm <= resize(laser1_pwm_pulse_width, 32);
            else
                dsp_data_in_laser1_pwm <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laser1_pwm <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laser1_pwm_cs(0)) then
            if (not to_boolean(laser1_pwm_cs(1))) then
                laser1_pwm_cs(0) <= '0';
            end if;
            laser1_pwm_pwm <= '0';
            if (laser1_pwm_main_cntr < laser1_pwm_pulse_width(16-1 downto (16 - 8))) then
                laser1_pwm_pwm <= '1';
            elsif (laser1_pwm_main_cntr = laser1_pwm_pulse_width(16-1 downto 8)) then
                if (laser1_pwm_temp >= 256) then
                    laser1_pwm_pwm <= '1';
                    laser1_pwm_cs(2) <= '1';
                    laser1_pwm_dither_cntr <= resize(laser1_pwm_temp - 256, 8);
                else
                    laser1_pwm_dither_cntr <= resize(laser1_pwm_temp, 8);
                end if;
            end if;
            laser1_pwm_main_cntr <= ((laser1_pwm_main_cntr + 1) mod 256);
        end if;
        laser1_pwm_cs(2) <= laser1_pwm_pwm;
    end if;
end process MAIN_LASER1_PWM_LOGIC;


laser4_pwm_out <= laser4_pwm_pwm;
laser4_pwm_inv_out <= (laser4_pwm_pwm xor laser4_pwm_cs(1));
laser4_pwm_temp <= (resize(laser4_pwm_dither_cntr, 9) + laser4_pwm_pulse_width(8-1 downto 0));

MAIN_LASER4_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laser4_pwm_cs <= "0000000000000000";
        laser4_pwm_pulse_width <= "0000000000000000";
        laser4_pwm_main_cntr <= "00000000";
        laser4_pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 7) then
                if to_boolean(dsp_wr) then
                    laser4_pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser4_pwm <= resize(laser4_pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 8) then
                if to_boolean(dsp_wr) then
                    laser4_pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser4_pwm <= resize(laser4_pwm_pulse_width, 32);
            else
                dsp_data_in_laser4_pwm <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laser4_pwm <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laser4_pwm_cs(0)) then
            if (not to_boolean(laser4_pwm_cs(1))) then
                laser4_pwm_cs(0) <= '0';
            end if;
            laser4_pwm_pwm <= '0';
            if (laser4_pwm_main_cntr < laser4_pwm_pulse_width(16-1 downto (16 - 8))) then
                laser4_pwm_pwm <= '1';
            elsif (laser4_pwm_main_cntr = laser4_pwm_pulse_width(16-1 downto 8)) then
                if (laser4_pwm_temp >= 256) then
                    laser4_pwm_pwm <= '1';
                    laser4_pwm_cs(2) <= '1';
                    laser4_pwm_dither_cntr <= resize(laser4_pwm_temp - 256, 8);
                else
                    laser4_pwm_dither_cntr <= resize(laser4_pwm_temp, 8);
                end if;
            end if;
            laser4_pwm_main_cntr <= ((laser4_pwm_main_cntr + 1) mod 256);
        end if;
        laser4_pwm_cs(2) <= laser4_pwm_pwm;
    end if;
end process MAIN_LASER4_PWM_LOGIC;


laser2_pwm_out <= laser2_pwm_pwm;
laser2_pwm_inv_out <= (laser2_pwm_pwm xor laser2_pwm_cs(1));
laser2_pwm_temp <= (resize(laser2_pwm_dither_cntr, 9) + laser2_pwm_pulse_width(8-1 downto 0));

MAIN_LASER2_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laser2_pwm_cs <= "0000000000000000";
        laser2_pwm_pulse_width <= "0000000000000000";
        laser2_pwm_main_cntr <= "00000000";
        laser2_pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 3) then
                if to_boolean(dsp_wr) then
                    laser2_pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser2_pwm <= resize(laser2_pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 4) then
                if to_boolean(dsp_wr) then
                    laser2_pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser2_pwm <= resize(laser2_pwm_pulse_width, 32);
            else
                dsp_data_in_laser2_pwm <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laser2_pwm <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laser2_pwm_cs(0)) then
            if (not to_boolean(laser2_pwm_cs(1))) then
                laser2_pwm_cs(0) <= '0';
            end if;
            laser2_pwm_pwm <= '0';
            if (laser2_pwm_main_cntr < laser2_pwm_pulse_width(16-1 downto (16 - 8))) then
                laser2_pwm_pwm <= '1';
            elsif (laser2_pwm_main_cntr = laser2_pwm_pulse_width(16-1 downto 8)) then
                if (laser2_pwm_temp >= 256) then
                    laser2_pwm_pwm <= '1';
                    laser2_pwm_cs(2) <= '1';
                    laser2_pwm_dither_cntr <= resize(laser2_pwm_temp - 256, 8);
                else
                    laser2_pwm_dither_cntr <= resize(laser2_pwm_temp, 8);
                end if;
            end if;
            laser2_pwm_main_cntr <= ((laser2_pwm_main_cntr + 1) mod 256);
        end if;
        laser2_pwm_cs(2) <= laser2_pwm_pwm;
    end if;
end process MAIN_LASER2_PWM_LOGIC;

end architecture MyHDL;
