-- File: main.vhd
-- Generated by MyHDL 0.6
-- Date: Fri Jul 10 19:58:44 2009


package pck_main is

    type t_enum_t_State_2 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
    type t_enum_SeqState_6 is (
    IDLE,
    START_INJECT,
    WAIT_FOR_PRECONTROL,
    WAIT_FOR_LOCK,
    WAIT_FOR_GATING_CONDITIONS,
    CHECK_BELOW_THRESHOLD,
    WAIT_FOR_THRESHOLD,
    IN_RINGDOWN,
    CHECK_PARAMS_DONE,
    ACQ_DONE
);
    type t_enum_t_State_1 is (
    INIT,
    WRITE1,
    WRITE2,
    READ1,
    READ2,
    IDLE
);
    type t_enum_ParamState_5 is (
    IDLE,
    STORING,
    DONE
);
    type t_enum_t_State_7 is (
    NORMAL,
    DISCONNECTED,
    RESETTING
);
    type t_enum_t_State_3 is (
    INIT,
    GENVALUE
);
    type t_enum_MetadataAcqState_4 is (
    IDLE,
    AWAIT_STROBE,
    ACQUIRING,
    DONE
);

end package pck_main;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_06.all;

use work.pck_main.all;

entity main is
    port (
        clk0: in std_logic;
        clk180: in std_logic;
        clk3f: in std_logic;
        clk3f180: in std_logic;
        clk_locked: in std_logic;
        reset: in std_logic;
        intronix: out unsigned(33 downto 0);
        fpga_led: out unsigned(3 downto 0);
        dsp_emif_we: in std_logic;
        dsp_emif_re: in std_logic;
        dsp_emif_oe: in std_logic;
        dsp_emif_ardy: out std_logic;
        dsp_emif_ea: in unsigned(19 downto 0);
        dsp_emif_din: out unsigned(31 downto 0);
        dsp_emif_dout: in unsigned(31 downto 0);
        dsp_emif_ddir: out std_logic;
        dsp_emif_be: in unsigned(3 downto 0);
        dsp_emif_ce: in unsigned(3 downto 0);
        dsp_eclk: in std_logic;
        lsr1_0: out std_logic;
        lsr1_1: out std_logic;
        lsr2_0: out std_logic;
        lsr2_1: out std_logic;
        lsr3_0: out std_logic;
        lsr3_1: out std_logic;
        lsr4_0: out std_logic;
        lsr4_1: out std_logic;
        lsr1_sck: out std_logic;
        lsr1_ss: out std_logic;
        lsr1_rd: out std_logic;
        lsr1_mosi: out std_logic;
        lsr1_disable: out std_logic;
        lsr2_sck: out std_logic;
        lsr2_ss: out std_logic;
        lsr2_rd: out std_logic;
        lsr2_mosi: out std_logic;
        lsr2_disable: out std_logic;
        lsr3_sck: out std_logic;
        lsr3_ss: out std_logic;
        lsr3_rd: out std_logic;
        lsr3_mosi: out std_logic;
        lsr3_disable: out std_logic;
        lsr4_sck: out std_logic;
        lsr4_ss: out std_logic;
        lsr4_rd: out std_logic;
        lsr4_mosi: out std_logic;
        lsr4_disable: out std_logic;
        sw1: out std_logic;
        sw2: out std_logic;
        sw3: out std_logic;
        sw4: out std_logic;
        i2c_rst0: out std_logic;
        i2c_rst1: out std_logic;
        i2c_scl0: in std_logic;
        i2c_sda0: in std_logic;
        i2c_scl1: in std_logic;
        i2c_sda1: in std_logic;
        rd_adc: in unsigned(15 downto 0);
        rd_adc_clk: out std_logic;
        rd_adc_oe: out std_logic;
        monitor: out std_logic;
        dsp_ext_int4: out std_logic;
        dsp_ext_int5: out std_logic;
        dsp_ext_int6: out std_logic;
        dsp_ext_int7: out std_logic;
        usb_connected: in std_logic;
        cyp_reset: out std_logic
    );
end entity main;

architecture MyHDL of main is

signal wr_meta: unsigned(15 downto 0);
signal clk_5M: std_logic;
signal meta: unsigned(15 downto 0);
signal ce2: std_logic;
signal rd_irq: std_logic;
signal laser_freq_ok: std_logic;
signal pulse_100k: std_logic;
signal laser3_pwm_inv_out: std_logic;
signal dsp_data_in_rdman: unsigned(31 downto 0);
signal tuner_slope: std_logic;
signal metadata_strobe: std_logic;
signal dsp_data_in_laser1_pwm: unsigned(31 downto 0);
signal dsp_data_in_twGen: unsigned(31 downto 0);
signal dsp_data_in_rdmemory: unsigned(31 downto 0);
signal data_addr: unsigned(11 downto 0);
signal bank: std_logic;
signal laser4_pwm_inv_out: std_logic;
signal tuner_in_window: std_logic;
signal meta_addr: unsigned(11 downto 0);
signal data_we: std_logic;
signal dsp_data_in: unsigned(31 downto 0);
signal laser3_pwm_out: std_logic;
signal soa_shutdown_in: std_logic;
signal laser_shutdown_in: std_logic;
signal laser1_pwm_inv_out: std_logic;
signal dsp_addr: unsigned(19 downto 0);
signal pulse_1M: std_logic;
signal dsp_data_in_laser3_pwm: unsigned(31 downto 0);
signal laser2_pwm_inv_out: std_logic;
signal dsp_data_in_inject: unsigned(31 downto 0);
signal param_addr: unsigned(5 downto 0);
signal laser_locked: std_logic;
signal laser1_pwm_out: std_logic;
signal dsp_data_in_laser2_pwm: unsigned(31 downto 0);
signal dsp_wr: std_logic;
signal rd_trig: std_logic;
signal wr_data: unsigned(17 downto 0);
signal data: unsigned(17 downto 0);
signal param_we: std_logic;
signal dsp_data_out: unsigned(31 downto 0);
signal tuner_value: unsigned(15 downto 0);
signal dsp_data_in_kernel: unsigned(31 downto 0);
signal rdsim_value: unsigned(15 downto 0);
signal adc_clk: std_logic;
signal dsp_data_in_laser4_pwm: unsigned(31 downto 0);
signal laser4_pwm_out: std_logic;
signal gpreg_1: unsigned(15 downto 0);
signal acq_done_irq: std_logic;
signal laser2_pwm_out: std_logic;
signal meta0: unsigned(15 downto 0);
signal meta1: unsigned(15 downto 0);
signal meta2: unsigned(15 downto 0);
signal meta3: unsigned(15 downto 0);
signal meta4: unsigned(15 downto 0);
signal meta5: unsigned(15 downto 0);
signal meta6: unsigned(15 downto 0);
signal meta7: unsigned(15 downto 0);
signal wr_param: unsigned(15 downto 0);
signal dsp_data_in_rdsim: unsigned(31 downto 0);
signal meta_we: std_logic;
signal clk_2M5: std_logic;
signal param: unsigned(15 downto 0);
signal counter: unsigned(27 downto 0);
signal laser_fine_current_in: unsigned(15 downto 0);
signal acc_en: std_logic;
signal rdman_control: unsigned(15 downto 0);
signal rdman_tuner_at_ringdown: unsigned(15 downto 0);
signal rdman_lapped: std_logic;
signal rdman_us_since_start: unsigned(31 downto 0);
signal rdman_metadata_addrcntr: unsigned(11 downto 0);
signal rdman_num_samp: unsigned(11 downto 0);
signal rdman_precontrol_duration: unsigned(15 downto 0);
signal rdman_acq_done_irq: std_logic;
signal rdman_freq_gating_conditions: std_logic;
signal rdman_rd_adc_clk: std_logic;
signal rdman_metadata_acq: std_logic;
signal rdman_threshold: unsigned(15 downto 0);
signal rdman_rd_irq: std_logic;
signal rdman_rd_trig: std_logic;
signal rdman_param7: unsigned(15 downto 0);
signal rdman_timeout_duration: unsigned(31 downto 0);
signal rdman_abort: std_logic;
signal rdman_us_timer_enable: std_logic;
signal rdman_seqState: t_enum_SeqState_6;
signal rdman_param4: unsigned(15 downto 0);
signal rdman_param1: unsigned(15 downto 0);
signal rdman_lock_duration: unsigned(15 downto 0);
signal rdman_status: unsigned(15 downto 0);
signal rdman_data_addrcntr: unsigned(11 downto 0);
signal rdman_rd_divider: unsigned(4 downto 0);
signal rdman_param_acq: std_logic;
signal rdman_param_addrcntr: unsigned(5 downto 0);
signal rdman_tuner_gating_conditions: std_logic;
signal rdman_expiry_time: unsigned(31 downto 0);
signal rdman_init_flag: std_logic;
signal rdman_bank: std_logic;
signal rdman_metadata_addr_at_ringdown: unsigned(15 downto 0);
signal rdman_metadataAcqState: t_enum_MetadataAcqState_4;
signal rdman_divisor: unsigned(4 downto 0);
signal rdman_paramState: t_enum_ParamState_5;
signal rdman_param6: unsigned(15 downto 0);
signal rdman_param5: unsigned(15 downto 0);
signal rdman_param3: unsigned(15 downto 0);
signal rdman_param2: unsigned(15 downto 0);
signal rdman_timeout: std_logic;
signal rdman_param0: unsigned(15 downto 0);
signal rdsim_a: unsigned(17 downto 0);
signal rdsim_b: unsigned(17 downto 0);
signal rdsim_p: unsigned(35 downto 0);
signal rdsim_tuner_center: unsigned(15 downto 0);
signal rdsim_accumulator: unsigned(19 downto 0);
signal rdsim_state: t_enum_t_State_3;
signal rdsim_decay: unsigned(15 downto 0);
signal rdsim_filling_rate: unsigned(15 downto 0);
signal rdsim_tuner_window_half_width: unsigned(15 downto 0);
signal inject_laser4_fine_current: unsigned(15 downto 0);
signal inject_laser_current_en: unsigned(3 downto 0);
signal inject_sel: unsigned(1 downto 0);
signal inject_laser_shutdown_en: std_logic;
signal inject_laser3_fine: unsigned(15 downto 0);
signal inject_laser3_fine_current: unsigned(15 downto 0);
signal inject_laser2_coarse_current: unsigned(15 downto 0);
signal inject_laser2_fine_current: unsigned(15 downto 0);
signal inject_laser4_coarse_current: unsigned(15 downto 0);
signal inject_manual_laser_en: unsigned(3 downto 0);
signal inject_soa_shutdown_en: std_logic;
signal inject_laser1_coarse_current: unsigned(15 downto 0);
signal inject_manual_soa_en: std_logic;
signal inject_control: unsigned(15 downto 0);
signal inject_laser1_fine_current: unsigned(15 downto 0);
signal inject_laser2_fine: unsigned(15 downto 0);
signal inject_laser1_fine: unsigned(15 downto 0);
signal inject_mode: std_logic;
signal inject_dsp_data_from_regs: unsigned(15 downto 0);
signal inject_laser4_fine: unsigned(15 downto 0);
signal inject_laser3_coarse_current: unsigned(15 downto 0);
signal inject_laser4_dac_counter: unsigned(5 downto 0);
signal inject_laser4_dac_state: t_enum_t_State_2;
signal inject_laser3_dac_counter: unsigned(5 downto 0);
signal inject_laser3_dac_state: t_enum_t_State_2;
signal inject_laser2_dac_counter: unsigned(5 downto 0);
signal inject_laser2_dac_state: t_enum_t_State_2;
signal inject_laser1_dac_counter: unsigned(5 downto 0);
signal inject_laser1_dac_state: t_enum_t_State_2;
signal twGen_slope: std_logic;
signal twGen_acc: unsigned(24 downto 0);
signal twGen_window_high: unsigned(15 downto 0);
signal twGen_slope_down: unsigned(15 downto 0);
signal twGen_sweep_low: unsigned(15 downto 0);
signal twGen_sweep_high: unsigned(15 downto 0);
signal twGen_slope_up: unsigned(15 downto 0);
signal twGen_cs: unsigned(15 downto 0);
signal twGen_value: unsigned(15 downto 0);
signal twGen_window_low: unsigned(15 downto 0);
signal twGen_dsp_data_from_regs: unsigned(15 downto 0);
signal clkgen_div1M: unsigned(2 downto 0);
signal clkgen_ff2: std_logic;
signal clkgen_ff1: std_logic;
signal clkgen_div5: unsigned(2 downto 0);
signal clkgen_div25: unsigned(4 downto 0);
signal kernel_counter: unsigned(25 downto 0);
signal kernel_gpreg_1: unsigned(15 downto 0);
signal kernel_state: t_enum_t_State_7;
signal kernel_kernel_reset: unsigned(0 downto 0);
signal rdmemory_wr_dataA: unsigned(17 downto 0);
signal rdmemory_wr_paramA: unsigned(15 downto 0);
signal rdmemory_enB_data: std_logic;
signal rdmemory_param_addrB: unsigned(6 downto 0);
signal rdmemory_param_addrA: unsigned(6 downto 0);
signal rdmemory_enA_data: std_logic;
signal rdmemory_enB_param: std_logic;
signal rdmemory_meta_addrB: unsigned(12 downto 0);
signal rdmemory_meta_addrA: unsigned(12 downto 0);
signal rdmemory_rd_dataA: unsigned(17 downto 0);
signal rdmemory_enA_param: std_logic;
signal rdmemory_data_addrA: unsigned(12 downto 0);
signal rdmemory_data_addrB: unsigned(12 downto 0);
signal rdmemory_rd_metaA: unsigned(15 downto 0);
signal rdmemory_enA_meta: std_logic;
signal rdmemory_rd_paramA: unsigned(15 downto 0);
signal rdmemory_enB_meta: std_logic;
signal rdmemory_wr_metaA: unsigned(15 downto 0);
signal laser4_pwm_temp: unsigned(8 downto 0);
signal laser4_pwm_pulse_width: unsigned(15 downto 0);
signal laser4_pwm_cs: unsigned(15 downto 0);
signal laser4_pwm_dither_cntr: unsigned(7 downto 0);
signal laser4_pwm_pwm: std_logic;
signal laser4_pwm_main_cntr: unsigned(7 downto 0);
signal laser3_pwm_temp: unsigned(8 downto 0);
signal laser3_pwm_pulse_width: unsigned(15 downto 0);
signal laser3_pwm_cs: unsigned(15 downto 0);
signal laser3_pwm_dither_cntr: unsigned(7 downto 0);
signal laser3_pwm_pwm: std_logic;
signal laser3_pwm_main_cntr: unsigned(7 downto 0);
signal laser2_pwm_temp: unsigned(8 downto 0);
signal laser2_pwm_pulse_width: unsigned(15 downto 0);
signal laser2_pwm_cs: unsigned(15 downto 0);
signal laser2_pwm_dither_cntr: unsigned(7 downto 0);
signal laser2_pwm_pwm: std_logic;
signal laser2_pwm_main_cntr: unsigned(7 downto 0);
signal laser1_pwm_temp: unsigned(8 downto 0);
signal laser1_pwm_pulse_width: unsigned(15 downto 0);
signal laser1_pwm_cs: unsigned(15 downto 0);
signal laser1_pwm_dither_cntr: unsigned(7 downto 0);
signal laser1_pwm_pwm: std_logic;
signal laser1_pwm_main_cntr: unsigned(7 downto 0);
signal dsp_interface_done_wr_d: std_logic;
signal dsp_interface_done_wr: std_logic;
signal dsp_interface_done_rd_d: std_logic;
signal dsp_interface_ce_h: std_logic;
signal dsp_interface_done_rd: std_logic;
signal dsp_interface_we_h: std_logic;
signal dsp_interface_re_h: std_logic;

begin

soa_shutdown_in <= '0';
laser_shutdown_in <= '0';
meta0 <= to_unsigned(0, 16);
meta1 <= to_unsigned(0, 16);
meta2 <= to_unsigned(0, 16);
meta3 <= to_unsigned(0, 16);
meta4 <= to_unsigned(0, 16);
meta5 <= to_unsigned(0, 16);
meta6 <= to_unsigned(0, 16);
meta7 <= to_unsigned(0, 16);
laser_fine_current_in <= to_unsigned(0, 16);


laser3_pwm_out <= laser3_pwm_pwm;
laser3_pwm_inv_out <= (laser3_pwm_pwm xor laser3_pwm_cs(1));
laser3_pwm_temp <= (resize(laser3_pwm_dither_cntr, 9) + laser3_pwm_pulse_width(8-1 downto 0));

MAIN_LASER3_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laser3_pwm_cs <= "0000000000000000";
        laser3_pwm_pulse_width <= "0000000000000000";
        laser3_pwm_main_cntr <= "00000000";
        laser3_pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 7) then
                if to_boolean(dsp_wr) then
                    laser3_pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser3_pwm <= resize(laser3_pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 8) then
                if to_boolean(dsp_wr) then
                    laser3_pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser3_pwm <= resize(laser3_pwm_pulse_width, 32);
            else
                dsp_data_in_laser3_pwm <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laser3_pwm <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laser3_pwm_cs(0)) then
            if (not to_boolean(laser3_pwm_cs(1))) then
                laser3_pwm_cs(0) <= '0';
            end if;
            laser3_pwm_pwm <= '0';
            if (laser3_pwm_main_cntr < laser3_pwm_pulse_width(16-1 downto (16 - 8))) then
                laser3_pwm_pwm <= '1';
            elsif (laser3_pwm_main_cntr = laser3_pwm_pulse_width(16-1 downto 8)) then
                if (laser3_pwm_temp >= 256) then
                    laser3_pwm_pwm <= '1';
                    laser3_pwm_cs(2) <= '1';
                    laser3_pwm_dither_cntr <= resize(laser3_pwm_temp - 256, 8);
                else
                    laser3_pwm_dither_cntr <= resize(laser3_pwm_temp, 8);
                end if;
            end if;
            laser3_pwm_main_cntr <= ((laser3_pwm_main_cntr + 1) mod 256);
        end if;
        laser3_pwm_cs(2) <= laser3_pwm_pwm;
    end if;
end process MAIN_LASER3_PWM_LOGIC;



dual_port_ram_2 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => rdmemory_enA_meta, wr_enableA => dsp_wr,
    addressA => rdmemory_meta_addrA, rd_dataA => rdmemory_rd_metaA, wr_dataA => rdmemory_wr_metaA,
    clockB => clk0, enableB => rdmemory_enB_meta, wr_enableB => meta_we,
    addressB => rdmemory_meta_addrB, rd_dataB => meta, wr_dataB => wr_meta
    );

MAIN_RDMEMORY_COMB: process (dsp_data_out, meta_addr, param_addr, rdmemory_rd_dataA, data_addr, rdmemory_rd_paramA, dsp_addr, rdmemory_rd_metaA, bank) is
    variable sel_meta: std_logic;
    variable sel_param: std_logic;
    variable sel_data: std_logic;
begin
    rdmemory_enB_data <= '1';
    sel_data := to_std_logic((dsp_addr(20-1 downto 12) = 4) or (dsp_addr(20-1 downto 12) = 0));
    rdmemory_data_addrA(12-1 downto 0) <= dsp_addr(12-1 downto 0);
    rdmemory_data_addrA(12) <= dsp_addr((12 + 2));
    rdmemory_enA_data <= sel_data;
    rdmemory_data_addrB(12-1 downto 0) <= data_addr;
    rdmemory_data_addrB(12) <= bank;
    rdmemory_wr_dataA <= dsp_data_out(18-1 downto 0);
    rdmemory_enB_meta <= '1';
    sel_meta := to_std_logic((dsp_addr(20-1 downto 12) = 5) or (dsp_addr(20-1 downto 12) = 1));
    rdmemory_meta_addrA(12-1 downto 0) <= dsp_addr(12-1 downto 0);
    rdmemory_meta_addrA(12) <= dsp_addr((12 + 2));
    rdmemory_enA_meta <= sel_meta;
    rdmemory_meta_addrB(12-1 downto 0) <= meta_addr;
    rdmemory_meta_addrB(12) <= bank;
    rdmemory_wr_metaA <= dsp_data_out(16-1 downto 0);
    rdmemory_enB_param <= '1';
    sel_param := to_std_logic((dsp_addr(20-1 downto 12) = 6) or (dsp_addr(20-1 downto 12) = 2));
    rdmemory_param_addrA(6-1 downto 0) <= dsp_addr(6-1 downto 0);
    rdmemory_param_addrA(6) <= dsp_addr((12 + 2));
    rdmemory_enA_param <= sel_param;
    rdmemory_param_addrB(6-1 downto 0) <= param_addr;
    rdmemory_param_addrB(6) <= bank;
    rdmemory_wr_paramA <= dsp_data_out(16-1 downto 0);
    if to_boolean(sel_data) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_dataA(18-1 downto 0), 32);
    elsif to_boolean(sel_meta) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_metaA(16-1 downto 0), 32);
    elsif to_boolean(sel_param) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_paramA(16-1 downto 0), 32);
    else
        dsp_data_in_rdmemory <= "00000000000000000000000000000000";
    end if;
end process MAIN_RDMEMORY_COMB;



dual_port_ram_3 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 7, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => rdmemory_enA_param, wr_enableA => dsp_wr,
    addressA => rdmemory_param_addrA, rd_dataA => rdmemory_rd_paramA, wr_dataA => rdmemory_wr_paramA,
    clockB => clk0, enableB => rdmemory_enB_param, wr_enableB => param_we,
    addressB => rdmemory_param_addrB, rd_dataB => param, wr_dataB => wr_param
    );



dual_port_ram_1 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 18)
    port map (
    clockA => clk0, enableA => rdmemory_enA_data, wr_enableA => dsp_wr,
    addressA => rdmemory_data_addrA, rd_dataA => rdmemory_rd_dataA, wr_dataA => rdmemory_wr_dataA,
    clockB => clk0, enableB => rdmemory_enB_data, wr_enableB => data_we,
    addressB => rdmemory_data_addrB, rd_dataB => data, wr_dataB => wr_data
    );

MAIN_DSP_INTERFACE_LOGIC: process (clk0, reset) is
    variable dsp_addr_v: unsigned(19 downto 0);
    variable done_rd_v: std_logic;
    variable dsp_wr_v: std_logic;
    variable dsp_data_out_v: unsigned(31 downto 0);
    variable done_wr_v: std_logic;
    variable state_v: t_enum_t_State_1;
begin
    if to_boolean(reset) then
        dsp_addr_v := "00000000000000000000";
        dsp_data_out_v := "00000000000000000000000000000000";
        dsp_wr_v := '0';
        done_rd_v := '0';
        done_wr_v := '0';
        state_v := INIT;
    elsif rising_edge(clk0) then
        dsp_wr_v := '0';
        case state_v is
            when INIT =>
                done_rd_v := '0';
                done_wr_v := '0';
                if to_boolean(dsp_interface_ce_h) then
                    dsp_addr_v := dsp_emif_ea;
                    if to_boolean(dsp_interface_re_h) then
                        state_v := READ1;
                    elsif to_boolean(dsp_interface_we_h) then
                        state_v := WRITE1;
                    end if;
                end if;
            when WRITE1 =>
                dsp_data_out_v := dsp_emif_dout;
                dsp_wr_v := '1';
                done_wr_v := '1';
                state_v := WRITE2;
            when WRITE2 =>
                if (not to_boolean(dsp_emif_we)) then
                    done_wr_v := '0';
                    state_v := IDLE;
                end if;
            when READ1 =>
                done_rd_v := '1';
                state_v := READ2;
            when READ2 =>
                if (not to_boolean(dsp_emif_re)) then
                    done_rd_v := '0';
                    state_v := IDLE;
                end if;
            when IDLE =>
                state_v := INIT;
        end case;
    end if;
    dsp_addr <= dsp_addr_v;
    dsp_data_out <= dsp_data_out_v;
    dsp_wr <= dsp_wr_v;
    dsp_interface_done_rd_d <= done_rd_v;
    dsp_interface_done_wr_d <= done_wr_v;
end process MAIN_DSP_INTERFACE_LOGIC;


dsp_emif_ddir <= to_std_logic(to_boolean(dsp_emif_oe) and to_boolean(ce2));
dsp_emif_ardy <= to_std_logic((not to_boolean(ce2)) or to_boolean(dsp_interface_done_rd) or to_boolean(dsp_interface_done_wr));
dsp_emif_din <= dsp_data_in;

MAIN_DSP_INTERFACE_HARDEN: process (clk0) is
begin
    if rising_edge(clk0) then
        dsp_interface_ce_h <= ce2;
        dsp_interface_we_h <= dsp_emif_we;
        dsp_interface_re_h <= dsp_emif_re;
    end if;
end process MAIN_DSP_INTERFACE_HARDEN;

MAIN_DSP_INTERFACE_MAKE_DONE_WR: process (clk0, dsp_emif_we) is
begin
    if (dsp_emif_we = '0') then
        dsp_interface_done_wr <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_wr <= dsp_interface_done_wr_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_WR;

MAIN_DSP_INTERFACE_MAKE_DONE_RD: process (clk0, dsp_emif_re) is
begin
    if (dsp_emif_re = '0') then
        dsp_interface_done_rd <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_rd <= dsp_interface_done_rd_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_RD;

MAIN_INJECT_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_control <= "0000000000000000";
        inject_laser1_coarse_current <= "0000000000000000";
        inject_laser2_coarse_current <= "0000000000000000";
        inject_laser3_coarse_current <= "0000000000000000";
        inject_laser4_coarse_current <= "0000000000000000";
        inject_laser1_fine_current <= "1000000000000000";
        inject_laser2_fine_current <= "1000000000000000";
        inject_laser3_fine_current <= "1000000000000000";
        inject_laser4_fine_current <= "1000000000000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 72) then
                if to_boolean(dsp_wr) then
                    inject_control <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_control;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 73) then
                if to_boolean(dsp_wr) then
                    inject_laser1_coarse_current <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_laser1_coarse_current;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 74) then
                if to_boolean(dsp_wr) then
                    inject_laser2_coarse_current <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_laser2_coarse_current;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 75) then
                if to_boolean(dsp_wr) then
                    inject_laser3_coarse_current <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_laser3_coarse_current;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 76) then
                if to_boolean(dsp_wr) then
                    inject_laser4_coarse_current <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_laser4_coarse_current;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 77) then
                if to_boolean(dsp_wr) then
                    inject_laser1_fine_current <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_laser1_fine_current;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 78) then
                if to_boolean(dsp_wr) then
                    inject_laser2_fine_current <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_laser2_fine_current;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 79) then
                if to_boolean(dsp_wr) then
                    inject_laser3_fine_current <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_laser3_fine_current;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 80) then
                if to_boolean(dsp_wr) then
                    inject_laser4_fine_current <= resize(dsp_data_out, 16);
                end if;
                inject_dsp_data_from_regs <= inject_laser4_fine_current;
            else
                inject_dsp_data_from_regs <= "0000000000000000";
            end if;
        else
            inject_dsp_data_from_regs <= "0000000000000000";
        end if;
    end if;
end process MAIN_INJECT_LOGIC;

MAIN_INJECT_LASER2_DAC_COMB2: process (inject_laser2_dac_counter, inject_laser2_fine, inject_laser2_coarse_current) is
begin
    if ((1 <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < 9)) then
        case ((9 - 1) - to_integer(inject_laser2_dac_counter)) is
            when 0 => lsr2_mosi <= '0';
            when 1 => lsr2_mosi <= '0';
            when 2 => lsr2_mosi <= '0';
            when 3 => lsr2_mosi <= '0';
            when 4 => lsr2_mosi <= '0';
            when 5 => lsr2_mosi <= '0';
            when 6 => lsr2_mosi <= '0';
            when others => lsr2_mosi <= '0';
        end case;
    elsif ((9 <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < 25)) then
        lsr2_mosi <= inject_laser2_coarse_current(((25 - 1) - to_integer(inject_laser2_dac_counter)));
    elsif ((26 <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < 34)) then
        case ((34 - 1) - to_integer(inject_laser2_dac_counter)) is
            when 0 => lsr2_mosi <= '0';
            when 1 => lsr2_mosi <= '0';
            when 2 => lsr2_mosi <= '1';
            when 3 => lsr2_mosi <= '0';
            when 4 => lsr2_mosi <= '1';
            when 5 => lsr2_mosi <= '1';
            when 6 => lsr2_mosi <= '0';
            when others => lsr2_mosi <= '0';
        end case;
    elsif ((34 <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < 50)) then
        lsr2_mosi <= inject_laser2_fine(((50 - 1) - to_integer(inject_laser2_dac_counter)));
    else
        lsr2_mosi <= '0';
    end if;
end process MAIN_INJECT_LASER2_DAC_COMB2;

MAIN_INJECT_LASER2_DAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_laser2_dac_counter <= "000000";
        lsr2_ss <= '0';
    elsif rising_edge(clk0) then
        case inject_laser2_dac_state is
            when IDLE =>
                lsr2_ss <= '0';
                if to_boolean(pulse_100k) then
                    inject_laser2_dac_counter <= "000000";
                    lsr2_ss <= '1';
                    inject_laser2_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_5M) then
                    if (inject_laser2_dac_counter < 49) then
                        if (inject_laser2_dac_counter = 24) then
                            lsr2_ss <= '0';
                        end if;
                        inject_laser2_dac_counter <= (inject_laser2_dac_counter + 1);
                        inject_laser2_dac_state <= WAIT_0;
                    else
                        lsr2_ss <= '0';
                        inject_laser2_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_5M)) then
                    lsr2_ss <= '1';
                    inject_laser2_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser2_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER2_DAC_LOGIC;

MAIN_INJECT_COMB2: process (inject_laser1_fine_current, inject_sel, soa_shutdown_in, inject_laser3_fine_current, inject_laser4_fine_current, laser_shutdown_in, inject_laser_current_en, inject_mode, inject_manual_soa_en, inject_laser2_fine_current, inject_manual_laser_en, laser_fine_current_in) is
begin
    inject_laser1_fine <= inject_laser1_fine_current;
    inject_laser2_fine <= inject_laser2_fine_current;
    inject_laser3_fine <= inject_laser3_fine_current;
    inject_laser4_fine <= inject_laser4_fine_current;
    lsr1_disable <= to_std_logic(not to_boolean(inject_laser_current_en(0)));
    lsr2_disable <= to_std_logic(not to_boolean(inject_laser_current_en(1)));
    lsr3_disable <= to_std_logic(not to_boolean(inject_laser_current_en(2)));
    lsr4_disable <= to_std_logic(not to_boolean(inject_laser_current_en(3)));
    lsr1_rd <= to_std_logic(not to_boolean(inject_manual_laser_en(0)));
    lsr2_rd <= to_std_logic(not to_boolean(inject_manual_laser_en(1)));
    lsr3_rd <= to_std_logic(not to_boolean(inject_manual_laser_en(2)));
    lsr4_rd <= to_std_logic(not to_boolean(inject_manual_laser_en(3)));
    sw3 <= to_std_logic(not to_boolean(inject_manual_soa_en));
    if to_boolean(inject_mode) then
        sw3 <= soa_shutdown_in;
        if (inject_sel = 0) then
            inject_laser1_fine <= laser_fine_current_in;
            lsr1_rd <= laser_shutdown_in;
        elsif (inject_sel = 1) then
            inject_laser2_fine <= laser_fine_current_in;
            lsr2_rd <= laser_shutdown_in;
        elsif (inject_sel = 2) then
            inject_laser3_fine <= laser_fine_current_in;
            lsr3_rd <= laser_shutdown_in;
        else
            inject_laser4_fine <= laser_fine_current_in;
            lsr4_rd <= laser_shutdown_in;
        end if;
    end if;
end process MAIN_INJECT_COMB2;

MAIN_INJECT_LASER3_DAC_COMB2: process (inject_laser3_dac_counter, inject_laser3_fine, inject_laser3_coarse_current) is
begin
    if ((1 <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < 9)) then
        case ((9 - 1) - to_integer(inject_laser3_dac_counter)) is
            when 0 => lsr3_mosi <= '0';
            when 1 => lsr3_mosi <= '0';
            when 2 => lsr3_mosi <= '0';
            when 3 => lsr3_mosi <= '0';
            when 4 => lsr3_mosi <= '0';
            when 5 => lsr3_mosi <= '0';
            when 6 => lsr3_mosi <= '0';
            when others => lsr3_mosi <= '0';
        end case;
    elsif ((9 <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < 25)) then
        lsr3_mosi <= inject_laser3_coarse_current(((25 - 1) - to_integer(inject_laser3_dac_counter)));
    elsif ((26 <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < 34)) then
        case ((34 - 1) - to_integer(inject_laser3_dac_counter)) is
            when 0 => lsr3_mosi <= '0';
            when 1 => lsr3_mosi <= '0';
            when 2 => lsr3_mosi <= '1';
            when 3 => lsr3_mosi <= '0';
            when 4 => lsr3_mosi <= '1';
            when 5 => lsr3_mosi <= '1';
            when 6 => lsr3_mosi <= '0';
            when others => lsr3_mosi <= '0';
        end case;
    elsif ((34 <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < 50)) then
        lsr3_mosi <= inject_laser3_fine(((50 - 1) - to_integer(inject_laser3_dac_counter)));
    else
        lsr3_mosi <= '0';
    end if;
end process MAIN_INJECT_LASER3_DAC_COMB2;

MAIN_INJECT_LASER3_DAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_laser3_dac_counter <= "000000";
        lsr3_ss <= '0';
    elsif rising_edge(clk0) then
        case inject_laser3_dac_state is
            when IDLE =>
                lsr3_ss <= '0';
                if to_boolean(pulse_100k) then
                    inject_laser3_dac_counter <= "000000";
                    lsr3_ss <= '1';
                    inject_laser3_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_5M) then
                    if (inject_laser3_dac_counter < 49) then
                        if (inject_laser3_dac_counter = 24) then
                            lsr3_ss <= '0';
                        end if;
                        inject_laser3_dac_counter <= (inject_laser3_dac_counter + 1);
                        inject_laser3_dac_state <= WAIT_0;
                    else
                        lsr3_ss <= '0';
                        inject_laser3_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_5M)) then
                    lsr3_ss <= '1';
                    inject_laser3_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser3_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER3_DAC_LOGIC;

MAIN_INJECT_LASER1_DAC_COMB2: process (inject_laser1_dac_counter, inject_laser1_fine, inject_laser1_coarse_current) is
begin
    if ((1 <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < 9)) then
        case ((9 - 1) - to_integer(inject_laser1_dac_counter)) is
            when 0 => lsr1_mosi <= '0';
            when 1 => lsr1_mosi <= '0';
            when 2 => lsr1_mosi <= '0';
            when 3 => lsr1_mosi <= '0';
            when 4 => lsr1_mosi <= '0';
            when 5 => lsr1_mosi <= '0';
            when 6 => lsr1_mosi <= '0';
            when others => lsr1_mosi <= '0';
        end case;
    elsif ((9 <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < 25)) then
        lsr1_mosi <= inject_laser1_coarse_current(((25 - 1) - to_integer(inject_laser1_dac_counter)));
    elsif ((26 <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < 34)) then
        case ((34 - 1) - to_integer(inject_laser1_dac_counter)) is
            when 0 => lsr1_mosi <= '0';
            when 1 => lsr1_mosi <= '0';
            when 2 => lsr1_mosi <= '1';
            when 3 => lsr1_mosi <= '0';
            when 4 => lsr1_mosi <= '1';
            when 5 => lsr1_mosi <= '1';
            when 6 => lsr1_mosi <= '0';
            when others => lsr1_mosi <= '0';
        end case;
    elsif ((34 <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < 50)) then
        lsr1_mosi <= inject_laser1_fine(((50 - 1) - to_integer(inject_laser1_dac_counter)));
    else
        lsr1_mosi <= '0';
    end if;
end process MAIN_INJECT_LASER1_DAC_COMB2;

MAIN_INJECT_LASER1_DAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_laser1_dac_counter <= "000000";
        lsr1_ss <= '0';
    elsif rising_edge(clk0) then
        case inject_laser1_dac_state is
            when IDLE =>
                lsr1_ss <= '0';
                if to_boolean(pulse_100k) then
                    inject_laser1_dac_counter <= "000000";
                    lsr1_ss <= '1';
                    inject_laser1_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_5M) then
                    if (inject_laser1_dac_counter < 49) then
                        if (inject_laser1_dac_counter = 24) then
                            lsr1_ss <= '0';
                        end if;
                        inject_laser1_dac_counter <= (inject_laser1_dac_counter + 1);
                        inject_laser1_dac_state <= WAIT_0;
                    else
                        lsr1_ss <= '0';
                        inject_laser1_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_5M)) then
                    lsr1_ss <= '1';
                    inject_laser1_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser1_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER1_DAC_LOGIC;

MAIN_INJECT_LASER4_DAC_COMB2: process (inject_laser4_dac_counter, inject_laser4_fine, inject_laser4_coarse_current) is
begin
    if ((1 <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < 9)) then
        case ((9 - 1) - to_integer(inject_laser4_dac_counter)) is
            when 0 => lsr4_mosi <= '0';
            when 1 => lsr4_mosi <= '0';
            when 2 => lsr4_mosi <= '0';
            when 3 => lsr4_mosi <= '0';
            when 4 => lsr4_mosi <= '0';
            when 5 => lsr4_mosi <= '0';
            when 6 => lsr4_mosi <= '0';
            when others => lsr4_mosi <= '0';
        end case;
    elsif ((9 <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < 25)) then
        lsr4_mosi <= inject_laser4_coarse_current(((25 - 1) - to_integer(inject_laser4_dac_counter)));
    elsif ((26 <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < 34)) then
        case ((34 - 1) - to_integer(inject_laser4_dac_counter)) is
            when 0 => lsr4_mosi <= '0';
            when 1 => lsr4_mosi <= '0';
            when 2 => lsr4_mosi <= '1';
            when 3 => lsr4_mosi <= '0';
            when 4 => lsr4_mosi <= '1';
            when 5 => lsr4_mosi <= '1';
            when 6 => lsr4_mosi <= '0';
            when others => lsr4_mosi <= '0';
        end case;
    elsif ((34 <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < 50)) then
        lsr4_mosi <= inject_laser4_fine(((50 - 1) - to_integer(inject_laser4_dac_counter)));
    else
        lsr4_mosi <= '0';
    end if;
end process MAIN_INJECT_LASER4_DAC_COMB2;

MAIN_INJECT_LASER4_DAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_laser4_dac_counter <= "000000";
        lsr4_ss <= '0';
    elsif rising_edge(clk0) then
        case inject_laser4_dac_state is
            when IDLE =>
                lsr4_ss <= '0';
                if to_boolean(pulse_100k) then
                    inject_laser4_dac_counter <= "000000";
                    lsr4_ss <= '1';
                    inject_laser4_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_5M) then
                    if (inject_laser4_dac_counter < 49) then
                        if (inject_laser4_dac_counter = 24) then
                            lsr4_ss <= '0';
                        end if;
                        inject_laser4_dac_counter <= (inject_laser4_dac_counter + 1);
                        inject_laser4_dac_state <= WAIT_0;
                    else
                        lsr4_ss <= '0';
                        inject_laser4_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_5M)) then
                    lsr4_ss <= '1';
                    inject_laser4_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser4_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER4_DAC_LOGIC;


dsp_data_in_inject <= resize(inject_dsp_data_from_regs, 32);
inject_mode <= inject_control(0);
inject_sel <= inject_control((1 + 2)-1 downto 1);
inject_laser_current_en <= inject_control((3 + 4)-1 downto 3);
inject_manual_laser_en <= inject_control((7 + 4)-1 downto 7);
inject_manual_soa_en <= inject_control(11);
inject_laser_shutdown_en <= inject_control(12);
inject_soa_shutdown_en <= inject_control(13);

MAIN_TWGEN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        twGen_acc(((16 + 9) - 1)) <= '1';
        twGen_acc(((16 + 9) - 1)-1 downto 0) <= "000000000000000000000000";
        twGen_cs <= "0000000000000000";
        twGen_slope_down <= "0000000000000000";
        twGen_slope_up <= "0000000000000000";
        twGen_sweep_low <= "0000000000000000";
        twGen_sweep_high <= "0000000000000000";
        twGen_window_low <= "0000000000000000";
        twGen_window_high <= "0000000000000000";
        twGen_slope <= '1';
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 64) then
                if to_boolean(dsp_wr) then
                    twGen_acc <= resize(dsp_data_out, 25);
                end if;
                twGen_dsp_data_from_regs <= resize(twGen_acc, 16);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 65) then
                if to_boolean(dsp_wr) then
                    twGen_cs <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_cs;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 66) then
                if to_boolean(dsp_wr) then
                    twGen_slope_down <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_slope_down;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 67) then
                if to_boolean(dsp_wr) then
                    twGen_slope_up <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_slope_up;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 68) then
                if to_boolean(dsp_wr) then
                    twGen_sweep_low <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_sweep_low;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 69) then
                if to_boolean(dsp_wr) then
                    twGen_sweep_high <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_sweep_high;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 70) then
                if to_boolean(dsp_wr) then
                    twGen_window_low <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_window_low;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 71) then
                if to_boolean(dsp_wr) then
                    twGen_window_high <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_window_high;
            else
                twGen_dsp_data_from_regs <= "0000000000000000";
            end if;
        else
            twGen_dsp_data_from_regs <= "0000000000000000";
        end if;
        if to_boolean(twGen_cs(0)) then
            if (not to_boolean(twGen_cs(1))) then
                twGen_cs(0) <= '0';
            end if;
            if to_boolean(twGen_cs(2)) then
                twGen_acc(((16 + 9) - 1)) <= '1';
                twGen_acc(((16 + 9) - 1)-1 downto 0) <= "000000000000000000000000";
                twGen_slope <= '1';
            else
                if (twGen_value >= twGen_sweep_high) then
                    twGen_slope <= '0';
                elsif (twGen_value <= twGen_sweep_low) then
                    twGen_slope <= '1';
                end if;
                if to_boolean(pulse_100k) then
                    if to_boolean(twGen_slope) then
                        twGen_acc <= (twGen_acc + twGen_slope_up);
                    else
                        twGen_acc <= (twGen_acc - twGen_slope_down);
                    end if;
                end if;
            end if;
        end if;
    end if;
end process MAIN_TWGEN_LOGIC;


twGen_value <= twGen_acc((16 + 9)-1 downto 9);


dsp_data_in_twGen <= resize(twGen_dsp_data_from_regs, 32);
tuner_value <= twGen_value;
tuner_in_window <= to_std_logic((twGen_value >= twGen_window_low) and (twGen_value <= twGen_window_high));
tuner_slope <= twGen_slope;

MAIN_COMB: process (laser1_pwm_out, rdsim_value, dsp_data_in_laser2_pwm, clk_5M, dsp_data_in_laser4_pwm, acq_done_irq, i2c_scl1, i2c_scl0, laser2_pwm_out, rd_irq, laser1_pwm_inv_out, dsp_data_in_laser3_pwm, pulse_100k, rd_trig, gpreg_1, laser3_pwm_inv_out, dsp_data_in_rdman, i2c_sda1, i2c_sda0, dsp_data_in_rdsim, tuner_value, dsp_data_in_laser1_pwm, dsp_data_in_twGen, dsp_data_in_rdmemory, clk0, adc_clk, bank, reset, laser4_pwm_inv_out, laser2_pwm_inv_out, dsp_data_in_inject, laser4_pwm_out, counter, dsp_emif_ce, laser_locked, dsp_data_in_kernel, laser3_pwm_out, rd_adc, acc_en) is
begin
    dsp_data_in <= (dsp_data_in_laser1_pwm or dsp_data_in_laser2_pwm or dsp_data_in_laser3_pwm or dsp_data_in_laser4_pwm or dsp_data_in_rdman or dsp_data_in_rdmemory or dsp_data_in_kernel or dsp_data_in_inject or dsp_data_in_twGen or dsp_data_in_rdsim);
    ce2 <= dsp_emif_ce(2);
    intronix(16) <= laser1_pwm_out;
    intronix(17) <= laser1_pwm_inv_out;
    lsr1_0 <= laser1_pwm_out;
    lsr1_1 <= laser1_pwm_inv_out;
    intronix(18) <= laser2_pwm_out;
    intronix(19) <= laser2_pwm_inv_out;
    lsr2_0 <= laser2_pwm_out;
    lsr2_1 <= laser2_pwm_inv_out;
    intronix(20) <= laser3_pwm_out;
    intronix(21) <= laser3_pwm_inv_out;
    lsr3_0 <= laser3_pwm_out;
    lsr3_1 <= laser3_pwm_inv_out;
    intronix(22) <= laser4_pwm_out;
    intronix(23) <= laser4_pwm_inv_out;
    lsr4_0 <= laser4_pwm_out;
    lsr4_1 <= laser4_pwm_inv_out;
    intronix(24) <= adc_clk;
    intronix(25) <= acc_en;
    intronix(26) <= laser_locked;
    intronix(27) <= bank;
    intronix(32) <= rd_trig;
    monitor <= rd_trig;
    rd_adc_clk <= adc_clk;
    rd_adc_oe <= '1';
    fpga_led <= counter(28-1 downto (28 - 4));
    i2c_rst0 <= reset;
    i2c_rst1 <= reset;
    intronix(28) <= i2c_scl0;
    intronix(29) <= i2c_sda0;
    intronix(30) <= i2c_scl1;
    intronix(31) <= i2c_sda1;
    if (gpreg_1(5-1 downto 0) = 0) then
        intronix(33) <= clk0;
    elsif (gpreg_1(5-1 downto 0) <= 28) then
        intronix(33) <= counter(to_integer(gpreg_1(5-1 downto 0) - 1));
    else
        intronix(33) <= '0';
    end if;
    if to_boolean(gpreg_1(6)) then
        intronix(8-1 downto 0) <= tuner_value(16-1 downto 8);
    else
        intronix(8-1 downto 0) <= rd_adc(14-1 downto 6);
    end if;
    intronix(16-1 downto 8) <= rdsim_value(14-1 downto 6);
    dsp_ext_int4 <= rd_irq;
    dsp_ext_int5 <= acq_done_irq;
    dsp_ext_int6 <= '0';
    dsp_ext_int7 <= '0';
    lsr1_sck <= clk_5M;
    lsr2_sck <= clk_5M;
    lsr3_sck <= clk_5M;
    lsr4_sck <= clk_5M;
    sw1 <= '0';
    sw2 <= '0';
    sw4 <= '0';
    laser_freq_ok <= '1';
    metadata_strobe <= pulse_100k;
end process MAIN_COMB;



unsigned_mult18x18 : entity work.UnsignedMult18x18_e(Behavioral) 
    port map (
    A => rdsim_a, B => rdsim_b, P => rdsim_p 
    );

MAIN_RDSIM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        rdsim_tuner_center <= "0000000000000000";
        rdsim_tuner_window_half_width <= "0000000000000000";
        rdsim_filling_rate <= "0000000000000000";
        rdsim_decay <= "0000000000000000";
        rdsim_accumulator <= "00000000000000000000";
        rdsim_state <= INIT;
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 11) then
                if to_boolean(dsp_wr) then
                    rdsim_tuner_center <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_tuner_center, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 12) then
                if to_boolean(dsp_wr) then
                    rdsim_tuner_window_half_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_tuner_window_half_width, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 13) then
                if to_boolean(dsp_wr) then
                    rdsim_filling_rate <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_filling_rate, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 14) then
                if to_boolean(dsp_wr) then
                    rdsim_decay <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_decay, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 15) then
                dsp_data_in_rdsim <= resize(rdsim_accumulator, 32);
            else
                dsp_data_in_rdsim <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_rdsim <= "00000000000000000000000000000000";
        end if;
        case rdsim_state is
            when INIT =>
                if to_boolean(adc_clk) then
                    if ((tuner_value < (rdsim_tuner_center + rdsim_tuner_window_half_width)) and (tuner_value > (rdsim_tuner_center - rdsim_tuner_window_half_width)) and (not to_boolean(rd_trig))) then
                        rdsim_accumulator <= (rdsim_accumulator + rdsim_filling_rate);
                    else
                        rdsim_accumulator <= (rdsim_accumulator - unsigned'(to_unsigned(0, 4) & rdsim_p(34-1 downto (34 - 16))));
                    end if;
                    rdsim_state <= GENVALUE;
                end if;
            when GENVALUE =>
                if (not to_boolean(adc_clk)) then
                    rdsim_state <= INIT;
                end if;
            when others =>
                rdsim_state <= INIT;
        end case;
        rdsim_value <= rdsim_accumulator((16 + 4)-1 downto 4);
        rdsim_a <= unsigned'(to_unsigned(0, 1) & rdsim_accumulator((16 + 4)-1 downto ((16 + 4) - 17)));
        rdsim_b <= unsigned'(to_unsigned(0, 1) & rdsim_decay & to_unsigned(0, 1));
    end if;
end process MAIN_RDSIM_LOGIC;


laser1_pwm_out <= laser1_pwm_pwm;
laser1_pwm_inv_out <= (laser1_pwm_pwm xor laser1_pwm_cs(1));
laser1_pwm_temp <= (resize(laser1_pwm_dither_cntr, 9) + laser1_pwm_pulse_width(8-1 downto 0));

MAIN_LASER1_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laser1_pwm_cs <= "0000000000000000";
        laser1_pwm_pulse_width <= "0000000000000000";
        laser1_pwm_main_cntr <= "00000000";
        laser1_pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 3) then
                if to_boolean(dsp_wr) then
                    laser1_pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser1_pwm <= resize(laser1_pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 4) then
                if to_boolean(dsp_wr) then
                    laser1_pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser1_pwm <= resize(laser1_pwm_pulse_width, 32);
            else
                dsp_data_in_laser1_pwm <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laser1_pwm <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laser1_pwm_cs(0)) then
            if (not to_boolean(laser1_pwm_cs(1))) then
                laser1_pwm_cs(0) <= '0';
            end if;
            laser1_pwm_pwm <= '0';
            if (laser1_pwm_main_cntr < laser1_pwm_pulse_width(16-1 downto (16 - 8))) then
                laser1_pwm_pwm <= '1';
            elsif (laser1_pwm_main_cntr = laser1_pwm_pulse_width(16-1 downto 8)) then
                if (laser1_pwm_temp >= 256) then
                    laser1_pwm_pwm <= '1';
                    laser1_pwm_cs(2) <= '1';
                    laser1_pwm_dither_cntr <= resize(laser1_pwm_temp - 256, 8);
                else
                    laser1_pwm_dither_cntr <= resize(laser1_pwm_temp, 8);
                end if;
            end if;
            laser1_pwm_main_cntr <= ((laser1_pwm_main_cntr + 1) mod 256);
        end if;
        laser1_pwm_cs(2) <= laser1_pwm_pwm;
    end if;
end process MAIN_LASER1_PWM_LOGIC;

MAIN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        counter <= "0000000000000000000000000000";
    elsif rising_edge(clk0) then
        counter <= (counter + 1);
    end if;
end process MAIN_LOGIC;


bank <= rdman_bank;
rd_irq <= rdman_rd_irq;
acq_done_irq <= rdman_acq_done_irq;
rd_trig <= rdman_rd_trig;
adc_clk <= rdman_rd_adc_clk;
rdman_tuner_gating_conditions <= to_std_logic(to_boolean(tuner_in_window) and ((to_boolean(tuner_slope) and to_boolean(rdman_control(5))) or ((not to_boolean(tuner_slope)) and to_boolean(rdman_control(6)))));
rdman_freq_gating_conditions <= to_std_logic(to_boolean(laser_freq_ok) or (not to_boolean(rdman_control(4))));
wr_data <= resize(rdsim_value, 18);

MAIN_RDMAN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        rdman_control <= "0000000000000000";
        rdman_status <= "0000000000000000";
        rdman_param0 <= "0000000000000000";
        rdman_param1 <= "0000000000000000";
        rdman_param2 <= "0000000000000000";
        rdman_param3 <= "0000000000000000";
        rdman_param4 <= "0000000000000000";
        rdman_param5 <= "0000000000000000";
        rdman_param6 <= "0000000000000000";
        rdman_param7 <= "0000000000000000";
        rdman_data_addrcntr <= "000000000000";
        rdman_metadata_addrcntr <= "000000000000";
        rdman_param_addrcntr <= "000000";
        rdman_divisor <= "00000";
        rdman_num_samp <= "000000000000";
        rdman_threshold <= "0000000000000000";
        rdman_lock_duration <= "0000000000000000";
        rdman_precontrol_duration <= "0000000000000000";
        rdman_timeout_duration <= "00000000000000000000000000000000";
        rdman_tuner_at_ringdown <= "0000000000000000";
        rdman_metadata_addr_at_ringdown <= "0000000000000000";
        rdman_abort <= '0';
        rdman_acq_done_irq <= '0';
        rdman_bank <= '0';
        rdman_expiry_time <= "00000000000000000000000000000000";
        rdman_init_flag <= '1';
        rdman_lapped <= '0';
        rdman_metadataAcqState <= IDLE;
        rdman_metadata_acq <= '0';
        rdman_paramState <= IDLE;
        rdman_param_acq <= '0';
        rdman_rd_adc_clk <= '0';
        rdman_rd_divider <= "00000";
        rdman_rd_irq <= '0';
        rdman_rd_trig <= '1';
        rdman_seqState <= IDLE;
        rdman_timeout <= '0';
        rdman_us_since_start <= "00000000000000000000000000000000";
        rdman_us_timer_enable <= '0';
        acc_en <= '0';
        laser_locked <= '0';
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 43) then
                if to_boolean(dsp_wr) then
                    rdman_control <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_control, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 44) then
                dsp_data_in_rdman <= resize(rdman_status, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 45) then
                if to_boolean(dsp_wr) then
                    rdman_param0 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_param0, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 46) then
                if to_boolean(dsp_wr) then
                    rdman_param1 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_param1, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 47) then
                if to_boolean(dsp_wr) then
                    rdman_param2 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_param2, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 48) then
                if to_boolean(dsp_wr) then
                    rdman_param3 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_param3, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 49) then
                if to_boolean(dsp_wr) then
                    rdman_param4 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_param4, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 50) then
                if to_boolean(dsp_wr) then
                    rdman_param5 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_param5, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 51) then
                if to_boolean(dsp_wr) then
                    rdman_param6 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_param6, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 52) then
                if to_boolean(dsp_wr) then
                    rdman_param7 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_param7, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 53) then
                dsp_data_in_rdman <= resize(rdman_data_addrcntr, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 54) then
                dsp_data_in_rdman <= resize(rdman_metadata_addrcntr, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 55) then
                dsp_data_in_rdman <= resize(rdman_param_addrcntr, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 56) then
                if to_boolean(dsp_wr) then
                    rdman_divisor <= resize(dsp_data_out, 5);
                end if;
                dsp_data_in_rdman <= resize(rdman_divisor, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 57) then
                if to_boolean(dsp_wr) then
                    rdman_num_samp <= resize(dsp_data_out, 12);
                end if;
                dsp_data_in_rdman <= resize(rdman_num_samp, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 58) then
                if to_boolean(dsp_wr) then
                    rdman_threshold <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_threshold, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 59) then
                if to_boolean(dsp_wr) then
                    rdman_lock_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_lock_duration, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 60) then
                if to_boolean(dsp_wr) then
                    rdman_precontrol_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_precontrol_duration, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 61) then
                if to_boolean(dsp_wr) then
                    rdman_timeout_duration <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_timeout_duration;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 62) then
                dsp_data_in_rdman <= resize(rdman_tuner_at_ringdown, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 63) then
                dsp_data_in_rdman <= resize(rdman_metadata_addr_at_ringdown, 32);
            else
                dsp_data_in_rdman <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_rdman <= "00000000000000000000000000000000";
        end if;
        if to_boolean(rdman_control(0)) then
            if (not to_boolean(rdman_control(1))) then
                rdman_control(0) <= '0';
            end if;
            data_we <= '0';
            rdman_rd_adc_clk <= to_std_logic(not to_boolean(rdman_rd_adc_clk));
            case rdman_seqState is
                when IDLE =>
                    rdman_us_since_start <= "00000000000000000000000000000000";
                    rdman_metadata_acq <= '0';
                    rdman_param_acq <= '0';
                    rdman_us_timer_enable <= '0';
                    acc_en <= '0';
                    laser_locked <= '0';
                    if to_boolean(rdman_control(2)) then
                        rdman_seqState <= START_INJECT;
                    end if;
                when START_INJECT =>
                    rdman_abort <= '0';
                    rdman_timeout <= '0';
                    rdman_rd_trig <= '0';
                    rdman_metadata_acq <= '1';
                    rdman_us_timer_enable <= '1';
                    acc_en <= '0';
                    rdman_expiry_time <= resize(rdman_precontrol_duration, 32);
                    rdman_control(2) <= '0';
                    rdman_seqState <= WAIT_FOR_PRECONTROL;
                when WAIT_FOR_PRECONTROL =>
                    if (rdman_us_since_start >= rdman_expiry_time) then
                        if to_boolean(rdman_control(4)) then
                            acc_en <= '1';
                            rdman_seqState <= WAIT_FOR_LOCK;
                        else
                            rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                        end if;
                    end if;
                when WAIT_FOR_LOCK =>
                    acc_en <= '1';
                    if to_boolean(laser_freq_ok) then
                        if (rdman_us_since_start >= rdman_expiry_time) then
                            laser_locked <= '1';
                            rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                        end if;
                    else
                        rdman_expiry_time <= (rdman_us_since_start + rdman_lock_duration);
                    end if;
                when WAIT_FOR_GATING_CONDITIONS =>
                    if (not to_boolean(rdman_freq_gating_conditions)) then
                        laser_locked <= '0';
                        rdman_seqState <= WAIT_FOR_LOCK;
                    elsif to_boolean(rdman_tuner_gating_conditions) then
                        rdman_seqState <= CHECK_BELOW_THRESHOLD;
                    end if;
                when CHECK_BELOW_THRESHOLD =>
                    if (rdsim_value < rdman_threshold) then
                        rdman_seqState <= WAIT_FOR_THRESHOLD;
                    else
                        rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                    end if;
                when WAIT_FOR_THRESHOLD =>
                    if (not to_boolean(rdman_freq_gating_conditions)) then
                        laser_locked <= '0';
                        rdman_seqState <= WAIT_FOR_LOCK;
                    elsif (not to_boolean(rdman_tuner_gating_conditions)) then
                        rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                    elsif (rdsim_value >= rdman_threshold) then
                        rdman_seqState <= IN_RINGDOWN;
                        rdman_rd_trig <= '1';
                        rdman_metadata_acq <= '0';
                        rdman_data_addrcntr <= "000000000000";
                        rdman_rd_divider <= "00000";
                        rdman_metadata_addr_at_ringdown <= resize(rdman_metadata_addrcntr, 16);
                        rdman_metadata_addr_at_ringdown((16 - 1)) <= rdman_lapped;
                        rdman_tuner_at_ringdown <= tuner_value;
                        rdman_rd_irq <= '1';
                        rdman_init_flag <= '1';
                    end if;
                when IN_RINGDOWN =>
                    rdman_param_acq <= '1';
                    if to_boolean(rdman_rd_adc_clk) then
                        if ((rdman_data_addrcntr = rdman_num_samp) and (not to_boolean(rdman_init_flag))) then
                            rdman_seqState <= CHECK_PARAMS_DONE;
                            if to_boolean(rdman_bank) then
                                rdman_status(5) <= '1';
                            else
                                rdman_status(4) <= '1';
                            end if;
                        elsif (rdman_rd_divider = rdman_divisor) then
                            rdman_rd_divider <= "00000";
                            rdman_data_addrcntr <= ((rdman_data_addrcntr + 1) mod 4096);
                            rdman_init_flag <= '0';
                            data_we <= '1';
                        else
                            rdman_rd_divider <= ((rdman_rd_divider + 1) mod 32);
                        end if;
                    end if;
                when CHECK_PARAMS_DONE =>
                    if (rdman_paramState = DONE) then
                        rdman_us_timer_enable <= '0';
                        rdman_seqState <= ACQ_DONE;
                    end if;
                when ACQ_DONE =>
                    rdman_bank <= to_std_logic(not to_boolean(rdman_bank));
                    rdman_acq_done_irq <= '1';
                    rdman_seqState <= IDLE;
            end case;
            case rdman_paramState is
                when IDLE =>
                    param_we <= '0';
                    if to_boolean(rdman_param_acq) then
                        rdman_param_addrcntr <= "000000";
                        rdman_paramState <= STORING;
                    end if;
                when STORING =>
                    param_we <= '1';
                    rdman_param_addrcntr <= (rdman_param_addrcntr + 1);
                    if (rdman_param_addrcntr(4-1 downto 0) = 0) then
                        wr_param <= rdman_param0;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 1) then
                        wr_param <= rdman_param1;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 2) then
                        wr_param <= rdman_param2;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 3) then
                        wr_param <= rdman_param3;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 4) then
                        wr_param <= rdman_param4;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 5) then
                        wr_param <= rdman_param5;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 6) then
                        wr_param <= rdman_param6;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 7) then
                        wr_param <= rdman_param7;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 8) then
                        wr_param <= rdman_tuner_at_ringdown;
                    else
                        wr_param <= rdman_metadata_addr_at_ringdown;
                        rdman_paramState <= DONE;
                    end if;
                when DONE =>
                    param_we <= '0';
            end case;
            case rdman_metadataAcqState is
                when IDLE =>
                    meta_we <= '0';
                    rdman_metadataAcqState <= AWAIT_STROBE;
                when AWAIT_STROBE =>
                    if (to_boolean(rdman_metadata_acq) and to_boolean(metadata_strobe)) then
                        rdman_metadata_addrcntr <= "000000000000";
                        rdman_metadataAcqState <= ACQUIRING;
                    end if;
                when ACQUIRING =>
                    if (not to_boolean(rdman_metadata_acq)) then
                        rdman_metadataAcqState <= DONE;
                    else
                        meta_we <= '1';
                        if (signed(resize(rdman_metadata_addrcntr, 13)) < ((8 * 512) - 1)) then
                            rdman_metadata_addrcntr <= (rdman_metadata_addrcntr + 1);
                        else
                            rdman_metadata_addrcntr <= to_unsigned(4 * 512, 12);
                            rdman_lapped <= '1';
                        end if;
                        if (rdman_metadata_addrcntr(3-1 downto 0) = 0) then
                            wr_meta <= meta0;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 1) then
                            wr_meta <= meta1;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 2) then
                            wr_meta <= meta2;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 3) then
                            wr_meta <= meta3;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 4) then
                            wr_meta <= meta4;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 5) then
                            wr_meta <= meta5;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 6) then
                            wr_meta <= meta6;
                        else
                            wr_meta <= meta7;
                            rdman_metadataAcqState <= DONE;
                        end if;
                    end if;
                when DONE =>
                    meta_we <= '0';
                    if (not to_boolean(metadata_strobe)) then
                        rdman_metadataAcqState <= AWAIT_STROBE;
                    end if;
            end case;
            if (to_boolean(rdman_us_timer_enable) and to_boolean(pulse_1M)) then
                rdman_us_since_start <= (rdman_us_since_start + 1);
                if (rdman_us_since_start >= rdman_timeout_duration) then
                    rdman_timeout <= '1';
                    rdman_metadata_acq <= '0';
                    rdman_param_acq <= '0';
                    rdman_us_timer_enable <= '0';
                    rdman_metadataAcqState <= IDLE;
                    rdman_paramState <= IDLE;
                    if (not to_boolean(rdman_rd_trig)) then
                        rdman_rd_trig <= '1';
                        rdman_rd_irq <= '1';
                    else
                        rdman_acq_done_irq <= '1';
                    end if;
                    rdman_seqState <= IDLE;
                end if;
            end if;
            if to_boolean(rdman_control(3)) then
                rdman_control(3) <= '0';
                rdman_rd_trig <= '1';
                rdman_abort <= '1';
                rdman_rd_irq <= '1';
                rdman_metadata_acq <= '0';
                rdman_param_acq <= '0';
                rdman_us_timer_enable <= '0';
                rdman_seqState <= IDLE;
                rdman_metadataAcqState <= IDLE;
                rdman_paramState <= IDLE;
            end if;
            if to_boolean(rdman_control(9)) then
                rdman_control(9) <= '0';
                rdman_rd_irq <= '0';
            end if;
            if to_boolean(rdman_control(10)) then
                rdman_control(10) <= '0';
                rdman_acq_done_irq <= '0';
            end if;
            if to_boolean(rdman_control(7)) then
                rdman_control(7) <= '0';
                rdman_status(4) <= '0';
            end if;
            if to_boolean(rdman_control(8)) then
                rdman_control(8) <= '0';
                rdman_status(5) <= '0';
            end if;
            data_addr <= rdman_data_addrcntr;
            meta_addr <= rdman_metadata_addrcntr;
            param_addr <= rdman_param_addrcntr;
        end if;
        rdman_status(2) <= rdman_acq_done_irq;
        rdman_status(3) <= rdman_bank;
        rdman_status(6) <= rdman_lapped;
        rdman_status(1) <= rdman_rd_irq;
        rdman_status(0) <= rdman_rd_trig;
        rdman_status(8) <= rdman_timeout;
    end if;
end process MAIN_RDMAN_LOGIC;


laser4_pwm_out <= laser4_pwm_pwm;
laser4_pwm_inv_out <= (laser4_pwm_pwm xor laser4_pwm_cs(1));
laser4_pwm_temp <= (resize(laser4_pwm_dither_cntr, 9) + laser4_pwm_pulse_width(8-1 downto 0));

MAIN_LASER4_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laser4_pwm_cs <= "0000000000000000";
        laser4_pwm_pulse_width <= "0000000000000000";
        laser4_pwm_main_cntr <= "00000000";
        laser4_pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 9) then
                if to_boolean(dsp_wr) then
                    laser4_pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser4_pwm <= resize(laser4_pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 10) then
                if to_boolean(dsp_wr) then
                    laser4_pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser4_pwm <= resize(laser4_pwm_pulse_width, 32);
            else
                dsp_data_in_laser4_pwm <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laser4_pwm <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laser4_pwm_cs(0)) then
            if (not to_boolean(laser4_pwm_cs(1))) then
                laser4_pwm_cs(0) <= '0';
            end if;
            laser4_pwm_pwm <= '0';
            if (laser4_pwm_main_cntr < laser4_pwm_pulse_width(16-1 downto (16 - 8))) then
                laser4_pwm_pwm <= '1';
            elsif (laser4_pwm_main_cntr = laser4_pwm_pulse_width(16-1 downto 8)) then
                if (laser4_pwm_temp >= 256) then
                    laser4_pwm_pwm <= '1';
                    laser4_pwm_cs(2) <= '1';
                    laser4_pwm_dither_cntr <= resize(laser4_pwm_temp - 256, 8);
                else
                    laser4_pwm_dither_cntr <= resize(laser4_pwm_temp, 8);
                end if;
            end if;
            laser4_pwm_main_cntr <= ((laser4_pwm_main_cntr + 1) mod 256);
        end if;
        laser4_pwm_cs(2) <= laser4_pwm_pwm;
    end if;
end process MAIN_LASER4_PWM_LOGIC;


gpreg_1 <= kernel_gpreg_1;

MAIN_KERNEL_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        kernel_kernel_reset <= "0";
        kernel_gpreg_1 <= "0000000000000000";
        cyp_reset <= '0';
        kernel_counter <= "00000000000000000000000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 0) then
                dsp_data_in_kernel <= "11000000110111100000000000000001";
            elsif (dsp_addr((20 - 1)-1 downto 0) = 1) then
                if to_boolean(dsp_wr) then
                    kernel_kernel_reset <= resize(dsp_data_out, 1);
                end if;
                dsp_data_in_kernel <= resize(kernel_kernel_reset, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 2) then
                if to_boolean(dsp_wr) then
                    kernel_gpreg_1 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_kernel <= resize(kernel_gpreg_1, 32);
            else
                dsp_data_in_kernel <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_kernel <= "00000000000000000000000000000000";
        end if;
        case kernel_state is
            when NORMAL =>
                cyp_reset <= '0';
                if to_boolean(kernel_kernel_reset) then
                    kernel_counter <= "00000000000000000000000000";
                    kernel_kernel_reset <= "0";
                    kernel_state <= RESETTING;
                elsif (not to_boolean(usb_connected)) then
                    kernel_counter <= "00000000000000000000000000";
                    kernel_state <= DISCONNECTED;
                else
                    kernel_state <= NORMAL;
                end if;
            when DISCONNECTED =>
                cyp_reset <= '0';
                if to_boolean(usb_connected) then
                    kernel_state <= NORMAL;
                elsif to_boolean(kernel_kernel_reset) then
                    kernel_counter <= "00000000000000000000000000";
                    kernel_kernel_reset <= "0";
                    kernel_state <= RESETTING;
                else
                    kernel_counter <= (kernel_counter + 1);
                    if (kernel_counter = 67108863) then
                        kernel_counter <= "00000000000000000000000000";
                        kernel_state <= RESETTING;
                    else
                        kernel_state <= DISCONNECTED;
                    end if;
                end if;
            when RESETTING =>
                cyp_reset <= '1';
                kernel_counter <= (kernel_counter + 1);
                if (kernel_counter = 67108863) then
                    kernel_kernel_reset <= "0";
                    kernel_state <= NORMAL;
                else
                    kernel_state <= RESETTING;
                end if;
            when others =>
                cyp_reset <= '0';
                kernel_state <= NORMAL;
        end case;
    end if;
end process MAIN_KERNEL_LOGIC;

MAIN_CLKGEN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        clkgen_div5 <= "000";
        clkgen_div25 <= "00000";
        clkgen_ff1 <= '0';
        clkgen_ff2 <= '0';
    elsif rising_edge(clk0) then
        pulse_100k <= '0';
        pulse_1M <= '0';
        if (clkgen_div5 = 4) then
            clkgen_div5 <= "000";
            clkgen_ff1 <= to_std_logic(not to_boolean(clkgen_ff1));
            if to_boolean(clkgen_ff1) then
                if (clkgen_div1M = 4) then
                    clkgen_div1M <= "000";
                    pulse_1M <= '1';
                else
                    clkgen_div1M <= (clkgen_div1M + 1);
                end if;
                clkgen_ff2 <= to_std_logic(not to_boolean(clkgen_ff2));
                if to_boolean(clkgen_ff2) then
                    if (clkgen_div25 = 24) then
                        clkgen_div25 <= "00000";
                        pulse_100k <= '1';
                    else
                        clkgen_div25 <= (clkgen_div25 + 1);
                    end if;
                end if;
            end if;
        else
            clkgen_div5 <= (clkgen_div5 + 1);
        end if;
    end if;
end process MAIN_CLKGEN_LOGIC;


clk_5M <= clkgen_ff1;
clk_2M5 <= clkgen_ff2;


laser2_pwm_out <= laser2_pwm_pwm;
laser2_pwm_inv_out <= (laser2_pwm_pwm xor laser2_pwm_cs(1));
laser2_pwm_temp <= (resize(laser2_pwm_dither_cntr, 9) + laser2_pwm_pulse_width(8-1 downto 0));

MAIN_LASER2_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laser2_pwm_cs <= "0000000000000000";
        laser2_pwm_pulse_width <= "0000000000000000";
        laser2_pwm_main_cntr <= "00000000";
        laser2_pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 5) then
                if to_boolean(dsp_wr) then
                    laser2_pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser2_pwm <= resize(laser2_pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 6) then
                if to_boolean(dsp_wr) then
                    laser2_pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laser2_pwm <= resize(laser2_pwm_pulse_width, 32);
            else
                dsp_data_in_laser2_pwm <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laser2_pwm <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laser2_pwm_cs(0)) then
            if (not to_boolean(laser2_pwm_cs(1))) then
                laser2_pwm_cs(0) <= '0';
            end if;
            laser2_pwm_pwm <= '0';
            if (laser2_pwm_main_cntr < laser2_pwm_pulse_width(16-1 downto (16 - 8))) then
                laser2_pwm_pwm <= '1';
            elsif (laser2_pwm_main_cntr = laser2_pwm_pulse_width(16-1 downto 8)) then
                if (laser2_pwm_temp >= 256) then
                    laser2_pwm_pwm <= '1';
                    laser2_pwm_cs(2) <= '1';
                    laser2_pwm_dither_cntr <= resize(laser2_pwm_temp - 256, 8);
                else
                    laser2_pwm_dither_cntr <= resize(laser2_pwm_temp, 8);
                end if;
            end if;
            laser2_pwm_main_cntr <= ((laser2_pwm_main_cntr + 1) mod 256);
        end if;
        laser2_pwm_cs(2) <= laser2_pwm_pwm;
    end if;
end process MAIN_LASER2_PWM_LOGIC;

end architecture MyHDL;
