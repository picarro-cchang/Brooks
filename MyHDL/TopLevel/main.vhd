-- File: main.vhd
-- Generated by MyHDL 0.6
-- Date: Sat May  9 19:05:06 2009


package pck_main is

    type t_enum_t_State_1 is (
    INIT,
    WRITE1,
    WRITE2,
    READ1,
    READ2,
    IDLE
);

end package pck_main;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_06.all;

use work.pck_main.all;

entity main is
    port (
        clk0: in std_logic;
        clk180: in std_logic;
        clk3f: in std_logic;
        clk3f180: in std_logic;
        clk_locked: in std_logic;
        reset: in std_logic;
        intronix: out unsigned(33 downto 0);
        fpga_led: out unsigned(3 downto 0);
        dsp_emif_we: in std_logic;
        dsp_emif_re: in std_logic;
        dsp_emif_oe: in std_logic;
        dsp_emif_ardy: out std_logic;
        dsp_emif_ea: in unsigned(19 downto 0);
        dsp_emif_din: out unsigned(31 downto 0);
        dsp_emif_dout: in unsigned(31 downto 0);
        dsp_emif_ddir: out std_logic;
        dsp_emif_be: in unsigned(3 downto 0);
        dsp_emif_ce: in unsigned(3 downto 0);
        i2c_rst0: out std_logic;
        i2c_rst1: out std_logic;
        i2c_scl0: in std_logic;
        i2c_sda0: in std_logic;
        i2c_scl1: in std_logic;
        i2c_sda1: in std_logic;
        rd_adc: in unsigned(15 downto 0);
        rd_adc_clk: out std_logic;
        rd_adc_oe: out std_logic
    );
end entity main;

architecture MyHDL of main is

signal dsp_wr: std_logic;
signal pwm_inv_out: std_logic;
signal ce2: std_logic;
signal dsp_addr: unsigned(19 downto 0);
signal pwm_out: std_logic;
signal dsp_data_out: unsigned(31 downto 0);
signal dsp_data_in: unsigned(31 downto 0);
signal counter: unsigned(27 downto 0);
signal pwm_temp: unsigned(8 downto 0);
signal pwm_pulse_width: unsigned(15 downto 0);
signal pwm_cs: unsigned(15 downto 0);
signal pwm_dither_cntr: unsigned(7 downto 0);
signal pwm_pwm: std_logic;
signal pwm_main_cntr: unsigned(7 downto 0);
signal dsp_interface_done_wr_d: std_logic;
signal dsp_interface_done_wr: std_logic;
signal dsp_interface_done_rd_d: std_logic;
signal dsp_interface_ce_h: std_logic;
signal dsp_interface_done_rd: std_logic;
signal dsp_interface_we_h: std_logic;
signal dsp_interface_re_h: std_logic;

begin


MAIN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        counter <= "0000000000000000000000000000";
    elsif rising_edge(clk0) then
        counter <= (counter + 1);
    end if;
end process MAIN_LOGIC;


pwm_out <= pwm_pwm;
pwm_inv_out <= (pwm_pwm xor pwm_cs(1));
pwm_temp <= (resize(pwm_dither_cntr, 9) + pwm_pulse_width(8-1 downto 0));

MAIN_PWM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        pwm_cs <= "0000000000000000";
        pwm_pulse_width <= "0000000000000000";
        pwm_main_cntr <= "00000000";
        pwm_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 1) then
                if to_boolean(dsp_wr) then
                    pwm_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in <= resize(pwm_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 2) then
                if to_boolean(dsp_wr) then
                    pwm_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in <= resize(pwm_pulse_width, 32);
            else
                dsp_data_in <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in <= "00000000000000000000000000000000";
        end if;
        if to_boolean(pwm_cs(0)) then
            if (not to_boolean(pwm_cs(1))) then
                pwm_cs(0) <= '0';
            end if;
            pwm_pwm <= '0';
            if (pwm_main_cntr < pwm_pulse_width(16-1 downto (16 - 8))) then
                pwm_pwm <= '1';
            elsif (pwm_main_cntr = pwm_pulse_width(16-1 downto 8)) then
                if (pwm_temp >= 256) then
                    pwm_pwm <= '1';
                    pwm_cs(2) <= '1';
                    pwm_dither_cntr <= resize(pwm_temp - 256, 8);
                else
                    pwm_dither_cntr <= resize(pwm_temp, 8);
                end if;
            end if;
            pwm_main_cntr <= ((pwm_main_cntr + 1) mod 256);
        end if;
        pwm_cs(2) <= pwm_pwm;
    end if;
end process MAIN_PWM_LOGIC;

MAIN_DSP_INTERFACE_LOGIC: process (clk0, reset) is
    variable dsp_addr_v: unsigned(19 downto 0);
    variable done_rd_v: std_logic;
    variable dsp_wr_v: std_logic;
    variable dsp_data_out_v: unsigned(31 downto 0);
    variable done_wr_v: std_logic;
    variable state_v: t_enum_t_State_1;
begin
    if to_boolean(reset) then
        dsp_addr_v := "00000000000000000000";
        dsp_data_out_v := "00000000000000000000000000000000";
        dsp_wr_v := '0';
        done_rd_v := '0';
        done_wr_v := '0';
        state_v := INIT;
    elsif rising_edge(clk0) then
        dsp_wr_v := '0';
        case state_v is
            when INIT =>
                done_rd_v := '0';
                done_wr_v := '0';
                if to_boolean(dsp_interface_ce_h) then
                    dsp_addr_v := dsp_emif_ea;
                    if to_boolean(dsp_interface_re_h) then
                        state_v := READ1;
                    elsif to_boolean(dsp_interface_we_h) then
                        state_v := WRITE1;
                    end if;
                end if;
            when WRITE1 =>
                dsp_data_out_v := dsp_emif_dout;
                dsp_wr_v := '1';
                done_wr_v := '1';
                state_v := WRITE2;
            when WRITE2 =>
                if (not to_boolean(dsp_emif_we)) then
                    done_wr_v := '0';
                    state_v := IDLE;
                end if;
            when READ1 =>
                done_rd_v := '1';
                state_v := READ2;
            when READ2 =>
                if (not to_boolean(dsp_emif_re)) then
                    done_rd_v := '0';
                    state_v := IDLE;
                end if;
            when IDLE =>
                state_v := INIT;
        end case;
    end if;
    dsp_addr <= dsp_addr_v;
    dsp_data_out <= dsp_data_out_v;
    dsp_wr <= dsp_wr_v;
    dsp_interface_done_rd_d <= done_rd_v;
    dsp_interface_done_wr_d <= done_wr_v;
end process MAIN_DSP_INTERFACE_LOGIC;


dsp_emif_ddir <= to_std_logic(to_boolean(dsp_emif_oe) and to_boolean(ce2));
dsp_emif_ardy <= to_std_logic((not to_boolean(ce2)) or to_boolean(dsp_interface_done_rd) or to_boolean(dsp_interface_done_wr));
dsp_emif_din <= dsp_data_in;

MAIN_DSP_INTERFACE_HARDEN: process (clk0) is
begin
    if rising_edge(clk0) then
        dsp_interface_ce_h <= ce2;
        dsp_interface_we_h <= dsp_emif_we;
        dsp_interface_re_h <= dsp_emif_re;
    end if;
end process MAIN_DSP_INTERFACE_HARDEN;

MAIN_DSP_INTERFACE_MAKE_DONE_WR: process (clk0, dsp_emif_we) is
begin
    if (dsp_emif_we = '0') then
        dsp_interface_done_wr <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_wr <= dsp_interface_done_wr_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_WR;

MAIN_DSP_INTERFACE_MAKE_DONE_RD: process (clk0, dsp_emif_re) is
begin
    if (dsp_emif_re = '0') then
        dsp_interface_done_rd <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_rd <= dsp_interface_done_rd_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_RD;

MAIN_COMB: process (reset, i2c_sda0, i2c_sda1, counter, dsp_emif_ce, pwm_inv_out, pwm_out, i2c_scl1, i2c_scl0, clk0, rd_adc) is
begin
    ce2 <= dsp_emif_ce(2);
    intronix(16) <= pwm_out;
    intronix(17) <= pwm_inv_out;
    intronix(16-1 downto 0) <= rd_adc;
    rd_adc_clk <= counter(0);
    rd_adc_oe <= '1';
    fpga_led <= counter(28-1 downto (28 - 4));
    i2c_rst0 <= reset;
    i2c_rst1 <= reset;
    intronix(28) <= i2c_scl0;
    intronix(29) <= i2c_sda0;
    intronix(30) <= i2c_scl1;
    intronix(31) <= i2c_sda1;
    intronix(32) <= reset;
    intronix(33) <= clk0;
end process MAIN_COMB;

end architecture MyHDL;
