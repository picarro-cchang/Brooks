-- File: main.vhd
-- Generated by MyHDL 0.6
-- Date: Thu Sep 17 15:11:05 2009


package pck_main is

    type t_enum_t_seqState_3 is (
    IDLE,
    WAIT_PROC1,
    WAIT_PROC2,
    WAIT_PROC3,
    WAIT_PROC4,
    WAIT_DIV1,
    WAIT_DIV2,
    WAIT_DIV3
);
    type t_enum_t_procState_2 is (
    WAITING,
    CALCULATING
);
    type t_enum_t_State_6 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
    type t_enum_t_State_4 is (
    INIT,
    WRITE1,
    WRITE2,
    READ1,
    READ2,
    IDLE
);
    type t_enum_t_State_11 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
    type t_enum_MetadataAcqState_8 is (
    IDLE,
    AWAIT_STROBE,
    ACQUIRING,
    DONE
);
    type t_enum_SeqState_10 is (
    IDLE,
    START_INJECT,
    WAIT_FOR_PRECONTROL,
    WAIT_FOR_LOCK,
    WAIT_FOR_GATING_CONDITIONS,
    CHECK_BELOW_THRESHOLD,
    WAIT_FOR_THRESHOLD,
    IN_RINGDOWN,
    CHECK_PARAMS_DONE,
    ACQ_DONE
);
    type t_enum_t_State_1 is (
    INIT,
    GENVALUE
);
    type t_enum_t_State_5 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
    type t_enum_t_State_7 is (
    NORMAL,
    DISCONNECTED,
    RESETTING
);
    type t_enum_ParamState_9 is (
    IDLE,
    STORING,
    DONE
);

end package pck_main;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_06.all;

use work.pck_main.all;

entity main is
    port (
        clk0: in std_logic;
        clk180: in std_logic;
        clk3f: in std_logic;
        clk3f180: in std_logic;
        clk_locked: in std_logic;
        reset: in std_logic;
        intronix: out unsigned(33 downto 0);
        fpga_led: out unsigned(3 downto 0);
        dsp_emif_we: in std_logic;
        dsp_emif_re: in std_logic;
        dsp_emif_oe: in std_logic;
        dsp_emif_ardy: out std_logic;
        dsp_emif_ea: in unsigned(19 downto 0);
        dsp_emif_din: out unsigned(31 downto 0);
        dsp_emif_dout: in unsigned(31 downto 0);
        dsp_emif_ddir: out std_logic;
        dsp_emif_be: in unsigned(3 downto 0);
        dsp_emif_ce: in unsigned(3 downto 0);
        dsp_eclk: in std_logic;
        lsr1_0: out std_logic;
        lsr1_1: out std_logic;
        lsr2_0: out std_logic;
        lsr2_1: out std_logic;
        lsr3_0: out std_logic;
        lsr3_1: out std_logic;
        lsr4_0: out std_logic;
        lsr4_1: out std_logic;
        lsr1_sck: out std_logic;
        lsr1_ss: out std_logic;
        lsr1_rd: out std_logic;
        lsr1_mosi: out std_logic;
        lsr1_disable: out std_logic;
        lsr2_sck: out std_logic;
        lsr2_ss: out std_logic;
        lsr2_rd: out std_logic;
        lsr2_mosi: out std_logic;
        lsr2_disable: out std_logic;
        lsr3_sck: out std_logic;
        lsr3_ss: out std_logic;
        lsr3_rd: out std_logic;
        lsr3_mosi: out std_logic;
        lsr3_disable: out std_logic;
        lsr4_sck: out std_logic;
        lsr4_ss: out std_logic;
        lsr4_rd: out std_logic;
        lsr4_mosi: out std_logic;
        lsr4_disable: out std_logic;
        sw1: out std_logic;
        sw2: out std_logic;
        sw3: out std_logic;
        sw4: out std_logic;
        i2c_rst0: out std_logic;
        i2c_rst1: out std_logic;
        i2c_scl0: in std_logic;
        i2c_sda0: in std_logic;
        i2c_scl1: in std_logic;
        i2c_sda1: in std_logic;
        rd_adc: in unsigned(15 downto 0);
        rd_adc_clk: out std_logic;
        rd_adc_oe: out std_logic;
        monitor: out std_logic;
        dsp_ext_int4: out std_logic;
        dsp_ext_int5: out std_logic;
        dsp_ext_int6: out std_logic;
        dsp_ext_int7: out std_logic;
        usb_connected: in std_logic;
        cyp_reset: out std_logic;
        pzt_valve_dac_ld: out std_logic;
        pzt_valve_dac_sck: out std_logic;
        pzt_valve_dac_sdi: out std_logic;
        inlet_valve_pwm: out std_logic;
        outlet_valve_pwm: out std_logic;
        inlet_valve_comparator: in std_logic;
        outlet_valve_comparator: in std_logic;
        heater_pwm: out std_logic;
        hot_box_pwm: out std_logic;
        hot_box_tec_overload: in std_logic;
        warm_box_pwm: out std_logic;
        warm_box_tec_overload: in std_logic;
        wmm_refl1: in std_logic;
        wmm_refl2: in std_logic;
        wmm_tran1: in std_logic;
        wmm_tran2: in std_logic;
        wmm_busy1: in std_logic;
        wmm_busy2: in std_logic;
        wmm_rd: out std_logic;
        wmm_convst: out std_logic;
        wmm_clk: out std_logic
    );
end entity main;

architecture MyHDL of main is

signal wr_meta: unsigned(15 downto 0);
signal data_addr: unsigned(11 downto 0);
signal meta: unsigned(15 downto 0);
signal ce2: std_logic;
signal dsp_data_in_pwm_laser2: unsigned(31 downto 0);
signal rd_irq: std_logic;
signal laser_freq_ok: std_logic;
signal pulse_100k: std_logic;
signal meta_we: std_logic;
signal dsp_data_in_rdman: unsigned(31 downto 0);
signal wlm_sim_actual: std_logic;
signal meta6: unsigned(15 downto 0);
signal metadata_strobe: std_logic;
signal dsp_data_in_twGen: unsigned(31 downto 0);
signal dsp_data_in_rdmemory: unsigned(31 downto 0);
signal eta2_actual: unsigned(15 downto 0);
signal meta5: unsigned(15 downto 0);
signal bank: std_logic;
signal tuner_in_window: std_logic;
signal meta_addr: unsigned(11 downto 0);
signal chanD_data_in: unsigned(15 downto 0);
signal data_we: std_logic;
signal eta2_sim: unsigned(15 downto 0);
signal pwm_laser3_inv_out: std_logic;
signal intronix_clksel: unsigned(4 downto 0);
signal eta1_sim: unsigned(15 downto 0);
signal ratio1: unsigned(15 downto 0);
signal pwm_laser4_inv_out: std_logic;
signal channel_4: unsigned(8 downto 0);
signal pulse_1M: std_logic;
signal sim_loss: unsigned(15 downto 0);
signal channel_3: unsigned(7 downto 0);
signal channel_2: unsigned(7 downto 0);
signal pwm_laser1_out: std_logic;
signal wlm_data_available: std_logic;
signal tuner_slope: std_logic;
signal laser_tuning_offset: unsigned(15 downto 0);
signal laser_fine_current: unsigned(15 downto 0);
signal param_addr: unsigned(5 downto 0);
signal ref1_actual: unsigned(15 downto 0);
signal eta1: unsigned(15 downto 0);
signal eta2: unsigned(15 downto 0);
signal dsp_data_in_inject: unsigned(31 downto 0);
signal laser_locked: std_logic;
signal eta1_actual: unsigned(15 downto 0);
signal dsp_wr: std_logic;
signal pwm_laser1_inv_out: std_logic;
signal sample_dark_in: std_logic;
signal dsp_data_in_laserlocker: unsigned(31 downto 0);
signal wr_data: unsigned(17 downto 0);
signal data: unsigned(17 downto 0);
signal param_we: std_logic;
signal ref2_sim: unsigned(15 downto 0);
signal dsp_data_in_pwm_laser3: unsigned(31 downto 0);
signal ref2_actual: unsigned(15 downto 0);
signal sel_laser: unsigned(1 downto 0);
signal sel_coarse_current: unsigned(15 downto 0);
signal clk_10M: std_logic;
signal dsp_data_out: unsigned(31 downto 0);
signal dsp_data_in_kernel: unsigned(31 downto 0);
signal data_available_sim: std_logic;
signal rdsim_value: unsigned(15 downto 0);
signal dsp_data_in_pwm_laser1: unsigned(31 downto 0);
signal adc_clk: std_logic;
signal dsp_data_in_pwm_laser4: unsigned(31 downto 0);
signal dsp_addr: unsigned(19 downto 0);
signal data_available_actual: std_logic;
signal dsp_data_in: unsigned(31 downto 0);
signal chanA_data_in: unsigned(15 downto 0);
signal chanB_data_in: unsigned(15 downto 0);
signal acq_done_irq: std_logic;
signal diag_1: unsigned(7 downto 0);
signal pzt: unsigned(15 downto 0);
signal ratio2: unsigned(15 downto 0);
signal pwm_laser2_inv_out: std_logic;
signal sel_fine_current: unsigned(15 downto 0);
signal intronix_1: unsigned(7 downto 0);
signal intronix_2: unsigned(7 downto 0);
signal intronix_3: unsigned(7 downto 0);
signal clk_5M: std_logic;
signal meta7: unsigned(15 downto 0);
signal pwm_laser4_out: std_logic;
signal wr_param: unsigned(31 downto 0);
signal dsp_data_in_rdsim: unsigned(31 downto 0);
signal ref1: unsigned(15 downto 0);
signal ref2: unsigned(15 downto 0);
signal sim_pzt: unsigned(15 downto 0);
signal clk_2M5: std_logic;
signal channel_1: unsigned(7 downto 0);
signal param: unsigned(31 downto 0);
signal pwm_laser2_out: std_logic;
signal tuner_value: unsigned(15 downto 0);
signal ref1_sim: unsigned(15 downto 0);
signal counter: unsigned(27 downto 0);
signal pwm_laser3_out: std_logic;
signal dsp_data_in_wlmsim: unsigned(31 downto 0);
signal rd_trig: std_logic;
signal acc_en: std_logic;
signal pztValveDac_chanD_data: unsigned(15 downto 0);
signal pztValveDac_chanB_data: unsigned(15 downto 0);
signal pztValveDac_chanA_data: unsigned(15 downto 0);
signal pztValveDac_counter: unsigned(6 downto 0);
signal pztValveDac_state: t_enum_t_State_11;
signal pztValveDac_chanC_data: unsigned(15 downto 0);
signal wlmsim_xu: unsigned(15 downto 0);
signal wlmsim_div_quot: unsigned(15 downto 0);
signal wlmsim_div_num: unsigned(15 downto 0);
signal wlmsim_done: std_logic;
signal wlmsim_div_ce: std_logic;
signal wlmsim_z0: unsigned(15 downto 0);
signal wlmsim_start_cordic: std_logic;
signal wlmsim_mult_p: unsigned(33 downto 0);
signal wlmsim_ref1: unsigned(15 downto 0);
signal wlmsim_ref2: unsigned(15 downto 0);
signal wlmsim_div_den: unsigned(15 downto 0);
signal wlmsim_zval: unsigned(15 downto 0);
signal wlmsim_mult_a: unsigned(16 downto 0);
signal wlmsim_mult_b: unsigned(16 downto 0);
signal wlmsim_yu: unsigned(15 downto 0);
signal wlmsim_wfac: unsigned(15 downto 0);
signal wlmsim_eta1: unsigned(15 downto 0);
signal wlmsim_eta2: unsigned(15 downto 0);
signal wlmsim_div_rfd: std_logic;
signal wlmsim_rfac: unsigned(15 downto 0);
signal wlmsim_options: unsigned(0 downto 0);
signal wlmsim_divider_Nreg: unsigned(16 downto 0);
signal wlmsim_divider_i: unsigned(3 downto 0);
signal wlmsim_divider_Qreg: unsigned(15 downto 0);
signal wlmsim_divider_done: std_logic;
signal wlmsim_divider_rfd: std_logic;
signal wlmsim_divider_Dreg: unsigned(15 downto 0);
signal wlmsim_multiplier_a_s: signed (17 downto 0);
signal wlmsim_multiplier_b_s: signed (17 downto 0);
signal wlmsim_multiplier_p_s: signed (35 downto 0);
signal wlmadcreader_counter: unsigned(4 downto 0);
signal wlmadcreader_ref1: unsigned(15 downto 0);
signal wlmadcreader_ref2: unsigned(15 downto 0);
signal wlmadcreader_state: t_enum_t_State_6;
signal wlmadcreader_eta2: unsigned(15 downto 0);
signal wlmadcreader_eta1: unsigned(15 downto 0);
signal twGen_slope: std_logic;
signal twGen_pzt_offset: unsigned(15 downto 0);
signal twGen_cs: unsigned(15 downto 0);
signal twGen_sweep_low: unsigned(15 downto 0);
signal twGen_acc: unsigned(24 downto 0);
signal twGen_window_high: unsigned(15 downto 0);
signal twGen_slope_down: unsigned(15 downto 0);
signal twGen_sweep_high: unsigned(15 downto 0);
signal twGen_value: unsigned(15 downto 0);
signal twGen_dsp_data_from_regs: unsigned(15 downto 0);
signal twGen_slope_up: unsigned(15 downto 0);
signal twGen_window_low: unsigned(15 downto 0);
signal rdsim_decay_in_shift: unsigned(3 downto 0);
signal rdsim_accumulator: unsigned(19 downto 0);
signal rdsim_state: t_enum_t_State_1;
signal rdsim_a: unsigned(16 downto 0);
signal rdsim_tuner_center: unsigned(15 downto 0);
signal rdsim_residual: unsigned(13 downto 0);
signal rdsim_filling_rate: unsigned(15 downto 0);
signal rdsim_tuner_window_half_width: unsigned(15 downto 0);
signal rdsim_decay_in_offset: unsigned(15 downto 0);
signal rdsim_b: unsigned(16 downto 0);
signal rdsim_decay: unsigned(15 downto 0);
signal rdsim_p: unsigned(33 downto 0);
signal rdsim_options: unsigned(0 downto 0);
signal rdsim_mult_a_s: signed (17 downto 0);
signal rdsim_mult_b_s: signed (17 downto 0);
signal rdsim_mult_p_s: signed (35 downto 0);
signal rdmemory_wr_dataA: unsigned(17 downto 0);
signal rdmemory_wr_paramA: unsigned(31 downto 0);
signal rdmemory_enB_data: std_logic;
signal rdmemory_param_addrB: unsigned(6 downto 0);
signal rdmemory_param_addrA: unsigned(6 downto 0);
signal rdmemory_enA_data: std_logic;
signal rdmemory_enB_param: std_logic;
signal rdmemory_meta_addrB: unsigned(12 downto 0);
signal rdmemory_meta_addrA: unsigned(12 downto 0);
signal rdmemory_rd_dataA: unsigned(17 downto 0);
signal rdmemory_enA_param: std_logic;
signal rdmemory_data_addrA: unsigned(12 downto 0);
signal rdmemory_data_addrB: unsigned(12 downto 0);
signal rdmemory_rd_metaA: unsigned(15 downto 0);
signal rdmemory_enA_meta: std_logic;
signal rdmemory_rd_paramA: unsigned(31 downto 0);
signal rdmemory_enB_meta: std_logic;
signal rdmemory_wr_enable: std_logic;
signal rdmemory_wr_metaA: unsigned(15 downto 0);
signal rdman_control: unsigned(15 downto 0);
signal rdman_tuner_at_ringdown: unsigned(15 downto 0);
signal rdman_lapped: std_logic;
signal rdman_us_since_start: unsigned(31 downto 0);
signal rdman_metadata_addrcntr: unsigned(11 downto 0);
signal rdman_num_samp: unsigned(11 downto 0);
signal rdman_precontrol_duration: unsigned(15 downto 0);
signal rdman_acq_done_irq: std_logic;
signal rdman_freq_gating_conditions: std_logic;
signal rdman_rd_adc_clk: std_logic;
signal rdman_metadata_acq: std_logic;
signal rdman_threshold: unsigned(15 downto 0);
signal rdman_rd_irq: std_logic;
signal rdman_rd_trig: std_logic;
signal rdman_param7: unsigned(31 downto 0);
signal rdman_timeout_duration: unsigned(31 downto 0);
signal rdman_abort: std_logic;
signal rdman_us_timer_enable: std_logic;
signal rdman_seqState: t_enum_SeqState_10;
signal rdman_param4: unsigned(31 downto 0);
signal rdman_param1: unsigned(31 downto 0);
signal rdman_lock_duration: unsigned(15 downto 0);
signal rdman_status: unsigned(15 downto 0);
signal rdman_data_addrcntr: unsigned(11 downto 0);
signal rdman_rd_data: unsigned(15 downto 0);
signal rdman_rd_divider: unsigned(4 downto 0);
signal rdman_param_acq: std_logic;
signal rdman_param_addrcntr: unsigned(5 downto 0);
signal rdman_tuner_gating_conditions: std_logic;
signal rdman_expiry_time: unsigned(31 downto 0);
signal rdman_init_flag: std_logic;
signal rdman_bank: std_logic;
signal rdman_metadata_addr_at_ringdown: unsigned(15 downto 0);
signal rdman_metadataAcqState: t_enum_MetadataAcqState_8;
signal rdman_divisor: unsigned(4 downto 0);
signal rdman_paramState: t_enum_ParamState_9;
signal rdman_param6: unsigned(31 downto 0);
signal rdman_param5: unsigned(31 downto 0);
signal rdman_param3: unsigned(31 downto 0);
signal rdman_param2: unsigned(31 downto 0);
signal rdman_timeout: std_logic;
signal rdman_param0: unsigned(31 downto 0);
signal rdman_options: unsigned(15 downto 0);
signal rdman_param9: unsigned(31 downto 0);
signal rdman_param8: unsigned(31 downto 0);
signal pwm_laser4_temp: unsigned(8 downto 0);
signal pwm_laser4_pulse_width: unsigned(15 downto 0);
signal pwm_laser4_cs: unsigned(15 downto 0);
signal pwm_laser4_dither_cntr: unsigned(7 downto 0);
signal pwm_laser4_pwm: std_logic;
signal pwm_laser4_main_cntr: unsigned(7 downto 0);
signal pwm_laser3_temp: unsigned(8 downto 0);
signal pwm_laser3_pulse_width: unsigned(15 downto 0);
signal pwm_laser3_cs: unsigned(15 downto 0);
signal pwm_laser3_dither_cntr: unsigned(7 downto 0);
signal pwm_laser3_pwm: std_logic;
signal pwm_laser3_main_cntr: unsigned(7 downto 0);
signal pwm_laser2_temp: unsigned(8 downto 0);
signal pwm_laser2_pulse_width: unsigned(15 downto 0);
signal pwm_laser2_cs: unsigned(15 downto 0);
signal pwm_laser2_dither_cntr: unsigned(7 downto 0);
signal pwm_laser2_pwm: std_logic;
signal pwm_laser2_main_cntr: unsigned(7 downto 0);
signal pwm_laser1_temp: unsigned(8 downto 0);
signal pwm_laser1_pulse_width: unsigned(15 downto 0);
signal pwm_laser1_cs: unsigned(15 downto 0);
signal pwm_laser1_dither_cntr: unsigned(7 downto 0);
signal pwm_laser1_pwm: std_logic;
signal pwm_laser1_main_cntr: unsigned(7 downto 0);
signal laserlocker_ref1_offset: unsigned(15 downto 0);
signal laserlocker_fine_current: unsigned(15 downto 0);
signal laserlocker_div_num: unsigned(15 downto 0);
signal laserlocker_div_quot: unsigned(15 downto 0);
signal laserlocker_ratio1_center: unsigned(15 downto 0);
signal laserlocker_ratio1: unsigned(15 downto 0);
signal laserlocker_ref2: unsigned(15 downto 0);
signal laserlocker_ratio2: unsigned(15 downto 0);
signal laserlocker_cs: unsigned(15 downto 0);
signal laserlocker_ref1_dark: unsigned(15 downto 0);
signal laserlocker_prev_lock_error_deriv: unsigned(15 downto 0);
signal laserlocker_div_ce: std_logic;
signal laserlocker_deriv: unsigned(15 downto 0);
signal laserlocker_eta2_dark: unsigned(15 downto 0);
signal laserlocker_prbs_augment: std_logic;
signal laserlocker_awaiting_strobe: std_logic;
signal laserlocker_cycle_counter: unsigned(15 downto 0);
signal laserlocker_ratio2_center: unsigned(15 downto 0);
signal laserlocker_wm_lock_window: unsigned(15 downto 0);
signal laserlocker_wm_deriv_gain: unsigned(15 downto 0);
signal laserlocker_prev_lock_error: unsigned(15 downto 0);
signal laserlocker_ref2_offset: unsigned(15 downto 0);
signal laserlocker_eta2_offset: unsigned(15 downto 0);
signal laserlocker_mult_p: unsigned(15 downto 0);
signal laserlocker_eta1_dark: unsigned(15 downto 0);
signal laserlocker_ref1: unsigned(15 downto 0);
signal laserlocker_div_den: unsigned(15 downto 0);
signal laserlocker_ratio1_multiplier: unsigned(15 downto 0);
signal laserlocker_lock_error: unsigned(15 downto 0);
signal laserlocker_mult_a: unsigned(15 downto 0);
signal laserlocker_wm_prop_gain: unsigned(15 downto 0);
signal laserlocker_mult_b: unsigned(15 downto 0);
signal laserlocker_ref2_dark: unsigned(15 downto 0);
signal laserlocker_mult_o: std_logic;
signal laserlocker_eta1_offset: unsigned(15 downto 0);
signal laserlocker_ratio2_multiplier: unsigned(15 downto 0);
signal laserlocker_prbs_reg: unsigned(7 downto 0);
signal laserlocker_eta1: unsigned(15 downto 0);
signal laserlocker_eta2: unsigned(15 downto 0);
signal laserlocker_tuning_offset: unsigned(15 downto 0);
signal laserlocker_div_rfd: std_logic;
signal laserlocker_deriv2: unsigned(15 downto 0);
signal laserlocker_options: unsigned(0 downto 0);
signal laserlocker_wm_int_gain: unsigned(15 downto 0);
signal laserlocker_signedMultiplier_a_s: signed (17 downto 0);
signal laserlocker_signedMultiplier_b_s: signed (17 downto 0);
signal laserlocker_signedMultiplier_p_s: signed (35 downto 0);
signal laserlocker_divider_Nreg: unsigned(16 downto 0);
signal laserlocker_divider_i: unsigned(3 downto 0);
signal laserlocker_divider_Qreg: unsigned(15 downto 0);
signal laserlocker_divider_done: std_logic;
signal laserlocker_divider_rfd: std_logic;
signal laserlocker_divider_Dreg: unsigned(15 downto 0);
signal kernel_intronix_clksel: unsigned(4 downto 0);
signal kernel_intronix_1: unsigned(7 downto 0);
signal kernel_intronix_2: unsigned(7 downto 0);
signal kernel_intronix_3: unsigned(7 downto 0);
signal kernel_state: t_enum_t_State_7;
signal kernel_fpga_reset: unsigned(0 downto 0);
signal kernel_counter: unsigned(25 downto 0);
signal kernel_diag_1: unsigned(7 downto 0);
signal inject_laser4_fine_current: unsigned(15 downto 0);
signal inject_laser_current_en: unsigned(3 downto 0);
signal inject_sel: unsigned(1 downto 0);
signal inject_laser_shutdown_en: std_logic;
signal inject_dac_strobe: std_logic;
signal inject_laser3_fine: unsigned(15 downto 0);
signal inject_laser3_fine_current: unsigned(15 downto 0);
signal inject_laser2_coarse_current: unsigned(15 downto 0);
signal inject_strobe_prev: std_logic;
signal inject_laser2_fine_current: unsigned(15 downto 0);
signal inject_laser4_coarse_current: unsigned(15 downto 0);
signal inject_manual_laser_en: unsigned(3 downto 0);
signal inject_soa_shutdown_en: std_logic;
signal inject_laser1_coarse_current: unsigned(15 downto 0);
signal inject_manual_soa_en: std_logic;
signal inject_control: unsigned(15 downto 0);
signal inject_laser1_fine_current: unsigned(15 downto 0);
signal inject_laser2_fine: unsigned(15 downto 0);
signal inject_laser1_fine: unsigned(15 downto 0);
signal inject_mode: std_logic;
signal inject_laser4_fine: unsigned(15 downto 0);
signal inject_laser3_coarse_current: unsigned(15 downto 0);
signal inject_laser4_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser4_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser4_dac_counter: unsigned(5 downto 0);
signal inject_laser4_dac_state: t_enum_t_State_5;
signal inject_laser3_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser3_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser3_dac_counter: unsigned(5 downto 0);
signal inject_laser3_dac_state: t_enum_t_State_5;
signal inject_laser2_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser2_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser2_dac_counter: unsigned(5 downto 0);
signal inject_laser2_dac_state: t_enum_t_State_5;
signal inject_laser1_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser1_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser1_dac_counter: unsigned(5 downto 0);
signal inject_laser1_dac_state: t_enum_t_State_5;
signal clkgen_div1M: unsigned(2 downto 0);
signal clkgen_ff2: std_logic;
signal clkgen_ff1: std_logic;
signal clkgen_div5: unsigned(2 downto 0);
signal clkgen_div25: unsigned(4 downto 0);
signal dsp_interface_done_wr_d: std_logic;
signal dsp_interface_done_wr: std_logic;
signal dsp_interface_done_rd_d: std_logic;
signal dsp_interface_ce_h: std_logic;
signal dsp_interface_done_rd: std_logic;
signal dsp_interface_we_h: std_logic;
signal dsp_interface_re_h: std_logic;

begin

meta6 <= to_unsigned(0, 16);
chanD_data_in <= to_unsigned(0, 16);
sample_dark_in <= '0';
chanA_data_in <= to_unsigned(0, 16);
chanB_data_in <= to_unsigned(0, 16);
meta7 <= to_unsigned(0, 16);



signed_mult18x18_2 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => rdsim_mult_a_s, B => rdsim_mult_b_s, P => rdsim_mult_p_s
    );

MAIN_RDSIM_MULT_COMB: process (rdsim_a, rdsim_b, rdsim_mult_p_s) is
begin
    rdsim_mult_a_s(17-1 downto 0) <= signed(rdsim_a);
    rdsim_mult_a_s(17) <= '0';
    rdsim_mult_b_s(17-1 downto 0) <= signed(rdsim_b);
    rdsim_mult_b_s(17) <= '0';
    rdsim_p <= unsigned(rdsim_mult_p_s(34-1 downto 0));
end process MAIN_RDSIM_MULT_COMB;

MAIN_RDSIM_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        rdsim_options <= "0";
        rdsim_tuner_center <= "0000000000000000";
        rdsim_tuner_window_half_width <= "0000000000000000";
        rdsim_filling_rate <= "0000000000000000";
        rdsim_decay <= "0000000000000000";
        rdsim_decay_in_shift <= "0000";
        rdsim_decay_in_offset <= "0000000000000000";
        rdsim_accumulator <= "00000000000000000000";
        rdsim_state <= INIT;
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 15) then
                if to_boolean(dsp_wr) then
                    rdsim_options <= resize(dsp_data_out, 1);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_options, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 16) then
                if to_boolean(dsp_wr) then
                    rdsim_tuner_center <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_tuner_center, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 17) then
                if to_boolean(dsp_wr) then
                    rdsim_tuner_window_half_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_tuner_window_half_width, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 18) then
                if to_boolean(dsp_wr) then
                    rdsim_filling_rate <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_filling_rate, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 19) then
                if to_boolean(dsp_wr) then
                    rdsim_decay <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_decay, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 20) then
                if to_boolean(dsp_wr) then
                    rdsim_decay_in_shift <= resize(dsp_data_out, 4);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_decay_in_shift, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 21) then
                if to_boolean(dsp_wr) then
                    rdsim_decay_in_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdsim <= resize(rdsim_decay_in_offset, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 22) then
                dsp_data_in_rdsim <= resize(rdsim_accumulator, 32);
            else
                dsp_data_in_rdsim <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_rdsim <= "00000000000000000000000000000000";
        end if;
        if to_boolean(rdsim_options(0)) then
            rdsim_decay <= (rdsim_decay_in_offset + shift_right(sim_loss, to_integer(rdsim_decay_in_shift)));
            rdsim_tuner_center <= sim_pzt;
        end if;
        rdsim_residual <= ((tuner_value - rdsim_tuner_center) and "0011111111111111");
        case rdsim_state is
            when INIT =>
                if to_boolean(adc_clk) then
                    if ((signed(rdsim_residual) < signed(resize(rdsim_tuner_window_half_width, 17))) and (signed(rdsim_residual) > (-rdsim_tuner_window_half_width)) and (not to_boolean(rd_trig))) then
                        rdsim_accumulator <= (rdsim_accumulator + rdsim_filling_rate);
                    else
                        rdsim_accumulator <= (rdsim_accumulator - unsigned'(to_unsigned(0, 4) & rdsim_p(34-1 downto (34 - 16))));
                    end if;
                    rdsim_state <= GENVALUE;
                end if;
            when GENVALUE =>
                if (not to_boolean(adc_clk)) then
                    rdsim_state <= INIT;
                end if;
            when others =>
                rdsim_state <= INIT;
        end case;
        rdsim_value <= rdsim_accumulator((16 + 4)-1 downto 4);
        rdsim_a <= rdsim_accumulator((16 + 4)-1 downto ((16 + 4) - 17));
        rdsim_b <= unsigned'(rdsim_decay & to_unsigned(0, 1));
    end if;
end process MAIN_RDSIM_LOGIC;



dual_port_ram_2 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => rdmemory_enA_meta, wr_enableA => rdmemory_wr_enable,
    addressA => rdmemory_meta_addrA, rd_dataA => rdmemory_rd_metaA, wr_dataA => rdmemory_wr_metaA,
    clockB => clk0, enableB => rdmemory_enB_meta, wr_enableB => meta_we,
    addressB => rdmemory_meta_addrB, rd_dataB => meta, wr_dataB => wr_meta
    );

MAIN_RDMEMORY_COMB: process (dsp_data_out, meta_addr, dsp_wr, rdmemory_rd_dataA, data_addr, rdmemory_rd_paramA, dsp_addr, param_addr, rdmemory_rd_metaA, bank) is
    variable sel_meta: std_logic;
    variable sel_data_and_metadata: std_logic;
    variable sel_param: std_logic;
    variable sel_data: std_logic;
begin
    sel_data_and_metadata := to_std_logic((dsp_addr(20-1 downto 12) = 6) or (dsp_addr(20-1 downto 12) = 2));
    rdmemory_wr_enable <= to_std_logic(to_boolean(dsp_wr) and (not to_boolean(sel_data_and_metadata)));
    rdmemory_enB_data <= '1';
    sel_data := to_std_logic((dsp_addr(20-1 downto 12) = 4) or (dsp_addr(20-1 downto 12) = 0) or to_boolean(sel_data_and_metadata));
    rdmemory_data_addrA(12-1 downto 0) <= dsp_addr(12-1 downto 0);
    rdmemory_data_addrA(12) <= dsp_addr((12 + 2));
    rdmemory_enA_data <= sel_data;
    rdmemory_data_addrB(12-1 downto 0) <= data_addr;
    rdmemory_data_addrB(12) <= bank;
    rdmemory_wr_dataA <= dsp_data_out(18-1 downto 0);
    rdmemory_enB_meta <= '1';
    sel_meta := to_std_logic((dsp_addr(20-1 downto 12) = 5) or (dsp_addr(20-1 downto 12) = 1) or to_boolean(sel_data_and_metadata));
    rdmemory_meta_addrA(12-1 downto 0) <= dsp_addr(12-1 downto 0);
    rdmemory_meta_addrA(12) <= dsp_addr((12 + 2));
    rdmemory_enA_meta <= sel_meta;
    rdmemory_meta_addrB(12-1 downto 0) <= meta_addr;
    rdmemory_meta_addrB(12) <= bank;
    rdmemory_wr_metaA <= dsp_data_out(16-1 downto 0);
    rdmemory_enB_param <= '1';
    sel_param := to_std_logic((dsp_addr(20-1 downto 12) = 7) or (dsp_addr(20-1 downto 12) = 3));
    rdmemory_param_addrA(6-1 downto 0) <= dsp_addr(6-1 downto 0);
    rdmemory_param_addrA(6) <= dsp_addr((12 + 2));
    rdmemory_enA_param <= sel_param;
    rdmemory_param_addrB(6-1 downto 0) <= param_addr;
    rdmemory_param_addrB(6) <= bank;
    rdmemory_wr_paramA <= dsp_data_out(32-1 downto 0);
    if to_boolean(sel_data_and_metadata) then
        dsp_data_in_rdmemory(16-1 downto 0) <= rdmemory_rd_dataA(16-1 downto 0);
        dsp_data_in_rdmemory(32-1 downto 16) <= rdmemory_rd_metaA(16-1 downto 0);
    elsif to_boolean(sel_data) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_dataA(18-1 downto 0), 32);
    elsif to_boolean(sel_meta) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_metaA(16-1 downto 0), 32);
    elsif to_boolean(sel_param) then
        dsp_data_in_rdmemory <= rdmemory_rd_paramA(32-1 downto 0);
    else
        dsp_data_in_rdmemory <= "00000000000000000000000000000000";
    end if;
end process MAIN_RDMEMORY_COMB;



dual_port_ram_3 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 7, DATA_WIDTH => 32)
    port map (
    clockA => clk0, enableA => rdmemory_enA_param, wr_enableA => rdmemory_wr_enable,
    addressA => rdmemory_param_addrA, rd_dataA => rdmemory_rd_paramA, wr_dataA => rdmemory_wr_paramA,
    clockB => clk0, enableB => rdmemory_enB_param, wr_enableB => param_we,
    addressB => rdmemory_param_addrB, rd_dataB => param, wr_dataB => wr_param
    );



dual_port_ram_1 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 18)
    port map (
    clockA => clk0, enableA => rdmemory_enA_data, wr_enableA => rdmemory_wr_enable,
    addressA => rdmemory_data_addrA, rd_dataA => rdmemory_rd_dataA, wr_dataA => rdmemory_wr_dataA,
    clockB => clk0, enableB => rdmemory_enB_data, wr_enableB => data_we,
    addressB => rdmemory_data_addrB, rd_dataB => data, wr_dataB => wr_data
    );

MAIN_WLMSIM_PROCESSOR: process (clk0, reset) is
    variable i: unsigned(3 downto 0);
    variable state: t_enum_t_procState_2;
    variable dz: signed(14 downto 0);
    variable dx: signed(15 downto 0);
    variable dy: signed(15 downto 0);
    variable y: signed(15 downto 0);
    variable x: signed(15 downto 0);
    variable z: signed(14 downto 0);
begin
    if to_boolean(reset) then
        state := WAITING;
        wlmsim_xu <= "0000000000000000";
        wlmsim_yu <= "0000000000000000";
        wlmsim_done <= '0';
        x := "0000000000000000";
        y := "0000000000000000";
        z := "000000000000000";
        i := "0000";
    elsif rising_edge(clk0) then
        case state is
            when WAITING =>
                if to_boolean(wlmsim_start_cordic) then
                    x := signed(wlmsim_mult_p(34-1 downto 18));
                    y := "0000000000000000";
                    z := signed(wlmsim_zval((16 - 1)-1 downto 0));
                    i := "0000";
                    wlmsim_done <= '0';
                    state := CALCULATING;
                end if;
            when CALCULATING =>
                dx := shift_right(y, to_integer(i));
                dy := shift_right(x, to_integer(i));
                case to_integer(i) is
                    when 0 => dz := "010000000000000";
                    when 1 => dz := "001001011100100";
                    when 2 => dz := "000100111111011";
                    when 3 => dz := "000010100010001";
                    when 4 => dz := "000001010001011";
                    when 5 => dz := "000000101000110";
                    when 6 => dz := "000000010100011";
                    when 7 => dz := "000000001010001";
                    when 8 => dz := "000000000101001";
                    when 9 => dz := "000000000010100";
                    when 10 => dz := "000000000001010";
                    when 11 => dz := "000000000000101";
                    when 12 => dz := "000000000000011";
                    when others => dz := "000000000000001";
                end case;
                if (z >= 0) then
                    x := (x - dx);
                    y := (y + dy);
                    z := (z - dz);
                else
                    x := (x + dx);
                    y := (y - dy);
                    z := (z + dz);
                end if;
                if (signed(resize(i, 5)) = (14 - 1)) then
                    if (wlmsim_zval((16 - 1)) /= wlmsim_zval((16 - 2))) then
                        wlmsim_xu <= unsigned(32768 + x);
                        wlmsim_yu <= unsigned(32768 + y);
                    else
                        wlmsim_xu <= unsigned(32768 - x);
                        wlmsim_yu <= unsigned(32768 - y);
                    end if;
                    state := WAITING;
                    wlmsim_done <= '1';
                else
                    i := (i + 1);
                end if;
        end case;
    end if;
end process MAIN_WLMSIM_PROCESSOR;

MAIN_WLMSIM_DIVIDER_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        wlmsim_divider_rfd <= '1';
        wlmsim_div_rfd <= '1';
        wlmsim_divider_Nreg <= "00000000000000000";
        wlmsim_divider_Dreg <= "0000000000000000";
        wlmsim_divider_Qreg <= "0000000000000000";
        wlmsim_div_quot <= "0000000000000000";
        wlmsim_divider_done <= '0';
        wlmsim_divider_i <= to_unsigned(16 - 1, 4);
    elsif rising_edge(clk0) then
        if to_boolean(wlmsim_divider_done) then
            wlmsim_div_quot <= wlmsim_divider_Qreg;
            wlmsim_divider_rfd <= '1';
            wlmsim_div_rfd <= '1';
            wlmsim_divider_done <= '0';
        elsif (to_boolean(wlmsim_divider_rfd) and to_boolean(wlmsim_div_ce)) then
            wlmsim_divider_Nreg <= resize(wlmsim_div_num, 17);
            wlmsim_divider_Dreg <= wlmsim_div_den;
            wlmsim_divider_rfd <= '0';
            wlmsim_div_rfd <= '0';
            wlmsim_divider_i <= to_unsigned(16 - 1, 4);
            wlmsim_divider_done <= '0';
        elsif (not to_boolean(wlmsim_divider_rfd)) then
            if (wlmsim_divider_Nreg >= wlmsim_divider_Dreg) then
                wlmsim_divider_Qreg(to_integer(wlmsim_divider_i)) <= '1';
                wlmsim_divider_Nreg <= shift_left((wlmsim_divider_Nreg - wlmsim_divider_Dreg), 1);
            else
                wlmsim_divider_Qreg(to_integer(wlmsim_divider_i)) <= '0';
                wlmsim_divider_Nreg <= shift_left(wlmsim_divider_Nreg, 1);
            end if;
            if (wlmsim_divider_i = 0) then
                wlmsim_divider_done <= '1';
                wlmsim_divider_i <= to_unsigned(16 - 1, 4);
            else
                wlmsim_divider_i <= (wlmsim_divider_i - 1);
            end if;
        end if;
    end if;
end process MAIN_WLMSIM_DIVIDER_LOGIC;



signed_mult18x18_3 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => wlmsim_multiplier_a_s, B => wlmsim_multiplier_b_s, P => wlmsim_multiplier_p_s
    );

MAIN_WLMSIM_MULTIPLIER_COMB: process (wlmsim_mult_a, wlmsim_mult_b, wlmsim_multiplier_p_s) is
begin
    wlmsim_multiplier_a_s(17-1 downto 0) <= signed(wlmsim_mult_a);
    wlmsim_multiplier_a_s(17) <= '0';
    wlmsim_multiplier_b_s(17-1 downto 0) <= signed(wlmsim_mult_b);
    wlmsim_multiplier_b_s(17) <= '0';
    wlmsim_mult_p <= unsigned(wlmsim_multiplier_p_s(34-1 downto 0));
end process MAIN_WLMSIM_MULTIPLIER_COMB;

MAIN_WLMSIM_LOGIC: process (clk0, reset) is
    variable state: t_enum_t_seqState_3;
begin
    if to_boolean(reset) then
        wlmsim_options <= "0";
        wlmsim_z0 <= "0000000000000000";
        wlmsim_rfac <= "1000000000000000";
        wlmsim_wfac <= "1111100000000000";
        wlmsim_eta1 <= "0000000000000000";
        wlmsim_ref1 <= "0000000000000000";
        wlmsim_eta2 <= "0000000000000000";
        wlmsim_ref2 <= "0000000000000000";
        wlmsim_zval <= "0000000000000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 93) then
                if to_boolean(dsp_wr) then
                    wlmsim_options <= resize(dsp_data_out, 1);
                end if;
                dsp_data_in_wlmsim <= resize(wlmsim_options, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 94) then
                if to_boolean(dsp_wr) then
                    wlmsim_z0 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_wlmsim <= resize(wlmsim_z0, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 95) then
                if to_boolean(dsp_wr) then
                    wlmsim_rfac <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_wlmsim <= resize(wlmsim_rfac, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 96) then
                if to_boolean(dsp_wr) then
                    wlmsim_wfac <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_wlmsim <= resize(wlmsim_wfac, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 97) then
                dsp_data_in_wlmsim <= resize(wlmsim_eta1, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 98) then
                dsp_data_in_wlmsim <= resize(wlmsim_ref1, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 99) then
                dsp_data_in_wlmsim <= resize(wlmsim_eta2, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 100) then
                dsp_data_in_wlmsim <= resize(wlmsim_ref2, 32);
            else
                dsp_data_in_wlmsim <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_wlmsim <= "00000000000000000000000000000000";
        end if;
        wlmsim_div_ce <= '0';
        wlmsim_mult_a(17-1 downto 1) <= "0100110110111010";
        if to_boolean(wlmsim_options(0)) then
            wlmsim_z0 <= (((shift_left(sel_coarse_current, 2) + sel_coarse_current) + shift_right(sel_fine_current, 1)) mod 65536);
        end if;
        if to_boolean(reset) then
            state := IDLE;
            data_available_sim <= '1';
        else
            case state is
                when IDLE =>
                    wlmsim_div_num <= (65536 - wlmsim_rfac);
                    wlmsim_mult_b(17-1 downto 1) <= (wlmsim_rfac - 1);
                    if to_boolean(pulse_100k) then
                        wlmsim_zval <= wlmsim_z0;
                        wlmsim_start_cordic <= '1';
                        state := WAIT_PROC1;
                        data_available_sim <= '0';
                    end if;
                when WAIT_PROC1 =>
                    wlmsim_start_cordic <= '0';
                    state := WAIT_PROC2;
                when WAIT_PROC2 =>
                    if to_boolean(wlmsim_done) then
                        wlmsim_div_den <= wlmsim_yu;
                        wlmsim_div_ce <= '1';
                        state := WAIT_DIV1;
                    end if;
                when WAIT_DIV1 =>
                    if (to_boolean(wlmsim_div_rfd) and (not to_boolean(wlmsim_div_ce))) then
                        wlmsim_ref1 <= wlmsim_div_quot;
                        wlmsim_eta1 <= (65536 - wlmsim_div_quot);
                        wlmsim_div_den <= wlmsim_xu;
                        wlmsim_div_ce <= '1';
                        state := WAIT_DIV2;
                    end if;
                when WAIT_DIV2 =>
                    if (to_boolean(wlmsim_div_rfd) and (not to_boolean(wlmsim_div_ce))) then
                        wlmsim_ref2 <= wlmsim_div_quot;
                        wlmsim_eta2 <= (65536 - wlmsim_div_quot);
                        wlmsim_div_num <= (65536 - wlmsim_wfac);
                        wlmsim_mult_b(17-1 downto 1) <= (wlmsim_wfac - 1);
                        wlmsim_zval <= (shift_left(wlmsim_zval, 2) mod 65536);
                        wlmsim_start_cordic <= '1';
                        state := WAIT_PROC3;
                    end if;
                when WAIT_PROC3 =>
                    wlmsim_start_cordic <= '0';
                    state := WAIT_PROC4;
                when WAIT_PROC4 =>
                    if to_boolean(wlmsim_done) then
                        wlmsim_div_den <= wlmsim_xu;
                        wlmsim_div_ce <= '1';
                        state := WAIT_DIV3;
                    end if;
                when WAIT_DIV3 =>
                    if (to_boolean(wlmsim_div_rfd) and (not to_boolean(wlmsim_div_ce))) then
                        sim_loss <= wlmsim_div_quot;
                        eta1_sim <= wlmsim_eta1;
                        ref1_sim <= wlmsim_ref1;
                        eta2_sim <= wlmsim_eta2;
                        ref2_sim <= wlmsim_ref2;
                        sim_pzt <= (shift_left(wlmsim_zval, 2) mod 65536);
                        data_available_sim <= '1';
                        state := IDLE;
                    end if;
            end case;
        end if;
    end if;
end process MAIN_WLMSIM_LOGIC;

MAIN_DSP_INTERFACE_LOGIC: process (clk0, reset) is
    variable dsp_addr_v: unsigned(19 downto 0);
    variable done_rd_v: std_logic;
    variable dsp_wr_v: std_logic;
    variable dsp_data_out_v: unsigned(31 downto 0);
    variable done_wr_v: std_logic;
    variable state_v: t_enum_t_State_4;
begin
    if to_boolean(reset) then
        dsp_addr_v := "00000000000000000000";
        dsp_data_out_v := "00000000000000000000000000000000";
        dsp_wr_v := '0';
        done_rd_v := '0';
        done_wr_v := '0';
        state_v := INIT;
    elsif rising_edge(clk0) then
        dsp_wr_v := '0';
        case state_v is
            when INIT =>
                done_rd_v := '0';
                done_wr_v := '0';
                if to_boolean(dsp_interface_ce_h) then
                    dsp_addr_v := dsp_emif_ea;
                    if to_boolean(dsp_interface_re_h) then
                        state_v := READ1;
                    elsif to_boolean(dsp_interface_we_h) then
                        state_v := WRITE1;
                    end if;
                end if;
            when WRITE1 =>
                dsp_data_out_v := dsp_emif_dout;
                dsp_wr_v := '1';
                done_wr_v := '1';
                state_v := WRITE2;
            when WRITE2 =>
                if (not to_boolean(dsp_emif_we)) then
                    done_wr_v := '0';
                    state_v := IDLE;
                end if;
            when READ1 =>
                done_rd_v := '1';
                state_v := READ2;
            when READ2 =>
                if (not to_boolean(dsp_emif_re)) then
                    done_rd_v := '0';
                    state_v := IDLE;
                end if;
            when IDLE =>
                state_v := INIT;
        end case;
    end if;
    dsp_addr <= dsp_addr_v;
    dsp_data_out <= dsp_data_out_v;
    dsp_wr <= dsp_wr_v;
    dsp_interface_done_rd_d <= done_rd_v;
    dsp_interface_done_wr_d <= done_wr_v;
end process MAIN_DSP_INTERFACE_LOGIC;


dsp_emif_ddir <= to_std_logic(to_boolean(dsp_emif_oe) and to_boolean(ce2));
dsp_emif_ardy <= to_std_logic((not to_boolean(ce2)) or to_boolean(dsp_interface_done_rd) or to_boolean(dsp_interface_done_wr));
dsp_emif_din <= dsp_data_in;

MAIN_DSP_INTERFACE_HARDEN: process (clk0) is
begin
    if rising_edge(clk0) then
        dsp_interface_ce_h <= ce2;
        dsp_interface_we_h <= dsp_emif_we;
        dsp_interface_re_h <= dsp_emif_re;
    end if;
end process MAIN_DSP_INTERFACE_HARDEN;

MAIN_DSP_INTERFACE_MAKE_DONE_WR: process (clk0, dsp_emif_we) is
begin
    if (dsp_emif_we = '0') then
        dsp_interface_done_wr <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_wr <= dsp_interface_done_wr_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_WR;

MAIN_DSP_INTERFACE_MAKE_DONE_RD: process (clk0, dsp_emif_re) is
begin
    if (dsp_emif_re = '0') then
        dsp_interface_done_rd <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_rd <= dsp_interface_done_rd_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_RD;

MAIN_INJECT_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_control <= "0000000000000000";
        inject_laser1_coarse_current <= "0000000000000000";
        inject_laser2_coarse_current <= "0000000000000000";
        inject_laser3_coarse_current <= "0000000000000000";
        inject_laser4_coarse_current <= "0000000000000000";
        inject_laser1_fine_current <= "1000000000000000";
        inject_laser2_fine_current <= "1000000000000000";
        inject_laser3_fine_current <= "1000000000000000";
        inject_laser4_fine_current <= "1000000000000000";
        inject_strobe_prev <= metadata_strobe;
        inject_dac_strobe <= '0';
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 84) then
                if to_boolean(dsp_wr) then
                    inject_control <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_control, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 85) then
                if to_boolean(dsp_wr) then
                    inject_laser1_coarse_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser1_coarse_current, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 86) then
                if to_boolean(dsp_wr) then
                    inject_laser2_coarse_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser2_coarse_current, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 87) then
                if to_boolean(dsp_wr) then
                    inject_laser3_coarse_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser3_coarse_current, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 88) then
                if to_boolean(dsp_wr) then
                    inject_laser4_coarse_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser4_coarse_current, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 89) then
                if to_boolean(dsp_wr) then
                    inject_laser1_fine_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser1_fine_current, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 90) then
                if to_boolean(dsp_wr) then
                    inject_laser2_fine_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser2_fine_current, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 91) then
                if to_boolean(dsp_wr) then
                    inject_laser3_fine_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser3_fine_current, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 92) then
                if to_boolean(dsp_wr) then
                    inject_laser4_fine_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser4_fine_current, 32);
            else
                dsp_data_in_inject <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_inject <= "00000000000000000000000000000000";
        end if;
        inject_dac_strobe <= to_std_logic(to_boolean(metadata_strobe) and (not to_boolean(inject_strobe_prev)));
        inject_strobe_prev <= metadata_strobe;
    end if;
end process MAIN_INJECT_LOGIC;

MAIN_INJECT_LASER2_DAC_COMB2: process (inject_laser2_dac_counter, inject_laser2_dac_chanB_data, inject_laser2_dac_chanA_data) is
begin
    if ((1 <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < 9)) then
        case ((9 - 1) - to_integer(inject_laser2_dac_counter)) is
            when 0 => lsr2_mosi <= '0';
            when 1 => lsr2_mosi <= '0';
            when 2 => lsr2_mosi <= '0';
            when 3 => lsr2_mosi <= '0';
            when 4 => lsr2_mosi <= '0';
            when 5 => lsr2_mosi <= '0';
            when 6 => lsr2_mosi <= '0';
            when others => lsr2_mosi <= '0';
        end case;
    elsif ((9 <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < 25)) then
        lsr2_mosi <= inject_laser2_dac_chanA_data(((25 - 1) - to_integer(inject_laser2_dac_counter)));
    elsif ((26 <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < 34)) then
        case ((34 - 1) - to_integer(inject_laser2_dac_counter)) is
            when 0 => lsr2_mosi <= '0';
            when 1 => lsr2_mosi <= '0';
            when 2 => lsr2_mosi <= '1';
            when 3 => lsr2_mosi <= '0';
            when 4 => lsr2_mosi <= '1';
            when 5 => lsr2_mosi <= '1';
            when 6 => lsr2_mosi <= '0';
            when others => lsr2_mosi <= '0';
        end case;
    elsif ((34 <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < 50)) then
        lsr2_mosi <= inject_laser2_dac_chanB_data(((50 - 1) - to_integer(inject_laser2_dac_counter)));
    else
        lsr2_mosi <= '0';
    end if;
end process MAIN_INJECT_LASER2_DAC_COMB2;

MAIN_INJECT_LASER2_DAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_laser2_dac_counter <= "000000";
        lsr2_ss <= '0';
    elsif rising_edge(clk0) then
        case inject_laser2_dac_state is
            when IDLE =>
                lsr2_ss <= '0';
                if to_boolean(inject_dac_strobe) then
                    inject_laser2_dac_chanA_data <= inject_laser2_coarse_current;
                    inject_laser2_dac_chanB_data <= inject_laser2_fine;
                    inject_laser2_dac_counter <= "000000";
                    lsr2_ss <= '1';
                    inject_laser2_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_5M) then
                    if (inject_laser2_dac_counter < 49) then
                        if (inject_laser2_dac_counter = 24) then
                            lsr2_ss <= '0';
                        end if;
                        inject_laser2_dac_counter <= (inject_laser2_dac_counter + 1);
                        inject_laser2_dac_state <= WAIT_0;
                    else
                        lsr2_ss <= '0';
                        inject_laser2_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_5M)) then
                    lsr2_ss <= '1';
                    inject_laser2_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser2_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER2_DAC_LOGIC;

MAIN_INJECT_COMB2: process (inject_laser1_fine_current, inject_sel, inject_laser_shutdown_en, rd_trig, inject_laser3_fine_current, inject_laser4_fine_current, rd_trig, inject_laser_current_en, inject_mode, inject_manual_soa_en, inject_laser2_fine_current, inject_manual_laser_en, inject_soa_shutdown_en, laser_fine_current) is
begin
    inject_laser1_fine <= inject_laser1_fine_current;
    inject_laser2_fine <= inject_laser2_fine_current;
    inject_laser3_fine <= inject_laser3_fine_current;
    inject_laser4_fine <= inject_laser4_fine_current;
    lsr1_disable <= to_std_logic(not to_boolean(inject_laser_current_en(0)));
    lsr2_disable <= to_std_logic(not to_boolean(inject_laser_current_en(1)));
    lsr3_disable <= to_std_logic(not to_boolean(inject_laser_current_en(2)));
    lsr4_disable <= to_std_logic(not to_boolean(inject_laser_current_en(3)));
    lsr1_rd <= to_std_logic(not to_boolean(inject_manual_laser_en(0)));
    lsr2_rd <= to_std_logic(not to_boolean(inject_manual_laser_en(1)));
    lsr3_rd <= to_std_logic(not to_boolean(inject_manual_laser_en(2)));
    lsr4_rd <= to_std_logic(not to_boolean(inject_manual_laser_en(3)));
    sw3 <= to_std_logic(not to_boolean(inject_manual_soa_en));
    if to_boolean(inject_mode) then
        sw3 <= to_std_logic(to_boolean(rd_trig) and to_boolean(inject_soa_shutdown_en));
        if (inject_sel = 0) then
            inject_laser1_fine <= laser_fine_current;
            lsr1_rd <= to_std_logic(to_boolean(rd_trig) and to_boolean(inject_laser_shutdown_en));
        elsif (inject_sel = 1) then
            inject_laser2_fine <= laser_fine_current;
            lsr2_rd <= to_std_logic(to_boolean(rd_trig) and to_boolean(inject_laser_shutdown_en));
        elsif (inject_sel = 2) then
            inject_laser3_fine <= laser_fine_current;
            lsr3_rd <= to_std_logic(to_boolean(rd_trig) and to_boolean(inject_laser_shutdown_en));
        else
            inject_laser4_fine <= laser_fine_current;
            lsr4_rd <= to_std_logic(to_boolean(rd_trig) and to_boolean(inject_laser_shutdown_en));
        end if;
    end if;
end process MAIN_INJECT_COMB2;

MAIN_INJECT_LASER3_DAC_COMB2: process (inject_laser3_dac_counter, inject_laser3_dac_chanB_data, inject_laser3_dac_chanA_data) is
begin
    if ((1 <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < 9)) then
        case ((9 - 1) - to_integer(inject_laser3_dac_counter)) is
            when 0 => lsr3_mosi <= '0';
            when 1 => lsr3_mosi <= '0';
            when 2 => lsr3_mosi <= '0';
            when 3 => lsr3_mosi <= '0';
            when 4 => lsr3_mosi <= '0';
            when 5 => lsr3_mosi <= '0';
            when 6 => lsr3_mosi <= '0';
            when others => lsr3_mosi <= '0';
        end case;
    elsif ((9 <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < 25)) then
        lsr3_mosi <= inject_laser3_dac_chanA_data(((25 - 1) - to_integer(inject_laser3_dac_counter)));
    elsif ((26 <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < 34)) then
        case ((34 - 1) - to_integer(inject_laser3_dac_counter)) is
            when 0 => lsr3_mosi <= '0';
            when 1 => lsr3_mosi <= '0';
            when 2 => lsr3_mosi <= '1';
            when 3 => lsr3_mosi <= '0';
            when 4 => lsr3_mosi <= '1';
            when 5 => lsr3_mosi <= '1';
            when 6 => lsr3_mosi <= '0';
            when others => lsr3_mosi <= '0';
        end case;
    elsif ((34 <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < 50)) then
        lsr3_mosi <= inject_laser3_dac_chanB_data(((50 - 1) - to_integer(inject_laser3_dac_counter)));
    else
        lsr3_mosi <= '0';
    end if;
end process MAIN_INJECT_LASER3_DAC_COMB2;

MAIN_INJECT_LASER3_DAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_laser3_dac_counter <= "000000";
        lsr3_ss <= '0';
    elsif rising_edge(clk0) then
        case inject_laser3_dac_state is
            when IDLE =>
                lsr3_ss <= '0';
                if to_boolean(inject_dac_strobe) then
                    inject_laser3_dac_chanA_data <= inject_laser3_coarse_current;
                    inject_laser3_dac_chanB_data <= inject_laser3_fine;
                    inject_laser3_dac_counter <= "000000";
                    lsr3_ss <= '1';
                    inject_laser3_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_5M) then
                    if (inject_laser3_dac_counter < 49) then
                        if (inject_laser3_dac_counter = 24) then
                            lsr3_ss <= '0';
                        end if;
                        inject_laser3_dac_counter <= (inject_laser3_dac_counter + 1);
                        inject_laser3_dac_state <= WAIT_0;
                    else
                        lsr3_ss <= '0';
                        inject_laser3_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_5M)) then
                    lsr3_ss <= '1';
                    inject_laser3_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser3_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER3_DAC_LOGIC;

MAIN_INJECT_LASER1_DAC_COMB2: process (inject_laser1_dac_counter, inject_laser1_dac_chanB_data, inject_laser1_dac_chanA_data) is
begin
    if ((1 <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < 9)) then
        case ((9 - 1) - to_integer(inject_laser1_dac_counter)) is
            when 0 => lsr1_mosi <= '0';
            when 1 => lsr1_mosi <= '0';
            when 2 => lsr1_mosi <= '0';
            when 3 => lsr1_mosi <= '0';
            when 4 => lsr1_mosi <= '0';
            when 5 => lsr1_mosi <= '0';
            when 6 => lsr1_mosi <= '0';
            when others => lsr1_mosi <= '0';
        end case;
    elsif ((9 <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < 25)) then
        lsr1_mosi <= inject_laser1_dac_chanA_data(((25 - 1) - to_integer(inject_laser1_dac_counter)));
    elsif ((26 <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < 34)) then
        case ((34 - 1) - to_integer(inject_laser1_dac_counter)) is
            when 0 => lsr1_mosi <= '0';
            when 1 => lsr1_mosi <= '0';
            when 2 => lsr1_mosi <= '1';
            when 3 => lsr1_mosi <= '0';
            when 4 => lsr1_mosi <= '1';
            when 5 => lsr1_mosi <= '1';
            when 6 => lsr1_mosi <= '0';
            when others => lsr1_mosi <= '0';
        end case;
    elsif ((34 <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < 50)) then
        lsr1_mosi <= inject_laser1_dac_chanB_data(((50 - 1) - to_integer(inject_laser1_dac_counter)));
    else
        lsr1_mosi <= '0';
    end if;
end process MAIN_INJECT_LASER1_DAC_COMB2;

MAIN_INJECT_LASER1_DAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_laser1_dac_counter <= "000000";
        lsr1_ss <= '0';
    elsif rising_edge(clk0) then
        case inject_laser1_dac_state is
            when IDLE =>
                lsr1_ss <= '0';
                if to_boolean(inject_dac_strobe) then
                    inject_laser1_dac_chanA_data <= inject_laser1_coarse_current;
                    inject_laser1_dac_chanB_data <= inject_laser1_fine;
                    inject_laser1_dac_counter <= "000000";
                    lsr1_ss <= '1';
                    inject_laser1_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_5M) then
                    if (inject_laser1_dac_counter < 49) then
                        if (inject_laser1_dac_counter = 24) then
                            lsr1_ss <= '0';
                        end if;
                        inject_laser1_dac_counter <= (inject_laser1_dac_counter + 1);
                        inject_laser1_dac_state <= WAIT_0;
                    else
                        lsr1_ss <= '0';
                        inject_laser1_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_5M)) then
                    lsr1_ss <= '1';
                    inject_laser1_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser1_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER1_DAC_LOGIC;

MAIN_INJECT_LASER4_DAC_COMB2: process (inject_laser4_dac_counter, inject_laser4_dac_chanB_data, inject_laser4_dac_chanA_data) is
begin
    if ((1 <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < 9)) then
        case ((9 - 1) - to_integer(inject_laser4_dac_counter)) is
            when 0 => lsr4_mosi <= '0';
            when 1 => lsr4_mosi <= '0';
            when 2 => lsr4_mosi <= '0';
            when 3 => lsr4_mosi <= '0';
            when 4 => lsr4_mosi <= '0';
            when 5 => lsr4_mosi <= '0';
            when 6 => lsr4_mosi <= '0';
            when others => lsr4_mosi <= '0';
        end case;
    elsif ((9 <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < 25)) then
        lsr4_mosi <= inject_laser4_dac_chanA_data(((25 - 1) - to_integer(inject_laser4_dac_counter)));
    elsif ((26 <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < 34)) then
        case ((34 - 1) - to_integer(inject_laser4_dac_counter)) is
            when 0 => lsr4_mosi <= '0';
            when 1 => lsr4_mosi <= '0';
            when 2 => lsr4_mosi <= '1';
            when 3 => lsr4_mosi <= '0';
            when 4 => lsr4_mosi <= '1';
            when 5 => lsr4_mosi <= '1';
            when 6 => lsr4_mosi <= '0';
            when others => lsr4_mosi <= '0';
        end case;
    elsif ((34 <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < 50)) then
        lsr4_mosi <= inject_laser4_dac_chanB_data(((50 - 1) - to_integer(inject_laser4_dac_counter)));
    else
        lsr4_mosi <= '0';
    end if;
end process MAIN_INJECT_LASER4_DAC_COMB2;

MAIN_INJECT_LASER4_DAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        inject_laser4_dac_counter <= "000000";
        lsr4_ss <= '0';
    elsif rising_edge(clk0) then
        case inject_laser4_dac_state is
            when IDLE =>
                lsr4_ss <= '0';
                if to_boolean(inject_dac_strobe) then
                    inject_laser4_dac_chanA_data <= inject_laser4_coarse_current;
                    inject_laser4_dac_chanB_data <= inject_laser4_fine;
                    inject_laser4_dac_counter <= "000000";
                    lsr4_ss <= '1';
                    inject_laser4_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_5M) then
                    if (inject_laser4_dac_counter < 49) then
                        if (inject_laser4_dac_counter = 24) then
                            lsr4_ss <= '0';
                        end if;
                        inject_laser4_dac_counter <= (inject_laser4_dac_counter + 1);
                        inject_laser4_dac_state <= WAIT_0;
                    else
                        lsr4_ss <= '0';
                        inject_laser4_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_5M)) then
                    lsr4_ss <= '1';
                    inject_laser4_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser4_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER4_DAC_LOGIC;

MAIN_INJECT_COMB1: process (inject_control, inject_laser1_fine_current, inject_laser3_coarse_current, inject_laser3_fine_current, inject_laser4_fine_current, inject_laser2_coarse_current, inject_laser1_coarse_current, inject_laser2_fine_current, inject_laser4_coarse_current, laser_fine_current) is
    variable s: unsigned(15 downto 0);
    variable m: std_logic;
begin
    s := resize(inject_control((1 + 2)-1 downto 1), 16);
    m := inject_control(0);
    inject_mode <= m;
    inject_sel <= resize(s, 2);
    inject_laser_current_en <= inject_control((3 + 4)-1 downto 3);
    inject_manual_laser_en <= inject_control((7 + 4)-1 downto 7);
    inject_manual_soa_en <= inject_control(11);
    inject_laser_shutdown_en <= inject_control(12);
    inject_soa_shutdown_en <= inject_control(13);
    sel_laser <= resize(s, 2);
    if (s = 0) then
        sel_coarse_current <= inject_laser1_coarse_current;
        sel_fine_current <= inject_laser1_fine_current;
    elsif (s = 1) then
        sel_coarse_current <= inject_laser2_coarse_current;
        sel_fine_current <= inject_laser2_fine_current;
    elsif (s = 2) then
        sel_coarse_current <= inject_laser3_coarse_current;
        sel_fine_current <= inject_laser3_fine_current;
    elsif (s = 3) then
        sel_coarse_current <= inject_laser4_coarse_current;
        sel_fine_current <= inject_laser4_fine_current;
    end if;
    if to_boolean(m) then
        sel_fine_current <= laser_fine_current;
    end if;
end process MAIN_INJECT_COMB1;

MAIN_WLMMUX_LOGIC: process (data_available_sim, eta2_sim, ref2_sim, ref2_actual, wlm_sim_actual, ref1_actual, eta2_actual, data_available_actual, ref1_sim, eta1_actual, eta1_sim) is
begin
    if to_boolean(wlm_sim_actual) then
        eta1 <= eta1_actual;
        ref1 <= ref1_actual;
        eta2 <= eta2_actual;
        ref2 <= ref2_actual;
        wlm_data_available <= data_available_actual;
    else
        eta1 <= eta1_sim;
        ref1 <= ref1_sim;
        eta2 <= eta2_sim;
        ref2 <= ref2_sim;
        wlm_data_available <= data_available_sim;
    end if;
end process MAIN_WLMMUX_LOGIC;

MAIN_TWGEN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        twGen_acc(((16 + 9) - 1)) <= '1';
        twGen_acc(((16 + 9) - 1)-1 downto 0) <= "000000000000000000000000";
        twGen_cs <= "0000000000000000";
        twGen_slope_down <= "0000000000000000";
        twGen_slope_up <= "0000000000000000";
        twGen_sweep_low <= "0000000000000000";
        twGen_sweep_high <= "0000000000000000";
        twGen_window_low <= "0000000000000000";
        twGen_window_high <= "0000000000000000";
        twGen_pzt_offset <= "0000000000000000";
        twGen_slope <= '1';
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 75) then
                if to_boolean(dsp_wr) then
                    twGen_acc <= resize(dsp_data_out, 25);
                end if;
                twGen_dsp_data_from_regs <= resize(twGen_acc, 16);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 76) then
                if to_boolean(dsp_wr) then
                    twGen_cs <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_cs;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 77) then
                if to_boolean(dsp_wr) then
                    twGen_slope_down <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_slope_down;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 78) then
                if to_boolean(dsp_wr) then
                    twGen_slope_up <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_slope_up;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 79) then
                if to_boolean(dsp_wr) then
                    twGen_sweep_low <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_sweep_low;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 80) then
                if to_boolean(dsp_wr) then
                    twGen_sweep_high <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_sweep_high;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 81) then
                if to_boolean(dsp_wr) then
                    twGen_window_low <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_window_low;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 82) then
                if to_boolean(dsp_wr) then
                    twGen_window_high <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_window_high;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 83) then
                if to_boolean(dsp_wr) then
                    twGen_pzt_offset <= resize(dsp_data_out, 16);
                end if;
                twGen_dsp_data_from_regs <= twGen_pzt_offset;
            else
                twGen_dsp_data_from_regs <= "0000000000000000";
            end if;
        else
            twGen_dsp_data_from_regs <= "0000000000000000";
        end if;
        if to_boolean(twGen_cs(0)) then
            if (not to_boolean(twGen_cs(1))) then
                twGen_cs(0) <= '0';
            end if;
            if to_boolean(twGen_cs(2)) then
                twGen_acc(((16 + 9) - 1)) <= '1';
                twGen_acc(((16 + 9) - 1)-1 downto 0) <= "000000000000000000000000";
                twGen_slope <= '1';
            else
                if (twGen_value >= twGen_sweep_high) then
                    twGen_slope <= '0';
                elsif (twGen_value <= twGen_sweep_low) then
                    twGen_slope <= '1';
                end if;
                if to_boolean(pulse_100k) then
                    if to_boolean(twGen_slope) then
                        twGen_acc <= (twGen_acc + twGen_slope_up);
                    else
                        twGen_acc <= (twGen_acc - twGen_slope_down);
                    end if;
                end if;
            end if;
        end if;
    end if;
end process MAIN_TWGEN_LOGIC;


twGen_value <= twGen_acc((16 + 9)-1 downto 9);

MAIN_TWGEN_COMB2: process (twGen_slope, twGen_window_high, twGen_pzt_offset, twGen_value, twGen_dsp_data_from_regs, twGen_cs, twGen_window_low) is
begin
    dsp_data_in_twGen <= resize(twGen_dsp_data_from_regs, 32);
    tuner_value <= twGen_value;
    tuner_in_window <= to_std_logic((twGen_value >= twGen_window_low) and (twGen_value <= twGen_window_high));
    tuner_slope <= twGen_slope;
    if to_boolean(twGen_cs(3)) then
        pzt <= ((twGen_value + twGen_pzt_offset) and "1111111111111111");
    else
        pzt <= twGen_pzt_offset;
    end if;
end process MAIN_TWGEN_COMB2;

MAIN_WLMADCREADER_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        wlmadcreader_counter <= "10101";
        eta1_actual <= "0000000000000000";
        ref1_actual <= "0000000000000000";
        eta2_actual <= "0000000000000000";
        ref2_actual <= "0000000000000000";
        wlmadcreader_state <= IDLE;
    elsif rising_edge(clk0) then
        data_available_actual <= '0';
        case wlmadcreader_state is
            when IDLE =>
                wlmadcreader_counter <= "10101";
                wlmadcreader_eta1 <= "0000000000000000";
                wlmadcreader_ref1 <= "0000000000000000";
                wlmadcreader_eta2 <= "0000000000000000";
                wlmadcreader_ref2 <= "0000000000000000";
                if to_boolean(pulse_100k) then
                    wlmadcreader_counter <= "00000";
                    wlmadcreader_state <= WAIT_1;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_2M5)) then
                    if ((wlmadcreader_counter >= 4) and (wlmadcreader_counter <= 19)) then
                        wlmadcreader_eta1((19 - to_integer(wlmadcreader_counter))) <= wmm_refl1;
                        wlmadcreader_ref1((19 - to_integer(wlmadcreader_counter))) <= wmm_tran1;
                        wlmadcreader_eta2((19 - to_integer(wlmadcreader_counter))) <= wmm_refl2;
                        wlmadcreader_ref2((19 - to_integer(wlmadcreader_counter))) <= wmm_tran2;
                    end if;
                    if (signed(resize(wlmadcreader_counter, 6)) = (21 - 1)) then
                        data_available_actual <= '1';
                    end if;
                    wlmadcreader_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_2M5) then
                    if (signed(resize(wlmadcreader_counter, 6)) = (21 - 2)) then
                        eta1_actual <= wlmadcreader_eta1;
                        ref1_actual <= wlmadcreader_ref1;
                        eta2_actual <= wlmadcreader_eta2;
                        ref2_actual <= wlmadcreader_ref2;
                    end if;
                    if (wlmadcreader_counter < 21) then
                        wlmadcreader_counter <= (wlmadcreader_counter + 1);
                        wlmadcreader_state <= WAIT_0;
                    else
                        wlmadcreader_state <= IDLE;
                    end if;
                end if;
            when others =>
                wlmadcreader_state <= IDLE;
        end case;
        wmm_rd <= to_std_logic(wlmadcreader_counter = 1);
        wmm_convst <= to_std_logic(wlmadcreader_counter = 1);
    end if;
end process MAIN_WLMADCREADER_LOGIC;

MAIN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        counter <= "0000000000000000000000000000";
        channel_1 <= "00000000";
        channel_2 <= "00000000";
        channel_3 <= "00000000";
    elsif rising_edge(clk0) then
        counter <= (counter + 1);
        if (intronix_1 = 0) then
            channel_1 <= tuner_value(8-1 downto 0);
        elsif (intronix_1 = 1) then
            channel_1 <= tuner_value(16-1 downto 8);
        elsif (intronix_1 = 2) then
            channel_1 <= unsigned'(rd_adc(6-1 downto 0) & '0' & '0');
        elsif (intronix_1 = 3) then
            channel_1 <= rd_adc(14-1 downto 6);
        elsif (intronix_1 = 4) then
            channel_1 <= unsigned'(rdsim_value(6-1 downto 0) & '0' & '0');
        elsif (intronix_1 = 5) then
            channel_1 <= rdsim_value(14-1 downto 6);
        elsif (intronix_1 = 6) then
            channel_1 <= laser_fine_current(8-1 downto 0);
        elsif (intronix_1 = 7) then
            channel_1 <= laser_fine_current(16-1 downto 8);
        elsif (intronix_1 = 8) then
            channel_1 <= meta5(8-1 downto 0);
        elsif (intronix_1 = 9) then
            channel_1 <= meta5(16-1 downto 8);
        elsif (intronix_1 = 10) then
            channel_1 <= ratio1(8-1 downto 0);
        elsif (intronix_1 = 11) then
            channel_1 <= ratio1(16-1 downto 8);
        elsif (intronix_1 = 12) then
            channel_1 <= ratio2(8-1 downto 0);
        else
            channel_1 <= ratio2(16-1 downto 8);
        end if;
        if (intronix_2 = 0) then
            channel_2 <= tuner_value(8-1 downto 0);
        elsif (intronix_2 = 1) then
            channel_2 <= tuner_value(16-1 downto 8);
        elsif (intronix_2 = 2) then
            channel_2 <= unsigned'(rd_adc(6-1 downto 0) & '0' & '0');
        elsif (intronix_2 = 3) then
            channel_2 <= rd_adc(14-1 downto 6);
        elsif (intronix_2 = 4) then
            channel_2 <= unsigned'(rdsim_value(6-1 downto 0) & '0' & '0');
        elsif (intronix_2 = 5) then
            channel_2 <= rdsim_value(14-1 downto 6);
        elsif (intronix_2 = 6) then
            channel_2 <= laser_fine_current(8-1 downto 0);
        elsif (intronix_2 = 7) then
            channel_2 <= laser_fine_current(16-1 downto 8);
        elsif (intronix_2 = 8) then
            channel_2 <= meta5(8-1 downto 0);
        elsif (intronix_2 = 9) then
            channel_2 <= meta5(16-1 downto 8);
        elsif (intronix_2 = 10) then
            channel_2 <= ratio1(8-1 downto 0);
        elsif (intronix_2 = 11) then
            channel_2 <= ratio1(16-1 downto 8);
        elsif (intronix_2 = 12) then
            channel_2 <= ratio2(8-1 downto 0);
        else
            channel_2 <= ratio2(16-1 downto 8);
        end if;
        if (intronix_3 = 0) then
            channel_3 <= tuner_value(8-1 downto 0);
        elsif (intronix_3 = 1) then
            channel_3 <= tuner_value(16-1 downto 8);
        elsif (intronix_3 = 2) then
            channel_3 <= unsigned'(rd_adc(6-1 downto 0) & '0' & '0');
        elsif (intronix_3 = 3) then
            channel_3 <= rd_adc(14-1 downto 6);
        elsif (intronix_3 = 4) then
            channel_3 <= unsigned'(rdsim_value(6-1 downto 0) & '0' & '0');
        elsif (intronix_3 = 5) then
            channel_3 <= rdsim_value(14-1 downto 6);
        elsif (intronix_3 = 6) then
            channel_3 <= laser_fine_current(8-1 downto 0);
        elsif (intronix_3 = 7) then
            channel_3 <= laser_fine_current(16-1 downto 8);
        elsif (intronix_3 = 8) then
            channel_3 <= meta5(8-1 downto 0);
        elsif (intronix_3 = 9) then
            channel_3 <= meta5(16-1 downto 8);
        elsif (intronix_3 = 10) then
            channel_3 <= ratio1(8-1 downto 0);
        elsif (intronix_3 = 11) then
            channel_3 <= ratio1(16-1 downto 8);
        elsif (intronix_3 = 12) then
            channel_3 <= ratio2(8-1 downto 0);
        else
            channel_3 <= ratio2(16-1 downto 8);
        end if;
        channel_4 <= unsigned'(rd_trig & diag_1(4-1 downto 0) & bank & laser_locked & acc_en & tuner_in_window);
    end if;
end process MAIN_LOGIC;


laser_tuning_offset <= laserlocker_tuning_offset;
wlm_sim_actual <= laserlocker_options(0);

MAIN_LASERLOCKER_LOGIC: process (clk0, reset) is
    variable temp: std_logic;
begin
    if to_boolean(reset) then
        laserlocker_cs <= "0000000000000000";
        laserlocker_options <= "0";
        laserlocker_eta1 <= "0000000000000000";
        laserlocker_ref1 <= "0000000000000000";
        laserlocker_eta2 <= "0000000000000000";
        laserlocker_ref2 <= "0000000000000000";
        laserlocker_eta1_dark <= "0000000000000000";
        laserlocker_ref1_dark <= "0000000000000000";
        laserlocker_eta2_dark <= "0000000000000000";
        laserlocker_ref2_dark <= "0000000000000000";
        laserlocker_eta1_offset <= "0000000000000000";
        laserlocker_ref1_offset <= "0000000000000000";
        laserlocker_eta2_offset <= "0000000000000000";
        laserlocker_ref2_offset <= "0000000000000000";
        laserlocker_ratio1 <= "0000000000000000";
        laserlocker_ratio2 <= "0000000000000000";
        laserlocker_ratio1_center <= "0000000000000000";
        laserlocker_ratio1_multiplier <= "0000000000000000";
        laserlocker_ratio2_center <= "0000000000000000";
        laserlocker_ratio2_multiplier <= "0000000000000000";
        laserlocker_tuning_offset <= "1000000000000000";
        laserlocker_lock_error <= "0000000000000000";
        laserlocker_wm_lock_window <= "0000000000000000";
        laserlocker_wm_int_gain <= "0000000000000000";
        laserlocker_wm_prop_gain <= "0000000000000000";
        laserlocker_wm_deriv_gain <= "0000000000000000";
        laserlocker_fine_current <= "0000000000000000";
        laserlocker_cycle_counter <= "0000000000110010";
        laserlocker_div_ce <= '0';
        laserlocker_div_num <= "0000000000000000";
        laserlocker_div_den <= "0000000000000000";
        laserlocker_prev_lock_error <= "0000000000000000";
        laserlocker_prev_lock_error_deriv <= "0000000000000000";
        laserlocker_deriv <= "0000000000000000";
        laserlocker_deriv2 <= "0000000000000000";
        laser_freq_ok <= '0';
        metadata_strobe <= '0';
        laserlocker_prbs_reg <= "00000001";
        laserlocker_prbs_augment <= '0';
        laserlocker_awaiting_strobe <= '1';
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 23) then
                if to_boolean(dsp_wr) then
                    laserlocker_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 24) then
                if to_boolean(dsp_wr) then
                    laserlocker_options <= resize(dsp_data_out, 1);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_options, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 25) then
                if to_boolean(dsp_wr) then
                    laserlocker_eta1 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_eta1, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 26) then
                if to_boolean(dsp_wr) then
                    laserlocker_ref1 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ref1, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 27) then
                if to_boolean(dsp_wr) then
                    laserlocker_eta2 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_eta2, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 28) then
                if to_boolean(dsp_wr) then
                    laserlocker_ref2 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ref2, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 29) then
                dsp_data_in_laserlocker <= resize(laserlocker_eta1_dark, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 30) then
                dsp_data_in_laserlocker <= resize(laserlocker_ref1_dark, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 31) then
                dsp_data_in_laserlocker <= resize(laserlocker_eta2_dark, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 32) then
                dsp_data_in_laserlocker <= resize(laserlocker_ref2_dark, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 33) then
                if to_boolean(dsp_wr) then
                    laserlocker_eta1_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_eta1_offset, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 34) then
                if to_boolean(dsp_wr) then
                    laserlocker_ref1_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ref1_offset, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 35) then
                if to_boolean(dsp_wr) then
                    laserlocker_eta2_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_eta2_offset, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 36) then
                if to_boolean(dsp_wr) then
                    laserlocker_ref2_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ref2_offset, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 37) then
                dsp_data_in_laserlocker <= resize(laserlocker_ratio1, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 38) then
                dsp_data_in_laserlocker <= resize(laserlocker_ratio2, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 39) then
                if to_boolean(dsp_wr) then
                    laserlocker_ratio1_center <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ratio1_center, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 40) then
                if to_boolean(dsp_wr) then
                    laserlocker_ratio1_multiplier <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ratio1_multiplier, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 41) then
                if to_boolean(dsp_wr) then
                    laserlocker_ratio2_center <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ratio2_center, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 42) then
                if to_boolean(dsp_wr) then
                    laserlocker_ratio2_multiplier <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ratio2_multiplier, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 43) then
                if to_boolean(dsp_wr) then
                    laserlocker_tuning_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_tuning_offset, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 44) then
                dsp_data_in_laserlocker <= resize(laserlocker_lock_error, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 45) then
                if to_boolean(dsp_wr) then
                    laserlocker_wm_lock_window <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_wm_lock_window, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 46) then
                if to_boolean(dsp_wr) then
                    laserlocker_wm_int_gain <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_wm_int_gain, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 47) then
                if to_boolean(dsp_wr) then
                    laserlocker_wm_prop_gain <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_wm_prop_gain, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 48) then
                if to_boolean(dsp_wr) then
                    laserlocker_wm_deriv_gain <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_wm_deriv_gain, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 49) then
                dsp_data_in_laserlocker <= resize(laserlocker_fine_current, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 50) then
                dsp_data_in_laserlocker <= resize(laserlocker_cycle_counter, 32);
            else
                dsp_data_in_laserlocker <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_laserlocker <= "00000000000000000000000000000000";
        end if;
        if to_boolean(laserlocker_cs(0)) then
            if to_boolean(laserlocker_cs(1)) then
                laserlocker_eta1 <= eta1;
                laserlocker_ref1 <= ref1;
                laserlocker_eta2 <= eta2;
                laserlocker_ref2 <= ref2;
                laserlocker_cs(3) <= acc_en;
                laserlocker_cs(4) <= sample_dark_in;
                laserlocker_cs(5) <= wlm_data_available;
            end if;
            if to_boolean(laserlocker_cs(6)) then
                laserlocker_tuning_offset <= tuner_value;
            end if;
            if to_boolean(laserlocker_cs(4)) then
                laserlocker_eta1_dark <= laserlocker_eta1;
                laserlocker_ref1_dark <= laserlocker_ref1;
                laserlocker_eta2_dark <= laserlocker_eta2;
                laserlocker_ref2_dark <= laserlocker_ref2;
            end if;
            laserlocker_div_ce <= to_std_logic((laserlocker_cycle_counter = 1) or (signed(resize(laserlocker_cycle_counter, 17)) = (19 + 1)));
            if (laserlocker_cycle_counter = 0) then
                laserlocker_div_num <= (laserlocker_eta1 - laserlocker_eta1_offset);
                laserlocker_div_den <= (laserlocker_ref1 - laserlocker_ref1_offset);
            elsif (laserlocker_cycle_counter = 19) then
                laserlocker_div_num <= (laserlocker_eta2 - laserlocker_eta2_offset);
                laserlocker_div_den <= (laserlocker_ref2 - laserlocker_ref2_offset);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (19 + 1)) then
                laserlocker_ratio1 <= laserlocker_div_quot;
                ratio1 <= laserlocker_div_quot;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (19 + 2)) then
                laserlocker_mult_a <= ((laserlocker_ratio1 - laserlocker_ratio1_center) mod 65536);
                laserlocker_mult_b <= laserlocker_ratio1_multiplier;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((19 + 2) + 2)) then
                laserlocker_lock_error <= ((laserlocker_lock_error + laserlocker_mult_p) mod 65536);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((2 * 19) + 1)) then
                laserlocker_ratio2 <= laserlocker_div_quot;
                ratio2 <= laserlocker_div_quot;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((2 * 19) + 2)) then
                laserlocker_mult_a <= ((laserlocker_ratio2 - laserlocker_ratio2_center) mod 65536);
                laserlocker_mult_b <= laserlocker_ratio2_multiplier;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (((2 * 19) + 2) + 2)) then
                laserlocker_lock_error <= ((laserlocker_lock_error + laserlocker_mult_p) mod 65536);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * 19) + 2) + 2) + 1)) then
                if (signed(laserlocker_lock_error) >= 0) then
                    laser_freq_ok <= to_std_logic(laserlocker_lock_error <= laserlocker_wm_lock_window);
                else
                    laser_freq_ok <= to_std_logic((-signed(laserlocker_lock_error)) <= signed(resize(laserlocker_wm_lock_window, 17)));
                end if;
                meta5 <= laserlocker_lock_error;
                laserlocker_mult_a <= laserlocker_lock_error;
                laserlocker_mult_b <= laserlocker_wm_int_gain;
                laserlocker_deriv <= ((laserlocker_lock_error - laserlocker_prev_lock_error) mod 65536);
                laserlocker_prev_lock_error <= laserlocker_lock_error;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * 19) + 1) + (2 * 2)) + 1)) then
                laserlocker_mult_a <= laserlocker_deriv;
                laserlocker_mult_b <= laserlocker_wm_prop_gain;
                laserlocker_deriv2 <= ((laserlocker_deriv - laserlocker_prev_lock_error_deriv) mod 65536);
                laserlocker_prev_lock_error_deriv <= laserlocker_deriv;
                laserlocker_fine_current <= ((laserlocker_fine_current + laserlocker_mult_p) mod 65536);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * 19) + 1) + (3 * 2)) + 1)) then
                laserlocker_mult_a <= laserlocker_deriv2;
                laserlocker_mult_b <= laserlocker_wm_deriv_gain;
                laserlocker_fine_current <= ((laserlocker_fine_current + laserlocker_mult_p) mod 65536);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * 19) + 1) + (4 * 2)) + 1)) then
                laserlocker_fine_current <= ((laserlocker_fine_current + laserlocker_mult_p) mod 65536);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * 19) + 1) + (4 * 2)) + 2)) then
                if to_boolean(laserlocker_cs(2)) then
                    if to_boolean(laserlocker_prbs_reg(0)) then
                        laser_fine_current <= "1000000100000000";
                    else
                        laser_fine_current <= "0111111100000000";
                    end if;
                    temp := to_std_logic((laserlocker_prbs_reg = 238) and (not to_boolean(laserlocker_prbs_augment)));
                    laserlocker_prbs_augment <= temp;
                    if (not to_boolean(temp)) then
                        if to_boolean(laserlocker_prbs_reg(7)) then
                            laserlocker_prbs_reg <= unsigned'((laserlocker_prbs_reg(7-1 downto 0) xor "0110100") & to_unsigned(1, 1));
                        else
                            laserlocker_prbs_reg <= unsigned'(laserlocker_prbs_reg(7-1 downto 0) & to_unsigned(0, 1));
                        end if;
                    end if;
                else
                    laser_fine_current <= laserlocker_fine_current;
                    laserlocker_prbs_reg <= "00000001";
                    laserlocker_prbs_augment <= '0';
                end if;
            end if;
            if (laserlocker_cycle_counter < 50) then
                laserlocker_cycle_counter <= (laserlocker_cycle_counter + 1);
            else
                metadata_strobe <= '1';
                if to_boolean(laserlocker_cs(5)) then
                    if to_boolean(laserlocker_awaiting_strobe) then
                        laserlocker_awaiting_strobe <= '0';
                        laserlocker_lock_error <= ((laserlocker_tuning_offset - 32768) mod 65536);
                        meta5 <= laserlocker_lock_error;
                        laserlocker_cycle_counter <= "0000000000000000";
                        metadata_strobe <= '0';
                    end if;
                else
                    laserlocker_awaiting_strobe <= '1';
                end if;
            end if;
            if (not to_boolean(laserlocker_cs(3))) then
                laserlocker_fine_current <= "1000000000000000";
                laser_fine_current <= "1000000000000000";
            end if;
            if (not to_boolean(laserlocker_cs(1))) then
                laserlocker_cs(0) <= '0';
            end if;
            laserlocker_cs(8) <= metadata_strobe;
            laserlocker_cs(7) <= laser_freq_ok;
        end if;
    end if;
end process MAIN_LASERLOCKER_LOGIC;



signed_mult18x18_1 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => laserlocker_signedMultiplier_a_s, B => laserlocker_signedMultiplier_b_s, P => laserlocker_signedMultiplier_p_s
    );


laserlocker_signedMultiplier_a_s <= signed(unsigned'(laserlocker_mult_a & '0' & '0'));
laserlocker_signedMultiplier_b_s <= signed(unsigned'(laserlocker_mult_b & '0' & '0'));
laserlocker_mult_p <= (unsigned'(laserlocker_signedMultiplier_p_s(35) & unsigned(laserlocker_signedMultiplier_p_s(34-1 downto 19))) mod 65536);
laserlocker_mult_o <= to_std_logic(laserlocker_signedMultiplier_p_s(35) /= laserlocker_signedMultiplier_p_s(34));

MAIN_LASERLOCKER_DIVIDER_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        laserlocker_divider_rfd <= '1';
        laserlocker_div_rfd <= '1';
        laserlocker_divider_Nreg <= "00000000000000000";
        laserlocker_divider_Dreg <= "0000000000000000";
        laserlocker_divider_Qreg <= "0000000000000000";
        laserlocker_div_quot <= "0000000000000000";
        laserlocker_divider_done <= '0';
        laserlocker_divider_i <= to_unsigned(16 - 1, 4);
    elsif rising_edge(clk0) then
        if to_boolean(laserlocker_divider_done) then
            laserlocker_div_quot <= laserlocker_divider_Qreg;
            laserlocker_divider_rfd <= '1';
            laserlocker_div_rfd <= '1';
            laserlocker_divider_done <= '0';
        elsif (to_boolean(laserlocker_divider_rfd) and to_boolean(laserlocker_div_ce)) then
            laserlocker_divider_Nreg <= resize(laserlocker_div_num, 17);
            laserlocker_divider_Dreg <= laserlocker_div_den;
            laserlocker_divider_rfd <= '0';
            laserlocker_div_rfd <= '0';
            laserlocker_divider_i <= to_unsigned(16 - 1, 4);
            laserlocker_divider_done <= '0';
        elsif (not to_boolean(laserlocker_divider_rfd)) then
            if (laserlocker_divider_Nreg >= laserlocker_divider_Dreg) then
                laserlocker_divider_Qreg(to_integer(laserlocker_divider_i)) <= '1';
                laserlocker_divider_Nreg <= shift_left((laserlocker_divider_Nreg - laserlocker_divider_Dreg), 1);
            else
                laserlocker_divider_Qreg(to_integer(laserlocker_divider_i)) <= '0';
                laserlocker_divider_Nreg <= shift_left(laserlocker_divider_Nreg, 1);
            end if;
            if (laserlocker_divider_i = 0) then
                laserlocker_divider_done <= '1';
                laserlocker_divider_i <= to_unsigned(16 - 1, 4);
            else
                laserlocker_divider_i <= (laserlocker_divider_i - 1);
            end if;
        end if;
    end if;
end process MAIN_LASERLOCKER_DIVIDER_LOGIC;


intronix_clksel <= kernel_intronix_clksel;
intronix_1 <= kernel_intronix_1;
intronix_2 <= kernel_intronix_2;
intronix_3 <= kernel_intronix_3;
diag_1 <= kernel_diag_1;

MAIN_KERNEL_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        kernel_fpga_reset <= "0";
        kernel_diag_1 <= "00000000";
        kernel_intronix_clksel <= "00000";
        kernel_intronix_1 <= "00000000";
        kernel_intronix_2 <= "00000000";
        kernel_intronix_3 <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 0) then
                dsp_data_in_kernel <= "11000000110111100000000000000001";
            elsif (dsp_addr((20 - 1)-1 downto 0) = 1) then
                if to_boolean(dsp_wr) then
                    kernel_fpga_reset <= resize(dsp_data_out, 1);
                end if;
                dsp_data_in_kernel <= resize(kernel_fpga_reset, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 2) then
                if to_boolean(dsp_wr) then
                    kernel_diag_1 <= resize(dsp_data_out, 8);
                end if;
                dsp_data_in_kernel <= resize(kernel_diag_1, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 3) then
                if to_boolean(dsp_wr) then
                    kernel_intronix_clksel <= resize(dsp_data_out, 5);
                end if;
                dsp_data_in_kernel <= resize(kernel_intronix_clksel, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 4) then
                if to_boolean(dsp_wr) then
                    kernel_intronix_1 <= resize(dsp_data_out, 8);
                end if;
                dsp_data_in_kernel <= resize(kernel_intronix_1, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 5) then
                if to_boolean(dsp_wr) then
                    kernel_intronix_2 <= resize(dsp_data_out, 8);
                end if;
                dsp_data_in_kernel <= resize(kernel_intronix_2, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 6) then
                if to_boolean(dsp_wr) then
                    kernel_intronix_3 <= resize(dsp_data_out, 8);
                end if;
                dsp_data_in_kernel <= resize(kernel_intronix_3, 32);
            else
                dsp_data_in_kernel <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_kernel <= "00000000000000000000000000000000";
        end if;
        case kernel_state is
            when NORMAL =>
                cyp_reset <= '0';
                if to_boolean(kernel_fpga_reset) then
                    kernel_counter <= "00000000000000000000000000";
                    kernel_fpga_reset <= "0";
                    kernel_state <= RESETTING;
                elsif (not to_boolean(usb_connected)) then
                    kernel_counter <= "00000000000000000000000000";
                    kernel_state <= DISCONNECTED;
                else
                    kernel_state <= NORMAL;
                end if;
            when DISCONNECTED =>
                cyp_reset <= '0';
                if to_boolean(usb_connected) then
                    kernel_state <= NORMAL;
                elsif to_boolean(kernel_fpga_reset) then
                    kernel_counter <= "00000000000000000000000000";
                    kernel_fpga_reset <= "0";
                    kernel_state <= RESETTING;
                else
                    kernel_counter <= (kernel_counter + 1);
                    if (kernel_counter = 67108863) then
                        kernel_counter <= "00000000000000000000000000";
                        kernel_state <= RESETTING;
                    else
                        kernel_state <= DISCONNECTED;
                    end if;
                end if;
            when RESETTING =>
                cyp_reset <= '1';
                kernel_counter <= (kernel_counter + 1);
                if (kernel_counter = 67108863) then
                    kernel_fpga_reset <= "0";
                    kernel_state <= NORMAL;
                else
                    kernel_state <= RESETTING;
                end if;
            when others =>
                cyp_reset <= '0';
                kernel_state <= NORMAL;
        end case;
    end if;
end process MAIN_KERNEL_LOGIC;

MAIN_COMB: process (clk_2M5, pwm_laser1_inv_out, intronix_clksel, pwm_laser2_inv_out, dsp_data_in_laserlocker, acq_done_irq, pwm_laser4_inv_out, rd_irq, rd_trig, channel_4, channel_1, channel_3, channel_2, dsp_data_in_wlmsim, pwm_laser1_out, pwm_laser4_out, dsp_data_in_rdman, dsp_data_in_pwm_laser3, dsp_data_in_rdsim, clk_10M, dsp_data_in_kernel, dsp_data_in_twGen, dsp_data_in_rdmemory, clk0, dsp_data_in_pwm_laser2, dsp_data_in_pwm_laser1, clk_5M, adc_clk, dsp_data_in_pwm_laser4, reset, pwm_laser2_out, dsp_data_in_inject, counter, pwm_laser3_inv_out, dsp_emif_ce, pwm_laser3_out) is
begin
    dsp_data_in <= (dsp_data_in_inject or dsp_data_in_kernel or dsp_data_in_laserlocker or dsp_data_in_pwm_laser1 or dsp_data_in_pwm_laser2 or dsp_data_in_pwm_laser3 or dsp_data_in_pwm_laser4 or dsp_data_in_rdman or dsp_data_in_rdmemory or dsp_data_in_rdsim or dsp_data_in_twGen or dsp_data_in_wlmsim);
    intronix(8-1 downto 0) <= channel_1;
    intronix(16-1 downto 8) <= channel_2;
    intronix(24-1 downto 16) <= channel_3;
    intronix(33-1 downto 24) <= channel_4;
    if (intronix_clksel = 0) then
        intronix(33) <= clk0;
    elsif (intronix_clksel <= 28) then
        intronix(33) <= counter(to_integer(intronix_clksel - 1));
    else
        intronix(33) <= '0';
    end if;
    monitor <= rd_trig;
    ce2 <= dsp_emif_ce(2);
    lsr1_0 <= pwm_laser1_out;
    lsr1_1 <= pwm_laser1_inv_out;
    lsr2_0 <= pwm_laser2_out;
    lsr2_1 <= pwm_laser2_inv_out;
    lsr3_0 <= pwm_laser3_out;
    lsr3_1 <= pwm_laser3_inv_out;
    lsr4_0 <= pwm_laser4_out;
    lsr4_1 <= pwm_laser4_inv_out;
    rd_adc_clk <= adc_clk;
    rd_adc_oe <= '1';
    fpga_led <= counter(28-1 downto (28 - 4));
    i2c_rst0 <= reset;
    i2c_rst1 <= reset;
    dsp_ext_int4 <= rd_irq;
    dsp_ext_int5 <= acq_done_irq;
    dsp_ext_int6 <= '0';
    dsp_ext_int7 <= '0';
    lsr1_sck <= clk_5M;
    lsr2_sck <= clk_5M;
    lsr3_sck <= clk_5M;
    lsr4_sck <= clk_5M;
    pzt_valve_dac_sck <= clk_10M;
    sw1 <= '0';
    sw2 <= '0';
    sw4 <= '0';
    inlet_valve_pwm <= '0';
    outlet_valve_pwm <= '0';
    heater_pwm <= '0';
    hot_box_pwm <= '0';
    warm_box_pwm <= '0';
    wmm_clk <= clk_2M5;
end process MAIN_COMB;

MAIN_RDMAN_COMB1: process (rd_adc, rdman_options, rdsim_value) is
begin
    if to_boolean(rdman_options(4)) then
        rdman_rd_data <= rd_adc;
    else
        rdman_rd_data <= rdsim_value;
    end if;
end process MAIN_RDMAN_COMB1;


bank <= rdman_bank;
rd_irq <= rdman_rd_irq;
acq_done_irq <= rdman_acq_done_irq;
rd_trig <= rdman_rd_trig;
adc_clk <= rdman_rd_adc_clk;
rdman_tuner_gating_conditions <= to_std_logic(to_boolean(tuner_in_window) and ((to_boolean(tuner_slope) and to_boolean(rdman_options(1))) or ((not to_boolean(tuner_slope)) and to_boolean(rdman_options(2)))));
rdman_freq_gating_conditions <= to_std_logic(to_boolean(laser_freq_ok) or (not to_boolean(rdman_options(0))));
wr_data <= resize(rdman_rd_data, 18);

MAIN_RDMAN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        rdman_control <= "0000000000000000";
        rdman_status <= "0000000000000000";
        rdman_options <= "0000000000000000";
        rdman_param0 <= "00000000000000000000000000000000";
        rdman_param1 <= "00000000000000000000000000000000";
        rdman_param2 <= "00000000000000000000000000000000";
        rdman_param3 <= "00000000000000000000000000000000";
        rdman_param4 <= "00000000000000000000000000000000";
        rdman_param5 <= "00000000000000000000000000000000";
        rdman_param6 <= "00000000000000000000000000000000";
        rdman_param7 <= "00000000000000000000000000000000";
        rdman_param8 <= "00000000000000000000000000000000";
        rdman_param9 <= "00000000000000000000000000000000";
        rdman_data_addrcntr <= "000000000000";
        rdman_metadata_addrcntr <= "000000000000";
        rdman_param_addrcntr <= "000000";
        rdman_divisor <= "00000";
        rdman_num_samp <= "000000000000";
        rdman_threshold <= "0000000000000000";
        rdman_lock_duration <= "0000000000000000";
        rdman_precontrol_duration <= "0000000000000000";
        rdman_timeout_duration <= "00000000000000000000000000000000";
        rdman_tuner_at_ringdown <= "0000000000000000";
        rdman_metadata_addr_at_ringdown <= "0000000000000000";
        rdman_abort <= '0';
        rdman_acq_done_irq <= '0';
        rdman_bank <= '0';
        rdman_expiry_time <= "00000000000000000000000000000000";
        rdman_init_flag <= '1';
        rdman_lapped <= '0';
        rdman_metadataAcqState <= IDLE;
        rdman_metadata_acq <= '0';
        rdman_paramState <= IDLE;
        rdman_param_acq <= '0';
        rdman_rd_adc_clk <= '0';
        rdman_rd_divider <= "00000";
        rdman_rd_irq <= '0';
        rdman_rd_trig <= '1';
        rdman_seqState <= IDLE;
        rdman_timeout <= '0';
        rdman_us_since_start <= "00000000000000000000000000000000";
        rdman_us_timer_enable <= '0';
        acc_en <= '0';
        laser_locked <= '0';
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 51) then
                if to_boolean(dsp_wr) then
                    rdman_control <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_control, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 52) then
                dsp_data_in_rdman <= resize(rdman_status, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 53) then
                if to_boolean(dsp_wr) then
                    rdman_options <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_options, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 54) then
                if to_boolean(dsp_wr) then
                    rdman_param0 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param0;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 55) then
                if to_boolean(dsp_wr) then
                    rdman_param1 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param1;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 56) then
                if to_boolean(dsp_wr) then
                    rdman_param2 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param2;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 57) then
                if to_boolean(dsp_wr) then
                    rdman_param3 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param3;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 58) then
                if to_boolean(dsp_wr) then
                    rdman_param4 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param4;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 59) then
                if to_boolean(dsp_wr) then
                    rdman_param5 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param5;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 60) then
                if to_boolean(dsp_wr) then
                    rdman_param6 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param6;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 61) then
                if to_boolean(dsp_wr) then
                    rdman_param7 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param7;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 62) then
                if to_boolean(dsp_wr) then
                    rdman_param8 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param8;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 63) then
                if to_boolean(dsp_wr) then
                    rdman_param9 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param9;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 64) then
                dsp_data_in_rdman <= resize(rdman_data_addrcntr, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 65) then
                dsp_data_in_rdman <= resize(rdman_metadata_addrcntr, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 66) then
                dsp_data_in_rdman <= resize(rdman_param_addrcntr, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 67) then
                if to_boolean(dsp_wr) then
                    rdman_divisor <= resize(dsp_data_out, 5);
                end if;
                dsp_data_in_rdman <= resize(rdman_divisor, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 68) then
                if to_boolean(dsp_wr) then
                    rdman_num_samp <= resize(dsp_data_out, 12);
                end if;
                dsp_data_in_rdman <= resize(rdman_num_samp, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 69) then
                if to_boolean(dsp_wr) then
                    rdman_threshold <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_threshold, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 70) then
                if to_boolean(dsp_wr) then
                    rdman_lock_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_lock_duration, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 71) then
                if to_boolean(dsp_wr) then
                    rdman_precontrol_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_precontrol_duration, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 72) then
                if to_boolean(dsp_wr) then
                    rdman_timeout_duration <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_timeout_duration;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 73) then
                dsp_data_in_rdman <= resize(rdman_tuner_at_ringdown, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 74) then
                dsp_data_in_rdman <= resize(rdman_metadata_addr_at_ringdown, 32);
            else
                dsp_data_in_rdman <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_rdman <= "00000000000000000000000000000000";
        end if;
        if to_boolean(rdman_control(0)) then
            if (not to_boolean(rdman_control(1))) then
                rdman_control(0) <= '0';
            end if;
            data_we <= '0';
            rdman_rd_adc_clk <= to_std_logic(not to_boolean(rdman_rd_adc_clk));
            if to_boolean(rdman_status(10)) then
                rdman_control(2) <= '0';
            end if;
            case rdman_seqState is
                when IDLE =>
                    rdman_status(10) <= '0';
                    rdman_us_since_start <= "00000000000000000000000000000000";
                    rdman_metadata_acq <= '0';
                    rdman_param_acq <= '0';
                    rdman_us_timer_enable <= '0';
                    acc_en <= '0';
                    laser_locked <= '0';
                    if to_boolean(rdman_control(2)) then
                        rdman_seqState <= START_INJECT;
                        rdman_status(10) <= '1';
                    end if;
                when START_INJECT =>
                    rdman_abort <= '0';
                    rdman_timeout <= '0';
                    rdman_rd_trig <= '0';
                    rdman_metadata_acq <= '1';
                    rdman_us_timer_enable <= '1';
                    acc_en <= '0';
                    rdman_expiry_time <= resize(rdman_precontrol_duration, 32);
                    rdman_seqState <= WAIT_FOR_PRECONTROL;
                when WAIT_FOR_PRECONTROL =>
                    if (rdman_us_since_start >= rdman_expiry_time) then
                        if to_boolean(rdman_options(0)) then
                            acc_en <= '1';
                            rdman_seqState <= WAIT_FOR_LOCK;
                        else
                            rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                        end if;
                    end if;
                when WAIT_FOR_LOCK =>
                    acc_en <= '1';
                    if to_boolean(laser_freq_ok) then
                        if (rdman_us_since_start >= rdman_expiry_time) then
                            laser_locked <= '1';
                            rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                        end if;
                    else
                        rdman_expiry_time <= (rdman_us_since_start + rdman_lock_duration);
                    end if;
                when WAIT_FOR_GATING_CONDITIONS =>
                    if (not to_boolean(rdman_freq_gating_conditions)) then
                        laser_locked <= '0';
                        rdman_seqState <= WAIT_FOR_LOCK;
                    elsif to_boolean(rdman_tuner_gating_conditions) then
                        rdman_seqState <= CHECK_BELOW_THRESHOLD;
                    end if;
                when CHECK_BELOW_THRESHOLD =>
                    if (rdman_rd_data < rdman_threshold) then
                        rdman_seqState <= WAIT_FOR_THRESHOLD;
                    else
                        rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                    end if;
                when WAIT_FOR_THRESHOLD =>
                    if (not to_boolean(rdman_freq_gating_conditions)) then
                        laser_locked <= '0';
                        rdman_seqState <= WAIT_FOR_LOCK;
                    elsif (not to_boolean(rdman_tuner_gating_conditions)) then
                        rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                    elsif (rdman_rd_data >= rdman_threshold) then
                        rdman_seqState <= IN_RINGDOWN;
                        rdman_rd_trig <= '1';
                        rdman_metadata_acq <= '0';
                        rdman_data_addrcntr <= "000000000000";
                        rdman_rd_divider <= "00000";
                        rdman_metadata_addr_at_ringdown <= resize(rdman_metadata_addrcntr, 16);
                        rdman_metadata_addr_at_ringdown((16 - 1)) <= rdman_lapped;
                        rdman_tuner_at_ringdown <= tuner_value;
                        rdman_rd_irq <= '1';
                        rdman_init_flag <= '1';
                    end if;
                when IN_RINGDOWN =>
                    rdman_param_acq <= '1';
                    if to_boolean(rdman_rd_adc_clk) then
                        if ((rdman_data_addrcntr = rdman_num_samp) and (not to_boolean(rdman_init_flag))) then
                            rdman_seqState <= CHECK_PARAMS_DONE;
                            if to_boolean(rdman_bank) then
                                rdman_status(5) <= '1';
                            else
                                rdman_status(4) <= '1';
                            end if;
                        elsif (rdman_rd_divider = rdman_divisor) then
                            rdman_rd_divider <= "00000";
                            rdman_data_addrcntr <= ((rdman_data_addrcntr + 1) mod 4096);
                            rdman_init_flag <= '0';
                            data_we <= '1';
                        else
                            rdman_rd_divider <= ((rdman_rd_divider + 1) mod 32);
                        end if;
                    end if;
                when CHECK_PARAMS_DONE =>
                    if (rdman_paramState = DONE) then
                        rdman_us_timer_enable <= '0';
                        rdman_seqState <= ACQ_DONE;
                        rdman_metadataAcqState <= IDLE;
                        rdman_paramState <= IDLE;
                    end if;
                when ACQ_DONE =>
                    rdman_bank <= to_std_logic(not to_boolean(rdman_bank));
                    rdman_acq_done_irq <= '1';
                    rdman_seqState <= IDLE;
            end case;
            case rdman_paramState is
                when IDLE =>
                    param_we <= '0';
                    if to_boolean(rdman_param_acq) then
                        rdman_param_addrcntr <= "000000";
                        rdman_paramState <= STORING;
                    end if;
                when STORING =>
                    param_we <= '1';
                    rdman_param_addrcntr <= (rdman_param_addrcntr + 1);
                    if (rdman_param_addrcntr(4-1 downto 0) = 0) then
                        wr_param <= rdman_param0;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 1) then
                        wr_param <= rdman_param1;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 2) then
                        wr_param <= rdman_param2;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 3) then
                        wr_param <= rdman_param3;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 4) then
                        wr_param <= rdman_param4;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 5) then
                        wr_param <= rdman_param5;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 6) then
                        wr_param <= rdman_param6;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 7) then
                        wr_param <= rdman_param7;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 8) then
                        wr_param <= rdman_param8;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 9) then
                        wr_param <= rdman_param9;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 10) then
                        wr_param <= resize(rdman_tuner_at_ringdown, 32);
                    else
                        wr_param <= resize(rdman_metadata_addr_at_ringdown, 32);
                        rdman_paramState <= DONE;
                    end if;
                when DONE =>
                    rdman_param_acq <= '0';
                    param_we <= '0';
            end case;
            case rdman_metadataAcqState is
                when IDLE =>
                    meta_we <= '0';
                    rdman_metadata_addrcntr <= "000000000000";
                    rdman_metadataAcqState <= AWAIT_STROBE;
                when AWAIT_STROBE =>
                    if (to_boolean(rdman_metadata_acq) and to_boolean(metadata_strobe)) then
                        rdman_metadataAcqState <= ACQUIRING;
                    end if;
                when ACQUIRING =>
                    if (not to_boolean(rdman_metadata_acq)) then
                        rdman_metadataAcqState <= DONE;
                    else
                        meta_we <= '1';
                        if (signed(resize(rdman_metadata_addrcntr, 13)) < ((8 * 512) - 1)) then
                            rdman_metadata_addrcntr <= (rdman_metadata_addrcntr + 1);
                        else
                            rdman_metadata_addrcntr <= to_unsigned(4 * 512, 12);
                            rdman_lapped <= '1';
                        end if;
                        if (rdman_metadata_addrcntr(3-1 downto 0) = 0) then
                            wr_meta <= ratio1;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 1) then
                            wr_meta <= ratio2;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 2) then
                            wr_meta <= pzt;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 3) then
                            wr_meta <= laser_tuning_offset;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 4) then
                            wr_meta <= laser_fine_current;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 5) then
                            wr_meta <= meta5;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 6) then
                            wr_meta <= meta6;
                        else
                            wr_meta <= meta7;
                            rdman_metadataAcqState <= DONE;
                        end if;
                    end if;
                when DONE =>
                    meta_we <= '0';
                    if (not to_boolean(metadata_strobe)) then
                        rdman_metadataAcqState <= AWAIT_STROBE;
                    end if;
            end case;
            if (to_boolean(rdman_us_timer_enable) and to_boolean(pulse_1M)) then
                rdman_us_since_start <= (rdman_us_since_start + 1);
                if (rdman_us_since_start >= rdman_timeout_duration) then
                    rdman_timeout <= '1';
                    rdman_metadata_acq <= '0';
                    rdman_param_acq <= '0';
                    rdman_us_timer_enable <= '0';
                    rdman_metadataAcqState <= IDLE;
                    rdman_paramState <= IDLE;
                    if (not to_boolean(rdman_rd_trig)) then
                        rdman_rd_trig <= '1';
                        rdman_rd_irq <= '1';
                    else
                        rdman_acq_done_irq <= '1';
                    end if;
                    rdman_seqState <= IDLE;
                end if;
            end if;
            if to_boolean(rdman_control(3)) then
                rdman_control(3) <= '0';
                rdman_rd_trig <= '1';
                rdman_abort <= '1';
                rdman_rd_irq <= '1';
                rdman_acq_done_irq <= '0';
                rdman_metadata_acq <= '0';
                rdman_param_acq <= '0';
                rdman_us_timer_enable <= '0';
                rdman_seqState <= IDLE;
                rdman_metadataAcqState <= IDLE;
                rdman_paramState <= IDLE;
            end if;
            if to_boolean(rdman_control(4)) then
                rdman_control(4) <= '0';
                rdman_rd_trig <= '1';
                rdman_abort <= '0';
                rdman_rd_irq <= '0';
                rdman_acq_done_irq <= '0';
                rdman_metadata_acq <= '0';
                rdman_param_acq <= '0';
                rdman_us_timer_enable <= '0';
                rdman_seqState <= IDLE;
                rdman_metadataAcqState <= IDLE;
                rdman_paramState <= IDLE;
            end if;
            if to_boolean(rdman_control(7)) then
                rdman_control(7) <= '0';
                rdman_rd_irq <= '0';
            end if;
            if to_boolean(rdman_control(8)) then
                rdman_control(8) <= '0';
                rdman_acq_done_irq <= '0';
            end if;
            if to_boolean(rdman_control(5)) then
                rdman_control(5) <= '0';
                rdman_status(4) <= '0';
            end if;
            if to_boolean(rdman_control(6)) then
                rdman_control(6) <= '0';
                rdman_status(5) <= '0';
            end if;
            data_addr <= rdman_data_addrcntr;
            meta_addr <= rdman_metadata_addrcntr;
            param_addr <= rdman_param_addrcntr;
        end if;
        rdman_status(2) <= rdman_acq_done_irq;
        rdman_status(3) <= rdman_bank;
        rdman_status(6) <= rdman_lapped;
        rdman_status(1) <= rdman_rd_irq;
        rdman_status(0) <= rdman_rd_trig;
        rdman_status(9) <= rdman_abort;
        rdman_status(8) <= rdman_timeout;
    end if;
end process MAIN_RDMAN_LOGIC;

MAIN_PZTVALVEDAC_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        pztValveDac_chanA_data <= "0000000000000000";
        pztValveDac_chanB_data <= "0000000000000000";
        pztValveDac_chanC_data <= "0000000000000000";
        pztValveDac_chanD_data <= "0000000000000000";
        pzt_valve_dac_ld <= '1';
    elsif rising_edge(clk0) then
        case pztValveDac_state is
            when IDLE =>
                if to_boolean(pulse_100k) then
                    pztValveDac_chanA_data <= chanA_data_in;
                    pztValveDac_chanB_data <= chanB_data_in;
                    pztValveDac_chanC_data <= pzt;
                    pztValveDac_chanD_data <= chanD_data_in;
                    pztValveDac_counter <= "0000000";
                    pzt_valve_dac_ld <= '0';
                    pztValveDac_state <= WAIT_0;
                end if;
            when WAIT_0 =>
                if (not to_boolean(clk_10M)) then
                    if (signed(resize(pztValveDac_counter, 8)) < (100 - 1)) then
                        if ((signed(resize(pztValveDac_counter, 8)) = (25 - 1)) or (signed(resize(pztValveDac_counter, 8)) = (50 - 1)) or (signed(resize(pztValveDac_counter, 8)) = (75 - 1))) then
                            pzt_valve_dac_ld <= '1';
                        end if;
                        pztValveDac_counter <= (pztValveDac_counter + 1);
                        pztValveDac_state <= WAIT_1;
                    else
                        pzt_valve_dac_ld <= '1';
                        pztValveDac_state <= IDLE;
                    end if;
                end if;
            when WAIT_1 =>
                if to_boolean(clk_10M) then
                    pzt_valve_dac_ld <= '0';
                    pztValveDac_state <= WAIT_0;
                end if;
            when others =>
                pztValveDac_state <= IDLE;
        end case;
    end if;
end process MAIN_PZTVALVEDAC_LOGIC;

MAIN_PZTVALVEDAC_COMB2: process (pztValveDac_chanD_data, pztValveDac_counter, pztValveDac_chanC_data, pztValveDac_chanB_data, pztValveDac_chanA_data) is
begin
    pzt_valve_dac_sdi <= '1';
    if ((1 <= pztValveDac_counter) and (pztValveDac_counter < 9)) then
        case ((9 - 1) - to_integer(pztValveDac_counter)) is
            when 0 => pzt_valve_dac_sdi <= '0';
            when 1 => pzt_valve_dac_sdi <= '0';
            when 2 => pzt_valve_dac_sdi <= '0';
            when 3 => pzt_valve_dac_sdi <= '0';
            when 4 => pzt_valve_dac_sdi <= '0';
            when 5 => pzt_valve_dac_sdi <= '0';
            when 6 => pzt_valve_dac_sdi <= '0';
            when others => pzt_valve_dac_sdi <= '0';
        end case;
    elsif ((9 <= pztValveDac_counter) and (pztValveDac_counter < 25)) then
        pzt_valve_dac_sdi <= pztValveDac_chanA_data(((25 - 1) - to_integer(pztValveDac_counter)));
    elsif ((26 <= pztValveDac_counter) and (pztValveDac_counter < 34)) then
        case ((34 - 1) - to_integer(pztValveDac_counter)) is
            when 0 => pzt_valve_dac_sdi <= '1';
            when 1 => pzt_valve_dac_sdi <= '0';
            when 2 => pzt_valve_dac_sdi <= '0';
            when 3 => pzt_valve_dac_sdi <= '0';
            when 4 => pzt_valve_dac_sdi <= '0';
            when 5 => pzt_valve_dac_sdi <= '0';
            when 6 => pzt_valve_dac_sdi <= '0';
            when others => pzt_valve_dac_sdi <= '0';
        end case;
    elsif ((34 <= pztValveDac_counter) and (pztValveDac_counter < 50)) then
        pzt_valve_dac_sdi <= pztValveDac_chanB_data(((50 - 1) - to_integer(pztValveDac_counter)));
    elsif ((51 <= pztValveDac_counter) and (pztValveDac_counter < 59)) then
        case ((59 - 1) - to_integer(pztValveDac_counter)) is
            when 0 => pzt_valve_dac_sdi <= '0';
            when 1 => pzt_valve_dac_sdi <= '1';
            when 2 => pzt_valve_dac_sdi <= '0';
            when 3 => pzt_valve_dac_sdi <= '0';
            when 4 => pzt_valve_dac_sdi <= '0';
            when 5 => pzt_valve_dac_sdi <= '0';
            when 6 => pzt_valve_dac_sdi <= '0';
            when others => pzt_valve_dac_sdi <= '0';
        end case;
    elsif ((59 <= pztValveDac_counter) and (pztValveDac_counter < 75)) then
        pzt_valve_dac_sdi <= pztValveDac_chanC_data(((75 - 1) - to_integer(pztValveDac_counter)));
    elsif ((76 <= pztValveDac_counter) and (pztValveDac_counter < 84)) then
        case ((84 - 1) - to_integer(pztValveDac_counter)) is
            when 0 => pzt_valve_dac_sdi <= '1';
            when 1 => pzt_valve_dac_sdi <= '1';
            when 2 => pzt_valve_dac_sdi <= '0';
            when 3 => pzt_valve_dac_sdi <= '0';
            when 4 => pzt_valve_dac_sdi <= '0';
            when 5 => pzt_valve_dac_sdi <= '1';
            when 6 => pzt_valve_dac_sdi <= '0';
            when others => pzt_valve_dac_sdi <= '0';
        end case;
    elsif ((84 <= pztValveDac_counter) and (pztValveDac_counter < 100)) then
        pzt_valve_dac_sdi <= pztValveDac_chanD_data(((100 - 1) - to_integer(pztValveDac_counter)));
    else
        pzt_valve_dac_sdi <= '0';
    end if;
end process MAIN_PZTVALVEDAC_COMB2;


pwm_laser4_out <= pwm_laser4_pwm;
pwm_laser4_inv_out <= (pwm_laser4_pwm xor pwm_laser4_cs(1));
pwm_laser4_temp <= (resize(pwm_laser4_dither_cntr, 9) + pwm_laser4_pulse_width(8-1 downto 0));

MAIN_PWM_LASER4_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        pwm_laser4_cs <= "0000000000000000";
        pwm_laser4_pulse_width <= "0000000000000000";
        pwm_laser4_main_cntr <= "00000000";
        pwm_laser4_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 13) then
                if to_boolean(dsp_wr) then
                    pwm_laser4_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser4 <= resize(pwm_laser4_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 14) then
                if to_boolean(dsp_wr) then
                    pwm_laser4_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser4 <= resize(pwm_laser4_pulse_width, 32);
            else
                dsp_data_in_pwm_laser4 <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_pwm_laser4 <= "00000000000000000000000000000000";
        end if;
        if to_boolean(pwm_laser4_cs(0)) then
            if (not to_boolean(pwm_laser4_cs(1))) then
                pwm_laser4_cs(0) <= '0';
            end if;
            pwm_laser4_pwm <= '0';
            if (pwm_laser4_main_cntr < pwm_laser4_pulse_width(16-1 downto (16 - 8))) then
                pwm_laser4_pwm <= '1';
            elsif (pwm_laser4_main_cntr = pwm_laser4_pulse_width(16-1 downto 8)) then
                if (pwm_laser4_temp >= 256) then
                    pwm_laser4_pwm <= '1';
                    pwm_laser4_cs(2) <= '1';
                    pwm_laser4_dither_cntr <= resize(pwm_laser4_temp - 256, 8);
                else
                    pwm_laser4_dither_cntr <= resize(pwm_laser4_temp, 8);
                end if;
            end if;
            pwm_laser4_main_cntr <= ((pwm_laser4_main_cntr + 1) mod 256);
        end if;
        pwm_laser4_cs(2) <= pwm_laser4_pwm;
    end if;
end process MAIN_PWM_LASER4_LOGIC;


pwm_laser3_out <= pwm_laser3_pwm;
pwm_laser3_inv_out <= (pwm_laser3_pwm xor pwm_laser3_cs(1));
pwm_laser3_temp <= (resize(pwm_laser3_dither_cntr, 9) + pwm_laser3_pulse_width(8-1 downto 0));

MAIN_PWM_LASER3_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        pwm_laser3_cs <= "0000000000000000";
        pwm_laser3_pulse_width <= "0000000000000000";
        pwm_laser3_main_cntr <= "00000000";
        pwm_laser3_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 11) then
                if to_boolean(dsp_wr) then
                    pwm_laser3_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser3 <= resize(pwm_laser3_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 12) then
                if to_boolean(dsp_wr) then
                    pwm_laser3_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser3 <= resize(pwm_laser3_pulse_width, 32);
            else
                dsp_data_in_pwm_laser3 <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_pwm_laser3 <= "00000000000000000000000000000000";
        end if;
        if to_boolean(pwm_laser3_cs(0)) then
            if (not to_boolean(pwm_laser3_cs(1))) then
                pwm_laser3_cs(0) <= '0';
            end if;
            pwm_laser3_pwm <= '0';
            if (pwm_laser3_main_cntr < pwm_laser3_pulse_width(16-1 downto (16 - 8))) then
                pwm_laser3_pwm <= '1';
            elsif (pwm_laser3_main_cntr = pwm_laser3_pulse_width(16-1 downto 8)) then
                if (pwm_laser3_temp >= 256) then
                    pwm_laser3_pwm <= '1';
                    pwm_laser3_cs(2) <= '1';
                    pwm_laser3_dither_cntr <= resize(pwm_laser3_temp - 256, 8);
                else
                    pwm_laser3_dither_cntr <= resize(pwm_laser3_temp, 8);
                end if;
            end if;
            pwm_laser3_main_cntr <= ((pwm_laser3_main_cntr + 1) mod 256);
        end if;
        pwm_laser3_cs(2) <= pwm_laser3_pwm;
    end if;
end process MAIN_PWM_LASER3_LOGIC;


pwm_laser1_out <= pwm_laser1_pwm;
pwm_laser1_inv_out <= (pwm_laser1_pwm xor pwm_laser1_cs(1));
pwm_laser1_temp <= (resize(pwm_laser1_dither_cntr, 9) + pwm_laser1_pulse_width(8-1 downto 0));

MAIN_PWM_LASER1_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        pwm_laser1_cs <= "0000000000000000";
        pwm_laser1_pulse_width <= "0000000000000000";
        pwm_laser1_main_cntr <= "00000000";
        pwm_laser1_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 7) then
                if to_boolean(dsp_wr) then
                    pwm_laser1_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser1 <= resize(pwm_laser1_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 8) then
                if to_boolean(dsp_wr) then
                    pwm_laser1_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser1 <= resize(pwm_laser1_pulse_width, 32);
            else
                dsp_data_in_pwm_laser1 <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_pwm_laser1 <= "00000000000000000000000000000000";
        end if;
        if to_boolean(pwm_laser1_cs(0)) then
            if (not to_boolean(pwm_laser1_cs(1))) then
                pwm_laser1_cs(0) <= '0';
            end if;
            pwm_laser1_pwm <= '0';
            if (pwm_laser1_main_cntr < pwm_laser1_pulse_width(16-1 downto (16 - 8))) then
                pwm_laser1_pwm <= '1';
            elsif (pwm_laser1_main_cntr = pwm_laser1_pulse_width(16-1 downto 8)) then
                if (pwm_laser1_temp >= 256) then
                    pwm_laser1_pwm <= '1';
                    pwm_laser1_cs(2) <= '1';
                    pwm_laser1_dither_cntr <= resize(pwm_laser1_temp - 256, 8);
                else
                    pwm_laser1_dither_cntr <= resize(pwm_laser1_temp, 8);
                end if;
            end if;
            pwm_laser1_main_cntr <= ((pwm_laser1_main_cntr + 1) mod 256);
        end if;
        pwm_laser1_cs(2) <= pwm_laser1_pwm;
    end if;
end process MAIN_PWM_LASER1_LOGIC;


pwm_laser2_out <= pwm_laser2_pwm;
pwm_laser2_inv_out <= (pwm_laser2_pwm xor pwm_laser2_cs(1));
pwm_laser2_temp <= (resize(pwm_laser2_dither_cntr, 9) + pwm_laser2_pulse_width(8-1 downto 0));

MAIN_PWM_LASER2_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        pwm_laser2_cs <= "0000000000000000";
        pwm_laser2_pulse_width <= "0000000000000000";
        pwm_laser2_main_cntr <= "00000000";
        pwm_laser2_dither_cntr <= "00000000";
    elsif rising_edge(clk0) then
        if (dsp_addr((20 - 1)) = '1') then
            if False then
                null;
            elsif (dsp_addr((20 - 1)-1 downto 0) = 9) then
                if to_boolean(dsp_wr) then
                    pwm_laser2_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser2 <= resize(pwm_laser2_cs, 32);
            elsif (dsp_addr((20 - 1)-1 downto 0) = 10) then
                if to_boolean(dsp_wr) then
                    pwm_laser2_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser2 <= resize(pwm_laser2_pulse_width, 32);
            else
                dsp_data_in_pwm_laser2 <= "00000000000000000000000000000000";
            end if;
        else
            dsp_data_in_pwm_laser2 <= "00000000000000000000000000000000";
        end if;
        if to_boolean(pwm_laser2_cs(0)) then
            if (not to_boolean(pwm_laser2_cs(1))) then
                pwm_laser2_cs(0) <= '0';
            end if;
            pwm_laser2_pwm <= '0';
            if (pwm_laser2_main_cntr < pwm_laser2_pulse_width(16-1 downto (16 - 8))) then
                pwm_laser2_pwm <= '1';
            elsif (pwm_laser2_main_cntr = pwm_laser2_pulse_width(16-1 downto 8)) then
                if (pwm_laser2_temp >= 256) then
                    pwm_laser2_pwm <= '1';
                    pwm_laser2_cs(2) <= '1';
                    pwm_laser2_dither_cntr <= resize(pwm_laser2_temp - 256, 8);
                else
                    pwm_laser2_dither_cntr <= resize(pwm_laser2_temp, 8);
                end if;
            end if;
            pwm_laser2_main_cntr <= ((pwm_laser2_main_cntr + 1) mod 256);
        end if;
        pwm_laser2_cs(2) <= pwm_laser2_pwm;
    end if;
end process MAIN_PWM_LASER2_LOGIC;

MAIN_CLKGEN_LOGIC: process (clk0, reset) is
begin
    if to_boolean(reset) then
        clk_10M <= '0';
        clkgen_div5 <= "000";
        clkgen_div25 <= "00000";
        clkgen_ff1 <= '0';
        clkgen_ff2 <= '0';
    elsif rising_edge(clk0) then
        pulse_100k <= '0';
        pulse_1M <= '0';
        if (clkgen_div5 = 4) then
            clkgen_div5 <= "000";
            clkgen_ff1 <= to_std_logic(not to_boolean(clkgen_ff1));
            if to_boolean(clkgen_ff1) then
                if (clkgen_div1M = 4) then
                    clkgen_div1M <= "000";
                    pulse_1M <= '1';
                else
                    clkgen_div1M <= (clkgen_div1M + 1);
                end if;
                clkgen_ff2 <= to_std_logic(not to_boolean(clkgen_ff2));
                if to_boolean(clkgen_ff2) then
                    if (clkgen_div25 = 24) then
                        clkgen_div25 <= "00000";
                        pulse_100k <= '1';
                    else
                        clkgen_div25 <= (clkgen_div25 + 1);
                    end if;
                end if;
            end if;
        else
            clkgen_div5 <= (clkgen_div5 + 1);
        end if;
        clk_10M <= to_std_logic((clkgen_div5 = 2) or (clkgen_div5 = 3));
    end if;
end process MAIN_CLKGEN_LOGIC;


clk_5M <= clkgen_ff1;
clk_2M5 <= clkgen_ff2;

end architecture MyHDL;
