from Builder import Builder, check_config_hashes, run_command
import json
import os
from pybuilder.core import task
from pybuilder.errors import BuildFailedException
import shutil
import textwrap
import time

ISCC_WIN7 = 'c:/program files (x86)/Inno Setup 5/ISCC.exe'
INSTALLER_SCRIPTS_DIR = ('src', 'main', 'python', 'Tools', 'Release', 'InstallerScriptsWin7')
RELEASE_VERSION_FILE = ('src', 'main', 'python', 'Host', 'Common', 'release_version.py')
INTERNAL_VERSION_FILE = ('src', 'main', 'python', 'Host', 'build_version.py')

class BuildMobile(Builder):
    def __init__(self, project, logger):
        super(BuildMobile, self).__init__(project, logger)
        logger.info("Instantiating BuildMobile")

    def initialize(self, product):
        project = self.project
        logger = self.logger
        assert product.lower() == "mobile"
        version_file = os.path.join("versions","%s_version.json" % product)
        self.handle_version(version_file)

        #  Default type is FEDS
        types = project.get_property("types", "FEDS")
        types_file = os.path.join("versions","%s_types.json" % product)
        with open(types_file,"r") as inp:
            config_info = json.load(inp)
        self.handle_types(types, config_info['buildTypes'])
        project.set_property('config_info', config_info['buildTypes'])
        # check_configs runs check_config_hashes before build is allowed to begin
        check_configs = project.get_property("check_configs", "False")
        check_configs = check_configs.lower() in ("yes", "y", "true", "t", "1")
        project.set_property("check_configs", check_configs)
        if check_configs:
            check_config_hashes(project, logger)
        types_to_build = project.get_property('types_to_build')
        logger.info("Installer types to build: %s" % ", ".join(types_to_build))
        self.log_selected_project_properties(['product', 'types', 'official', 'incr_version', 'set_version',
            'check_working_tree', 'check_configs', 'push', 'tag'])

    def handle_types(self, types, build_info):
        # Types is a comma-separated string of device types
        #  which may be preceeded by an "!" to indicate that those
        #  types are to be excluded.
        project = self.project
        logger = self.logger
        types = types.strip()
        negate = (types and types[0] == "!")
        types_list = (types[1:] if negate else types).split(',')
        types_list = [item.strip() for item in types_list]

        types_to_build = []
        for item in sorted(build_info.keys()):
            if negate:
                if item not in types_list:
                    types_to_build.append(item)
            else:
                if item in types_list:
                    types_to_build.append(item)
        project.set_property('types_to_build', types_to_build)

    def compile_sources(self):
        project = self.project
        logger = self.logger
        logger.info("Compiling source files")
        output_file_path = self.get_report_file_path("compile_sources")
        with open(output_file_path, "a") as output_file:
            stdout, return_code = run_command("doit compile_sources", True)
            output_file.write(stdout)
        if return_code != 0:
            raise BuildFailedException("Error while executing compile_sources")

    def publish(self):
        project = self.project
        logger = self.logger
        logger.info("Running py2exe in %s", project.expand_path("$dir_dist"))
        output_file_path = self.get_report_file_path("build_hostexe")
        with open(output_file_path, "a") as output_file:
            cmd = "doit dist_dir=%s build_hostexe" % project.expand_path("$dir_dist")
            stdout, return_code = run_command(cmd, True)
            output_file.write(stdout)
            if return_code != 0:
                raise BuildFailedException("Error while executing run_py2exe/build_hostexe")


    def _make_python_version_files(self):
        project = self.project
        official = project.get_property("official")
        product = project.get_property("product")
        contents = textwrap.dedent("""\
        # autogenerated by PyBuilder

        def versionString():
            return '%s'

        def versionNumString():
            return '%s'

        def buildType():
            # Empty string indicates official release
            return '%s'
        """)
        src_file = os.path.join("versions", "%s_version.json" % product)
        ver = {"git_hash":self.git_hash[:8]}

        target = os.path.join(*RELEASE_VERSION_FILE) if official else os.path.join(*INTERNAL_VERSION_FILE)
        with open(src_file,"r") as inp:
            ver.update(json.load(inp))
        with open(target,"w") as outp:
            outp.write(contents % (self._verAsString(product, ver),
                                   self._verAsNumString(ver), '' if official else 'INTERNAL'))

    def after_prepare(self):
        logger = self.logger
        self._remove_python_version_files()
        logger.info("Writing version files into source tree")
        self._make_python_version_files()

    def make_installers(self):
        project = self.project
        logger = self.logger
        raw_version = project.get_property('raw_version')
        config_info = project.get_property('config_info')
        sandbox_dir = project.expand_path('$dir_source_main_python')
        resource_dir = project.expand_path('$dir_target/Installers/%s-%s' % (project.name, raw_version))
        dist_dir = project.expand_path('$dir_dist')
        output_file_path = self.get_report_file_path("make_mobile_installers")
        for installer_type in project.get_property('types_to_build'):
            species = config_info[installer_type]['species']
            iss_filename = "setup_%s_%s.iss" % (installer_type, species)
            setup_file_path = os.path.join(*(INSTALLER_SCRIPTS_DIR + (iss_filename,)))
            logger.info("Building from %s" % setup_file_path)
            config_dir = os.path.join(os.getcwd(),'Config')
            #
            # Build a fully qualified path for the scripts folder, so ISCC can find
            # the include files (can't find them using a relative path here)
            # Notes:
            #
            # installerVersion: must be of the form x.x.x.x, for baking version number
            #                   into setup_xxx.exe metadata (for Explorer properties)
            # hostVersion:      e.g., mobile_win7-x.x.x-x, displayed in the installer UI
            # productVersion:   used for displaying Product version in Explorer properties
            current_year = time.strftime("%Y")
            logger.info('Project version: %s' % project.version)
            args = [ISCC_WIN7, "/dinstallerType=%s" % installer_type,
                    "/dhostVersion=%s" % raw_version,
                    "/dinstallerVersion=%s" % project.get_property('installer_version'),
                    "/dproductVersion=%s" % project.version,
                    "/dproductYear=%s" % current_year,
                    "/dsandboxDir=%s" % sandbox_dir,
                    "/dconfigDir=%s" % config_dir,
                    "/dcommonName=%s" % species,
                    "/ddistDir=%s" % dist_dir,
                    "/v9",
                    "/O%s" % resource_dir,
                    setup_file_path]
            with open(output_file_path, "a") as output_file:
                output_file.write("=== %s ===\n" % time.asctime())
                stdout, return_code = run_command(" ".join(args), True)
                output_file.write(stdout)
                if return_code != 0:
                    raise BuildFailedException("Error while making installer for %s" % installer_type)

def get_dir_hash(root):
    s = sha1()
    ini = None
    hash_ok = False
    for path, dirs, files in os.walk(root):
        dirs.sort()
        for f in files:
            fname = os.path.join(path, f)
            relname = fname[len(root)+1:]
            if relname.lower() == "version.ini":
                ini = ConfigObj(fname)
                continue
            s.update(relname)
            with open(fname,"rb") as f1:
                while True:
                    # Read file in as little chunks
                    buf = f1.read(4096)
                    if not buf : break
                    s.update(buf)
    result = s.hexdigest()
    revno = '0.0.0'
    if ini:
        if 'Version' in ini and 'dir_hash' in ini['Version']:
            hash_ok =  (ini['Version']['dir_hash'] == result)
            revno = ini['Version'].get('revno', '0.0.0')
    return result, hash_ok, revno
