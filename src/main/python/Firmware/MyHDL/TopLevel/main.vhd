-- File: main.vhd
-- Generated by MyHDL 0.9.0
-- Date: Mon Mar 13 09:38:36 2017


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_090.all;

entity main is
    port (
        clk0: in std_logic;
        clk180: in std_logic;
        clk3f: in std_logic;
        clk3f180: in std_logic;
        clk_locked: in std_logic;
        reset: in std_logic;
        intronix: out unsigned(33 downto 0);
        fpga_led: out unsigned(3 downto 0);
        dsp_emif_we: in std_logic;
        dsp_emif_re: in std_logic;
        dsp_emif_oe: in std_logic;
        dsp_emif_ardy: out std_logic;
        dsp_emif_ea: in unsigned(19 downto 0);
        dsp_emif_din: out unsigned(31 downto 0);
        dsp_emif_dout: in unsigned(31 downto 0);
        dsp_emif_ddir: out std_logic;
        dsp_emif_be: in unsigned(3 downto 0);
        dsp_emif_ce: in unsigned(3 downto 0);
        dsp_eclk: in std_logic;
        lsr1_0: out std_logic;
        lsr1_1: out std_logic;
        lsr2_0: out std_logic;
        lsr2_1: out std_logic;
        lsr3_0: out std_logic;
        lsr3_1: out std_logic;
        lsr4_0: out std_logic;
        lsr4_1: out std_logic;
        lc1: in std_logic;
        lc2: in std_logic;
        lc3: in std_logic;
        lc4: in std_logic;
        lsr1_sck: out std_logic;
        lsr1_ss: out std_logic;
        lsr1_rd: out std_logic;
        lsr1_mosi: out std_logic;
        lsr1_disable: out std_logic;
        lsr2_sck: out std_logic;
        lsr2_ss: out std_logic;
        lsr2_rd: out std_logic;
        lsr2_mosi: out std_logic;
        lsr2_disable: out std_logic;
        lsr3_sck: out std_logic;
        lsr3_ss: out std_logic;
        lsr3_rd: out std_logic;
        lsr3_mosi: out std_logic;
        lsr3_disable: out std_logic;
        lsr4_sck: out std_logic;
        lsr4_ss: out std_logic;
        lsr4_rd: out std_logic;
        lsr4_mosi: out std_logic;
        lsr4_disable: out std_logic;
        sw1: out std_logic;
        sw2: out std_logic;
        sw3: out std_logic;
        sw4: out std_logic;
        i2c_rst0: out std_logic;
        i2c_rst1: out std_logic;
        i2c_scl0: in std_logic;
        i2c_sda0: in std_logic;
        i2c_scl1: in std_logic;
        i2c_sda1: in std_logic;
        fp_lcd: out unsigned(7 downto 0);
        fp_led: out unsigned(3 downto 0);
        fp_rs_n: in std_logic;
        rd_adc: in unsigned(15 downto 0);
        rd_adc_clk: out std_logic;
        rd_adc_oe: out std_logic;
        monitor: out std_logic;
        dsp_ext_int4: out std_logic;
        dsp_ext_int5: out std_logic;
        dsp_ext_int6: out std_logic;
        dsp_ext_int7: out std_logic;
        usb_internal_connected: in std_logic;
        usb_rear_connected: in std_logic;
        fpga_program_enable: out std_logic;
        cyp_reset: out std_logic;
        pzt_valve_dac_ld: out std_logic;
        pzt_valve_dac_sck: out std_logic;
        pzt_valve_dac_sdi: out std_logic;
        inlet_valve_pwm: out std_logic;
        outlet_valve_pwm: out std_logic;
        inlet_valve_comparator: in std_logic;
        outlet_valve_comparator: in std_logic;
        heater_pwm: out std_logic;
        hot_box_pwm: out std_logic;
        hot_box_tec_overload: in std_logic;
        warm_box_pwm: out std_logic;
        warm_box_tec_overload: in std_logic;
        wmm_refl1: in std_logic;
        wmm_refl2: in std_logic;
        wmm_tran1: in std_logic;
        wmm_tran2: in std_logic;
        wmm_busy1: in std_logic;
        wmm_busy2: in std_logic;
        wmm_rd: out std_logic;
        wmm_convst: out std_logic;
        wmm_clk: out std_logic;
        dout_man: out std_logic;
        dout: out unsigned(39 downto 0);
        din: in unsigned(23 downto 0);
        aux_din: out unsigned(3 downto 0);
        aux_dout: in unsigned(3 downto 0)
    );
end entity main;


architecture MyHDL of main is


constant rdman_param8_addr: integer := 81;
constant OVERLOAD_WarmBoxTecBit: integer := 0;
constant inject_laser2_fine_current_range_addr: integer := 117;
constant RDMAN_STATUS_BANK_B: integer := 3;
constant lasercurrentgenerator_first_breakpoint_addr: integer := 157;
constant INJECT_CONTROL_LASER_CURRENT_ENABLE_W: integer := 4;
constant RDMAN_STATUS_BUSY_B: integer := 10;
constant laserlocker_wm_prop_gain_addr: integer := 66;
constant RDMAN_CONTROL_RESET_RDMAN_B: integer := 4;
constant RDMAN_STATUS_RD_IRQ_B: integer := 1;
constant inject_laser4_extra_coarse_scale_addr: integer := 123;
constant lasercurrentgenerator_upper_window_addr: integer := 162;
constant wlmsim_eta2_offset_addr: integer := 139;
constant kernel_din_addr: integer := 11;
constant rdsim_filling_rate_addr: integer := 37;
constant rdman_param6_addr: integer := 79;
constant TWGen_window_low_addr: integer := 103;
constant laserlocker_eta2_dark_addr: integer := 50;
constant rdman_param5_addr: integer := 78;
constant KERNEL_CONFIG_AUX_PZT_B: integer := 0;
constant rdman_control_addr: integer := 70;
constant INJECT_CONTROL_LASER_SELECT_W: integer := 2;
constant laserlocker_ref1_offset_addr: integer := 53;
constant inject_laser1_coarse_current_addr: integer := 108;
constant MAX_WIDTH: integer := 64535;
constant CHANB_DATA_START: integer := 34;
constant OVERLOAD_HotBoxTecBit: integer := 1;
constant lasercurrentgenerator_second_offset_addr: integer := 156;
constant inject_laser2_fine_current_addr: integer := 113;
constant RDMAN_OPTIONS_SCOPE_SLOPE_B: integer := 6;
constant INJECT_CONTROL_LASER_SELECT_B: integer := 1;
constant RDSIM_EXTRA: integer := 4;
constant CHANA_DATA_START: integer := 9;
constant kernel_overload_addr: integer := 8;
constant rdman_divisor_addr: integer := 86;
constant kernel_status_led_addr: integer := 12;
constant rdman_param_addrcntr_addr: integer := 85;
constant RDMAN_CONTROL_START_RD_B: integer := 2;
constant LASERLOCKER_CS_CONT_B: integer := 1;
constant KERNEL_CONTROL_OVERLOAD_RESET_B: integer := 1;
constant INJECT_CONTROL_MANUAL_LASER_ENABLE_B: integer := 7;
constant HIGH: integer := 1;
constant TWGen_sweep_low_addr: integer := 101;
constant EMIF_DATA_WIDTH: integer := 2**5;
constant laserlocker_wm_deriv_gain_addr: integer := 67;
constant INJECT_CONTROL_MANUAL_LASER_ENABLE_W: integer := 4;
constant laserlocker_lock_error_addr: integer := 2**6-1;
constant TWGen_sweep_high_addr: integer := 102;
constant RDMEM_RESERVED_BANK_ADDR_WIDTH: integer := 12;
constant KERNEL_CONTROL_DOUT_MAN_B: integer := 3;
constant RDMEM_DATA_WIDTH: integer := 18;
constant rmask: integer := 2**14-1;
constant dynamicpwm_slope_addr: integer := 150;
constant LASERLOCKER_OPTIONS_DIRECT_TUNE_B: integer := 1;
constant TWGen_pzt_offset_addr: integer := 105;
constant inject_laser2_extra_offset_addr: integer := 129;
constant lasercurrentgenerator_slow_slope_addr: integer := 153;
constant KERNEL_CONTROL_I2C_RESET_B: integer := 2;
constant MULT_LATENCY: integer := 2;
constant rdman_options_addr: integer := 72;
constant inject_laser1_extra_offset_addr: integer := 2**7;
constant wlmsim_wfac_addr: integer := 135;
constant inject_control_addr: integer := 106;
constant RDMAN_OPTIONS_SCOPE_MODE_B: integer := 5;
constant lasercurrentgenerator_period_counter_limit_addr: integer := 160;
constant FPGA_REG_MAXVAL: integer := 2**16;
constant rdman_param9_addr: integer := 82;
constant inject_laser2_extra_coarse_scale_addr: integer := 121;
constant LASERLOCKER_CS_RUN_B: integer := 0;
constant inject_laser3_fine_current_addr: integer := 114;
constant kernel_intronix_clksel_addr: integer := 4;
constant laserlocker_cs_addr: integer := 42;
constant laserlocker_tuning_offset_addr: integer := 62;
constant laserlocker_ref2_dark_addr: integer := 51;
constant INJECT_CONTROL2_EXTRA_MODE_B: integer := 2;
constant CHANB_DATA_END: integer := 50;
constant M4: integer := 2**14;
constant inject_laser3_fine_current_range_addr: integer := 118;
constant TWGEN_CS_RUN_B: integer := 0;
constant mod_main: integer := 2**8;
constant rdman_param3_addr: integer := 76;
constant M2: integer := 2**15;
constant MIN_WIDTH: integer := 1000;
constant lasercurrentgenerator_control_status_addr: integer := 152;
constant KERNEL_FAN_FAN1_B: integer := 0;
constant CHANA_CONTROL_END: integer := 9;
constant ACCUMULATOR_MODULO: integer := 2**24;
constant laserlocker_eta2_offset_addr: integer := 54;
constant dynamicpwm_low_addr: integer := 149;
constant LASERLOCKER_CS_TUNING_OFFSET_SEL_B: integer := 6;
constant scale: integer := 19898;
constant laserlocker_ratio2_addr: integer := 57;
constant inject_laser1_fine_current_addr: integer := 112;
constant OPTICAL_SWITCH_WIDTH: integer := 100;
constant TWGEN_CS_CONT_B: integer := 1;
constant FPGA_REG_MASK: integer := 1;
constant INJECT_CONTROL_LASER_CURRENT_ENABLE_B: integer := 3;
constant RDMAN_CONTROL_ACQ_DONE_ACK_B: integer := 8;
constant INJECT_CONTROL2_EXTINGUISH_DESELECTED_B: integer := 1;
constant RDSIM_OPTIONS_INPUT_SEL_B: integer := 0;
constant CHANB_CONTROL_END: integer := 34;
constant kernel_intronix_3_addr: integer := 7;
constant dynamicpwm_delta_addr: integer := 147;
constant PWM_CS_CONT_B: integer := 1;
constant scaler_scale1_addr: integer := 151;
constant kernel_intronix_2_addr: integer := 6;
constant KERNEL_FAN_FAN2_B: integer := 1;
constant kernel_dout_lo_addr: integer := 10;
constant RDMAN_CONTROL_CONT_B: integer := 1;
constant CHAND_DATA_END: integer := 25;
constant rdman_data_addrcntr_addr: integer := 83;
constant wlmsim_ref1_offset_addr: integer := 138;
constant wlmsim_eta1_offset_addr: integer := 137;
constant lasercurrentgenerator_lower_window_addr: integer := 161;
constant TWGen_slope_down_addr: integer := 99;
constant kernel_magic_code_addr: integer := 0;
constant laserlocker_ratio2_center_addr: integer := 60;
constant W: integer := 2**4;
constant rdman_param7_addr: integer := 80;
constant mod_dither: integer := 2**8;
constant KERNEL_CONFIG_ENGINE1_TEC_B: integer := 1;
constant INJECT_CONTROL2_EXTRA_ENABLE_B: integer := 3;
constant wlmsim_ref2_offset_addr: integer := 140;
constant inject_laser2_extra_fine_scale_addr: integer := 125;
constant laserlocker_ratio2_multiplier_addr: integer := 61;
constant rdsim_options_addr: integer := 34;
constant kernel_diag_1_addr: integer := 2;
constant ADC_LAST_CYCLE: integer := 19;
constant pwm_pulse_width_addr: integer := 29;
constant DYNAMICPWM_CS_RUN_B: integer := 0;
constant lasercurrentgenerator_sequence_id_addr: integer := 163;
constant RDMAN_CONTROL_RD_IRQ_ACK_B: integer := 7;
constant LASER_CURRENT_GEN_ACC_WIDTH: integer := 24;
constant laserlocker_fine_current_addr: integer := 68;
constant DYNAMICPWM_CS_CONT_B: integer := 1;
constant CHANA_CONTROL_START: integer := 1;
constant rdman_param4_addr: integer := 77;
constant RDMAN_CONTROL_BANK1_CLEAR_B: integer := 6;
constant RDMAN_CONTROL_BANK0_CLEAR_B: integer := 5;
constant PWM_CS_PWM_OUT_B: integer := 2;
constant inject_laser4_fine_current_range_addr: integer := 119;
constant inject_laser1_extra_coarse_scale_addr: integer := 120;
constant rdsim_decay_addr: integer := 38;
constant lasercurrentgenerator_transition_counter_limit_addr: integer := 159;
constant META_SIZE: integer := 2**9;
constant laserlocker_eta2_addr: integer := 46;
constant extra: integer := 8;
constant rdsim_accumulator_addr: integer := 41;
constant rdman_status_addr: integer := 71;
constant WLMSIM_OPTIONS_INPUT_SEL_B: integer := 0;
constant TWGEN_CS_RESET_B: integer := 2;
constant rdman_ringdown_data_addr: integer := 96;
constant LASERLOCKER_CS_SAMPLE_DARK_B: integer := 4;
constant CHANB_CONTROL_START: integer := 26;
constant LASERLOCKER_CS_LASER_FREQ_OK_B: integer := 7;
constant KERNEL_STATUS_LED_GREEN_B: integer := 1;
constant wlmsim_rfac_addr: integer := 134;
constant rdman_off_duration_addr: integer := 91;
constant RDMAN_CONTROL_ABORT_RD_B: integer := 3;
constant rdman_param1_addr: integer := 74;
constant rdman_metadata_addrcntr_addr: integer := 84;
constant inject_laser3_extra_offset_addr: integer := 130;
constant MASK: integer := 2**16-1;
constant inject_laser1_extra_fine_scale_addr: integer := 124;
constant kernel_fan_addr: integer := 13;
constant TWGen_acc_addr: integer := 97;
constant width: integer := 2**4;
constant CHAND_DATA_START: integer := 9;
constant INJECT_CONTROL_MANUAL_SOA_ENABLE_B: integer := 11;
constant inject_laser4_extra_offset_addr: integer := 131;
constant rdsim_pzt_center_addr: integer := 35;
constant laserlocker_wm_int_gain_addr: integer := 65;
constant DYNAMICPWM_CS_PWM_INVERT_B: integer := 5;
constant laserlocker_ratio1_multiplier_addr: integer := 59;
constant rdman_num_samp_addr: integer := 87;
constant RDMAN_STATUS_SHUTDOWN_B: integer := 0;
constant laserlocker_ratio1_center_addr: integer := 58;
constant RDMAN_STATUS_LAPPED_B: integer := 6;
constant laserlocker_ratio1_addr: integer := 56;
constant N: integer := 14;
constant kernel_dout_hi_addr: integer := 9;
constant dynamicpwm_high_addr: integer := 148;
constant RDMAN_OPTIONS_UP_SLOPE_ENABLE_B: integer := 1;
constant kernel_config_addr: integer := 3;
constant kernel_intronix_1_addr: integer := 5;
constant TWGEN_CS_TUNE_PZT_B: integer := 3;
constant LASERCURRENTGENERATOR_CONTROL_STATUS_MODE_B: integer := 0;
constant laserlocker_ref1_addr: integer := 45;
constant rdsim_decay_in_offset_addr: integer := 40;
constant INJECT_CONTROL_SOA_SHUTDOWN_ENABLE_B: integer := 13;
constant inject_laser1_fine_current_range_addr: integer := 116;
constant inject_control2_addr: integer := 107;
constant rdsim_decay_in_shift_addr: integer := 39;
constant wlmsim_z0_addr: integer := 133;
constant DYNAMICPWM_CS_PWM_ENABLE_B: integer := 2;
constant rdman_param0_addr: integer := 73;
constant DATA_BANK_ADDR_WIDTH: integer := 12;
constant RDMAN_STATUS_BANK1_IN_USE_B: integer := 5;
constant laserlocker_ref2_addr: integer := 47;
constant RDMAN_OPTIONS_LOCK_ENABLE_B: integer := 0;
constant RDMAN_OPTIONS_DOWN_SLOPE_ENABLE_B: integer := 2;
constant FPGA_REG_WIDTH: integer := 2**4;
constant laserlocker_wm_lock_window_addr: integer := 2**6;
constant TWGen_slope_up_addr: integer := 100;
constant ADC_CYCLE: integer := 21;
constant inject_laser3_coarse_current_addr: integer := 110;
constant main_width: integer := 8;
constant laserlocker_ref1_dark_addr: integer := 49;
constant LOW: integer := 0;
constant INJECT_CONTROL_SOA_PRESENT_B: integer := 2**4-1;
constant NSTAGES: integer := 28;
constant RDMEM_META_WIDTH: integer := 2**4;
constant TWGen_cs_addr: integer := 98;
constant PWM_CS_RUN_B: integer := 0;
constant pwm_cs_addr: integer := 28;
constant INJECT_CONTROL_OPTICAL_SWITCH_SELECT_B: integer := 14;
constant wlmsim_laser_temp_addr: integer := 136;
constant rdman_tuner_at_ringdown_addr: integer := 94;
constant PERIOD_COUNTER_WIDTH: integer := 9;
constant inject_laser4_fine_current_addr: integer := 115;
constant LASERCURRENTGENERATOR_CONTROL_STATUS_BANK_SELECT_B: integer := 3;
constant MAX_CYCLES: integer := 51;
constant CHAND_CONTROL_END: integer := 9;
constant RDMAN_CONTROL_RUN_B: integer := 0;
constant LASERLOCKER_CS_PRBS_B: integer := 2;
constant DIV_LATENCY: integer := 19;
constant inject_laser2_coarse_current_addr: integer := 109;
constant RDMAN_OPTIONS_SIM_ACTUAL_B: integer := 4;
constant ADC_DATA_WIDTH: integer := 2**4;
constant kernel_control_addr: integer := 1;
constant control_init: integer := 4;
constant laserlocker_ref2_offset_addr: integer := 55;
constant CHAND_CONTROL_START: integer := 1;
constant INJECT_CONTROL2_EXTENDED_CURRENT_MODE_B: integer := 4;
constant META_BANK_ADDR_WIDTH: integer := 12;
constant laserlocker_options_addr: integer := 43;
constant rdman_precontrol_duration_addr: integer := 90;
constant INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_B: integer := 5;
constant INJECT_CONTROL_MODE_B: integer := 0;
constant inject_laser4_coarse_current_addr: integer := 111;
constant RDMAN_STATUS_BANK0_IN_USE_B: integer := 4;
constant inject_laser4_extra_fine_scale_addr: integer := 2**7-1;
constant DYNAMICPWM_CS_USE_COMPARATOR_B: integer := 3;
constant wlmsim_options_addr: integer := 132;
constant INJECT_CONTROL2_FIBER_AMP_PRESENT_B: integer := 0;
constant lasercurrentgenerator_first_offset_addr: integer := 155;
constant RDMAN_STATUS_ABORTED_B: integer := 9;
constant CHANA_DATA_END: integer := 25;
constant INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_W: integer := 4;
constant KERNEL_CONFIG_ENGINE2_TEC_B: integer := 2;
constant rdman_extra_duration_addr: integer := 92;
constant INJECT_CONTROL_LASER_SHUTDOWN_ENABLE_B: integer := 12;
constant laserlocker_eta1_offset_addr: integer := 52;
constant LASERCURRENTGENERATOR_CONTROL_STATUS_LASER_SELECT_B: integer := 1;
constant RDMAN_STATUS_TIMEOUT_B: integer := 8;
constant M: integer := 2**16;
constant LASERLOCKER_OPTIONS_SIM_ACTUAL_B: integer := 0;
constant laserlocker_eta1_dark_addr: integer := 48;
constant lasercurrentgenerator_second_breakpoint_addr: integer := 158;
constant laserlocker_eta1_addr: integer := 44;
constant EMIF_ADDR_WIDTH: integer := 20;
constant rdman_timeout_duration_addr: integer := 93;
constant ADC_START_CYCLE: integer := 4;
constant RDMAN_STATUS_ACQ_DONE_B: integer := 2;
constant rdman_param2_addr: integer := 75;
constant PARAM_BANK_ADDR_WIDTH: integer := 6;
constant rdman_lock_duration_addr: integer := 89;
constant LASERCURRENTGENERATOR_CONTROL_STATUS_LASER_SELECT_W: integer := 2;
constant lasercurrentgenerator_fast_slope_addr: integer := 154;
constant dynamicpwm_cs_addr: integer := 146;
constant laserlocker_cycle_counter_addr: integer := 69;
constant KERNEL_STATUS_LED_RED_B: integer := 0;
constant LASERLOCKER_CS_ACC_EN_B: integer := 3;
constant inject_laser3_extra_coarse_scale_addr: integer := 122;
constant rdman_threshold_addr: integer := 88;
constant TWGen_window_high_addr: integer := 104;
constant LASERLOCKER_CS_CURRENT_OK_B: integer := 8;
constant rdman_metadata_addr_at_ringdown_addr: integer := 95;
constant DYNAMICPWM_CS_PWM_OUT_B: integer := 4;
constant inject_laser3_extra_fine_scale_addr: integer := 126;
constant dither_width: integer := 8;
constant rdsim_pzt_window_half_width_addr: integer := 36;
constant LASERLOCKER_CS_ADC_STROBE_B: integer := 5;
constant RDMEM_PARAM_WIDTH: integer := 2**5;


type t_enum_MetadataAcqState_10 is (
    IDLE,
    AWAIT_STROBE,
    ACQUIRING,
    DONE
);
type t_enum_OptSwitchState_7 is (
    IDLE,
    PULSING_1,
    SELECTED_1,
    PULSING_2,
    SELECTED_2
);
type t_enum_ParamState_11 is (
    IDLE,
    STORING,
    DONE
);
type t_enum_SeqState_12 is (
    IDLE,
    START_INJECT,
    WAIT_FOR_PRECONTROL,
    WAIT_FOR_LOCK,
    WAIT_FOR_GATING_CONDITIONS,
    CHECK_BELOW_THRESHOLD,
    WAIT_FOR_THRESHOLD,
    IN_RINGDOWN,
    CHECK_PARAMS_DONE,
    ACQ_DONE,
    AWAIT_SWEEP_1,
    AWAIT_SWEEP_2,
    WAIT_RD_DONE_1,
    WAIT_RD_DONE_2
);
type t_enum_SwitchPulserState_8 is (
    START,
    PULSING,
    WAITING
);
type t_enum_t_State_1 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
type t_enum_t_State_2 is (
    INIT,
    GENVALUE
);
type t_enum_t_State_5 is (
    INIT,
    WRITE1,
    WRITE2,
    READ1,
    READ2,
    IDLE
);
type t_enum_t_State_6 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
type t_enum_t_State_9 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
type t_enum_t_procState_3 is (
    WAITING,
    CALCULATING
);
type t_enum_t_seqState_4 is (
    IDLE,
    WAIT_PROC1,
    WAIT_PROC2,
    WAIT_PROC3,
    WAIT_PROC4,
    WAIT_DIV1,
    WAIT_DIV2,
    WAIT_DIV3,
    WAIT_SCALE1,
    WAIT_SCALE2,
    WAIT_SCALE3,
    WAIT_SCALE4
);

signal wr_meta: unsigned(15 downto 0);
signal sim_pzt: unsigned(15 downto 0);
signal clk_5M: std_logic;
signal meta: unsigned(15 downto 0);
signal ce2: std_logic;
signal heater_pwm_inv: std_logic;
signal rd_irq: std_logic;
signal laser_freq_ok: std_logic;
signal pulse_100k: std_logic;
signal ref1_actual: unsigned(15 downto 0);
signal dsp_data_in_rdman: unsigned(31 downto 0);
signal engine1_pwm_inv: std_logic;
signal laser_extra: std_logic;
signal fan: unsigned(1 downto 0);
signal dsp_data_in_twGen: unsigned(31 downto 0);
signal dsp_data_in_rdmemory: unsigned(31 downto 0);
signal data_available_actual: std_logic;
signal heater_pwm_out: std_logic;
signal filter_heater_pwm_inv_out: std_logic;
signal bank: std_logic;
signal tuner_in_window: std_logic;
signal pwm_laser4_out: std_logic;
signal inlet_valve_dac: unsigned(15 downto 0);
signal meta_addr: unsigned(11 downto 0);
signal chanC_data_in: unsigned(15 downto 0);
signal i2c_reset: std_logic;
signal dsp_data_in_dynamicpwm_outlet: unsigned(31 downto 0);
signal dsp_data_in_lasercurrentgenerator: unsigned(31 downto 0);
signal eta1: unsigned(15 downto 0);
signal data_we: std_logic;
signal wlm_sim_actual: std_logic;
signal tuner_slope: std_logic;
signal laser_locking_pid: unsigned(15 downto 0);
signal eta2_sim: unsigned(15 downto 0);
signal intronix_clksel: unsigned(4 downto 0);
signal eta1_sim: unsigned(15 downto 0);
signal ratio1: unsigned(15 downto 0);
signal eta2_actual: unsigned(15 downto 0);
signal pwm_laser4_inv_out: std_logic;
signal lsr2_ss_temp: std_logic;
signal wmm_rd_out: std_logic;
signal dsp_data_in_dynamicpwm_inlet: unsigned(31 downto 0);
signal channel_1: unsigned(7 downto 0);
signal sim_loss: unsigned(15 downto 0);
signal channel_3: unsigned(7 downto 0);
signal channel_2: unsigned(7 downto 0);
signal data_addr: unsigned(11 downto 0);
signal pwm_laser1_out: std_logic;
signal wr_data: unsigned(17 downto 0);
signal wlm_data_available: std_logic;
signal laser_tuning_offset: unsigned(15 downto 0);
signal engine2_pwm_out: std_logic;
signal laser_fine_current: unsigned(15 downto 0);
signal lsr1_mosi_temp: std_logic;
signal warm_box_pwm_inv: std_logic;
signal ref2: unsigned(15 downto 0);
signal lsr2_mosi_temp: std_logic;
signal aux_pzt_dac_sdi: std_logic;
signal laser1_fine_ext: unsigned(15 downto 0);
signal dsp_data_in_pwm_heater: unsigned(31 downto 0);
signal eta2: unsigned(15 downto 0);
signal ext_laser_level_counter: unsigned(15 downto 0);
signal param_addr: unsigned(5 downto 0);
signal dsp_data_in_pwm_engine2: unsigned(31 downto 0);
signal laser_locked: std_logic;
signal eta1_actual: unsigned(15 downto 0);
signal lsr3_ss_temp: std_logic;
signal clk_2M5: std_logic;
signal dsp_wr: std_logic;
signal pwm_laser1_inv_out: std_logic;
signal ext_laser_sequence_id: unsigned(15 downto 0);
signal channel_4: unsigned(8 downto 0);
signal dsp_data_in_laserlocker: unsigned(31 downto 0);
signal aux_pzt_dac_ld: std_logic;
signal lsr4_mosi_temp: std_logic;
signal param_we: std_logic;
signal aux_pzt_dac_sck: std_logic;
signal extended_current_mode: std_logic;
signal warm_box_pwm_out: std_logic;
signal filter_heater_pwm_out: std_logic;
signal meta5: unsigned(15 downto 0);
signal ref2_sim: unsigned(15 downto 0);
signal engine1_pwm_out: std_logic;
signal laser4_fine_ext: unsigned(15 downto 0);
signal dsp_data_in_pwm_laser3: unsigned(31 downto 0);
signal sel_laser: unsigned(1 downto 0);
signal tuner_value: unsigned(15 downto 0);
signal clk_10M: std_logic;
signal dsp_data_in_kernel: unsigned(31 downto 0);
signal engine2_pwm_inv: std_logic;
signal rdsim_value: unsigned(15 downto 0);
signal laser2_fine_ext: unsigned(15 downto 0);
signal dsp_data_in_pwm_laser2: unsigned(31 downto 0);
signal dsp_data_in_pwm_laser1: unsigned(31 downto 0);
signal adc_clk: std_logic;
signal dsp_data_in_pwm_laser4: unsigned(31 downto 0);
signal status_led: unsigned(1 downto 0);
signal ref2_actual: unsigned(15 downto 0);
signal outlet_valve_dac: unsigned(15 downto 0);
signal dsp_data_in: unsigned(31 downto 0);
signal pwm_laser3_inv_out: std_logic;
signal sel_coarse_current: unsigned(15 downto 0);
signal dsp_data_in_inject: unsigned(31 downto 0);
signal ext_laser_current_in_window: std_logic;
signal diag_1: unsigned(7 downto 0);
signal hot_box_pwm_inv: std_logic;
signal pzt: unsigned(15 downto 0);
signal ratio2: unsigned(15 downto 0);
signal dsp_data_in_pwm_hotbox: unsigned(31 downto 0);
signal data_available_sim: std_logic;
signal pwm_laser2_inv_out: std_logic;
signal hot_box_pwm_out: std_logic;
signal dsp_addr: unsigned(19 downto 0);
signal acq_done_irq: std_logic;
signal sel_fine_current: unsigned(15 downto 0);
signal intronix_1: unsigned(7 downto 0);
signal intronix_2: unsigned(7 downto 0);
signal intronix_3: unsigned(7 downto 0);
signal dsp_data_in_scaler: unsigned(31 downto 0);
signal dsp_data_in_wlmsim: unsigned(31 downto 0);
signal dsp_data_in_pwm_engine1: unsigned(31 downto 0);
signal lsr3_mosi_temp: std_logic;
signal metadata_strobe: std_logic;
signal meta7: unsigned(15 downto 0);
signal overload_out: std_logic;
signal config: unsigned(15 downto 0);
signal wr_param: unsigned(31 downto 0);
signal laser3_fine_ext: unsigned(15 downto 0);
signal lsr4_ss_temp: std_logic;
signal ref1: unsigned(15 downto 0);
signal meta_we: std_logic;
signal dsp_data_in_pwm_warmbox: unsigned(31 downto 0);
signal pzt_scaled: unsigned(15 downto 0);
signal lsr1_ss_temp: std_logic;
signal pulse_1M: std_logic;
signal param: unsigned(31 downto 0);
signal data: unsigned(17 downto 0);
signal dsp_data_out: unsigned(31 downto 0);
signal pwm_laser2_out: std_logic;
signal ref1_sim: unsigned(15 downto 0);
signal counter: unsigned(27 downto 0);
signal overload_in: unsigned(15 downto 0);
signal pwm_laser3_out: std_logic;
signal dsp_data_in_pwm_filter_heater: unsigned(31 downto 0);
signal rd_trig: std_logic;
signal dsp_data_in_rdsim: unsigned(31 downto 0);
signal acc_en: std_logic;
signal scaler_a: unsigned(16 downto 0);
signal scaler_b: unsigned(16 downto 0);
signal scaler_scale1: unsigned(15 downto 0);
signal scaler_p: unsigned(33 downto 0);
signal scaler_mult_a_s: signed (17 downto 0);
signal scaler_mult_b_s: signed (17 downto 0);
signal scaler_mult_p_s: signed (35 downto 0);
signal dynamicPwmOutlet_slope: unsigned(15 downto 0);
signal dynamicPwmOutlet_high: unsigned(15 downto 0);
signal dynamicPwmOutlet_cs: unsigned(15 downto 0);
signal dynamicPwmOutlet_extra0: unsigned(7 downto 0);
signal dynamicPwmOutlet_low: unsigned(15 downto 0);
signal dynamicPwmOutlet_main_cntr: unsigned(7 downto 0);
signal dynamicPwmOutlet_acc: unsigned(23 downto 0);
signal dynamicPwmOutlet_delta: signed (15 downto 0);
signal dynamicPwmOutlet_pwm: std_logic;
signal dynamicPwmOutlet_temp: unsigned(8 downto 0);
signal dynamicPwmOutlet_up: std_logic;
signal dynamicPwmOutlet_dither_cntr: unsigned(7 downto 0);
signal dynamicPwmOutlet_pulse_width: unsigned(15 downto 0);
signal dynamicPwmInlet_slope: unsigned(15 downto 0);
signal dynamicPwmInlet_high: unsigned(15 downto 0);
signal dynamicPwmInlet_cs: unsigned(15 downto 0);
signal dynamicPwmInlet_extra0: unsigned(7 downto 0);
signal dynamicPwmInlet_low: unsigned(15 downto 0);
signal dynamicPwmInlet_main_cntr: unsigned(7 downto 0);
signal dynamicPwmInlet_acc: unsigned(23 downto 0);
signal dynamicPwmInlet_delta: signed (15 downto 0);
signal dynamicPwmInlet_pwm: std_logic;
signal dynamicPwmInlet_temp: unsigned(8 downto 0);
signal dynamicPwmInlet_up: std_logic;
signal dynamicPwmInlet_dither_cntr: unsigned(7 downto 0);
signal dynamicPwmInlet_pulse_width: unsigned(15 downto 0);
signal auxPztDac_dac_sdi: std_logic;
signal auxPztDac_counter: unsigned(4 downto 0);
signal auxPztDac_chanD_data: unsigned(15 downto 0);
signal auxPztDac_state: t_enum_t_State_1;
signal auxPztDac_dac_ld: std_logic;
signal pztValveDac_dac_sdi: std_logic;
signal pztValveDac_counter: unsigned(4 downto 0);
signal pztValveDac_chanD_data: unsigned(15 downto 0);
signal pztValveDac_state: t_enum_t_State_1;
signal pztValveDac_dac_ld: std_logic;
signal wlmsim_ref1_offset: unsigned(15 downto 0);
signal wlmsim_div_num: unsigned(15 downto 0);
signal wlmsim_div_quot: unsigned(15 downto 0);
signal wlmsim_done: std_logic;
signal wlmsim_div_ce: std_logic;
signal wlmsim_xu: unsigned(15 downto 0);
signal wlmsim_div_rfd: std_logic;
signal wlmsim_z0: unsigned(15 downto 0);
signal wlmsim_start_cordic: std_logic;
signal wlmsim_laser_temp: unsigned(15 downto 0);
signal wlmsim_ref2_offset: unsigned(15 downto 0);
signal wlmsim_eta2_offset: unsigned(15 downto 0);
signal wlmsim_mult_p: unsigned(33 downto 0);
signal wlmsim_ref1: unsigned(15 downto 0);
signal wlmsim_ref2: unsigned(15 downto 0);
signal wlmsim_div_den: unsigned(15 downto 0);
signal wlmsim_zval: unsigned(15 downto 0);
signal wlmsim_mult_a: unsigned(16 downto 0);
signal wlmsim_mult_b: unsigned(16 downto 0);
signal wlmsim_yu: unsigned(15 downto 0);
signal wlmsim_eta1_offset: unsigned(15 downto 0);
signal wlmsim_wfac: unsigned(15 downto 0);
signal wlmsim_eta1: unsigned(15 downto 0);
signal wlmsim_eta2: unsigned(15 downto 0);
signal wlmsim_rfac: unsigned(15 downto 0);
signal wlmsim_options: unsigned(0 downto 0);
signal wlmsim_divider_Nreg: unsigned(16 downto 0);
signal wlmsim_divider_i: unsigned(3 downto 0);
signal wlmsim_divider_Qreg: unsigned(15 downto 0);
signal wlmsim_divider_done: std_logic;
signal wlmsim_divider_rfd: std_logic;
signal wlmsim_divider_Dreg: unsigned(15 downto 0);
signal wlmsim_multiplier_a_s: signed (17 downto 0);
signal wlmsim_multiplier_b_s: signed (17 downto 0);
signal wlmsim_multiplier_p_s: signed (35 downto 0);
signal wlmadcreader_counter: unsigned(4 downto 0);
signal wlmadcreader_ref1: unsigned(15 downto 0);
signal wlmadcreader_ref2: unsigned(15 downto 0);
signal wlmadcreader_state: t_enum_t_State_9;
signal wlmadcreader_eta2: unsigned(15 downto 0);
signal wlmadcreader_eta1: unsigned(15 downto 0);
signal twGen_slope: std_logic;
signal twGen_pzt_offset: unsigned(15 downto 0);
signal twGen_cs: unsigned(15 downto 0);
signal twGen_extra0: unsigned(8 downto 0);
signal twGen_sweep_low: unsigned(15 downto 0);
signal twGen_acc: unsigned(24 downto 0);
signal twGen_window_high: unsigned(15 downto 0);
signal twGen_slope_down: unsigned(15 downto 0);
signal twGen_sweep_high: unsigned(15 downto 0);
signal twGen_slope_up: unsigned(15 downto 0);
signal twGen_window_low: unsigned(15 downto 0);
signal rdsim_pzt_window_half_width: unsigned(15 downto 0);
signal rdsim_decay_in_shift: unsigned(3 downto 0);
signal rdsim_accumulator: unsigned(19 downto 0);
signal rdsim_state: t_enum_t_State_2;
signal rdsim_decay_in_offset: unsigned(15 downto 0);
signal rdsim_residual: unsigned(13 downto 0);
signal rdsim_a: unsigned(16 downto 0);
signal rdsim_pzt_center: unsigned(15 downto 0);
signal rdsim_filling_rate: unsigned(15 downto 0);
signal rdsim_b: unsigned(16 downto 0);
signal rdsim_decay: unsigned(15 downto 0);
signal rdsim_p: unsigned(33 downto 0);
signal rdsim_options: unsigned(0 downto 0);
signal rdsim_mult_a_s: signed (17 downto 0);
signal rdsim_mult_b_s: signed (17 downto 0);
signal rdsim_mult_p_s: signed (35 downto 0);
signal rdmemory_wr_dataA: unsigned(17 downto 0);
signal rdmemory_wr_paramA: unsigned(31 downto 0);
signal rdmemory_enB_data: std_logic;
signal rdmemory_param_addrB: unsigned(6 downto 0);
signal rdmemory_param_addrA: unsigned(6 downto 0);
signal rdmemory_enA_data: std_logic;
signal rdmemory_enB_param: std_logic;
signal rdmemory_meta_addrB: unsigned(12 downto 0);
signal rdmemory_meta_addrA: unsigned(12 downto 0);
signal rdmemory_rd_dataA: unsigned(17 downto 0);
signal rdmemory_enA_param: std_logic;
signal rdmemory_data_addrA: unsigned(12 downto 0);
signal rdmemory_data_addrB: unsigned(12 downto 0);
signal rdmemory_rd_metaA: unsigned(15 downto 0);
signal rdmemory_wr_metaA: unsigned(15 downto 0);
signal rdmemory_rd_paramA: unsigned(31 downto 0);
signal rdmemory_enB_meta: std_logic;
signal rdmemory_wr_enable: std_logic;
signal rdmemory_enA_meta: std_logic;
signal rdman_lapped: std_logic;
signal rdman_rd_adc_clk: std_logic;
signal rdman_threshold: unsigned(15 downto 0);
signal rdman_rd_irq: std_logic;
signal rdman_timeout_duration: unsigned(31 downto 0);
signal rdman_off_duration: unsigned(15 downto 0);
signal rdman_num_samp: unsigned(11 downto 0);
signal rdman_param_acq: std_logic;
signal rdman_bank: std_logic;
signal rdman_metadataAcqState: t_enum_MetadataAcqState_10;
signal rdman_timeout: std_logic;
signal rdman_us_since_start: unsigned(31 downto 0);
signal rdman_metadata_addrcntr: unsigned(11 downto 0);
signal rdman_ringdown_data: unsigned(17 downto 0);
signal rdman_tuner_gating_conditions: std_logic;
signal rdman_rd_data: unsigned(15 downto 0);
signal rdman_us_timer_enable: std_logic;
signal rdman_param4: unsigned(31 downto 0);
signal rdman_param2: unsigned(31 downto 0);
signal rdman_data_addrcntr: unsigned(11 downto 0);
signal rdman_sel_fine_current_slope: std_logic;
signal rdman_us_after_ringdown: unsigned(16 downto 0);
signal rdman_divisor: unsigned(15 downto 0);
signal rdman_ext_laser_level_counter: unsigned(15 downto 0);
signal rdman_metadata_addr_at_ringdown: unsigned(15 downto 0);
signal rdman_paramState: t_enum_ParamState_11;
signal rdman_options: unsigned(15 downto 0);
signal rdman_ext_laser_sequence_id: unsigned(15 downto 0);
signal rdman_freq_gating_conditions: std_logic;
signal rdman_metadata_acq: std_logic;
signal rdman_rd_trig: std_logic;
signal rdman_expiry_time: unsigned(31 downto 0);
signal rdman_div50_counter: unsigned(5 downto 0);
signal rdman_rd_divider: unsigned(15 downto 0);
signal rdman_precontrol_duration: unsigned(15 downto 0);
signal rdman_param7: unsigned(31 downto 0);
signal rdman_param6: unsigned(31 downto 0);
signal rdman_param5: unsigned(31 downto 0);
signal rdman_abort: std_logic;
signal rdman_param3: unsigned(31 downto 0);
signal rdman_lock_duration: unsigned(15 downto 0);
signal rdman_param1: unsigned(31 downto 0);
signal rdman_param0: unsigned(31 downto 0);
signal rdman_sel_fine_current_prev: unsigned(15 downto 0);
signal rdman_param9: unsigned(31 downto 0);
signal rdman_param8: unsigned(31 downto 0);
signal rdman_control: unsigned(15 downto 0);
signal rdman_seqState: t_enum_SeqState_12;
signal rdman_param_addrcntr: unsigned(5 downto 0);
signal rdman_acq_done_irq: std_logic;
signal rdman_sel_fine_current: unsigned(15 downto 0);
signal rdman_status: unsigned(15 downto 0);
signal rdman_laser_extra: std_logic;
signal rdman_init_flag: std_logic;
signal rdman_extra_duration: unsigned(15 downto 0);
signal rdman_tuner_at_ringdown: unsigned(15 downto 0);
signal pwm_filter_heater_temp: unsigned(8 downto 0);
signal pwm_filter_heater_pulse_width: unsigned(15 downto 0);
signal pwm_filter_heater_cs: unsigned(15 downto 0);
signal pwm_filter_heater_dither_cntr: unsigned(7 downto 0);
signal pwm_filter_heater_pwm: std_logic;
signal pwm_filter_heater_main_cntr: unsigned(7 downto 0);
signal pwm_heater_temp: unsigned(8 downto 0);
signal pwm_heater_pulse_width: unsigned(15 downto 0);
signal pwm_heater_cs: unsigned(15 downto 0);
signal pwm_heater_dither_cntr: unsigned(7 downto 0);
signal pwm_heater_pwm: std_logic;
signal pwm_heater_main_cntr: unsigned(7 downto 0);
signal pwm_engine2_temp: unsigned(8 downto 0);
signal pwm_engine2_pulse_width: unsigned(15 downto 0);
signal pwm_engine2_cs: unsigned(15 downto 0);
signal pwm_engine2_dither_cntr: unsigned(7 downto 0);
signal pwm_engine2_pwm: std_logic;
signal pwm_engine2_main_cntr: unsigned(7 downto 0);
signal pwm_engine1_temp: unsigned(8 downto 0);
signal pwm_engine1_pulse_width: unsigned(15 downto 0);
signal pwm_engine1_cs: unsigned(15 downto 0);
signal pwm_engine1_dither_cntr: unsigned(7 downto 0);
signal pwm_engine1_pwm: std_logic;
signal pwm_engine1_main_cntr: unsigned(7 downto 0);
signal pwm_hotbox_temp: unsigned(8 downto 0);
signal pwm_hotbox_pulse_width: unsigned(15 downto 0);
signal pwm_hotbox_cs: unsigned(15 downto 0);
signal pwm_hotbox_dither_cntr: unsigned(7 downto 0);
signal pwm_hotbox_pwm: std_logic;
signal pwm_hotbox_main_cntr: unsigned(7 downto 0);
signal pwm_warmbox_temp: unsigned(8 downto 0);
signal pwm_warmbox_pulse_width: unsigned(15 downto 0);
signal pwm_warmbox_cs: unsigned(15 downto 0);
signal pwm_warmbox_dither_cntr: unsigned(7 downto 0);
signal pwm_warmbox_pwm: std_logic;
signal pwm_warmbox_main_cntr: unsigned(7 downto 0);
signal pwm_laser4_temp: unsigned(8 downto 0);
signal pwm_laser4_pulse_width: unsigned(15 downto 0);
signal pwm_laser4_cs: unsigned(15 downto 0);
signal pwm_laser4_dither_cntr: unsigned(7 downto 0);
signal pwm_laser4_pwm: std_logic;
signal pwm_laser4_main_cntr: unsigned(7 downto 0);
signal pwm_laser3_temp: unsigned(8 downto 0);
signal pwm_laser3_pulse_width: unsigned(15 downto 0);
signal pwm_laser3_cs: unsigned(15 downto 0);
signal pwm_laser3_dither_cntr: unsigned(7 downto 0);
signal pwm_laser3_pwm: std_logic;
signal pwm_laser3_main_cntr: unsigned(7 downto 0);
signal pwm_laser2_temp: unsigned(8 downto 0);
signal pwm_laser2_pulse_width: unsigned(15 downto 0);
signal pwm_laser2_cs: unsigned(15 downto 0);
signal pwm_laser2_dither_cntr: unsigned(7 downto 0);
signal pwm_laser2_pwm: std_logic;
signal pwm_laser2_main_cntr: unsigned(7 downto 0);
signal pwm_laser1_temp: unsigned(8 downto 0);
signal pwm_laser1_pulse_width: unsigned(15 downto 0);
signal pwm_laser1_cs: unsigned(15 downto 0);
signal pwm_laser1_dither_cntr: unsigned(7 downto 0);
signal pwm_laser1_pwm: std_logic;
signal pwm_laser1_main_cntr: unsigned(7 downto 0);
signal laserlocker_ref1_offset: unsigned(15 downto 0);
signal laserlocker_fine_current: unsigned(15 downto 0);
signal laserlocker_div_num: unsigned(15 downto 0);
signal laserlocker_div_quot: unsigned(15 downto 0);
signal laserlocker_cs: unsigned(15 downto 0);
signal laserlocker_ratio1: unsigned(15 downto 0);
signal laserlocker_ratio2: unsigned(15 downto 0);
signal laserlocker_ratio2_multiplier: unsigned(15 downto 0);
signal laserlocker_ref1_dark: unsigned(15 downto 0);
signal laserlocker_prev_lock_error_deriv: unsigned(15 downto 0);
signal laserlocker_div_ce: std_logic;
signal laserlocker_deriv: unsigned(15 downto 0);
signal laserlocker_eta2_dark: unsigned(15 downto 0);
signal laserlocker_prbs_augment: std_logic;
signal laserlocker_awaiting_strobe: std_logic;
signal laserlocker_ratio1_center: unsigned(15 downto 0);
signal laserlocker_cycle_counter: unsigned(15 downto 0);
signal laserlocker_ratio2_center: unsigned(15 downto 0);
signal laserlocker_wm_deriv_gain: unsigned(15 downto 0);
signal laserlocker_prev_lock_error: unsigned(15 downto 0);
signal laserlocker_ref2: unsigned(15 downto 0);
signal laserlocker_eta2_offset: unsigned(15 downto 0);
signal laserlocker_mult_p: unsigned(15 downto 0);
signal laserlocker_eta1_dark: unsigned(15 downto 0);
signal laserlocker_ref1: unsigned(15 downto 0);
signal laserlocker_div_den: unsigned(15 downto 0);
signal laserlocker_ratio1_multiplier: unsigned(15 downto 0);
signal laserlocker_lock_error: unsigned(15 downto 0);
signal laserlocker_mult_a: unsigned(15 downto 0);
signal laserlocker_wm_prop_gain: unsigned(15 downto 0);
signal laserlocker_mult_b: unsigned(15 downto 0);
signal laserlocker_ref2_dark: unsigned(15 downto 0);
signal laserlocker_mult_o: std_logic;
signal laserlocker_eta1_offset: unsigned(15 downto 0);
signal laserlocker_eta1: unsigned(15 downto 0);
signal laserlocker_ref2_offset: unsigned(15 downto 0);
signal laserlocker_prbs_reg: unsigned(7 downto 0);
signal laserlocker_eta2: unsigned(15 downto 0);
signal laserlocker_tuning_offset: unsigned(15 downto 0);
signal laserlocker_div_rfd: std_logic;
signal laserlocker_wm_lock_window: unsigned(15 downto 0);
signal laserlocker_deriv2: unsigned(15 downto 0);
signal laserlocker_options: unsigned(1 downto 0);
signal laserlocker_wm_int_gain: unsigned(15 downto 0);
signal laserlocker_signedMultiplier_a_s: signed (17 downto 0);
signal laserlocker_signedMultiplier_p_s: signed (35 downto 0);
signal laserlocker_signedMultiplier_b_s: signed (17 downto 0);
signal laserlocker_divider_Nreg: unsigned(16 downto 0);
signal laserlocker_divider_i: unsigned(3 downto 0);
signal laserlocker_divider_Qreg: unsigned(15 downto 0);
signal laserlocker_divider_done: std_logic;
signal laserlocker_divider_rfd: std_logic;
signal laserlocker_divider_Dreg: unsigned(15 downto 0);
signal laserCurrentGenerator_wr_enB_laser2: std_logic;
signal laserCurrentGenerator_upper_window_4: unsigned(15 downto 0);
signal laserCurrentGenerator_upper_window_1: unsigned(15 downto 0);
signal laserCurrentGenerator_upper_window_2: unsigned(15 downto 0);
signal laserCurrentGenerator_upper_window_3: unsigned(15 downto 0);
signal laserCurrentGenerator_transition_counter_limit: unsigned(15 downto 0);
signal laserCurrentGenerator_first_breakpoint_4: unsigned(15 downto 0);
signal laserCurrentGenerator_first_breakpoint_3: unsigned(15 downto 0);
signal laserCurrentGenerator_first_breakpoint_2: unsigned(15 downto 0);
signal laserCurrentGenerator_first_breakpoint_1: unsigned(15 downto 0);
signal laserCurrentGenerator_period_counter_limit_1: unsigned(8 downto 0);
signal laserCurrentGenerator_prev_level_4: unsigned(15 downto 0);
signal laserCurrentGenerator_period_counter_limit_3: unsigned(8 downto 0);
signal laserCurrentGenerator_period_counter_limit_2: unsigned(8 downto 0);
signal laserCurrentGenerator_prev_level_1: unsigned(15 downto 0);
signal laserCurrentGenerator_period_counter_limit_4: unsigned(8 downto 0);
signal laserCurrentGenerator_prev_level_3: unsigned(15 downto 0);
signal laserCurrentGenerator_prev_level_2: unsigned(15 downto 0);
signal laserCurrentGenerator_wr_dataA_laser2: unsigned(15 downto 0);
signal laserCurrentGenerator_wr_enB_laser1: std_logic;
signal laserCurrentGenerator_wr_enB_laser3: std_logic;
signal laserCurrentGenerator_wr_enB_laser4: std_logic;
signal laserCurrentGenerator_wr_dataA_laser4: unsigned(15 downto 0);
signal laserCurrentGenerator_slow_slope_4: unsigned(23 downto 0);
signal laserCurrentGenerator_slow_slope_2: unsigned(23 downto 0);
signal laserCurrentGenerator_slow_slope_3: unsigned(23 downto 0);
signal laserCurrentGenerator_slow_slope_1: unsigned(23 downto 0);
signal laserCurrentGenerator_transition_counter_1: unsigned(15 downto 0);
signal laserCurrentGenerator_transition_counter_3: unsigned(15 downto 0);
signal laserCurrentGenerator_transition_counter_2: unsigned(15 downto 0);
signal laserCurrentGenerator_transition_counter_4: unsigned(15 downto 0);
signal laserCurrentGenerator_second_offset_4: unsigned(23 downto 0);
signal laserCurrentGenerator_second_offset_1: unsigned(23 downto 0);
signal laserCurrentGenerator_second_offset_2: unsigned(23 downto 0);
signal laserCurrentGenerator_second_offset_3: unsigned(23 downto 0);
signal laserCurrentGenerator_second_breakpoint: unsigned(15 downto 0);
signal laserCurrentGenerator_transition_counter_limit_3: unsigned(15 downto 0);
signal laserCurrentGenerator_transition_counter_limit_2: unsigned(15 downto 0);
signal laserCurrentGenerator_transition_counter_limit_1: unsigned(15 downto 0);
signal laserCurrentGenerator_fast_slope: unsigned(23 downto 0);
signal laserCurrentGenerator_transition_counter_limit_4: unsigned(15 downto 0);
signal laserCurrentGenerator_current_level_4: unsigned(15 downto 0);
signal laserCurrentGenerator_current_level_2: unsigned(15 downto 0);
signal laserCurrentGenerator_current_level_3: unsigned(15 downto 0);
signal laserCurrentGenerator_current_level_1: unsigned(15 downto 0);
signal laserCurrentGenerator_interp_y1: unsigned(15 downto 0);
signal laserCurrentGenerator_interp_y0: unsigned(15 downto 0);
signal laserCurrentGenerator_interp_yout: unsigned(15 downto 0);
signal laserCurrentGenerator_control_status: unsigned(15 downto 0);
signal laserCurrentGenerator_lower_window_1: unsigned(15 downto 0);
signal laserCurrentGenerator_lower_window_3: unsigned(15 downto 0);
signal laserCurrentGenerator_lower_window_2: unsigned(15 downto 0);
signal laserCurrentGenerator_lower_window_4: unsigned(15 downto 0);
signal laserCurrentGenerator_second_offset: unsigned(23 downto 0);
signal laserCurrentGenerator_fast_slope_3: unsigned(23 downto 0);
signal laserCurrentGenerator_fast_slope_2: unsigned(23 downto 0);
signal laserCurrentGenerator_fast_slope_1: unsigned(23 downto 0);
signal laserCurrentGenerator_fast_slope_4: unsigned(23 downto 0);
signal laserCurrentGenerator_sequence_id_1: unsigned(15 downto 0);
signal laserCurrentGenerator_sequence_id_3: unsigned(15 downto 0);
signal laserCurrentGenerator_sequence_id_2: unsigned(15 downto 0);
signal laserCurrentGenerator_enB_laser3: std_logic;
signal laserCurrentGenerator_sequence_id_4: unsigned(15 downto 0);
signal laserCurrentGenerator_second_breakpoint_4: unsigned(15 downto 0);
signal laserCurrentGenerator_second_breakpoint_1: unsigned(15 downto 0);
signal laserCurrentGenerator_second_breakpoint_2: unsigned(15 downto 0);
signal laserCurrentGenerator_second_breakpoint_3: unsigned(15 downto 0);
signal laserCurrentGenerator_period_counter_limit: unsigned(15 downto 0);
signal laserCurrentGenerator_period_counter_4: unsigned(8 downto 0);
signal laserCurrentGenerator_period_counter_3: unsigned(8 downto 0);
signal laserCurrentGenerator_period_counter_2: unsigned(8 downto 0);
signal laserCurrentGenerator_period_counter_1: unsigned(8 downto 0);
signal laserCurrentGenerator_addrA_laser2: unsigned(9 downto 0);
signal laserCurrentGenerator_addrA_laser3: unsigned(9 downto 0);
signal laserCurrentGenerator_addrA_laser1: unsigned(9 downto 0);
signal laserCurrentGenerator_bank_3: std_logic;
signal laserCurrentGenerator_addrA_laser4: unsigned(9 downto 0);
signal laserCurrentGenerator_bank_2: std_logic;
signal laserCurrentGenerator_output_counter: unsigned(3 downto 0);
signal laserCurrentGenerator_dsp_wr_delayed: std_logic;
signal laserCurrentGenerator_addrB_laser3: unsigned(9 downto 0);
signal laserCurrentGenerator_addrB_laser2: unsigned(9 downto 0);
signal laserCurrentGenerator_addrB_laser1: unsigned(9 downto 0);
signal laserCurrentGenerator_addrB_laser4: unsigned(9 downto 0);
signal laserCurrentGenerator_interp_3: unsigned(23 downto 0);
signal laserCurrentGenerator_interp_2: unsigned(23 downto 0);
signal laserCurrentGenerator_interp_1: unsigned(23 downto 0);
signal laserCurrentGenerator_interp_4: unsigned(23 downto 0);
signal laserCurrentGenerator_rd_dataA_laser1: unsigned(15 downto 0);
signal laserCurrentGenerator_rd_dataA_laser3: unsigned(15 downto 0);
signal laserCurrentGenerator_rd_dataA_laser2: unsigned(15 downto 0);
signal laserCurrentGenerator_rd_dataA_laser4: unsigned(15 downto 0);
signal laserCurrentGenerator_enB_laser4: std_logic;
signal laserCurrentGenerator_rd_dataB_laser1: unsigned(15 downto 0);
signal laserCurrentGenerator_sequence_id: unsigned(15 downto 0);
signal laserCurrentGenerator_rd_dataB_laser3: unsigned(15 downto 0);
signal laserCurrentGenerator_rd_dataB_laser4: unsigned(15 downto 0);
signal laserCurrentGenerator_interp_beta: unsigned(15 downto 0);
signal laserCurrentGenerator_lower_window: unsigned(15 downto 0);
signal laserCurrentGenerator_wr_dataB_laser4: unsigned(15 downto 0);
signal laserCurrentGenerator_wr_dataB_laser3: unsigned(15 downto 0);
signal laserCurrentGenerator_wr_dataB_laser2: unsigned(15 downto 0);
signal laserCurrentGenerator_wr_dataB_laser1: unsigned(15 downto 0);
signal laserCurrentGenerator_enA_laser4: std_logic;
signal laserCurrentGenerator_bank_4: std_logic;
signal laserCurrentGenerator_bank_1: std_logic;
signal laserCurrentGenerator_enA_laser1: std_logic;
signal laserCurrentGenerator_enA_laser2: std_logic;
signal laserCurrentGenerator_enA_laser3: std_logic;
signal laserCurrentGenerator_enB_laser2: std_logic;
signal laserCurrentGenerator_first_offset_3: unsigned(23 downto 0);
signal laserCurrentGenerator_first_offset_2: unsigned(23 downto 0);
signal laserCurrentGenerator_first_offset_1: unsigned(23 downto 0);
signal laserCurrentGenerator_enB_laser1: std_logic;
signal laserCurrentGenerator_first_offset_4: unsigned(23 downto 0);
signal laserCurrentGenerator_first_breakpoint: unsigned(15 downto 0);
signal laserCurrentGenerator_fast_accumulator_4: unsigned(23 downto 0);
signal laserCurrentGenerator_fast_accumulator_2: unsigned(23 downto 0);
signal laserCurrentGenerator_fast_accumulator_3: unsigned(23 downto 0);
signal laserCurrentGenerator_fast_accumulator_1: unsigned(23 downto 0);
signal laserCurrentGenerator_slow_slope: unsigned(23 downto 0);
signal laserCurrentGenerator_first_offset: unsigned(23 downto 0);
signal laserCurrentGenerator_slow_accumulator_4: unsigned(23 downto 0);
signal laserCurrentGenerator_slow_accumulator_3: unsigned(23 downto 0);
signal laserCurrentGenerator_slow_accumulator_2: unsigned(23 downto 0);
signal laserCurrentGenerator_slow_accumulator_1: unsigned(23 downto 0);
signal laserCurrentGenerator_wr_dataA_laser3: unsigned(15 downto 0);
signal laserCurrentGenerator_rd_dataB_laser2: unsigned(15 downto 0);
signal laserCurrentGenerator_upper_window: unsigned(15 downto 0);
signal laserCurrentGenerator_wr_dataA_laser1: unsigned(15 downto 0);
signal laserCurrentGenerator_interpolator_mult_p: unsigned(33 downto 0);
signal laserCurrentGenerator_interpolator_mult_a: unsigned(16 downto 0);
signal laserCurrentGenerator_interpolator_mult_b: unsigned(16 downto 0);
signal laserCurrentGenerator_interpolator_multiplier_a_s: signed (17 downto 0);
signal laserCurrentGenerator_interpolator_multiplier_b_s: signed (17 downto 0);
signal laserCurrentGenerator_interpolator_multiplier_p_s: signed (35 downto 0);
signal kernel_control: unsigned(15 downto 0);
signal kernel_intronix_clksel: unsigned(4 downto 0);
signal kernel_intronix_1: unsigned(7 downto 0);
signal kernel_intronix_2: unsigned(7 downto 0);
signal kernel_overload: unsigned(15 downto 0);
signal kernel_dout_hi: unsigned(7 downto 0);
signal kernel_dout_lo: unsigned(31 downto 0);
signal kernel_config: unsigned(15 downto 0);
signal kernel_intronix_3: unsigned(7 downto 0);
signal kernel_din: unsigned(23 downto 0);
signal kernel_fan: unsigned(15 downto 0);
signal kernel_status_led: unsigned(15 downto 0);
signal kernel_diag_1: unsigned(7 downto 0);
signal inject_extra_enable: std_logic;
signal inject_laser3_extra_fine_scale: unsigned(15 downto 0);
signal inject_last_sel: unsigned(1 downto 0);
signal inject_laser4_fine_current: unsigned(15 downto 0);
signal inject_laser1_fine: unsigned(15 downto 0);
signal inject_extinguish_deselected: std_logic;
signal inject_laser4_coarse_current: unsigned(15 downto 0);
signal inject_optSwitchState: t_enum_OptSwitchState_7;
signal inject_sw4_4way: std_logic;
signal inject_disable_soa_with_laser_mask: unsigned(3 downto 0);
signal inject_manual_laser_en: unsigned(3 downto 0);
signal inject_laser3_coarse_current: unsigned(15 downto 0);
signal inject_control2: unsigned(15 downto 0);
signal inject_laser1_coarse_current: unsigned(15 downto 0);
signal inject_laser1_fine_current: unsigned(15 downto 0);
signal inject_laser4_fine_current_range: unsigned(15 downto 0);
signal inject_sel: unsigned(1 downto 0);
signal inject_pulse_counter: unsigned(6 downto 0);
signal inject_edge_strobe: std_logic;
signal inject_laser2_extra_offset: unsigned(15 downto 0);
signal inject_laser1_extra_offset: unsigned(15 downto 0);
signal inject_mode: std_logic;
signal inject_sw2_2way: std_logic;
signal inject_laser1_coarse: unsigned(15 downto 0);
signal inject_laser3_extra_offset: unsigned(15 downto 0);
signal inject_extra_mode: std_logic;
signal inject_optical_switch_counter: unsigned(6 downto 0);
signal inject_laser2_extra_coarse_scale: unsigned(15 downto 0);
signal inject_use_extra: std_logic;
signal inject_laser3_fine: unsigned(15 downto 0);
signal inject_laser3_fine_current: unsigned(15 downto 0);
signal inject_strobe_prev: std_logic;
signal inject_laser2_extra_fine_scale: unsigned(15 downto 0);
signal inject_extra_current_counter: unsigned(3 downto 0);
signal inject_laser3_extra_coarse_scale: unsigned(15 downto 0);
signal inject_laser3_coarse: unsigned(15 downto 0);
signal inject_laser3_fine_current_range: unsigned(15 downto 0);
signal inject_fs_mult_p: unsigned(33 downto 0);
signal inject_fs_mult_b: unsigned(16 downto 0);
signal inject_fs_mult_a: unsigned(16 downto 0);
signal inject_control: unsigned(15 downto 0);
signal inject_laser2_coarse: unsigned(15 downto 0);
signal inject_sw1_2way: std_logic;
signal inject_laser_current_en: unsigned(3 downto 0);
signal inject_soa_present: std_logic;
signal inject_laser4_extra_coarse_scale: unsigned(15 downto 0);
signal inject_laser_shutdown_en: std_logic;
signal inject_laser1_extra_fine_scale: unsigned(15 downto 0);
signal inject_cs_mult_b: unsigned(16 downto 0);
signal inject_cs_mult_a: unsigned(16 downto 0);
signal inject_laser4_coarse_scaled: unsigned(15 downto 0);
signal inject_laser2_coarse_current: unsigned(15 downto 0);
signal inject_laser2_fine_current_range: unsigned(15 downto 0);
signal inject_cs_mult_p: unsigned(33 downto 0);
signal inject_laser2_fine_current: unsigned(15 downto 0);
signal inject_soa_shutdown_en: std_logic;
signal inject_laser1_extra_coarse_scale: unsigned(15 downto 0);
signal inject_laser3_coarse_scaled: unsigned(15 downto 0);
signal inject_manual_soa_en: std_logic;
signal inject_laser2_coarse_scaled: unsigned(15 downto 0);
signal inject_laser4_extra_offset: unsigned(15 downto 0);
signal inject_switchPulserState: t_enum_SwitchPulserState_8;
signal inject_use_extra_r: std_logic;
signal inject_laser4_coarse: unsigned(15 downto 0);
signal inject_dac_strobe: std_logic;
signal inject_extended_mode: std_logic;
signal inject_laser4_extra_fine_scale: unsigned(15 downto 0);
signal inject_laser2_fine: unsigned(15 downto 0);
signal inject_laser1_coarse_scaled: unsigned(15 downto 0);
signal inject_laser4_fine: unsigned(15 downto 0);
signal inject_laser1_fine_current_range: unsigned(15 downto 0);
signal inject_laser4_dac_counter: unsigned(5 downto 0);
signal inject_laser4_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser4_dac_state: t_enum_t_State_6;
signal inject_laser4_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser3_dac_counter: unsigned(5 downto 0);
signal inject_laser3_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser3_dac_state: t_enum_t_State_6;
signal inject_laser3_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser2_dac_counter: unsigned(5 downto 0);
signal inject_laser2_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser2_dac_state: t_enum_t_State_6;
signal inject_laser2_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser1_dac_counter: unsigned(5 downto 0);
signal inject_laser1_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser1_dac_state: t_enum_t_State_6;
signal inject_laser1_dac_chanB_data: unsigned(15 downto 0);
signal inject_fine_scale_multiplier_a_s: signed (17 downto 0);
signal inject_fine_scale_multiplier_b_s: signed (17 downto 0);
signal inject_fine_scale_multiplier_p_s: signed (35 downto 0);
signal inject_coarse_scale_multiplier_a_s: signed (17 downto 0);
signal inject_coarse_scale_multiplier_b_s: signed (17 downto 0);
signal inject_coarse_scale_multiplier_p_s: signed (35 downto 0);
signal clkgen_div1M: unsigned(2 downto 0);
signal clkgen_ff2: std_logic;
signal clkgen_ff1: std_logic;
signal clkgen_div5: unsigned(2 downto 0);
signal clkgen_div25: unsigned(4 downto 0);
signal dsp_interface_done_wr_d: std_logic;
signal dsp_interface_done_wr: std_logic;
signal dsp_interface_done_rd_d: std_logic;
signal dsp_interface_ce_h: std_logic;
signal dsp_interface_done_rd: std_logic;
signal dsp_interface_we_h: std_logic;
signal dsp_interface_re_h: std_logic;

begin


meta7 <= to_unsigned(0, 16);




engine2_pwm_out <= pwm_engine2_pwm;
engine2_pwm_inv <= (pwm_engine2_pwm xor pwm_engine2_cs(PWM_CS_CONT_B));
pwm_engine2_temp <= (resize(pwm_engine2_dither_cntr, 9) + resize(pwm_engine2_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_ENGINE2_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_engine2_cs <= to_unsigned(0, 16);
        pwm_engine2_pulse_width <= to_unsigned(0, 16);
        pwm_engine2_main_cntr <= to_unsigned(0, 8);
        pwm_engine2_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = pwm_cs_addr) then
                if bool(dsp_wr) then
                    pwm_engine2_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_engine2 <= resize(pwm_engine2_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = pwm_pulse_width_addr) then
                if bool(dsp_wr) then
                    pwm_engine2_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_engine2 <= resize(pwm_engine2_pulse_width, 32);
            else
                dsp_data_in_pwm_engine2 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_engine2 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_engine2_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_engine2_cs(PWM_CS_CONT_B))) then
                pwm_engine2_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_engine2_pwm <= '0';
            if (pwm_engine2_main_cntr < pwm_engine2_pulse_width(width-1 downto (width - main_width))) then
                pwm_engine2_pwm <= '1';
            elsif (pwm_engine2_main_cntr = pwm_engine2_pulse_width(width-1 downto dither_width)) then
                if (pwm_engine2_temp >= mod_dither) then
                    pwm_engine2_pwm <= '1';
                    pwm_engine2_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_engine2_dither_cntr <= resize(pwm_engine2_temp - mod_dither, 8);
                else
                    pwm_engine2_dither_cntr <= resize(pwm_engine2_temp, 8);
                end if;
            end if;
            pwm_engine2_main_cntr <= ((pwm_engine2_main_cntr + 1) mod mod_main);
        end if;
        pwm_engine2_cs(PWM_CS_PWM_OUT_B) <= pwm_engine2_pwm;
    end if;
end process MAIN_PWM_ENGINE2_LOGIC;


MAIN_AUXPZTDAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        auxPztDac_chanD_data <= to_unsigned(0, 16);
        auxPztDac_dac_ld <= '1';
    elsif rising_edge(clk0) then
        case auxPztDac_state is
            when IDLE =>
                if bool(pulse_100k) then
                    auxPztDac_chanD_data <= laser_fine_current;
                    auxPztDac_counter <= to_unsigned(0, 5);
                    auxPztDac_dac_ld <= '0';
                    auxPztDac_state <= WAIT_0;
                end if;
            when WAIT_0 =>
                if (not bool(clk_2M5)) then
                    if (signed(resize(auxPztDac_counter, 6)) < (CHAND_DATA_END - 1)) then
                        auxPztDac_counter <= (auxPztDac_counter + 1);
                        auxPztDac_state <= WAIT_1;
                    else
                        auxPztDac_dac_ld <= '1';
                        auxPztDac_state <= IDLE;
                    end if;
                end if;
            when WAIT_1 =>
                if bool(clk_2M5) then
                    auxPztDac_dac_ld <= '0';
                    auxPztDac_state <= WAIT_0;
                end if;
            when others =>
                auxPztDac_state <= IDLE;
        end case;
        aux_pzt_dac_sdi <= auxPztDac_dac_sdi;
        aux_pzt_dac_ld <= auxPztDac_dac_ld;
        aux_pzt_dac_sck <= clk_2M5;
    end if;
end process MAIN_AUXPZTDAC_LOGIC;


MAIN_AUXPZTDAC_COMB2: process (auxPztDac_chanD_data, auxPztDac_counter) is
begin
    auxPztDac_dac_sdi <= '1';
    if ((CHAND_CONTROL_START <= auxPztDac_counter) and (auxPztDac_counter < CHAND_CONTROL_END)) then
        case ((CHAND_CONTROL_END - 1) - to_integer(auxPztDac_counter)) is
            when 0 => auxPztDac_dac_sdi <= '1';
            when 1 => auxPztDac_dac_sdi <= '1';
            when 2 => auxPztDac_dac_sdi <= '0';
            when 3 => auxPztDac_dac_sdi <= '0';
            when 4 => auxPztDac_dac_sdi <= '1';
            when 5 => auxPztDac_dac_sdi <= '1';
            when 6 => auxPztDac_dac_sdi <= '0';
            when others => auxPztDac_dac_sdi <= '0';
        end case;
    elsif ((CHAND_DATA_START <= auxPztDac_counter) and (auxPztDac_counter < CHAND_DATA_END)) then
        auxPztDac_dac_sdi <= auxPztDac_chanD_data(((CHAND_DATA_END - 1) - to_integer(auxPztDac_counter)));
    else
        auxPztDac_dac_sdi <= '0';
    end if;
end process MAIN_AUXPZTDAC_COMB2;


MAIN_DYNAMICPWMOUTLET_COMB: process (dynamicPwmOutlet_cs, dynamicPwmOutlet_dither_cntr, dynamicPwmOutlet_pwm, dynamicPwmOutlet_pulse_width) is
begin
    if bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_ENABLE_B)) then
        outlet_valve_pwm <= dynamicPwmOutlet_pwm;
    else
        outlet_valve_pwm <= '0';
    end if;
    dynamicPwmOutlet_temp <= (resize(dynamicPwmOutlet_dither_cntr, 9) + resize(dynamicPwmOutlet_pulse_width(dither_width-1 downto 0), 9));
end process MAIN_DYNAMICPWMOUTLET_COMB;


MAIN_DYNAMICPWMOUTLET_LOGIC: process (clk0, reset) is
    variable value: unsigned(23 downto 0);
begin
    if bool(reset) then
        dynamicPwmOutlet_cs <= to_unsigned(0, 16);
        dynamicPwmOutlet_delta <= to_signed(0, 16);
        dynamicPwmOutlet_high <= to_unsigned(0, 16);
        dynamicPwmOutlet_low <= to_unsigned(0, 16);
        dynamicPwmOutlet_slope <= to_unsigned(0, 16);
        dynamicPwmOutlet_pulse_width <= to_unsigned(32768, 16);
        dynamicPwmOutlet_main_cntr <= to_unsigned(0, 8);
        dynamicPwmOutlet_dither_cntr <= to_unsigned(0, 8);
        dynamicPwmOutlet_acc((FPGA_REG_WIDTH + extra)-1 downto 0) <= to_unsigned(0, 24);
        dynamicPwmOutlet_up <= '0';
        dynamicPwmOutlet_extra0 <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_cs_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_cs <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(dynamicPwmOutlet_cs, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_delta_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_delta <= resize(signed(dsp_data_out), 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(unsigned(dynamicPwmOutlet_delta(FPGA_REG_WIDTH-1 downto 0)), 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_high_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_high <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(dynamicPwmOutlet_high, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_low_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_low <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(dynamicPwmOutlet_low, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_slope_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_slope <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(dynamicPwmOutlet_slope, 32);
                else
                    dsp_data_in_dynamicpwm_outlet <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_dynamicpwm_outlet <= to_unsigned(0, 32);
        end if;
        if bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_RUN_B)) then
            if (not bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_CONT_B))) then
                dynamicPwmOutlet_cs(DYNAMICPWM_CS_RUN_B) <= '0';
            end if;
            value := resize(dynamicPwmOutlet_acc((FPGA_REG_WIDTH + extra)-1 downto extra), 24);
            if bool(pulse_100k) then
                if bool(dynamicPwmOutlet_up) then
                    if ((dynamicPwmOutlet_acc + dynamicPwmOutlet_slope) > unsigned'(dynamicPwmOutlet_high & dynamicPwmOutlet_extra0)) then
                        dynamicPwmOutlet_acc <= unsigned'(dynamicPwmOutlet_high & dynamicPwmOutlet_extra0);
                        dynamicPwmOutlet_up <= '0';
                    else
                        dynamicPwmOutlet_acc <= (dynamicPwmOutlet_acc + dynamicPwmOutlet_slope);
                    end if;
                else
                    if ((signed(resize(dynamicPwmOutlet_acc, 25)) - signed(resize(dynamicPwmOutlet_slope, 17))) < signed(resize(unsigned'(dynamicPwmOutlet_low & dynamicPwmOutlet_extra0), 25))) then
                        dynamicPwmOutlet_acc <= unsigned'(dynamicPwmOutlet_low & dynamicPwmOutlet_extra0);
                        dynamicPwmOutlet_up <= '1';
                    else
                        dynamicPwmOutlet_acc <= (dynamicPwmOutlet_acc - dynamicPwmOutlet_slope);
                    end if;
                end if;
                if bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_USE_COMPARATOR_B)) then
                    if (dynamicPwmOutlet_delta > 0) then
                        if bool(outlet_valve_comparator) then
                            if ((signed(resize(dynamicPwmOutlet_pulse_width, 17)) + dynamicPwmOutlet_delta) < MAX_WIDTH) then
                                dynamicPwmOutlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmOutlet_pulse_width, 17)) + dynamicPwmOutlet_delta), 16);
                            else
                                dynamicPwmOutlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
                            end if;
                        else
                            if ((signed(resize(dynamicPwmOutlet_pulse_width, 17)) - dynamicPwmOutlet_delta) > MIN_WIDTH) then
                                dynamicPwmOutlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmOutlet_pulse_width, 17)) - dynamicPwmOutlet_delta), 16);
                            else
                                dynamicPwmOutlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
                            end if;
                        end if;
                    else
                        if bool(outlet_valve_comparator) then
                            if ((signed(resize(dynamicPwmOutlet_pulse_width, 17)) + dynamicPwmOutlet_delta) > MIN_WIDTH) then
                                dynamicPwmOutlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmOutlet_pulse_width, 17)) + dynamicPwmOutlet_delta), 16);
                            else
                                dynamicPwmOutlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
                            end if;
                        else
                            if ((signed(resize(dynamicPwmOutlet_pulse_width, 17)) - dynamicPwmOutlet_delta) < MAX_WIDTH) then
                                dynamicPwmOutlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmOutlet_pulse_width, 17)) - dynamicPwmOutlet_delta), 16);
                            else
                                dynamicPwmOutlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
                            end if;
                        end if;
                    end if;
                else
                    dynamicPwmOutlet_pulse_width <= resize(value, 16);
                end if;
            end if;
            if (dynamicPwmOutlet_acc > unsigned'(dynamicPwmOutlet_high & dynamicPwmOutlet_extra0)) then
                dynamicPwmOutlet_acc <= unsigned'(dynamicPwmOutlet_high & dynamicPwmOutlet_extra0);
            end if;
            if (dynamicPwmOutlet_acc < unsigned'(dynamicPwmOutlet_low & dynamicPwmOutlet_extra0)) then
                dynamicPwmOutlet_acc <= unsigned'(dynamicPwmOutlet_low & dynamicPwmOutlet_extra0);
            end if;
            if (dynamicPwmOutlet_pulse_width > MAX_WIDTH) then
                dynamicPwmOutlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
            end if;
            if (dynamicPwmOutlet_pulse_width < MIN_WIDTH) then
                dynamicPwmOutlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
            end if;
            dynamicPwmOutlet_pwm <= dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_INVERT_B);
            if (dynamicPwmOutlet_main_cntr < dynamicPwmOutlet_pulse_width(width-1 downto (width - main_width))) then
                dynamicPwmOutlet_pwm <= stdl((not bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_INVERT_B))));
            elsif (dynamicPwmOutlet_main_cntr = dynamicPwmOutlet_pulse_width(width-1 downto dither_width)) then
                if (dynamicPwmOutlet_temp >= mod_dither) then
                    dynamicPwmOutlet_pwm <= stdl((not bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_INVERT_B))));
                    dynamicPwmOutlet_dither_cntr <= resize(dynamicPwmOutlet_temp - mod_dither, 8);
                else
                    dynamicPwmOutlet_dither_cntr <= resize(dynamicPwmOutlet_temp, 8);
                end if;
            end if;
            dynamicPwmOutlet_main_cntr <= ((dynamicPwmOutlet_main_cntr + 1) mod mod_main);
            outlet_valve_dac <= resize(value, 16);
        end if;
        dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_OUT_B) <= dynamicPwmOutlet_pwm;
    end if;
end process MAIN_DYNAMICPWMOUTLET_LOGIC;



signed_mult18x18_5 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => rdsim_mult_a_s, B => rdsim_mult_b_s, P => rdsim_mult_p_s
    );


MAIN_RDSIM_MULT_COMB: process (rdsim_a, rdsim_b, rdsim_mult_p_s) is
begin
    rdsim_mult_a_s(17-1 downto 0) <= signed(rdsim_a);
    rdsim_mult_a_s(17) <= '0';
    rdsim_mult_b_s(17-1 downto 0) <= signed(rdsim_b);
    rdsim_mult_b_s(17) <= '0';
    rdsim_p <= unsigned(rdsim_mult_p_s(34-1 downto 0));
end process MAIN_RDSIM_MULT_COMB;


MAIN_RDSIM_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        rdsim_options <= to_unsigned(0, 1);
        rdsim_pzt_center <= to_unsigned(0, 16);
        rdsim_pzt_window_half_width <= to_unsigned(0, 16);
        rdsim_filling_rate <= to_unsigned(0, 16);
        rdsim_decay <= to_unsigned(0, 16);
        rdsim_decay_in_shift <= to_unsigned(0, 4);
        rdsim_decay_in_offset <= to_unsigned(0, 16);
        rdsim_accumulator <= to_unsigned(0, 20);
        rdsim_state <= INIT;
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdsim_options_addr) then
                    if bool(dsp_wr) then
                        rdsim_options <= resize(dsp_data_out, 1);
                    end if;
                    dsp_data_in_rdsim <= resize(rdsim_options, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdsim_pzt_center_addr) then
                    if bool(dsp_wr) then
                        rdsim_pzt_center <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_rdsim <= resize(rdsim_pzt_center, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdsim_pzt_window_half_width_addr) then
                    if bool(dsp_wr) then
                        rdsim_pzt_window_half_width <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_rdsim <= resize(rdsim_pzt_window_half_width, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdsim_filling_rate_addr) then
                    if bool(dsp_wr) then
                        rdsim_filling_rate <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_rdsim <= resize(rdsim_filling_rate, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdsim_decay_addr) then
                    if bool(dsp_wr) then
                        rdsim_decay <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_rdsim <= resize(rdsim_decay, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdsim_decay_in_shift_addr) then
                    if bool(dsp_wr) then
                        rdsim_decay_in_shift <= resize(dsp_data_out, 4);
                    end if;
                    dsp_data_in_rdsim <= resize(rdsim_decay_in_shift, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdsim_decay_in_offset_addr) then
                    if bool(dsp_wr) then
                        rdsim_decay_in_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_rdsim <= resize(rdsim_decay_in_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdsim_accumulator_addr) then
                    dsp_data_in_rdsim <= resize(rdsim_accumulator, 32);
                else
                    dsp_data_in_rdsim <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_rdsim <= to_unsigned(0, 32);
        end if;
        if bool(rdsim_options(RDSIM_OPTIONS_INPUT_SEL_B)) then
            rdsim_decay <= (rdsim_decay_in_offset + shift_right(sim_loss, to_integer(rdsim_decay_in_shift)));
            rdsim_pzt_center <= sim_pzt;
        end if;
        rdsim_residual <= resize(unsigned(((signed(resize(pzt, 17)) - signed(resize(rdsim_pzt_center, 17))) and to_signed(rmask, 17))), 14);
        case rdsim_state is
            when INIT =>
                if bool(adc_clk) then
                    if ((signed(rdsim_residual) < signed(resize(rdsim_pzt_window_half_width, 17))) and (signed(rdsim_residual) > (-rdsim_pzt_window_half_width)) and (not bool(rd_trig))) then
                        rdsim_accumulator <= (rdsim_accumulator + rdsim_filling_rate);
                    else
                        rdsim_accumulator <= (rdsim_accumulator - unsigned'(to_unsigned(0, 4) & rdsim_p(34-1 downto (34 - FPGA_REG_WIDTH))));
                    end if;
                    rdsim_state <= GENVALUE;
                end if;
            when GENVALUE =>
                if (not bool(adc_clk)) then
                    rdsim_state <= INIT;
                end if;
            when others =>
                rdsim_state <= INIT;
        end case;
        rdsim_value <= rdsim_accumulator((FPGA_REG_WIDTH + RDSIM_EXTRA)-1 downto RDSIM_EXTRA);
        rdsim_a <= rdsim_accumulator((FPGA_REG_WIDTH + RDSIM_EXTRA)-1 downto ((FPGA_REG_WIDTH + RDSIM_EXTRA) - 17));
        rdsim_b <= unsigned'(rdsim_decay & to_unsigned(0, 1));
    end if;
end process MAIN_RDSIM_LOGIC;



filter_heater_pwm_out <= pwm_filter_heater_pwm;
filter_heater_pwm_inv_out <= (pwm_filter_heater_pwm xor pwm_filter_heater_cs(PWM_CS_CONT_B));
pwm_filter_heater_temp <= (resize(pwm_filter_heater_dither_cntr, 9) + resize(pwm_filter_heater_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_FILTER_HEATER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_filter_heater_cs <= to_unsigned(0, 16);
        pwm_filter_heater_pulse_width <= to_unsigned(0, 16);
        pwm_filter_heater_main_cntr <= to_unsigned(0, 8);
        pwm_filter_heater_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 32) then
                if bool(dsp_wr) then
                    pwm_filter_heater_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_filter_heater <= resize(pwm_filter_heater_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 33) then
                if bool(dsp_wr) then
                    pwm_filter_heater_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_filter_heater <= resize(pwm_filter_heater_pulse_width, 32);
            else
                dsp_data_in_pwm_filter_heater <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_filter_heater <= to_unsigned(0, 32);
        end if;
        if bool(pwm_filter_heater_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_filter_heater_cs(PWM_CS_CONT_B))) then
                pwm_filter_heater_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_filter_heater_pwm <= '0';
            if (pwm_filter_heater_main_cntr < pwm_filter_heater_pulse_width(width-1 downto (width - main_width))) then
                pwm_filter_heater_pwm <= '1';
            elsif (pwm_filter_heater_main_cntr = pwm_filter_heater_pulse_width(width-1 downto dither_width)) then
                if (pwm_filter_heater_temp >= mod_dither) then
                    pwm_filter_heater_pwm <= '1';
                    pwm_filter_heater_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_filter_heater_dither_cntr <= resize(pwm_filter_heater_temp - mod_dither, 8);
                else
                    pwm_filter_heater_dither_cntr <= resize(pwm_filter_heater_temp, 8);
                end if;
            end if;
            pwm_filter_heater_main_cntr <= ((pwm_filter_heater_main_cntr + 1) mod mod_main);
        end if;
        pwm_filter_heater_cs(PWM_CS_PWM_OUT_B) <= pwm_filter_heater_pwm;
    end if;
end process MAIN_PWM_FILTER_HEATER_LOGIC;



dual_port_ram_6 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => rdmemory_enA_meta, wr_enableA => rdmemory_wr_enable,
    addressA => rdmemory_meta_addrA, rd_dataA => rdmemory_rd_metaA, wr_dataA => rdmemory_wr_metaA,
    clockB => clk0, enableB => rdmemory_enB_meta, wr_enableB => meta_we,
    addressB => rdmemory_meta_addrB, rd_dataB => meta, wr_dataB => wr_meta
    );


MAIN_RDMEMORY_COMB: process (dsp_data_out, meta_addr, dsp_wr, rdmemory_rd_dataA, data_addr, rdmemory_rd_paramA, dsp_addr, param_addr, rdmemory_rd_metaA, bank) is
    variable sel_meta: std_logic;
    variable sel_data_and_metadata: std_logic;
    variable sel_param: std_logic;
    variable sel_data: std_logic;
begin
    sel_data_and_metadata := stdl((dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 6) or (dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 2));
    rdmemory_wr_enable <= stdl(bool(dsp_wr) and (not bool(sel_data_and_metadata)));
    rdmemory_enB_data <= '1';
    sel_data := stdl((dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 4) or (dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 0) or bool(sel_data_and_metadata));
    rdmemory_data_addrA(DATA_BANK_ADDR_WIDTH-1 downto 0) <= dsp_addr(DATA_BANK_ADDR_WIDTH-1 downto 0);
    rdmemory_data_addrA(DATA_BANK_ADDR_WIDTH) <= dsp_addr((RDMEM_RESERVED_BANK_ADDR_WIDTH + 2));
    rdmemory_enA_data <= sel_data;
    rdmemory_data_addrB(DATA_BANK_ADDR_WIDTH-1 downto 0) <= data_addr;
    rdmemory_data_addrB(DATA_BANK_ADDR_WIDTH) <= bank;
    rdmemory_wr_dataA <= dsp_data_out(RDMEM_DATA_WIDTH-1 downto 0);
    rdmemory_enB_meta <= '1';
    sel_meta := stdl((dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 5) or (dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 1) or bool(sel_data_and_metadata));
    rdmemory_meta_addrA(META_BANK_ADDR_WIDTH-1 downto 0) <= dsp_addr(META_BANK_ADDR_WIDTH-1 downto 0);
    rdmemory_meta_addrA(META_BANK_ADDR_WIDTH) <= dsp_addr((RDMEM_RESERVED_BANK_ADDR_WIDTH + 2));
    rdmemory_enA_meta <= sel_meta;
    rdmemory_meta_addrB(META_BANK_ADDR_WIDTH-1 downto 0) <= meta_addr;
    rdmemory_meta_addrB(META_BANK_ADDR_WIDTH) <= bank;
    rdmemory_wr_metaA <= dsp_data_out(RDMEM_META_WIDTH-1 downto 0);
    rdmemory_enB_param <= '1';
    sel_param := stdl((dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 7) or (dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 3));
    rdmemory_param_addrA(PARAM_BANK_ADDR_WIDTH-1 downto 0) <= dsp_addr(PARAM_BANK_ADDR_WIDTH-1 downto 0);
    rdmemory_param_addrA(PARAM_BANK_ADDR_WIDTH) <= dsp_addr((RDMEM_RESERVED_BANK_ADDR_WIDTH + 2));
    rdmemory_enA_param <= sel_param;
    rdmemory_param_addrB(PARAM_BANK_ADDR_WIDTH-1 downto 0) <= param_addr;
    rdmemory_param_addrB(PARAM_BANK_ADDR_WIDTH) <= bank;
    rdmemory_wr_paramA <= dsp_data_out(RDMEM_PARAM_WIDTH-1 downto 0);
    if bool(sel_data_and_metadata) then
        dsp_data_in_rdmemory(FPGA_REG_WIDTH-1 downto 0) <= rdmemory_rd_dataA(FPGA_REG_WIDTH-1 downto 0);
        dsp_data_in_rdmemory(EMIF_DATA_WIDTH-1 downto FPGA_REG_WIDTH) <= rdmemory_rd_metaA(FPGA_REG_WIDTH-1 downto 0);
    elsif bool(sel_data) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_dataA(RDMEM_DATA_WIDTH-1 downto 0), 32);
    elsif bool(sel_meta) then
        dsp_data_in_rdmemory <= resize(rdmemory_rd_metaA(RDMEM_META_WIDTH-1 downto 0), 32);
    elsif bool(sel_param) then
        dsp_data_in_rdmemory <= rdmemory_rd_paramA(RDMEM_PARAM_WIDTH-1 downto 0);
    else
        dsp_data_in_rdmemory <= to_unsigned(0, 32);
    end if;
end process MAIN_RDMEMORY_COMB;



dual_port_ram_7 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 7, DATA_WIDTH => 32)
    port map (
    clockA => clk0, enableA => rdmemory_enA_param, wr_enableA => rdmemory_wr_enable,
    addressA => rdmemory_param_addrA, rd_dataA => rdmemory_rd_paramA, wr_dataA => rdmemory_wr_paramA,
    clockB => clk0, enableB => rdmemory_enB_param, wr_enableB => param_we,
    addressB => rdmemory_param_addrB, rd_dataB => param, wr_dataB => wr_param
    );



dual_port_ram_5 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 18)
    port map (
    clockA => clk0, enableA => rdmemory_enA_data, wr_enableA => rdmemory_wr_enable,
    addressA => rdmemory_data_addrA, rd_dataA => rdmemory_rd_dataA, wr_dataA => rdmemory_wr_dataA,
    clockB => clk0, enableB => rdmemory_enB_data, wr_enableB => data_we,
    addressB => rdmemory_data_addrB, rd_dataB => data, wr_dataB => wr_data
    );


MAIN_WLMSIM_PROCESSOR: process (clk0, reset) is
    variable i: unsigned(3 downto 0);
    variable state: t_enum_t_procState_3;
    variable dz: signed(14 downto 0);
    variable dx: signed(15 downto 0);
    variable dy: signed(15 downto 0);
    variable y: signed(15 downto 0);
    variable x: signed(15 downto 0);
    variable z: signed(14 downto 0);
begin
    if bool(reset) then
        state := WAITING;
        wlmsim_xu <= to_unsigned(0, 16);
        wlmsim_yu <= to_unsigned(0, 16);
        wlmsim_done <= '0';
        x := to_signed(0, 16);
        y := to_signed(0, 16);
        z := to_signed(0, 15);
        i := to_unsigned(0, 4);
    elsif rising_edge(clk0) then
        case state is
            when WAITING =>
                if bool(wlmsim_start_cordic) then
                    x := signed(wlmsim_mult_p(34-1 downto 18));
                    y := to_signed(0, 16);
                    z := signed(wlmsim_zval((W - 1)-1 downto 0));
                    i := to_unsigned(0, 4);
                    wlmsim_done <= '0';
                    state := CALCULATING;
                end if;
            when others => -- CALCULATING
                dx := shift_right(y, to_integer(i));
                dy := shift_right(x, to_integer(i));
                case to_integer(i) is
                    when 0 => dz := "010000000000000";
                    when 1 => dz := "001001011100100";
                    when 2 => dz := "000100111111011";
                    when 3 => dz := "000010100010001";
                    when 4 => dz := "000001010001011";
                    when 5 => dz := "000000101000110";
                    when 6 => dz := "000000010100011";
                    when 7 => dz := "000000001010001";
                    when 8 => dz := "000000000101001";
                    when 9 => dz := "000000000010100";
                    when 10 => dz := "000000000001010";
                    when 11 => dz := "000000000000101";
                    when 12 => dz := "000000000000011";
                    when others => dz := "000000000000001";
                end case;
                if (z >= 0) then
                    x := (x - dx);
                    y := (y + dy);
                    z := (z - dz);
                else
                    x := (x + dx);
                    y := (y - dy);
                    z := (z + dz);
                end if;
                if (signed(resize(i, 5)) = (N - 1)) then
                    if (wlmsim_zval((W - 1)) /= wlmsim_zval((W - 2))) then
                        wlmsim_xu <= unsigned(M2 + x);
                        wlmsim_yu <= unsigned(M2 + y);
                    else
                        wlmsim_xu <= unsigned(M2 - x);
                        wlmsim_yu <= unsigned(M2 - y);
                    end if;
                    state := WAITING;
                    wlmsim_done <= '1';
                else
                    i := (i + 1);
                end if;
        end case;
    end if;
end process MAIN_WLMSIM_PROCESSOR;



signed_mult18x18_6 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => wlmsim_multiplier_a_s, B => wlmsim_multiplier_b_s, P => wlmsim_multiplier_p_s
    );


MAIN_WLMSIM_MULTIPLIER_COMB: process (wlmsim_mult_a, wlmsim_mult_b, wlmsim_multiplier_p_s) is
begin
    wlmsim_multiplier_a_s(17-1 downto 0) <= signed(wlmsim_mult_a);
    wlmsim_multiplier_a_s(17) <= '0';
    wlmsim_multiplier_b_s(17-1 downto 0) <= signed(wlmsim_mult_b);
    wlmsim_multiplier_b_s(17) <= '0';
    wlmsim_mult_p <= unsigned(wlmsim_multiplier_p_s(34-1 downto 0));
end process MAIN_WLMSIM_MULTIPLIER_COMB;


MAIN_WLMSIM_DIVIDER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        wlmsim_divider_rfd <= '1';
        wlmsim_div_rfd <= '1';
        wlmsim_divider_Nreg <= to_unsigned(0, 17);
        wlmsim_divider_Dreg <= to_unsigned(0, 16);
        wlmsim_divider_Qreg <= to_unsigned(0, 16);
        wlmsim_div_quot <= to_unsigned(0, 16);
        wlmsim_divider_done <= '0';
        wlmsim_divider_i <= to_unsigned(width - 1, 4);
    elsif rising_edge(clk0) then
        if bool(wlmsim_divider_done) then
            wlmsim_div_quot <= wlmsim_divider_Qreg;
            wlmsim_divider_rfd <= '1';
            wlmsim_div_rfd <= '1';
            wlmsim_divider_done <= '0';
        elsif (bool(wlmsim_divider_rfd) and bool(wlmsim_div_ce)) then
            wlmsim_divider_Nreg <= resize(wlmsim_div_num, 17);
            wlmsim_divider_Dreg <= wlmsim_div_den;
            wlmsim_divider_rfd <= '0';
            wlmsim_div_rfd <= '0';
            wlmsim_divider_i <= to_unsigned(width - 1, 4);
            wlmsim_divider_done <= '0';
        elsif (not bool(wlmsim_divider_rfd)) then
            if (wlmsim_divider_Nreg >= wlmsim_divider_Dreg) then
                wlmsim_divider_Qreg(to_integer(wlmsim_divider_i)) <= '1';
                wlmsim_divider_Nreg <= resize(unsigned(shift_left((signed(resize(wlmsim_divider_Nreg, 18)) - signed(resize(wlmsim_divider_Dreg, 17))), 1)), 17);
            else
                wlmsim_divider_Qreg(to_integer(wlmsim_divider_i)) <= '0';
                wlmsim_divider_Nreg <= shift_left(wlmsim_divider_Nreg, 1);
            end if;
            if (wlmsim_divider_i = 0) then
                wlmsim_divider_done <= '1';
                wlmsim_divider_i <= to_unsigned(width - 1, 4);
            else
                wlmsim_divider_i <= (wlmsim_divider_i - 1);
            end if;
        end if;
    end if;
end process MAIN_WLMSIM_DIVIDER_LOGIC;


MAIN_WLMSIM_LOGIC: process (clk0, reset) is
    variable state: t_enum_t_seqState_4;
begin
    if bool(reset) then
        wlmsim_options <= to_unsigned(0, 1);
        wlmsim_z0 <= to_unsigned(0, 16);
        wlmsim_rfac <= to_unsigned(32768, 16);
        wlmsim_wfac <= to_unsigned(63488, 16);
        wlmsim_laser_temp <= to_unsigned(0, 16);
        wlmsim_eta1_offset <= to_unsigned(0, 16);
        wlmsim_ref1_offset <= to_unsigned(0, 16);
        wlmsim_eta2_offset <= to_unsigned(0, 16);
        wlmsim_ref2_offset <= to_unsigned(0, 16);
        wlmsim_zval <= to_unsigned(0, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_options_addr) then
                    if bool(dsp_wr) then
                        wlmsim_options <= resize(dsp_data_out, 1);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_options, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_z0_addr) then
                    if bool(dsp_wr) then
                        wlmsim_z0 <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_z0, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_rfac_addr) then
                    if bool(dsp_wr) then
                        wlmsim_rfac <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_rfac, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_wfac_addr) then
                    if bool(dsp_wr) then
                        wlmsim_wfac <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_wfac, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_laser_temp_addr) then
                    if bool(dsp_wr) then
                        wlmsim_laser_temp <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_laser_temp, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_eta1_offset_addr) then
                    if bool(dsp_wr) then
                        wlmsim_eta1_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_eta1_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_ref1_offset_addr) then
                    if bool(dsp_wr) then
                        wlmsim_ref1_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_ref1_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_eta2_offset_addr) then
                    if bool(dsp_wr) then
                        wlmsim_eta2_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_eta2_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = wlmsim_ref2_offset_addr) then
                    if bool(dsp_wr) then
                        wlmsim_ref2_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_wlmsim <= resize(wlmsim_ref2_offset, 32);
                else
                    dsp_data_in_wlmsim <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_wlmsim <= to_unsigned(0, 32);
        end if;
        wlmsim_div_ce <= '0';
        if bool(wlmsim_options(WLMSIM_OPTIONS_INPUT_SEL_B)) then
            wlmsim_z0 <= (((((shift_left(wlmsim_laser_temp, 4) + shift_left(wlmsim_laser_temp, 1)) + shift_left(sel_coarse_current, 2)) + sel_coarse_current) + sel_fine_current) mod M);
        end if;
        if bool(reset) then
            state := IDLE;
            data_available_sim <= '1';
        else
            case state is
                when IDLE =>
                    wlmsim_mult_a(17-1 downto 1) <= to_unsigned(scale, 16);
                    wlmsim_div_num <= (M - wlmsim_rfac);
                    wlmsim_mult_b(17-1 downto 1) <= (wlmsim_rfac - 1);
                    if bool(pulse_100k) then
                        wlmsim_zval <= wlmsim_z0;
                        wlmsim_start_cordic <= '1';
                        state := WAIT_PROC1;
                        data_available_sim <= '0';
                    end if;
                when WAIT_PROC1 =>
                    wlmsim_start_cordic <= '0';
                    state := WAIT_PROC2;
                when WAIT_PROC2 =>
                    if bool(wlmsim_done) then
                        wlmsim_div_den <= wlmsim_yu;
                        wlmsim_div_ce <= '1';
                        state := WAIT_DIV1;
                    end if;
                when WAIT_DIV1 =>
                    if (bool(wlmsim_div_rfd) and (not bool(wlmsim_div_ce))) then
                        wlmsim_ref1 <= wlmsim_div_quot;
                        wlmsim_eta1 <= (M - wlmsim_div_quot);
                        wlmsim_div_den <= wlmsim_xu;
                        wlmsim_div_ce <= '1';
                        state := WAIT_DIV2;
                    end if;
                when WAIT_DIV2 =>
                    if (bool(wlmsim_div_rfd) and (not bool(wlmsim_div_ce))) then
                        wlmsim_ref2 <= wlmsim_div_quot;
                        wlmsim_eta2 <= (M - wlmsim_div_quot);
                        wlmsim_div_num <= (M - wlmsim_wfac);
                        wlmsim_mult_b(17-1 downto 1) <= (wlmsim_wfac - 1);
                        wlmsim_zval <= (shift_left(wlmsim_zval, 2) mod M);
                        wlmsim_start_cordic <= '1';
                        state := WAIT_PROC3;
                    end if;
                when WAIT_PROC3 =>
                    wlmsim_start_cordic <= '0';
                    state := WAIT_PROC4;
                when WAIT_PROC4 =>
                    if bool(wlmsim_done) then
                        wlmsim_div_den <= wlmsim_xu;
                        wlmsim_div_ce <= '1';
                        wlmsim_mult_a(17-1 downto 1) <= (((shift_right(sel_coarse_current, 1) + shift_right(sel_coarse_current, 3)) + shift_right(sel_fine_current, 3)) mod M);
                        state := WAIT_DIV3;
                    end if;
                when WAIT_DIV3 =>
                    if (bool(wlmsim_div_rfd) and (not bool(wlmsim_div_ce))) then
                        sim_loss <= wlmsim_div_quot;
                        wlmsim_mult_b(17-1 downto 1) <= wlmsim_eta1;
                        state := WAIT_SCALE1;
                    end if;
                when WAIT_SCALE1 =>
                    eta1_sim <= (wlmsim_mult_p(34-1 downto 18) + wlmsim_eta1_offset);
                    wlmsim_mult_b(17-1 downto 1) <= wlmsim_ref1;
                    state := WAIT_SCALE2;
                when WAIT_SCALE2 =>
                    ref1_sim <= (wlmsim_mult_p(34-1 downto 18) + wlmsim_ref1_offset);
                    wlmsim_mult_b(17-1 downto 1) <= wlmsim_eta2;
                    state := WAIT_SCALE3;
                when WAIT_SCALE3 =>
                    eta2_sim <= (wlmsim_mult_p(34-1 downto 18) + wlmsim_eta2_offset);
                    wlmsim_mult_b(17-1 downto 1) <= wlmsim_ref2;
                    state := WAIT_SCALE4;
                when others => -- WAIT_SCALE4
                    ref2_sim <= (wlmsim_mult_p(34-1 downto 18) + wlmsim_ref2_offset);
                    sim_pzt <= resize(unsigned((M - signed(shift_left(resize(wlmsim_zval, 17), 2))) mod M), 16);
                    data_available_sim <= '1';
                    state := IDLE;
            end case;
        end if;
    end if;
end process MAIN_WLMSIM_LOGIC;


MAIN_DSP_INTERFACE_LOGIC: process (clk0, reset) is
    variable dsp_addr_v: unsigned(19 downto 0);
    variable done_rd_v: std_logic;
    variable dsp_wr_v: std_logic;
    variable dsp_data_out_v: unsigned(31 downto 0);
    variable done_wr_v: std_logic;
    variable state_v: t_enum_t_State_5;
begin
    if bool(reset) then
        dsp_addr_v := to_unsigned(0, 20);
        dsp_data_out_v := to_unsigned(0, 32);
        dsp_wr_v := '0';
        done_rd_v := '0';
        done_wr_v := '0';
        state_v := INIT;
    elsif rising_edge(clk0) then
        dsp_wr_v := '0';
        case state_v is
            when INIT =>
                done_rd_v := '0';
                done_wr_v := '0';
                if bool(dsp_interface_ce_h) then
                    dsp_addr_v := dsp_emif_ea;
                    if bool(dsp_interface_re_h) then
                        state_v := READ1;
                    elsif bool(dsp_interface_we_h) then
                        state_v := WRITE1;
                    end if;
                end if;
            when WRITE1 =>
                dsp_data_out_v := dsp_emif_dout;
                dsp_wr_v := '1';
                done_wr_v := '1';
                state_v := WRITE2;
            when WRITE2 =>
                if (not bool(dsp_emif_we)) then
                    done_wr_v := '0';
                    state_v := IDLE;
                end if;
            when READ1 =>
                done_rd_v := '1';
                state_v := READ2;
            when READ2 =>
                if (not bool(dsp_emif_re)) then
                    done_rd_v := '0';
                    state_v := IDLE;
                end if;
            when others => -- IDLE
                state_v := INIT;
        end case;
    end if;
    dsp_addr <= dsp_addr_v;
    dsp_data_out <= dsp_data_out_v;
    dsp_wr <= dsp_wr_v;
    dsp_interface_done_rd_d <= done_rd_v;
    dsp_interface_done_wr_d <= done_wr_v;
end process MAIN_DSP_INTERFACE_LOGIC;



dsp_emif_ddir <= stdl(bool(dsp_emif_oe) and bool(ce2));
dsp_emif_ardy <= stdl((not bool(ce2)) or bool(dsp_interface_done_rd) or bool(dsp_interface_done_wr));
dsp_emif_din <= dsp_data_in;


MAIN_DSP_INTERFACE_HARDEN: process (clk0) is
begin
    if rising_edge(clk0) then
        dsp_interface_ce_h <= ce2;
        dsp_interface_we_h <= dsp_emif_we;
        dsp_interface_re_h <= dsp_emif_re;
    end if;
end process MAIN_DSP_INTERFACE_HARDEN;


MAIN_DSP_INTERFACE_MAKE_DONE_WR: process (clk0, dsp_emif_we) is
begin
    if (dsp_emif_we = '0') then
        dsp_interface_done_wr <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_wr <= dsp_interface_done_wr_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_WR;


MAIN_DSP_INTERFACE_MAKE_DONE_RD: process (clk0, dsp_emif_re) is
begin
    if (dsp_emif_re = '0') then
        dsp_interface_done_rd <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_rd <= dsp_interface_done_rd_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_RD;


MAIN_INJECT_COMB1: process (inject_control, inject_sw1_2way, inject_laser2_fine, inject_sw4_4way, inject_laser3_coarse_current, inject_laser3_fine, inject_laser1_fine, inject_control2, inject_laser2_coarse_current, pwm_laser4_out, inject_sw2_2way, inject_laser1_coarse_current, inject_laser4_fine, inject_laser4_coarse_current) is
    variable e: std_logic;
    variable s: unsigned(15 downto 0);
    variable m: std_logic;
    variable ext_mode: std_logic;
begin
    s := resize(inject_control((INJECT_CONTROL_LASER_SELECT_B + INJECT_CONTROL_LASER_SELECT_W)-1 downto INJECT_CONTROL_LASER_SELECT_B), 16);
    m := inject_control(INJECT_CONTROL_MODE_B);
    e := inject_control2(INJECT_CONTROL2_EXTINGUISH_DESELECTED_B);
    ext_mode := inject_control2(INJECT_CONTROL2_EXTENDED_CURRENT_MODE_B);
    inject_mode <= m;
    inject_sel <= resize(s, 2);
    inject_extinguish_deselected <= e;
    inject_extended_mode <= ext_mode;
    extended_current_mode <= ext_mode;
    if bool(inject_control(INJECT_CONTROL_OPTICAL_SWITCH_SELECT_B)) then
        sw1 <= s(0);
        sw2 <= s(1);
    else
        sw1 <= inject_sw1_2way;
        sw2 <= inject_sw2_2way;
    end if;
    sw4 <= inject_sw4_4way;
    if bool(inject_control2(INJECT_CONTROL2_FIBER_AMP_PRESENT_B)) then
        sw4 <= pwm_laser4_out;
    end if;
    inject_laser_current_en <= inject_control((INJECT_CONTROL_LASER_CURRENT_ENABLE_B + INJECT_CONTROL_LASER_CURRENT_ENABLE_W)-1 downto INJECT_CONTROL_LASER_CURRENT_ENABLE_B);
    inject_manual_laser_en <= inject_control((INJECT_CONTROL_MANUAL_LASER_ENABLE_B + INJECT_CONTROL_MANUAL_LASER_ENABLE_W)-1 downto INJECT_CONTROL_MANUAL_LASER_ENABLE_B);
    inject_manual_soa_en <= inject_control(INJECT_CONTROL_MANUAL_SOA_ENABLE_B);
    inject_laser_shutdown_en <= inject_control(INJECT_CONTROL_LASER_SHUTDOWN_ENABLE_B);
    inject_soa_shutdown_en <= inject_control(INJECT_CONTROL_SOA_SHUTDOWN_ENABLE_B);
    inject_soa_present <= inject_control(INJECT_CONTROL_SOA_PRESENT_B);
    inject_extra_mode <= inject_control2(INJECT_CONTROL2_EXTRA_MODE_B);
    inject_extra_enable <= inject_control2(INJECT_CONTROL2_EXTRA_ENABLE_B);
    inject_disable_soa_with_laser_mask <= inject_control2((INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_B + INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_W)-1 downto INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_B);
    sel_laser <= resize(s, 2);
    if (s = 0) then
        sel_coarse_current <= inject_laser1_coarse_current;
        sel_fine_current <= inject_laser1_fine;
    elsif (s = 1) then
        sel_coarse_current <= inject_laser2_coarse_current;
        sel_fine_current <= inject_laser2_fine;
    elsif (s = 2) then
        sel_coarse_current <= inject_laser3_coarse_current;
        sel_fine_current <= inject_laser3_fine;
    elsif (s = 3) then
        sel_coarse_current <= inject_laser4_coarse_current;
        sel_fine_current <= inject_laser4_fine;
    end if;
end process MAIN_INJECT_COMB1;


MAIN_INJECT_COMB2: process (inject_extra_enable, inject_manual_laser_en, inject_extinguish_deselected, inject_laser3_coarse_current, laser_extra, rd_trig, inject_disable_soa_with_laser_mask, inject_manual_soa_en, inject_laser2_coarse_current, inject_laser_current_en, inject_soa_present, inject_laser1_coarse_current, inject_extra_mode, inject_soa_shutdown_en, inject_laser4_coarse_current, inject_sel, inject_laser_shutdown_en, inject_mode) is
    variable laser_shutdown: std_logic;
begin
    lsr1_disable <= stdl((not bool(inject_laser_current_en(0))));
    lsr2_disable <= stdl((not bool(inject_laser_current_en(1))));
    lsr3_disable <= stdl((not bool(inject_laser_current_en(2))));
    lsr4_disable <= stdl((not bool(inject_laser_current_en(3))));
    inject_laser1_coarse <= inject_laser1_coarse_current;
    inject_laser2_coarse <= inject_laser2_coarse_current;
    inject_laser3_coarse <= inject_laser3_coarse_current;
    inject_laser4_coarse <= inject_laser4_coarse_current;
    sw3 <= stdl((not bool(inject_manual_soa_en)));
    laser_shutdown := stdl(bool(rd_trig) and bool(inject_laser_shutdown_en));
    if bool(inject_mode) then
        sw3 <= stdl(bool(rd_trig) and bool(inject_soa_shutdown_en));
        lsr1_rd <= laser_shutdown;
        lsr2_rd <= laser_shutdown;
        lsr3_rd <= laser_shutdown;
        lsr4_rd <= laser_shutdown;
        if bool(inject_extinguish_deselected) then
            case inject_sel is
                when "00" =>
                    inject_laser2_coarse <= to_unsigned(0, 16);
                    inject_laser3_coarse <= to_unsigned(0, 16);
                    inject_laser4_coarse <= to_unsigned(0, 16);
                when "01" =>
                    inject_laser1_coarse <= to_unsigned(0, 16);
                    inject_laser3_coarse <= to_unsigned(0, 16);
                    inject_laser4_coarse <= to_unsigned(0, 16);
                when "10" =>
                    inject_laser1_coarse <= to_unsigned(0, 16);
                    inject_laser2_coarse <= to_unsigned(0, 16);
                    inject_laser4_coarse <= to_unsigned(0, 16);
                when others =>
                    inject_laser1_coarse <= to_unsigned(0, 16);
                    inject_laser2_coarse <= to_unsigned(0, 16);
                    inject_laser3_coarse <= to_unsigned(0, 16);
            end case;
        end if;
    else
        lsr1_rd <= stdl((not bool(inject_manual_laser_en(0))));
        lsr2_rd <= stdl((not bool(inject_manual_laser_en(1))));
        lsr3_rd <= stdl((not bool(inject_manual_laser_en(2))));
        lsr4_rd <= stdl((not bool(inject_manual_laser_en(3))));
    end if;
    if ((not bool(inject_soa_present)) or ((inject_sel = 0) and bool(inject_disable_soa_with_laser_mask(0))) or ((inject_sel = 1) and bool(inject_disable_soa_with_laser_mask(1))) or ((inject_sel = 2) and bool(inject_disable_soa_with_laser_mask(2))) or ((inject_sel = 3) and bool(inject_disable_soa_with_laser_mask(3)))) then
        sw3 <= '1';
    end if;
    if bool(inject_extra_mode) then
        inject_use_extra <= inject_extra_enable;
    else
        inject_use_extra <= stdl(bool(inject_laser_shutdown_en) and bool(laser_extra));
    end if;
end process MAIN_INJECT_COMB2;



signed_mult18x18_2 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => inject_fine_scale_multiplier_a_s, B => inject_fine_scale_multiplier_b_s, P => inject_fine_scale_multiplier_p_s
    );


MAIN_INJECT_FINE_SCALE_MULTIPLIER_COMB: process (inject_fs_mult_a, inject_fs_mult_b, inject_fine_scale_multiplier_p_s) is
begin
    inject_fine_scale_multiplier_a_s(17-1 downto 0) <= signed(inject_fs_mult_a);
    inject_fine_scale_multiplier_a_s(17) <= '0';
    inject_fine_scale_multiplier_b_s(17-1 downto 0) <= signed(inject_fs_mult_b);
    inject_fine_scale_multiplier_b_s(17) <= '0';
    inject_fs_mult_p <= unsigned(inject_fine_scale_multiplier_p_s(34-1 downto 0));
end process MAIN_INJECT_FINE_SCALE_MULTIPLIER_COMB;


MAIN_INJECT_LASER3_DAC_COMB2: process (inject_laser3_dac_counter, inject_laser3_dac_chanB_data, inject_laser3_dac_chanA_data) is
begin
    if ((CHANA_CONTROL_START <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < CHANA_CONTROL_END)) then
        case ((CHANA_CONTROL_END - 1) - to_integer(inject_laser3_dac_counter)) is
            when 0 => lsr3_mosi_temp <= '0';
            when 1 => lsr3_mosi_temp <= '0';
            when 2 => lsr3_mosi_temp <= '0';
            when 3 => lsr3_mosi_temp <= '0';
            when 4 => lsr3_mosi_temp <= '0';
            when 5 => lsr3_mosi_temp <= '0';
            when 6 => lsr3_mosi_temp <= '0';
            when others => lsr3_mosi_temp <= '0';
        end case;
    elsif ((CHANA_DATA_START <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < CHANA_DATA_END)) then
        lsr3_mosi_temp <= inject_laser3_dac_chanA_data(((CHANA_DATA_END - 1) - to_integer(inject_laser3_dac_counter)));
    elsif ((CHANB_CONTROL_START <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < CHANB_CONTROL_END)) then
        case ((CHANB_CONTROL_END - 1) - to_integer(inject_laser3_dac_counter)) is
            when 0 => lsr3_mosi_temp <= '0';
            when 1 => lsr3_mosi_temp <= '0';
            when 2 => lsr3_mosi_temp <= '1';
            when 3 => lsr3_mosi_temp <= '0';
            when 4 => lsr3_mosi_temp <= '1';
            when 5 => lsr3_mosi_temp <= '1';
            when 6 => lsr3_mosi_temp <= '0';
            when others => lsr3_mosi_temp <= '0';
        end case;
    elsif ((CHANB_DATA_START <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < CHANB_DATA_END)) then
        lsr3_mosi_temp <= inject_laser3_dac_chanB_data(((CHANB_DATA_END - 1) - to_integer(inject_laser3_dac_counter)));
    else
        lsr3_mosi_temp <= '0';
    end if;
end process MAIN_INJECT_LASER3_DAC_COMB2;


MAIN_INJECT_LASER3_DAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_laser3_dac_counter <= to_unsigned(0, 6);
        lsr3_ss_temp <= '0';
    elsif rising_edge(clk0) then
        case inject_laser3_dac_state is
            when IDLE =>
                lsr3_ss_temp <= '0';
                if bool(inject_dac_strobe) then
                    inject_laser3_dac_chanA_data <= inject_laser3_coarse_scaled;
                    inject_laser3_dac_chanB_data <= inject_laser3_fine;
                    inject_laser3_dac_counter <= to_unsigned(0, 6);
                    lsr3_ss_temp <= '1';
                    inject_laser3_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_5M) then
                    if (inject_laser3_dac_counter < 49) then
                        if (inject_laser3_dac_counter = 24) then
                            lsr3_ss_temp <= '0';
                        end if;
                        inject_laser3_dac_counter <= (inject_laser3_dac_counter + 1);
                        inject_laser3_dac_state <= WAIT_0;
                    else
                        lsr3_ss_temp <= '0';
                        inject_laser3_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not bool(clk_5M)) then
                    lsr3_ss_temp <= '1';
                    inject_laser3_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser3_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER3_DAC_LOGIC;


MAIN_INJECT_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_control <= to_unsigned(0, 16);
        inject_control2 <= to_unsigned(0, 16);
        inject_laser1_coarse_current <= to_unsigned(0, 16);
        inject_laser2_coarse_current <= to_unsigned(0, 16);
        inject_laser3_coarse_current <= to_unsigned(0, 16);
        inject_laser4_coarse_current <= to_unsigned(0, 16);
        inject_laser1_fine_current <= to_unsigned(32768, 16);
        inject_laser2_fine_current <= to_unsigned(32768, 16);
        inject_laser3_fine_current <= to_unsigned(32768, 16);
        inject_laser4_fine_current <= to_unsigned(32768, 16);
        inject_laser1_fine_current_range <= to_unsigned(32767, 16);
        inject_laser2_fine_current_range <= to_unsigned(32767, 16);
        inject_laser3_fine_current_range <= to_unsigned(32767, 16);
        inject_laser4_fine_current_range <= to_unsigned(32767, 16);
        inject_laser1_extra_coarse_scale <= to_unsigned(0, 16);
        inject_laser2_extra_coarse_scale <= to_unsigned(0, 16);
        inject_laser3_extra_coarse_scale <= to_unsigned(0, 16);
        inject_laser4_extra_coarse_scale <= to_unsigned(0, 16);
        inject_laser1_extra_fine_scale <= to_unsigned(0, 16);
        inject_laser2_extra_fine_scale <= to_unsigned(0, 16);
        inject_laser3_extra_fine_scale <= to_unsigned(0, 16);
        inject_laser4_extra_fine_scale <= to_unsigned(0, 16);
        inject_laser1_extra_offset <= to_unsigned(0, 16);
        inject_laser2_extra_offset <= to_unsigned(0, 16);
        inject_laser3_extra_offset <= to_unsigned(0, 16);
        inject_laser4_extra_offset <= to_unsigned(0, 16);
        inject_strobe_prev <= metadata_strobe;
        inject_edge_strobe <= '0';
        inject_dac_strobe <= '0';
        inject_optical_switch_counter <= to_unsigned(0, 7);
        inject_pulse_counter <= to_unsigned(0, 7);
        inject_extra_current_counter <= to_unsigned(0, 4);
        inject_optSwitchState <= IDLE;
        inject_switchPulserState <= START;
        inject_sw4_4way <= '1';
        inject_use_extra_r <= '0';
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_control_addr) then
                    if bool(dsp_wr) then
                        inject_control <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_control, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_control2_addr) then
                    if bool(dsp_wr) then
                        inject_control2 <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_control2, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_coarse_current_addr) then
                    if bool(dsp_wr) then
                        inject_laser1_coarse_current <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser1_coarse_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_coarse_current_addr) then
                    if bool(dsp_wr) then
                        inject_laser2_coarse_current <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser2_coarse_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_coarse_current_addr) then
                    if bool(dsp_wr) then
                        inject_laser3_coarse_current <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser3_coarse_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_coarse_current_addr) then
                    if bool(dsp_wr) then
                        inject_laser4_coarse_current <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser4_coarse_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_fine_current_addr) then
                    if bool(dsp_wr) then
                        inject_laser1_fine_current <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser1_fine_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_fine_current_addr) then
                    if bool(dsp_wr) then
                        inject_laser2_fine_current <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser2_fine_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_fine_current_addr) then
                    if bool(dsp_wr) then
                        inject_laser3_fine_current <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser3_fine_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_fine_current_addr) then
                    if bool(dsp_wr) then
                        inject_laser4_fine_current <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser4_fine_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_fine_current_range_addr) then
                    if bool(dsp_wr) then
                        inject_laser1_fine_current_range <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser1_fine_current_range, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_fine_current_range_addr) then
                    if bool(dsp_wr) then
                        inject_laser2_fine_current_range <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser2_fine_current_range, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_fine_current_range_addr) then
                    if bool(dsp_wr) then
                        inject_laser3_fine_current_range <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser3_fine_current_range, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_fine_current_range_addr) then
                    if bool(dsp_wr) then
                        inject_laser4_fine_current_range <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser4_fine_current_range, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_extra_coarse_scale_addr) then
                    if bool(dsp_wr) then
                        inject_laser1_extra_coarse_scale <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser1_extra_coarse_scale, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_extra_coarse_scale_addr) then
                    if bool(dsp_wr) then
                        inject_laser2_extra_coarse_scale <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser2_extra_coarse_scale, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_extra_coarse_scale_addr) then
                    if bool(dsp_wr) then
                        inject_laser3_extra_coarse_scale <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser3_extra_coarse_scale, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_extra_coarse_scale_addr) then
                    if bool(dsp_wr) then
                        inject_laser4_extra_coarse_scale <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser4_extra_coarse_scale, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_extra_fine_scale_addr) then
                    if bool(dsp_wr) then
                        inject_laser1_extra_fine_scale <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser1_extra_fine_scale, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_extra_fine_scale_addr) then
                    if bool(dsp_wr) then
                        inject_laser2_extra_fine_scale <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser2_extra_fine_scale, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_extra_fine_scale_addr) then
                    if bool(dsp_wr) then
                        inject_laser3_extra_fine_scale <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser3_extra_fine_scale, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_extra_fine_scale_addr) then
                    if bool(dsp_wr) then
                        inject_laser4_extra_fine_scale <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser4_extra_fine_scale, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_extra_offset_addr) then
                    if bool(dsp_wr) then
                        inject_laser1_extra_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser1_extra_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_extra_offset_addr) then
                    if bool(dsp_wr) then
                        inject_laser2_extra_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser2_extra_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_extra_offset_addr) then
                    if bool(dsp_wr) then
                        inject_laser3_extra_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser3_extra_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_extra_offset_addr) then
                    if bool(dsp_wr) then
                        inject_laser4_extra_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_inject <= resize(inject_laser4_extra_offset, 32);
                else
                    dsp_data_in_inject <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_inject <= to_unsigned(0, 32);
        end if;
        inject_edge_strobe <= stdl(bool(metadata_strobe) and (not bool(inject_strobe_prev)));
        inject_strobe_prev <= metadata_strobe;
        if bool(inject_mode) then
            if bool(inject_extended_mode) then
                inject_laser1_fine <= laser1_fine_ext;
                inject_laser2_fine <= laser2_fine_ext;
                inject_laser3_fine <= laser3_fine_ext;
                inject_laser4_fine <= laser4_fine_ext;
            else
                if (laser_fine_current > (32768 + inject_laser1_fine_current_range)) then
                    inject_laser1_fine <= (32768 + inject_laser1_fine_current_range);
                elsif (signed(resize(laser_fine_current, 17)) < (32768 - signed(resize(inject_laser1_fine_current_range, 17)))) then
                    inject_laser1_fine <= (32768 - inject_laser1_fine_current_range);
                else
                    inject_laser1_fine <= laser_fine_current;
                end if;
                if (laser_fine_current > (32768 + inject_laser2_fine_current_range)) then
                    inject_laser2_fine <= (32768 + inject_laser2_fine_current_range);
                elsif (signed(resize(laser_fine_current, 17)) < (32768 - signed(resize(inject_laser2_fine_current_range, 17)))) then
                    inject_laser2_fine <= (32768 - inject_laser2_fine_current_range);
                else
                    inject_laser2_fine <= laser_fine_current;
                end if;
                if (laser_fine_current > (32768 + inject_laser3_fine_current_range)) then
                    inject_laser3_fine <= (32768 + inject_laser3_fine_current_range);
                elsif (signed(resize(laser_fine_current, 17)) < (32768 - signed(resize(inject_laser3_fine_current_range, 17)))) then
                    inject_laser3_fine <= (32768 - inject_laser3_fine_current_range);
                else
                    inject_laser3_fine <= laser_fine_current;
                end if;
                if (laser_fine_current > (32768 + inject_laser4_fine_current_range)) then
                    inject_laser4_fine <= (32768 + inject_laser4_fine_current_range);
                elsif (signed(resize(laser_fine_current, 17)) < (32768 - signed(resize(inject_laser4_fine_current_range, 17)))) then
                    inject_laser4_fine <= (32768 - inject_laser4_fine_current_range);
                else
                    inject_laser4_fine <= laser_fine_current;
                end if;
                if bool(inject_extinguish_deselected) then
                    case inject_sel is
                        when "00" =>
                            inject_laser2_fine <= to_unsigned(0, 16);
                            inject_laser3_fine <= to_unsigned(0, 16);
                            inject_laser4_fine <= to_unsigned(0, 16);
                        when "01" =>
                            inject_laser1_fine <= to_unsigned(0, 16);
                            inject_laser3_fine <= to_unsigned(0, 16);
                            inject_laser4_fine <= to_unsigned(0, 16);
                        when "10" =>
                            inject_laser1_fine <= to_unsigned(0, 16);
                            inject_laser2_fine <= to_unsigned(0, 16);
                            inject_laser4_fine <= to_unsigned(0, 16);
                        when others =>
                            inject_laser1_fine <= to_unsigned(0, 16);
                            inject_laser2_fine <= to_unsigned(0, 16);
                            inject_laser3_fine <= to_unsigned(0, 16);
                    end case;
                end if;
            end if;
        else
            inject_laser1_fine <= inject_laser1_fine_current;
            inject_laser2_fine <= inject_laser2_fine_current;
            inject_laser3_fine <= inject_laser3_fine_current;
            inject_laser4_fine <= inject_laser4_fine_current;
        end if;
        case inject_optSwitchState is
            when IDLE =>
                inject_sw1_2way <= '0';
                inject_sw2_2way <= '0';
                if (inject_sel(0) = '0') then
                    inject_optSwitchState <= PULSING_1;
                    inject_optical_switch_counter <= to_unsigned(0, 7);
                else
                    inject_optSwitchState <= PULSING_2;
                    inject_optical_switch_counter <= to_unsigned(0, 7);
                end if;
            when PULSING_1 =>
                inject_sw1_2way <= '1';
                inject_sw2_2way <= '0';
                if bool(inject_edge_strobe) then
                    if (signed(resize(inject_optical_switch_counter, 8)) >= (OPTICAL_SWITCH_WIDTH - 1)) then
                        inject_optSwitchState <= SELECTED_1;
                        inject_optical_switch_counter <= to_unsigned(0, 7);
                    else
                        inject_optical_switch_counter <= (inject_optical_switch_counter + 1);
                    end if;
                end if;
            when SELECTED_1 =>
                inject_sw1_2way <= '0';
                inject_sw2_2way <= '0';
                if (inject_sel(0) = '1') then
                    inject_optSwitchState <= PULSING_2;
                    inject_optical_switch_counter <= to_unsigned(0, 7);
                end if;
            when PULSING_2 =>
                inject_sw1_2way <= '0';
                inject_sw2_2way <= '1';
                if bool(inject_edge_strobe) then
                    if (signed(resize(inject_optical_switch_counter, 8)) >= (OPTICAL_SWITCH_WIDTH - 1)) then
                        inject_optSwitchState <= SELECTED_2;
                        inject_optical_switch_counter <= to_unsigned(0, 7);
                    else
                        inject_optical_switch_counter <= (inject_optical_switch_counter + 1);
                    end if;
                end if;
            when others => -- SELECTED_2
                inject_sw1_2way <= '0';
                inject_sw2_2way <= '0';
                if (inject_sel(0) = '0') then
                    inject_optSwitchState <= PULSING_1;
                    inject_optical_switch_counter <= to_unsigned(0, 7);
                end if;
        end case;
        if bool(inject_control(INJECT_CONTROL_OPTICAL_SWITCH_SELECT_B)) then
            case inject_switchPulserState is
                when START =>
                    inject_sw4_4way <= '1';
                    inject_switchPulserState <= PULSING;
                    inject_pulse_counter <= to_unsigned(0, 7);
                when PULSING =>
                    inject_sw4_4way <= '0';
                    inject_last_sel <= inject_sel;
                    if bool(inject_edge_strobe) then
                        if (signed(resize(inject_pulse_counter, 8)) >= (OPTICAL_SWITCH_WIDTH - 1)) then
                            inject_switchPulserState <= WAITING;
                            inject_pulse_counter <= to_unsigned(0, 7);
                        else
                            inject_pulse_counter <= (inject_pulse_counter + 1);
                        end if;
                    end if;
                when others => -- WAITING
                    inject_sw4_4way <= '1';
                    if (inject_sel /= inject_last_sel) then
                        inject_switchPulserState <= PULSING;
                        inject_pulse_counter <= to_unsigned(0, 7);
                    end if;
            end case;
        end if;
        case inject_extra_current_counter is
            when "0000" =>
                if bool(inject_edge_strobe) then
                    inject_use_extra_r <= inject_use_extra;
                    inject_extra_current_counter <= to_unsigned(1, 4);
                    inject_cs_mult_a <= unsigned'(inject_laser1_extra_coarse_scale & to_unsigned(0, 1));
                    inject_cs_mult_b <= unsigned'(inject_laser1_coarse & to_unsigned(0, 1));
                    inject_fs_mult_a <= unsigned'(inject_laser1_extra_fine_scale & to_unsigned(0, 1));
                    inject_fs_mult_b <= unsigned'(inject_laser1_fine & to_unsigned(0, 1));
                end if;
            when "0001" =>
                inject_extra_current_counter <= to_unsigned(2, 4);
                if bool(inject_use_extra_r) then
                    inject_laser1_coarse_scaled <= (((inject_cs_mult_p(33-1 downto 17) + inject_fs_mult_p(34-1 downto 18)) + inject_laser1_extra_offset) mod 65536);
                else
                    inject_laser1_coarse_scaled <= inject_laser1_coarse;
                end if;
            when "0010" =>
                inject_extra_current_counter <= to_unsigned(3, 4);
                inject_cs_mult_a <= unsigned'(inject_laser2_extra_coarse_scale & to_unsigned(0, 1));
                inject_cs_mult_b <= unsigned'(inject_laser2_coarse & to_unsigned(0, 1));
                inject_fs_mult_a <= unsigned'(inject_laser2_extra_fine_scale & to_unsigned(0, 1));
                inject_fs_mult_b <= unsigned'(inject_laser2_fine & to_unsigned(0, 1));
            when "0011" =>
                inject_extra_current_counter <= to_unsigned(4, 4);
                if bool(inject_use_extra_r) then
                    inject_laser2_coarse_scaled <= (((inject_cs_mult_p(33-1 downto 17) + inject_fs_mult_p(34-1 downto 18)) + inject_laser2_extra_offset) mod 65536);
                else
                    inject_laser2_coarse_scaled <= inject_laser2_coarse;
                end if;
            when "0100" =>
                inject_extra_current_counter <= to_unsigned(5, 4);
                inject_cs_mult_a <= unsigned'(inject_laser3_extra_coarse_scale & to_unsigned(0, 1));
                inject_cs_mult_b <= unsigned'(inject_laser3_coarse & to_unsigned(0, 1));
                inject_fs_mult_a <= unsigned'(inject_laser3_extra_fine_scale & to_unsigned(0, 1));
                inject_fs_mult_b <= unsigned'(inject_laser3_fine & to_unsigned(0, 1));
            when "0101" =>
                inject_extra_current_counter <= to_unsigned(6, 4);
                if bool(inject_use_extra_r) then
                    inject_laser3_coarse_scaled <= (((inject_cs_mult_p(33-1 downto 17) + inject_fs_mult_p(34-1 downto 18)) + inject_laser3_extra_offset) mod 65536);
                else
                    inject_laser3_coarse_scaled <= inject_laser3_coarse;
                end if;
            when "0110" =>
                inject_extra_current_counter <= to_unsigned(7, 4);
                inject_cs_mult_a <= unsigned'(inject_laser4_extra_coarse_scale & to_unsigned(0, 1));
                inject_cs_mult_b <= unsigned'(inject_laser4_coarse & to_unsigned(0, 1));
                inject_fs_mult_a <= unsigned'(inject_laser4_extra_fine_scale & to_unsigned(0, 1));
                inject_fs_mult_b <= unsigned'(inject_laser4_fine & to_unsigned(0, 1));
            when "0111" =>
                inject_extra_current_counter <= to_unsigned(8, 4);
                if bool(inject_use_extra_r) then
                    inject_laser4_coarse_scaled <= (((inject_cs_mult_p(33-1 downto 17) + inject_fs_mult_p(34-1 downto 18)) + inject_laser4_extra_offset) mod 65536);
                else
                    inject_laser4_coarse_scaled <= inject_laser4_coarse;
                end if;
            when "1111" =>
                inject_extra_current_counter <= to_unsigned(0, 4);
            when others =>
                inject_extra_current_counter <= (inject_extra_current_counter + 1);
        end case;
        inject_dac_strobe <= stdl(inject_extra_current_counter = 15);
    end if;
end process MAIN_INJECT_LOGIC;


MAIN_INJECT_LASER2_DAC_COMB2: process (inject_laser2_dac_counter, inject_laser2_dac_chanB_data, inject_laser2_dac_chanA_data) is
begin
    if ((CHANA_CONTROL_START <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < CHANA_CONTROL_END)) then
        case ((CHANA_CONTROL_END - 1) - to_integer(inject_laser2_dac_counter)) is
            when 0 => lsr2_mosi_temp <= '0';
            when 1 => lsr2_mosi_temp <= '0';
            when 2 => lsr2_mosi_temp <= '0';
            when 3 => lsr2_mosi_temp <= '0';
            when 4 => lsr2_mosi_temp <= '0';
            when 5 => lsr2_mosi_temp <= '0';
            when 6 => lsr2_mosi_temp <= '0';
            when others => lsr2_mosi_temp <= '0';
        end case;
    elsif ((CHANA_DATA_START <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < CHANA_DATA_END)) then
        lsr2_mosi_temp <= inject_laser2_dac_chanA_data(((CHANA_DATA_END - 1) - to_integer(inject_laser2_dac_counter)));
    elsif ((CHANB_CONTROL_START <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < CHANB_CONTROL_END)) then
        case ((CHANB_CONTROL_END - 1) - to_integer(inject_laser2_dac_counter)) is
            when 0 => lsr2_mosi_temp <= '0';
            when 1 => lsr2_mosi_temp <= '0';
            when 2 => lsr2_mosi_temp <= '1';
            when 3 => lsr2_mosi_temp <= '0';
            when 4 => lsr2_mosi_temp <= '1';
            when 5 => lsr2_mosi_temp <= '1';
            when 6 => lsr2_mosi_temp <= '0';
            when others => lsr2_mosi_temp <= '0';
        end case;
    elsif ((CHANB_DATA_START <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < CHANB_DATA_END)) then
        lsr2_mosi_temp <= inject_laser2_dac_chanB_data(((CHANB_DATA_END - 1) - to_integer(inject_laser2_dac_counter)));
    else
        lsr2_mosi_temp <= '0';
    end if;
end process MAIN_INJECT_LASER2_DAC_COMB2;


MAIN_INJECT_LASER2_DAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_laser2_dac_counter <= to_unsigned(0, 6);
        lsr2_ss_temp <= '0';
    elsif rising_edge(clk0) then
        case inject_laser2_dac_state is
            when IDLE =>
                lsr2_ss_temp <= '0';
                if bool(inject_dac_strobe) then
                    inject_laser2_dac_chanA_data <= inject_laser2_coarse_scaled;
                    inject_laser2_dac_chanB_data <= inject_laser2_fine;
                    inject_laser2_dac_counter <= to_unsigned(0, 6);
                    lsr2_ss_temp <= '1';
                    inject_laser2_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_5M) then
                    if (inject_laser2_dac_counter < 49) then
                        if (inject_laser2_dac_counter = 24) then
                            lsr2_ss_temp <= '0';
                        end if;
                        inject_laser2_dac_counter <= (inject_laser2_dac_counter + 1);
                        inject_laser2_dac_state <= WAIT_0;
                    else
                        lsr2_ss_temp <= '0';
                        inject_laser2_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not bool(clk_5M)) then
                    lsr2_ss_temp <= '1';
                    inject_laser2_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser2_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER2_DAC_LOGIC;


MAIN_INJECT_LASER1_DAC_COMB2: process (inject_laser1_dac_counter, inject_laser1_dac_chanB_data, inject_laser1_dac_chanA_data) is
begin
    if ((CHANA_CONTROL_START <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < CHANA_CONTROL_END)) then
        case ((CHANA_CONTROL_END - 1) - to_integer(inject_laser1_dac_counter)) is
            when 0 => lsr1_mosi_temp <= '0';
            when 1 => lsr1_mosi_temp <= '0';
            when 2 => lsr1_mosi_temp <= '0';
            when 3 => lsr1_mosi_temp <= '0';
            when 4 => lsr1_mosi_temp <= '0';
            when 5 => lsr1_mosi_temp <= '0';
            when 6 => lsr1_mosi_temp <= '0';
            when others => lsr1_mosi_temp <= '0';
        end case;
    elsif ((CHANA_DATA_START <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < CHANA_DATA_END)) then
        lsr1_mosi_temp <= inject_laser1_dac_chanA_data(((CHANA_DATA_END - 1) - to_integer(inject_laser1_dac_counter)));
    elsif ((CHANB_CONTROL_START <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < CHANB_CONTROL_END)) then
        case ((CHANB_CONTROL_END - 1) - to_integer(inject_laser1_dac_counter)) is
            when 0 => lsr1_mosi_temp <= '0';
            when 1 => lsr1_mosi_temp <= '0';
            when 2 => lsr1_mosi_temp <= '1';
            when 3 => lsr1_mosi_temp <= '0';
            when 4 => lsr1_mosi_temp <= '1';
            when 5 => lsr1_mosi_temp <= '1';
            when 6 => lsr1_mosi_temp <= '0';
            when others => lsr1_mosi_temp <= '0';
        end case;
    elsif ((CHANB_DATA_START <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < CHANB_DATA_END)) then
        lsr1_mosi_temp <= inject_laser1_dac_chanB_data(((CHANB_DATA_END - 1) - to_integer(inject_laser1_dac_counter)));
    else
        lsr1_mosi_temp <= '0';
    end if;
end process MAIN_INJECT_LASER1_DAC_COMB2;


MAIN_INJECT_LASER1_DAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_laser1_dac_counter <= to_unsigned(0, 6);
        lsr1_ss_temp <= '0';
    elsif rising_edge(clk0) then
        case inject_laser1_dac_state is
            when IDLE =>
                lsr1_ss_temp <= '0';
                if bool(inject_dac_strobe) then
                    inject_laser1_dac_chanA_data <= inject_laser1_coarse_scaled;
                    inject_laser1_dac_chanB_data <= inject_laser1_fine;
                    inject_laser1_dac_counter <= to_unsigned(0, 6);
                    lsr1_ss_temp <= '1';
                    inject_laser1_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_5M) then
                    if (inject_laser1_dac_counter < 49) then
                        if (inject_laser1_dac_counter = 24) then
                            lsr1_ss_temp <= '0';
                        end if;
                        inject_laser1_dac_counter <= (inject_laser1_dac_counter + 1);
                        inject_laser1_dac_state <= WAIT_0;
                    else
                        lsr1_ss_temp <= '0';
                        inject_laser1_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not bool(clk_5M)) then
                    lsr1_ss_temp <= '1';
                    inject_laser1_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser1_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER1_DAC_LOGIC;



signed_mult18x18_1 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => inject_coarse_scale_multiplier_a_s, B => inject_coarse_scale_multiplier_b_s, P => inject_coarse_scale_multiplier_p_s
    );


MAIN_INJECT_COARSE_SCALE_MULTIPLIER_COMB: process (inject_cs_mult_a, inject_cs_mult_b, inject_coarse_scale_multiplier_p_s) is
begin
    inject_coarse_scale_multiplier_a_s(17-1 downto 0) <= signed(inject_cs_mult_a);
    inject_coarse_scale_multiplier_a_s(17) <= '0';
    inject_coarse_scale_multiplier_b_s(17-1 downto 0) <= signed(inject_cs_mult_b);
    inject_coarse_scale_multiplier_b_s(17) <= '0';
    inject_cs_mult_p <= unsigned(inject_coarse_scale_multiplier_p_s(34-1 downto 0));
end process MAIN_INJECT_COARSE_SCALE_MULTIPLIER_COMB;


MAIN_INJECT_LASER4_DAC_COMB2: process (inject_laser4_dac_counter, inject_laser4_dac_chanB_data, inject_laser4_dac_chanA_data) is
begin
    if ((CHANA_CONTROL_START <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < CHANA_CONTROL_END)) then
        case ((CHANA_CONTROL_END - 1) - to_integer(inject_laser4_dac_counter)) is
            when 0 => lsr4_mosi_temp <= '0';
            when 1 => lsr4_mosi_temp <= '0';
            when 2 => lsr4_mosi_temp <= '0';
            when 3 => lsr4_mosi_temp <= '0';
            when 4 => lsr4_mosi_temp <= '0';
            when 5 => lsr4_mosi_temp <= '0';
            when 6 => lsr4_mosi_temp <= '0';
            when others => lsr4_mosi_temp <= '0';
        end case;
    elsif ((CHANA_DATA_START <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < CHANA_DATA_END)) then
        lsr4_mosi_temp <= inject_laser4_dac_chanA_data(((CHANA_DATA_END - 1) - to_integer(inject_laser4_dac_counter)));
    elsif ((CHANB_CONTROL_START <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < CHANB_CONTROL_END)) then
        case ((CHANB_CONTROL_END - 1) - to_integer(inject_laser4_dac_counter)) is
            when 0 => lsr4_mosi_temp <= '0';
            when 1 => lsr4_mosi_temp <= '0';
            when 2 => lsr4_mosi_temp <= '1';
            when 3 => lsr4_mosi_temp <= '0';
            when 4 => lsr4_mosi_temp <= '1';
            when 5 => lsr4_mosi_temp <= '1';
            when 6 => lsr4_mosi_temp <= '0';
            when others => lsr4_mosi_temp <= '0';
        end case;
    elsif ((CHANB_DATA_START <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < CHANB_DATA_END)) then
        lsr4_mosi_temp <= inject_laser4_dac_chanB_data(((CHANB_DATA_END - 1) - to_integer(inject_laser4_dac_counter)));
    else
        lsr4_mosi_temp <= '0';
    end if;
end process MAIN_INJECT_LASER4_DAC_COMB2;


MAIN_INJECT_LASER4_DAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_laser4_dac_counter <= to_unsigned(0, 6);
        lsr4_ss_temp <= '0';
    elsif rising_edge(clk0) then
        case inject_laser4_dac_state is
            when IDLE =>
                lsr4_ss_temp <= '0';
                if bool(inject_dac_strobe) then
                    inject_laser4_dac_chanA_data <= inject_laser4_coarse_scaled;
                    inject_laser4_dac_chanB_data <= inject_laser4_fine;
                    inject_laser4_dac_counter <= to_unsigned(0, 6);
                    lsr4_ss_temp <= '1';
                    inject_laser4_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_5M) then
                    if (inject_laser4_dac_counter < 49) then
                        if (inject_laser4_dac_counter = 24) then
                            lsr4_ss_temp <= '0';
                        end if;
                        inject_laser4_dac_counter <= (inject_laser4_dac_counter + 1);
                        inject_laser4_dac_state <= WAIT_0;
                    else
                        lsr4_ss_temp <= '0';
                        inject_laser4_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not bool(clk_5M)) then
                    lsr4_ss_temp <= '1';
                    inject_laser4_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser4_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER4_DAC_LOGIC;


MAIN_WLMMUX_LOGIC: process (data_available_sim, eta2_sim, ref2_sim, ref2_actual, wlm_sim_actual, ref1_actual, eta2_actual, data_available_actual, ref1_sim, eta1_actual, eta1_sim) is
begin
    if bool(wlm_sim_actual) then
        eta1 <= eta1_actual;
        ref1 <= ref1_actual;
        eta2 <= eta2_actual;
        ref2 <= ref2_actual;
        wlm_data_available <= data_available_actual;
    else
        eta1 <= eta1_sim;
        ref1 <= ref1_sim;
        eta2 <= eta2_sim;
        ref2 <= ref2_sim;
        wlm_data_available <= data_available_sim;
    end if;
end process MAIN_WLMMUX_LOGIC;


MAIN_TWGEN_LOGIC: process (clk0, reset) is
    variable value: unsigned(24 downto 0);
begin
    if bool(reset) then
        twGen_acc(((FPGA_REG_WIDTH + 9) - 1)) <= '1';
        twGen_acc(((FPGA_REG_WIDTH + 9) - 1)-1 downto 0) <= to_unsigned(0, 24);
        twGen_cs <= to_unsigned(0, 16);
        twGen_slope_down <= to_unsigned(0, 16);
        twGen_slope_up <= to_unsigned(0, 16);
        twGen_sweep_low <= to_unsigned(0, 16);
        twGen_sweep_high <= to_unsigned(0, 16);
        twGen_window_low <= to_unsigned(0, 16);
        twGen_window_high <= to_unsigned(0, 16);
        twGen_pzt_offset <= to_unsigned(0, 16);
        twGen_slope <= '1';
        twGen_extra0 <= to_unsigned(0, 9);
        tuner_slope <= '1';
        tuner_value <= to_unsigned(32768, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_acc_addr) then
                    if bool(dsp_wr) then
                        twGen_acc <= resize(dsp_data_out, 25);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_acc, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_cs_addr) then
                    if bool(dsp_wr) then
                        twGen_cs <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_cs, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_slope_down_addr) then
                    if bool(dsp_wr) then
                        twGen_slope_down <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_slope_down, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_slope_up_addr) then
                    if bool(dsp_wr) then
                        twGen_slope_up <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_slope_up, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_sweep_low_addr) then
                    if bool(dsp_wr) then
                        twGen_sweep_low <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_sweep_low, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_sweep_high_addr) then
                    if bool(dsp_wr) then
                        twGen_sweep_high <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_sweep_high, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_window_low_addr) then
                    if bool(dsp_wr) then
                        twGen_window_low <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_window_low, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_window_high_addr) then
                    if bool(dsp_wr) then
                        twGen_window_high <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_window_high, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_pzt_offset_addr) then
                    if bool(dsp_wr) then
                        twGen_pzt_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_pzt_offset, 32);
                else
                    dsp_data_in_twGen <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_twGen <= to_unsigned(0, 32);
        end if;
        if bool(twGen_cs(TWGEN_CS_RUN_B)) then
            if (not bool(twGen_cs(TWGEN_CS_CONT_B))) then
                twGen_cs(TWGEN_CS_RUN_B) <= '0';
            end if;
            if bool(twGen_cs(TWGEN_CS_RESET_B)) then
                twGen_acc(((FPGA_REG_WIDTH + 9) - 1)) <= '1';
                twGen_acc(((FPGA_REG_WIDTH + 9) - 1)-1 downto 0) <= to_unsigned(0, 24);
                twGen_slope <= '1';
            else
                value := resize(twGen_acc((FPGA_REG_WIDTH + 9)-1 downto 9), 25);
                tuner_value <= resize(value, 16);
                tuner_in_window <= stdl((value >= twGen_window_low) and (value <= twGen_window_high));
                tuner_slope <= twGen_slope;
                if bool(twGen_cs(TWGEN_CS_TUNE_PZT_B)) then
                    pzt <= resize(((value + twGen_pzt_offset) and to_unsigned(MASK, 25)), 16);
                else
                    pzt <= twGen_pzt_offset;
                end if;
                if bool(pulse_100k) then
                    if bool(twGen_slope) then
                        if ((twGen_acc + twGen_slope_up) > unsigned'(twGen_sweep_high & twGen_extra0)) then
                            twGen_acc <= unsigned'(twGen_sweep_high & twGen_extra0);
                            twGen_slope <= '0';
                        else
                            twGen_acc <= (twGen_acc + twGen_slope_up);
                        end if;
                    else
                        if ((signed(resize(twGen_acc, 26)) - signed(resize(twGen_slope_down, 17))) < signed(resize(unsigned'(twGen_sweep_low & twGen_extra0), 26))) then
                            twGen_acc <= unsigned'(twGen_sweep_low & twGen_extra0);
                            twGen_slope <= '1';
                        else
                            twGen_acc <= (twGen_acc - twGen_slope_down);
                        end if;
                    end if;
                end if;
                if (twGen_acc > unsigned'(twGen_sweep_high & twGen_extra0)) then
                    twGen_acc <= unsigned'(twGen_sweep_high & twGen_extra0);
                elsif (twGen_acc < unsigned'(twGen_sweep_low & twGen_extra0)) then
                    twGen_acc <= unsigned'(twGen_sweep_low & twGen_extra0);
                end if;
            end if;
        end if;
    end if;
end process MAIN_TWGEN_LOGIC;


MAIN_WLMADCREADER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        wlmadcreader_counter <= to_unsigned(ADC_CYCLE, 5);
        eta1_actual <= to_unsigned(0, 16);
        ref1_actual <= to_unsigned(0, 16);
        eta2_actual <= to_unsigned(0, 16);
        ref2_actual <= to_unsigned(0, 16);
        wlmadcreader_state <= IDLE;
    elsif rising_edge(clk0) then
        data_available_actual <= '0';
        case wlmadcreader_state is
            when IDLE =>
                wlmadcreader_counter <= to_unsigned(ADC_CYCLE, 5);
                wlmadcreader_eta1 <= to_unsigned(0, 16);
                wlmadcreader_ref1 <= to_unsigned(0, 16);
                wlmadcreader_eta2 <= to_unsigned(0, 16);
                wlmadcreader_ref2 <= to_unsigned(0, 16);
                if bool(pulse_100k) then
                    wlmadcreader_counter <= to_unsigned(0, 5);
                    wlmadcreader_state <= WAIT_1;
                end if;
            when WAIT_0 =>
                if (not bool(clk_2M5)) then
                    if ((wlmadcreader_counter >= ADC_START_CYCLE) and (wlmadcreader_counter <= ADC_LAST_CYCLE)) then
                        wlmadcreader_eta1((ADC_LAST_CYCLE - to_integer(wlmadcreader_counter))) <= wmm_refl1;
                        wlmadcreader_ref1((ADC_LAST_CYCLE - to_integer(wlmadcreader_counter))) <= wmm_tran1;
                        wlmadcreader_eta2((ADC_LAST_CYCLE - to_integer(wlmadcreader_counter))) <= wmm_refl2;
                        wlmadcreader_ref2((ADC_LAST_CYCLE - to_integer(wlmadcreader_counter))) <= wmm_tran2;
                    end if;
                    if (signed(resize(wlmadcreader_counter, 6)) = (ADC_CYCLE - 1)) then
                        data_available_actual <= '1';
                    end if;
                    wlmadcreader_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_2M5) then
                    if (signed(resize(wlmadcreader_counter, 6)) = (ADC_CYCLE - 2)) then
                        eta1_actual((ADC_DATA_WIDTH - 1)) <= stdl((not bool(wlmadcreader_eta1((ADC_DATA_WIDTH - 1)))));
                        ref1_actual((ADC_DATA_WIDTH - 1)) <= stdl((not bool(wlmadcreader_ref1((ADC_DATA_WIDTH - 1)))));
                        eta2_actual((ADC_DATA_WIDTH - 1)) <= stdl((not bool(wlmadcreader_eta2((ADC_DATA_WIDTH - 1)))));
                        ref2_actual((ADC_DATA_WIDTH - 1)) <= stdl((not bool(wlmadcreader_ref2((ADC_DATA_WIDTH - 1)))));
                        eta1_actual((ADC_DATA_WIDTH - 1)-1 downto 0) <= wlmadcreader_eta1((ADC_DATA_WIDTH - 1)-1 downto 0);
                        ref1_actual((ADC_DATA_WIDTH - 1)-1 downto 0) <= wlmadcreader_ref1((ADC_DATA_WIDTH - 1)-1 downto 0);
                        eta2_actual((ADC_DATA_WIDTH - 1)-1 downto 0) <= wlmadcreader_eta2((ADC_DATA_WIDTH - 1)-1 downto 0);
                        ref2_actual((ADC_DATA_WIDTH - 1)-1 downto 0) <= wlmadcreader_ref2((ADC_DATA_WIDTH - 1)-1 downto 0);
                    end if;
                    if (wlmadcreader_counter < ADC_CYCLE) then
                        wlmadcreader_counter <= (wlmadcreader_counter + 1);
                        wlmadcreader_state <= WAIT_0;
                    else
                        wlmadcreader_state <= IDLE;
                    end if;
                end if;
            when others =>
                wlmadcreader_state <= IDLE;
        end case;
        wmm_rd_out <= stdl(wlmadcreader_counter = 1);
        wmm_convst <= stdl(wlmadcreader_counter = 1);
    end if;
end process MAIN_WLMADCREADER_LOGIC;


MAIN_LOGIC: process (clk0, reset) is
    variable eta1_adc_high: unsigned(15 downto 0);
    variable ratio2_high: unsigned(15 downto 0);
    variable rd_adc_low: unsigned(7 downto 0);
    variable tuner_low: unsigned(15 downto 0);
    variable ref1_adc_low: unsigned(15 downto 0);
    variable tuner_high: unsigned(15 downto 0);
    variable eta2_adc_low: unsigned(15 downto 0);
    variable wlm_adc: unsigned(7 downto 0);
    variable lock_error_high: unsigned(15 downto 0);
    variable system_clocks: unsigned(7 downto 0);
    variable i2c_signals: unsigned(7 downto 0);
    variable eta1_adc_low: unsigned(15 downto 0);
    variable ratio1_high: unsigned(15 downto 0);
    variable rd_adc_high: unsigned(15 downto 0);
    variable ref2_adc_low: unsigned(15 downto 0);
    variable eta2_adc_high: unsigned(15 downto 0);
    variable ratio2_low: unsigned(15 downto 0);
    variable rd_sim_high: unsigned(15 downto 0);
    variable pzt_high: unsigned(15 downto 0);
    variable lock_error_low: unsigned(15 downto 0);
    variable pwm_signals: unsigned(7 downto 0);
    variable ratio1_low: unsigned(15 downto 0);
    variable ref2_adc_high: unsigned(15 downto 0);
    variable ref1_adc_high: unsigned(15 downto 0);
    variable sel_fine_current_low: unsigned(15 downto 0);
    variable pzt_low: unsigned(15 downto 0);
    variable rd_sim_low: unsigned(7 downto 0);
    variable sel_fine_current_high: unsigned(15 downto 0);
begin
    if bool(reset) then
        counter <= to_unsigned(0, 28);
        channel_1 <= to_unsigned(0, 8);
        channel_2 <= to_unsigned(0, 8);
        channel_3 <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        counter <= (counter + 1);
        tuner_low := resize(tuner_value(8-1 downto 0), 16);
        tuner_high := resize(tuner_value(16-1 downto 8), 16);
        rd_adc_low := unsigned'(rd_adc(6-1 downto 0) & '0' & '0');
        rd_adc_high := resize(rd_adc(14-1 downto 6), 16);
        rd_sim_low := unsigned'(rdsim_value(6-1 downto 0) & '0' & '0');
        rd_sim_high := resize(rdsim_value(14-1 downto 6), 16);
        sel_fine_current_low := resize(sel_fine_current(8-1 downto 0), 16);
        sel_fine_current_high := resize(sel_fine_current(16-1 downto 8), 16);
        lock_error_low := resize(meta5(8-1 downto 0), 16);
        lock_error_high := resize(meta5(16-1 downto 8), 16);
        ratio1_low := resize(ratio1(8-1 downto 0), 16);
        ratio1_high := resize(ratio1(16-1 downto 8), 16);
        ratio2_low := resize(ratio2(8-1 downto 0), 16);
        ratio2_high := resize(ratio2(16-1 downto 8), 16);
        pzt_low := resize(pzt(8-1 downto 0), 16);
        pzt_high := resize(pzt(16-1 downto 8), 16);
        eta1_adc_low := resize(eta1_actual(8-1 downto 0), 16);
        eta1_adc_high := resize(eta1_actual(16-1 downto 8), 16);
        ref1_adc_low := resize(ref1_actual(8-1 downto 0), 16);
        ref1_adc_high := resize(ref1_actual(16-1 downto 8), 16);
        eta2_adc_low := resize(eta2_actual(8-1 downto 0), 16);
        eta2_adc_high := resize(eta2_actual(16-1 downto 8), 16);
        ref2_adc_low := resize(ref2_actual(8-1 downto 0), 16);
        ref2_adc_high := resize(ref2_actual(16-1 downto 8), 16);
        wlm_adc := unsigned'(wmm_busy2 & wmm_busy1 & wmm_rd_out & clk_2M5 & wmm_tran2 & wmm_refl2 & wmm_tran1 & wmm_refl1);
        system_clocks := unsigned'(data_we & clk_10M & clk_5M & clk_2M5 & pulse_1M & pulse_100k & wlm_data_available & metadata_strobe);
        pwm_signals := unsigned'(engine2_pwm_out & engine1_pwm_out & hot_box_pwm_out & warm_box_pwm_out & pwm_laser4_out & pwm_laser3_out & pwm_laser2_out & pwm_laser1_out);
        i2c_signals := unsigned'(heater_pwm_out & '0' & '0' & '0' & i2c_scl0 & i2c_sda0 & i2c_scl1 & i2c_sda1);
        case intronix_1 is
            when "00000000" =>
                channel_1 <= resize(tuner_low, 8);
            when "00000001" =>
                channel_1 <= resize(tuner_high, 8);
            when "00000010" =>
                channel_1 <= rd_adc_low;
            when "00000011" =>
                channel_1 <= resize(rd_adc_high, 8);
            when "00000100" =>
                channel_1 <= rd_sim_low;
            when "00000101" =>
                channel_1 <= resize(rd_sim_high, 8);
            when "00000110" =>
                channel_1 <= resize(sel_fine_current_low, 8);
            when "00000111" =>
                channel_1 <= resize(sel_fine_current_high, 8);
            when "00001000" =>
                channel_1 <= resize(lock_error_low, 8);
            when "00001001" =>
                channel_1 <= resize(lock_error_low, 8);
            when "00001010" =>
                channel_1 <= resize(ratio1_low, 8);
            when "00001011" =>
                channel_1 <= resize(ratio1_high, 8);
            when "00001100" =>
                channel_1 <= resize(ratio2_low, 8);
            when "00001101" =>
                channel_1 <= resize(ratio2_high, 8);
            when "00001110" =>
                channel_1 <= resize(pzt_low, 8);
            when "00001111" =>
                channel_1 <= resize(pzt_high, 8);
            when "00010000" =>
                channel_1 <= resize(eta1_adc_low, 8);
            when "00010001" =>
                channel_1 <= resize(eta1_adc_high, 8);
            when "00010010" =>
                channel_1 <= resize(ref1_adc_low, 8);
            when "00010011" =>
                channel_1 <= resize(ref1_adc_high, 8);
            when "00010100" =>
                channel_1 <= resize(eta2_adc_low, 8);
            when "00010101" =>
                channel_1 <= resize(eta2_adc_high, 8);
            when "00010110" =>
                channel_1 <= resize(ref2_adc_low, 8);
            when "00010111" =>
                channel_1 <= resize(ref2_adc_high, 8);
            when "00011000" =>
                channel_1 <= wlm_adc;
            when "00011001" =>
                channel_1 <= system_clocks;
            when "00011010" =>
                channel_1 <= pwm_signals;
            when others =>
                channel_1 <= i2c_signals;
        end case;
        case intronix_2 is
            when "00000000" =>
                channel_2 <= resize(tuner_low, 8);
            when "00000001" =>
                channel_2 <= resize(tuner_high, 8);
            when "00000010" =>
                channel_2 <= rd_adc_low;
            when "00000011" =>
                channel_2 <= resize(rd_adc_high, 8);
            when "00000100" =>
                channel_2 <= rd_sim_low;
            when "00000101" =>
                channel_2 <= resize(rd_sim_high, 8);
            when "00000110" =>
                channel_2 <= resize(sel_fine_current_low, 8);
            when "00000111" =>
                channel_2 <= resize(sel_fine_current_high, 8);
            when "00001000" =>
                channel_2 <= resize(lock_error_low, 8);
            when "00001001" =>
                channel_2 <= resize(lock_error_low, 8);
            when "00001010" =>
                channel_2 <= resize(ratio1_low, 8);
            when "00001011" =>
                channel_2 <= resize(ratio1_high, 8);
            when "00001100" =>
                channel_2 <= resize(ratio2_low, 8);
            when "00001101" =>
                channel_2 <= resize(ratio2_high, 8);
            when "00001110" =>
                channel_2 <= resize(pzt_low, 8);
            when "00001111" =>
                channel_2 <= resize(pzt_high, 8);
            when "00010000" =>
                channel_2 <= resize(eta1_adc_low, 8);
            when "00010001" =>
                channel_2 <= resize(eta1_adc_high, 8);
            when "00010010" =>
                channel_2 <= resize(ref1_adc_low, 8);
            when "00010011" =>
                channel_2 <= resize(ref1_adc_high, 8);
            when "00010100" =>
                channel_2 <= resize(eta2_adc_low, 8);
            when "00010101" =>
                channel_2 <= resize(eta2_adc_high, 8);
            when "00010110" =>
                channel_2 <= resize(ref2_adc_low, 8);
            when "00010111" =>
                channel_2 <= resize(ref2_adc_high, 8);
            when "00011000" =>
                channel_2 <= wlm_adc;
            when "00011001" =>
                channel_2 <= system_clocks;
            when "00011010" =>
                channel_2 <= pwm_signals;
            when others =>
                channel_2 <= i2c_signals;
        end case;
        case intronix_3 is
            when "00000000" =>
                channel_3 <= resize(tuner_low, 8);
            when "00000001" =>
                channel_3 <= resize(tuner_high, 8);
            when "00000010" =>
                channel_3 <= rd_adc_low;
            when "00000011" =>
                channel_3 <= resize(rd_adc_high, 8);
            when "00000100" =>
                channel_3 <= rd_sim_low;
            when "00000101" =>
                channel_3 <= resize(rd_sim_high, 8);
            when "00000110" =>
                channel_3 <= resize(sel_fine_current_low, 8);
            when "00000111" =>
                channel_3 <= resize(sel_fine_current_high, 8);
            when "00001000" =>
                channel_3 <= resize(lock_error_low, 8);
            when "00001001" =>
                channel_3 <= resize(lock_error_low, 8);
            when "00001010" =>
                channel_3 <= resize(ratio1_low, 8);
            when "00001011" =>
                channel_3 <= resize(ratio1_high, 8);
            when "00001100" =>
                channel_3 <= resize(ratio2_low, 8);
            when "00001101" =>
                channel_3 <= resize(ratio2_high, 8);
            when "00001110" =>
                channel_3 <= resize(pzt_low, 8);
            when "00001111" =>
                channel_3 <= resize(pzt_high, 8);
            when "00010000" =>
                channel_3 <= resize(eta1_adc_low, 8);
            when "00010001" =>
                channel_3 <= resize(eta1_adc_high, 8);
            when "00010010" =>
                channel_3 <= resize(ref1_adc_low, 8);
            when "00010011" =>
                channel_3 <= resize(ref1_adc_high, 8);
            when "00010100" =>
                channel_3 <= resize(eta2_adc_low, 8);
            when "00010101" =>
                channel_3 <= resize(eta2_adc_high, 8);
            when "00010110" =>
                channel_3 <= resize(ref2_adc_low, 8);
            when "00010111" =>
                channel_3 <= resize(ref2_adc_high, 8);
            when "00011000" =>
                channel_3 <= wlm_adc;
            when "00011001" =>
                channel_3 <= system_clocks;
            when "00011010" =>
                channel_3 <= pwm_signals;
            when others =>
                channel_3 <= i2c_signals;
        end case;
        channel_4 <= unsigned'(rd_trig & diag_1(4-1 downto 0) & bank & laser_locked & acc_en & tuner_in_window);
    end if;
end process MAIN_LOGIC;



signed_mult18x18_3 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => laserCurrentGenerator_interpolator_multiplier_a_s, B => laserCurrentGenerator_interpolator_multiplier_b_s, P => laserCurrentGenerator_interpolator_multiplier_p_s
    );


MAIN_LASERCURRENTGENERATOR_INTERPOLATOR_MULTIPLIER_COMB: process (laserCurrentGenerator_interpolator_mult_a, laserCurrentGenerator_interpolator_mult_b, laserCurrentGenerator_interpolator_multiplier_p_s) is
begin
    laserCurrentGenerator_interpolator_multiplier_a_s(17-1 downto 0) <= signed(laserCurrentGenerator_interpolator_mult_a);
    laserCurrentGenerator_interpolator_multiplier_a_s(17) <= '0';
    laserCurrentGenerator_interpolator_multiplier_b_s(17-1 downto 0) <= signed(laserCurrentGenerator_interpolator_mult_b);
    laserCurrentGenerator_interpolator_multiplier_b_s(17) <= '0';
    laserCurrentGenerator_interpolator_mult_p <= unsigned(laserCurrentGenerator_interpolator_multiplier_p_s(34-1 downto 0));
end process MAIN_LASERCURRENTGENERATOR_INTERPOLATOR_MULTIPLIER_COMB;


MAIN_LASERCURRENTGENERATOR_INTERPOLATOR_COMB: process (laserCurrentGenerator_interp_y1, laserCurrentGenerator_interp_y0, laserCurrentGenerator_interp_beta, laserCurrentGenerator_interpolator_mult_p) is
begin
    laserCurrentGenerator_interpolator_mult_a(17-1 downto 1) <= laserCurrentGenerator_interp_beta;
    if (laserCurrentGenerator_interp_y1 >= laserCurrentGenerator_interp_y0) then
        laserCurrentGenerator_interpolator_mult_b(17-1 downto 1) <= (laserCurrentGenerator_interp_y1 - laserCurrentGenerator_interp_y0);
        laserCurrentGenerator_interp_yout <= (laserCurrentGenerator_interp_y0 + laserCurrentGenerator_interpolator_mult_p(34-1 downto 18));
    else
        laserCurrentGenerator_interpolator_mult_b(17-1 downto 1) <= (laserCurrentGenerator_interp_y0 - laserCurrentGenerator_interp_y1);
        laserCurrentGenerator_interp_yout <= (laserCurrentGenerator_interp_y0 - laserCurrentGenerator_interpolator_mult_p(34-1 downto 18));
    end if;
end process MAIN_LASERCURRENTGENERATOR_INTERPOLATOR_COMB;



dual_port_ram_4 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 10, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => laserCurrentGenerator_enA_laser4, wr_enableA => laserCurrentGenerator_dsp_wr_delayed,
    addressA => laserCurrentGenerator_addrA_laser4, rd_dataA => laserCurrentGenerator_rd_dataA_laser4, wr_dataA => laserCurrentGenerator_wr_dataA_laser4,
    clockB => clk0, enableB => laserCurrentGenerator_enB_laser4, wr_enableB => laserCurrentGenerator_wr_enB_laser4,
    addressB => laserCurrentGenerator_addrB_laser4, rd_dataB => laserCurrentGenerator_rd_dataB_laser4, wr_dataB => laserCurrentGenerator_wr_dataB_laser4
    );



dual_port_ram_3 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 10, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => laserCurrentGenerator_enA_laser3, wr_enableA => laserCurrentGenerator_dsp_wr_delayed,
    addressA => laserCurrentGenerator_addrA_laser3, rd_dataA => laserCurrentGenerator_rd_dataA_laser3, wr_dataA => laserCurrentGenerator_wr_dataA_laser3,
    clockB => clk0, enableB => laserCurrentGenerator_enB_laser3, wr_enableB => laserCurrentGenerator_wr_enB_laser3,
    addressB => laserCurrentGenerator_addrB_laser3, rd_dataB => laserCurrentGenerator_rd_dataB_laser3, wr_dataB => laserCurrentGenerator_wr_dataB_laser3
    );


MAIN_LASERCURRENTGENERATOR_COMB: process (laserCurrentGenerator_transition_counter_1, laserCurrentGenerator_bank_4, laserCurrentGenerator_transition_counter_3, laserCurrentGenerator_transition_counter_2, laserCurrentGenerator_bank_1, laserCurrentGenerator_transition_counter_4, laserCurrentGenerator_bank_3, laserCurrentGenerator_bank_2, laserCurrentGenerator_second_offset_3, laserCurrentGenerator_first_offset_3, laserCurrentGenerator_first_offset_2, laserCurrentGenerator_first_offset_1, laserCurrentGenerator_second_offset_1, laserCurrentGenerator_second_breakpoint_2, laserCurrentGenerator_second_breakpoint_3, laserCurrentGenerator_fast_accumulator_4, laserCurrentGenerator_period_counter_4, laserCurrentGenerator_fast_accumulator_2, laserCurrentGenerator_fast_accumulator_3, laserCurrentGenerator_period_counter_1, laserCurrentGenerator_fast_accumulator_1, laserCurrentGenerator_period_counter_3, laserCurrentGenerator_second_offset_4, laserCurrentGenerator_period_counter_2, laserCurrentGenerator_first_breakpoint_4, laserCurrentGenerator_first_breakpoint_3, laserCurrentGenerator_first_breakpoint_2, laserCurrentGenerator_first_breakpoint_1, laserCurrentGenerator_first_offset_4, laserCurrentGenerator_second_offset_2, laserCurrentGenerator_second_breakpoint_4, laserCurrentGenerator_slow_accumulator_4, laserCurrentGenerator_slow_accumulator_3, laserCurrentGenerator_slow_accumulator_2, laserCurrentGenerator_slow_accumulator_1, laserCurrentGenerator_second_breakpoint_1) is
begin
    if (laserCurrentGenerator_transition_counter_1 < laserCurrentGenerator_first_breakpoint_1) then
        laserCurrentGenerator_interp_1 <= laserCurrentGenerator_slow_accumulator_1;
    elsif (laserCurrentGenerator_transition_counter_1 < laserCurrentGenerator_second_breakpoint_1) then
        laserCurrentGenerator_interp_1 <= ((laserCurrentGenerator_fast_accumulator_1 + laserCurrentGenerator_first_offset_1) mod ACCUMULATOR_MODULO);
    else
        laserCurrentGenerator_interp_1 <= ((laserCurrentGenerator_slow_accumulator_1 + laserCurrentGenerator_second_offset_1) mod ACCUMULATOR_MODULO);
    end if;
    if (laserCurrentGenerator_transition_counter_2 < laserCurrentGenerator_first_breakpoint_2) then
        laserCurrentGenerator_interp_2 <= laserCurrentGenerator_slow_accumulator_2;
    elsif (laserCurrentGenerator_transition_counter_2 < laserCurrentGenerator_second_breakpoint_2) then
        laserCurrentGenerator_interp_2 <= ((laserCurrentGenerator_fast_accumulator_2 + laserCurrentGenerator_first_offset_2) mod ACCUMULATOR_MODULO);
    else
        laserCurrentGenerator_interp_2 <= ((laserCurrentGenerator_slow_accumulator_2 + laserCurrentGenerator_second_offset_2) mod ACCUMULATOR_MODULO);
    end if;
    if (laserCurrentGenerator_transition_counter_3 < laserCurrentGenerator_first_breakpoint_3) then
        laserCurrentGenerator_interp_3 <= laserCurrentGenerator_slow_accumulator_3;
    elsif (laserCurrentGenerator_transition_counter_3 < laserCurrentGenerator_second_breakpoint_3) then
        laserCurrentGenerator_interp_3 <= ((laserCurrentGenerator_fast_accumulator_3 + laserCurrentGenerator_first_offset_3) mod ACCUMULATOR_MODULO);
    else
        laserCurrentGenerator_interp_3 <= ((laserCurrentGenerator_slow_accumulator_3 + laserCurrentGenerator_second_offset_3) mod ACCUMULATOR_MODULO);
    end if;
    if (laserCurrentGenerator_transition_counter_4 < laserCurrentGenerator_first_breakpoint_4) then
        laserCurrentGenerator_interp_4 <= laserCurrentGenerator_slow_accumulator_4;
    elsif (laserCurrentGenerator_transition_counter_4 < laserCurrentGenerator_second_breakpoint_4) then
        laserCurrentGenerator_interp_4 <= ((laserCurrentGenerator_fast_accumulator_4 + laserCurrentGenerator_first_offset_4) mod ACCUMULATOR_MODULO);
    else
        laserCurrentGenerator_interp_4 <= ((laserCurrentGenerator_slow_accumulator_4 + laserCurrentGenerator_second_offset_4) mod ACCUMULATOR_MODULO);
    end if;
    laserCurrentGenerator_enB_laser1 <= '1';
    laserCurrentGenerator_wr_enB_laser1 <= '0';
    laserCurrentGenerator_addrB_laser1(PERIOD_COUNTER_WIDTH-1 downto 0) <= laserCurrentGenerator_period_counter_1;
    laserCurrentGenerator_addrB_laser1(PERIOD_COUNTER_WIDTH) <= laserCurrentGenerator_bank_1;
    laserCurrentGenerator_wr_dataB_laser1 <= to_unsigned(0, 16);
    laserCurrentGenerator_enB_laser2 <= '1';
    laserCurrentGenerator_wr_enB_laser2 <= '0';
    laserCurrentGenerator_addrB_laser2(PERIOD_COUNTER_WIDTH-1 downto 0) <= laserCurrentGenerator_period_counter_2;
    laserCurrentGenerator_addrB_laser2(PERIOD_COUNTER_WIDTH) <= laserCurrentGenerator_bank_2;
    laserCurrentGenerator_wr_dataB_laser2 <= to_unsigned(0, 16);
    laserCurrentGenerator_enB_laser3 <= '1';
    laserCurrentGenerator_wr_enB_laser3 <= '0';
    laserCurrentGenerator_addrB_laser3(PERIOD_COUNTER_WIDTH-1 downto 0) <= laserCurrentGenerator_period_counter_3;
    laserCurrentGenerator_addrB_laser3(PERIOD_COUNTER_WIDTH) <= laserCurrentGenerator_bank_3;
    laserCurrentGenerator_wr_dataB_laser3 <= to_unsigned(0, 16);
    laserCurrentGenerator_enB_laser4 <= '1';
    laserCurrentGenerator_wr_enB_laser4 <= '0';
    laserCurrentGenerator_addrB_laser4(PERIOD_COUNTER_WIDTH-1 downto 0) <= laserCurrentGenerator_period_counter_4;
    laserCurrentGenerator_addrB_laser4(PERIOD_COUNTER_WIDTH) <= laserCurrentGenerator_bank_4;
    laserCurrentGenerator_wr_dataB_laser4 <= to_unsigned(0, 16);
end process MAIN_LASERCURRENTGENERATOR_COMB;


MAIN_LASERCURRENTGENERATOR_LOGIC: process (clk0, reset) is
    variable laser_select_w: natural;
    variable mode: std_logic;
    variable laser_selected: unsigned(15 downto 0);
    variable sel_laser4: std_logic;
    variable sel_laser2: std_logic;
    variable laser_select_b: natural;
    variable sel_laser1: std_logic;
    variable bank: std_logic;
    variable sel_laser3: std_logic;
begin
    if bool(reset) then
        laserCurrentGenerator_control_status <= to_unsigned(0, 16);
        laserCurrentGenerator_slow_slope <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_slope <= to_unsigned(0, 24);
        laserCurrentGenerator_first_offset <= to_unsigned(0, 24);
        laserCurrentGenerator_second_offset <= to_unsigned(0, 24);
        laserCurrentGenerator_first_breakpoint <= to_unsigned(0, 16);
        laserCurrentGenerator_second_breakpoint <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_limit <= to_unsigned(0, 16);
        laserCurrentGenerator_period_counter_limit <= to_unsigned(0, 16);
        laserCurrentGenerator_lower_window <= to_unsigned(0, 16);
        laserCurrentGenerator_upper_window <= to_unsigned(0, 16);
        laserCurrentGenerator_sequence_id <= to_unsigned(0, 16);
        laserCurrentGenerator_slow_slope_1 <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_slope_1 <= to_unsigned(0, 24);
        laserCurrentGenerator_first_offset_1 <= to_unsigned(0, 24);
        laserCurrentGenerator_second_offset_1 <= to_unsigned(0, 24);
        laserCurrentGenerator_first_breakpoint_1 <= to_unsigned(0, 16);
        laserCurrentGenerator_second_breakpoint_1 <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_limit_1 <= to_unsigned(32, 16);
        laserCurrentGenerator_period_counter_limit_1 <= to_unsigned(16, 9);
        laserCurrentGenerator_lower_window_1 <= to_unsigned(20000, 16);
        laserCurrentGenerator_upper_window_1 <= to_unsigned(40000, 16);
        laserCurrentGenerator_sequence_id_1 <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_1 <= to_unsigned(0, 16);
        laserCurrentGenerator_period_counter_1 <= to_unsigned(0, 9);
        laserCurrentGenerator_slow_accumulator_1 <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_accumulator_1 <= to_unsigned(0, 24);
        laserCurrentGenerator_bank_1 <= '0';
        laserCurrentGenerator_current_level_1 <= to_unsigned(0, 16);
        laserCurrentGenerator_prev_level_1 <= to_unsigned(0, 16);
        laserCurrentGenerator_slow_slope_2 <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_slope_2 <= to_unsigned(0, 24);
        laserCurrentGenerator_first_offset_2 <= to_unsigned(0, 24);
        laserCurrentGenerator_second_offset_2 <= to_unsigned(0, 24);
        laserCurrentGenerator_first_breakpoint_2 <= to_unsigned(0, 16);
        laserCurrentGenerator_second_breakpoint_2 <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_limit_2 <= to_unsigned(32, 16);
        laserCurrentGenerator_period_counter_limit_2 <= to_unsigned(16, 9);
        laserCurrentGenerator_lower_window_2 <= to_unsigned(20000, 16);
        laserCurrentGenerator_upper_window_2 <= to_unsigned(40000, 16);
        laserCurrentGenerator_sequence_id_2 <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_2 <= to_unsigned(0, 16);
        laserCurrentGenerator_period_counter_2 <= to_unsigned(0, 9);
        laserCurrentGenerator_slow_accumulator_2 <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_accumulator_2 <= to_unsigned(0, 24);
        laserCurrentGenerator_bank_2 <= '0';
        laserCurrentGenerator_current_level_2 <= to_unsigned(0, 16);
        laserCurrentGenerator_prev_level_2 <= to_unsigned(0, 16);
        laserCurrentGenerator_slow_slope_3 <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_slope_3 <= to_unsigned(0, 24);
        laserCurrentGenerator_first_offset_3 <= to_unsigned(0, 24);
        laserCurrentGenerator_second_offset_3 <= to_unsigned(0, 24);
        laserCurrentGenerator_first_breakpoint_3 <= to_unsigned(0, 16);
        laserCurrentGenerator_second_breakpoint_3 <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_limit_3 <= to_unsigned(32, 16);
        laserCurrentGenerator_period_counter_limit_3 <= to_unsigned(16, 9);
        laserCurrentGenerator_lower_window_3 <= to_unsigned(20000, 16);
        laserCurrentGenerator_upper_window_3 <= to_unsigned(40000, 16);
        laserCurrentGenerator_sequence_id_3 <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_3 <= to_unsigned(0, 16);
        laserCurrentGenerator_period_counter_3 <= to_unsigned(0, 9);
        laserCurrentGenerator_slow_accumulator_3 <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_accumulator_3 <= to_unsigned(0, 24);
        laserCurrentGenerator_bank_3 <= '0';
        laserCurrentGenerator_current_level_3 <= to_unsigned(0, 16);
        laserCurrentGenerator_prev_level_3 <= to_unsigned(0, 16);
        laserCurrentGenerator_slow_slope_4 <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_slope_4 <= to_unsigned(0, 24);
        laserCurrentGenerator_first_offset_4 <= to_unsigned(0, 24);
        laserCurrentGenerator_second_offset_4 <= to_unsigned(0, 24);
        laserCurrentGenerator_first_breakpoint_4 <= to_unsigned(0, 16);
        laserCurrentGenerator_second_breakpoint_4 <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_limit_4 <= to_unsigned(32, 16);
        laserCurrentGenerator_period_counter_limit_4 <= to_unsigned(16, 9);
        laserCurrentGenerator_lower_window_4 <= to_unsigned(20000, 16);
        laserCurrentGenerator_upper_window_4 <= to_unsigned(40000, 16);
        laserCurrentGenerator_sequence_id_4 <= to_unsigned(0, 16);
        laserCurrentGenerator_transition_counter_4 <= to_unsigned(0, 16);
        laserCurrentGenerator_period_counter_4 <= to_unsigned(0, 9);
        laserCurrentGenerator_slow_accumulator_4 <= to_unsigned(0, 24);
        laserCurrentGenerator_fast_accumulator_4 <= to_unsigned(0, 24);
        laserCurrentGenerator_bank_4 <= '0';
        laserCurrentGenerator_current_level_4 <= to_unsigned(0, 16);
        laserCurrentGenerator_prev_level_4 <= to_unsigned(0, 16);
        laserCurrentGenerator_output_counter <= to_unsigned(0, 4);
        laserCurrentGenerator_dsp_wr_delayed <= '0';
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_control_status_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_control_status <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_control_status, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_slow_slope_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_slow_slope <= resize(dsp_data_out, 24);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_slow_slope, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_fast_slope_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_fast_slope <= resize(dsp_data_out, 24);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_fast_slope, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_first_offset_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_first_offset <= resize(dsp_data_out, 24);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_first_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_second_offset_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_second_offset <= resize(dsp_data_out, 24);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_second_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_first_breakpoint_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_first_breakpoint <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_first_breakpoint, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_second_breakpoint_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_second_breakpoint <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_second_breakpoint, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_transition_counter_limit_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_transition_counter_limit <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_transition_counter_limit, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_period_counter_limit_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_period_counter_limit <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_period_counter_limit, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_lower_window_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_lower_window <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_lower_window, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_upper_window_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_upper_window <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_upper_window, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = lasercurrentgenerator_sequence_id_addr) then
                    if bool(dsp_wr) then
                        laserCurrentGenerator_sequence_id <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_sequence_id, 32);
                else
                    dsp_data_in_lasercurrentgenerator <= to_unsigned(0, 32);
                end if;
            end if;
        else
            sel_laser1 := stdl(dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 8);
            sel_laser2 := stdl(dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 9);
            sel_laser3 := stdl(dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 10);
            sel_laser4 := stdl(dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 11);
            laserCurrentGenerator_dsp_wr_delayed <= dsp_wr;
            laserCurrentGenerator_enA_laser1 <= sel_laser1;
            laserCurrentGenerator_addrA_laser1 <= dsp_addr((PERIOD_COUNTER_WIDTH + 1)-1 downto 0);
            laserCurrentGenerator_wr_dataA_laser1 <= dsp_data_out(FPGA_REG_WIDTH-1 downto 0);
            laserCurrentGenerator_enA_laser2 <= sel_laser2;
            laserCurrentGenerator_addrA_laser2 <= dsp_addr((PERIOD_COUNTER_WIDTH + 1)-1 downto 0);
            laserCurrentGenerator_wr_dataA_laser2 <= dsp_data_out(FPGA_REG_WIDTH-1 downto 0);
            laserCurrentGenerator_enA_laser3 <= sel_laser3;
            laserCurrentGenerator_addrA_laser3 <= dsp_addr((PERIOD_COUNTER_WIDTH + 1)-1 downto 0);
            laserCurrentGenerator_wr_dataA_laser3 <= dsp_data_out(FPGA_REG_WIDTH-1 downto 0);
            laserCurrentGenerator_enA_laser4 <= sel_laser4;
            laserCurrentGenerator_addrA_laser4 <= dsp_addr((PERIOD_COUNTER_WIDTH + 1)-1 downto 0);
            laserCurrentGenerator_wr_dataA_laser4 <= dsp_data_out(FPGA_REG_WIDTH-1 downto 0);
            if bool(sel_laser1) then
                dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_rd_dataA_laser1, 32);
            elsif bool(sel_laser2) then
                dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_rd_dataA_laser2, 32);
            elsif bool(sel_laser3) then
                dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_rd_dataA_laser3, 32);
            elsif bool(sel_laser4) then
                dsp_data_in_lasercurrentgenerator <= resize(laserCurrentGenerator_rd_dataA_laser4, 32);
            else
                dsp_data_in_lasercurrentgenerator <= to_unsigned(0, 32);
            end if;
        end if;
        laser_select_b := LASERCURRENTGENERATOR_CONTROL_STATUS_LASER_SELECT_B;
        laser_select_w := LASERCURRENTGENERATOR_CONTROL_STATUS_LASER_SELECT_W;
        laser_selected := resize(laserCurrentGenerator_control_status((laser_select_b + laser_select_w)-1 downto laser_select_b), 16);
        mode := laserCurrentGenerator_control_status(LASERCURRENTGENERATOR_CONTROL_STATUS_MODE_B);
        bank := laserCurrentGenerator_control_status(LASERCURRENTGENERATOR_CONTROL_STATUS_BANK_SELECT_B);
        ext_laser_level_counter <= to_unsigned(0, 16);
        ext_laser_sequence_id <= to_unsigned(0, 16);
        case sel_laser is
            when "00" =>
                ext_laser_level_counter(FPGA_REG_WIDTH-1 downto (FPGA_REG_WIDTH - PERIOD_COUNTER_WIDTH)) <= laserCurrentGenerator_period_counter_1;
                ext_laser_level_counter(((FPGA_REG_WIDTH - PERIOD_COUNTER_WIDTH) - 1)) <= stdl(laserCurrentGenerator_transition_counter_1 >= shift_right(laserCurrentGenerator_transition_counter_limit, 1));
                ext_laser_sequence_id <= laserCurrentGenerator_sequence_id_1;
            when "01" =>
                ext_laser_level_counter(FPGA_REG_WIDTH-1 downto (FPGA_REG_WIDTH - PERIOD_COUNTER_WIDTH)) <= laserCurrentGenerator_period_counter_2;
                ext_laser_level_counter(((FPGA_REG_WIDTH - PERIOD_COUNTER_WIDTH) - 1)) <= stdl(laserCurrentGenerator_transition_counter_2 >= shift_right(laserCurrentGenerator_transition_counter_limit, 1));
                ext_laser_sequence_id <= laserCurrentGenerator_sequence_id_2;
            when "10" =>
                ext_laser_level_counter(FPGA_REG_WIDTH-1 downto (FPGA_REG_WIDTH - PERIOD_COUNTER_WIDTH)) <= laserCurrentGenerator_period_counter_3;
                ext_laser_level_counter(((FPGA_REG_WIDTH - PERIOD_COUNTER_WIDTH) - 1)) <= stdl(laserCurrentGenerator_transition_counter_3 >= shift_right(laserCurrentGenerator_transition_counter_limit, 1));
                ext_laser_sequence_id <= laserCurrentGenerator_sequence_id_3;
            when others => -- "11"
                ext_laser_level_counter(FPGA_REG_WIDTH-1 downto (FPGA_REG_WIDTH - PERIOD_COUNTER_WIDTH)) <= laserCurrentGenerator_period_counter_4;
                ext_laser_level_counter(((FPGA_REG_WIDTH - PERIOD_COUNTER_WIDTH) - 1)) <= stdl(laserCurrentGenerator_transition_counter_4 >= shift_right(laserCurrentGenerator_transition_counter_limit, 1));
                ext_laser_sequence_id <= laserCurrentGenerator_sequence_id_4;
        end case;
        if bool(pulse_100k) then
            if (signed(resize(laserCurrentGenerator_transition_counter_1, 17)) < (signed(resize(laserCurrentGenerator_transition_counter_limit_1, 17)) - 1)) then
                laserCurrentGenerator_transition_counter_1 <= (laserCurrentGenerator_transition_counter_1 + 1);
                laserCurrentGenerator_slow_accumulator_1 <= ((laserCurrentGenerator_slow_accumulator_1 + laserCurrentGenerator_slow_slope_1) mod ACCUMULATOR_MODULO);
                laserCurrentGenerator_fast_accumulator_1 <= ((laserCurrentGenerator_fast_accumulator_1 + laserCurrentGenerator_fast_slope_1) mod ACCUMULATOR_MODULO);
            else
                laserCurrentGenerator_current_level_1 <= laserCurrentGenerator_rd_dataB_laser1;
                laserCurrentGenerator_prev_level_1 <= laserCurrentGenerator_current_level_1;
                laserCurrentGenerator_transition_counter_1 <= to_unsigned(0, 16);
                laserCurrentGenerator_slow_accumulator_1 <= to_unsigned(0, 24);
                laserCurrentGenerator_fast_accumulator_1 <= to_unsigned(0, 24);
                if (signed(resize(laserCurrentGenerator_period_counter_1, 10)) < (signed(resize(laserCurrentGenerator_period_counter_limit_1, 10)) - 1)) then
                    laserCurrentGenerator_period_counter_1 <= (laserCurrentGenerator_period_counter_1 + 1);
                else
                    laserCurrentGenerator_period_counter_1 <= to_unsigned(0, 9);
                end if;
                if ((laser_selected = 0) and bool(mode)) then
                    laserCurrentGenerator_slow_slope_1 <= laserCurrentGenerator_slow_slope;
                    laserCurrentGenerator_fast_slope_1 <= laserCurrentGenerator_fast_slope;
                    laserCurrentGenerator_first_offset_1 <= laserCurrentGenerator_first_offset;
                    laserCurrentGenerator_second_offset_1 <= laserCurrentGenerator_second_offset;
                    laserCurrentGenerator_first_breakpoint_1 <= laserCurrentGenerator_first_breakpoint;
                    laserCurrentGenerator_second_breakpoint_1 <= laserCurrentGenerator_second_breakpoint;
                    laserCurrentGenerator_transition_counter_limit_1 <= laserCurrentGenerator_transition_counter_limit;
                    laserCurrentGenerator_period_counter_limit_1 <= resize(laserCurrentGenerator_period_counter_limit, 9);
                    laserCurrentGenerator_lower_window_1 <= laserCurrentGenerator_lower_window;
                    laserCurrentGenerator_upper_window_1 <= laserCurrentGenerator_upper_window;
                    laserCurrentGenerator_sequence_id_1 <= laserCurrentGenerator_sequence_id;
                    laserCurrentGenerator_bank_1 <= bank;
                    laserCurrentGenerator_control_status(LASERCURRENTGENERATOR_CONTROL_STATUS_MODE_B) <= '0';
                end if;
            end if;
            if (signed(resize(laserCurrentGenerator_transition_counter_2, 17)) < (signed(resize(laserCurrentGenerator_transition_counter_limit_2, 17)) - 1)) then
                laserCurrentGenerator_transition_counter_2 <= (laserCurrentGenerator_transition_counter_2 + 1);
                laserCurrentGenerator_slow_accumulator_2 <= ((laserCurrentGenerator_slow_accumulator_2 + laserCurrentGenerator_slow_slope_2) mod ACCUMULATOR_MODULO);
                laserCurrentGenerator_fast_accumulator_2 <= ((laserCurrentGenerator_fast_accumulator_2 + laserCurrentGenerator_fast_slope_2) mod ACCUMULATOR_MODULO);
            else
                laserCurrentGenerator_current_level_2 <= laserCurrentGenerator_rd_dataB_laser2;
                laserCurrentGenerator_prev_level_2 <= laserCurrentGenerator_current_level_2;
                laserCurrentGenerator_transition_counter_2 <= to_unsigned(0, 16);
                laserCurrentGenerator_slow_accumulator_2 <= to_unsigned(0, 24);
                laserCurrentGenerator_fast_accumulator_2 <= to_unsigned(0, 24);
                if (signed(resize(laserCurrentGenerator_period_counter_2, 10)) < (signed(resize(laserCurrentGenerator_period_counter_limit_2, 10)) - 1)) then
                    laserCurrentGenerator_period_counter_2 <= (laserCurrentGenerator_period_counter_2 + 1);
                else
                    laserCurrentGenerator_period_counter_2 <= to_unsigned(0, 9);
                end if;
                if ((laser_selected = 1) and bool(mode)) then
                    laserCurrentGenerator_slow_slope_2 <= laserCurrentGenerator_slow_slope;
                    laserCurrentGenerator_fast_slope_2 <= laserCurrentGenerator_fast_slope;
                    laserCurrentGenerator_first_offset_2 <= laserCurrentGenerator_first_offset;
                    laserCurrentGenerator_second_offset_2 <= laserCurrentGenerator_second_offset;
                    laserCurrentGenerator_first_breakpoint_2 <= laserCurrentGenerator_first_breakpoint;
                    laserCurrentGenerator_second_breakpoint_2 <= laserCurrentGenerator_second_breakpoint;
                    laserCurrentGenerator_transition_counter_limit_2 <= laserCurrentGenerator_transition_counter_limit;
                    laserCurrentGenerator_period_counter_limit_2 <= resize(laserCurrentGenerator_period_counter_limit, 9);
                    laserCurrentGenerator_lower_window_2 <= laserCurrentGenerator_lower_window;
                    laserCurrentGenerator_upper_window_2 <= laserCurrentGenerator_upper_window;
                    laserCurrentGenerator_sequence_id_2 <= laserCurrentGenerator_sequence_id;
                    laserCurrentGenerator_bank_2 <= bank;
                    laserCurrentGenerator_control_status(LASERCURRENTGENERATOR_CONTROL_STATUS_MODE_B) <= '0';
                end if;
            end if;
            if (signed(resize(laserCurrentGenerator_transition_counter_3, 17)) < (signed(resize(laserCurrentGenerator_transition_counter_limit_3, 17)) - 1)) then
                laserCurrentGenerator_transition_counter_3 <= (laserCurrentGenerator_transition_counter_3 + 1);
                laserCurrentGenerator_slow_accumulator_3 <= ((laserCurrentGenerator_slow_accumulator_3 + laserCurrentGenerator_slow_slope_3) mod ACCUMULATOR_MODULO);
                laserCurrentGenerator_fast_accumulator_3 <= ((laserCurrentGenerator_fast_accumulator_3 + laserCurrentGenerator_fast_slope_3) mod ACCUMULATOR_MODULO);
            else
                laserCurrentGenerator_current_level_3 <= laserCurrentGenerator_rd_dataB_laser3;
                laserCurrentGenerator_prev_level_3 <= laserCurrentGenerator_current_level_3;
                laserCurrentGenerator_transition_counter_3 <= to_unsigned(0, 16);
                laserCurrentGenerator_slow_accumulator_3 <= to_unsigned(0, 24);
                laserCurrentGenerator_fast_accumulator_3 <= to_unsigned(0, 24);
                if (signed(resize(laserCurrentGenerator_period_counter_3, 10)) < (signed(resize(laserCurrentGenerator_period_counter_limit_3, 10)) - 1)) then
                    laserCurrentGenerator_period_counter_3 <= (laserCurrentGenerator_period_counter_3 + 1);
                else
                    laserCurrentGenerator_period_counter_3 <= to_unsigned(0, 9);
                end if;
                if ((laser_selected = 2) and bool(mode)) then
                    laserCurrentGenerator_slow_slope_3 <= laserCurrentGenerator_slow_slope;
                    laserCurrentGenerator_fast_slope_3 <= laserCurrentGenerator_fast_slope;
                    laserCurrentGenerator_first_offset_3 <= laserCurrentGenerator_first_offset;
                    laserCurrentGenerator_second_offset_3 <= laserCurrentGenerator_second_offset;
                    laserCurrentGenerator_first_breakpoint_3 <= laserCurrentGenerator_first_breakpoint;
                    laserCurrentGenerator_second_breakpoint_3 <= laserCurrentGenerator_second_breakpoint;
                    laserCurrentGenerator_transition_counter_limit_3 <= laserCurrentGenerator_transition_counter_limit;
                    laserCurrentGenerator_period_counter_limit_3 <= resize(laserCurrentGenerator_period_counter_limit, 9);
                    laserCurrentGenerator_lower_window_3 <= laserCurrentGenerator_lower_window;
                    laserCurrentGenerator_upper_window_3 <= laserCurrentGenerator_upper_window;
                    laserCurrentGenerator_sequence_id_3 <= laserCurrentGenerator_sequence_id;
                    laserCurrentGenerator_bank_3 <= bank;
                    laserCurrentGenerator_control_status(LASERCURRENTGENERATOR_CONTROL_STATUS_MODE_B) <= '0';
                end if;
            end if;
            if (signed(resize(laserCurrentGenerator_transition_counter_4, 17)) < (signed(resize(laserCurrentGenerator_transition_counter_limit_4, 17)) - 1)) then
                laserCurrentGenerator_transition_counter_4 <= (laserCurrentGenerator_transition_counter_4 + 1);
                laserCurrentGenerator_slow_accumulator_4 <= ((laserCurrentGenerator_slow_accumulator_4 + laserCurrentGenerator_slow_slope_4) mod ACCUMULATOR_MODULO);
                laserCurrentGenerator_fast_accumulator_4 <= ((laserCurrentGenerator_fast_accumulator_4 + laserCurrentGenerator_fast_slope_4) mod ACCUMULATOR_MODULO);
            else
                laserCurrentGenerator_current_level_4 <= laserCurrentGenerator_rd_dataB_laser4;
                laserCurrentGenerator_prev_level_4 <= laserCurrentGenerator_current_level_4;
                laserCurrentGenerator_transition_counter_4 <= to_unsigned(0, 16);
                laserCurrentGenerator_slow_accumulator_4 <= to_unsigned(0, 24);
                laserCurrentGenerator_fast_accumulator_4 <= to_unsigned(0, 24);
                if (signed(resize(laserCurrentGenerator_period_counter_4, 10)) < (signed(resize(laserCurrentGenerator_period_counter_limit_4, 10)) - 1)) then
                    laserCurrentGenerator_period_counter_4 <= (laserCurrentGenerator_period_counter_4 + 1);
                else
                    laserCurrentGenerator_period_counter_4 <= to_unsigned(0, 9);
                end if;
                if ((laser_selected = 3) and bool(mode)) then
                    laserCurrentGenerator_slow_slope_4 <= laserCurrentGenerator_slow_slope;
                    laserCurrentGenerator_fast_slope_4 <= laserCurrentGenerator_fast_slope;
                    laserCurrentGenerator_first_offset_4 <= laserCurrentGenerator_first_offset;
                    laserCurrentGenerator_second_offset_4 <= laserCurrentGenerator_second_offset;
                    laserCurrentGenerator_first_breakpoint_4 <= laserCurrentGenerator_first_breakpoint;
                    laserCurrentGenerator_second_breakpoint_4 <= laserCurrentGenerator_second_breakpoint;
                    laserCurrentGenerator_transition_counter_limit_4 <= laserCurrentGenerator_transition_counter_limit;
                    laserCurrentGenerator_period_counter_limit_4 <= resize(laserCurrentGenerator_period_counter_limit, 9);
                    laserCurrentGenerator_lower_window_4 <= laserCurrentGenerator_lower_window;
                    laserCurrentGenerator_upper_window_4 <= laserCurrentGenerator_upper_window;
                    laserCurrentGenerator_sequence_id_4 <= laserCurrentGenerator_sequence_id;
                    laserCurrentGenerator_bank_4 <= bank;
                    laserCurrentGenerator_control_status(LASERCURRENTGENERATOR_CONTROL_STATUS_MODE_B) <= '0';
                end if;
            end if;
        end if;
        case laserCurrentGenerator_output_counter is
            when "0000" =>
                if bool(pulse_100k) then
                    laserCurrentGenerator_output_counter <= to_unsigned(1, 4);
                end if;
            when "0001" =>
                laserCurrentGenerator_output_counter <= to_unsigned(2, 4);
                laserCurrentGenerator_interp_y0 <= laserCurrentGenerator_prev_level_1;
                laserCurrentGenerator_interp_y1 <= laserCurrentGenerator_current_level_1;
                laserCurrentGenerator_interp_beta <= laserCurrentGenerator_interp_1(LASER_CURRENT_GEN_ACC_WIDTH-1 downto (LASER_CURRENT_GEN_ACC_WIDTH - FPGA_REG_WIDTH));
            when "0010" =>
                laserCurrentGenerator_output_counter <= to_unsigned(3, 4);
                laser1_fine_ext <= laserCurrentGenerator_interp_yout;
                if (sel_laser = 0) then
                    ext_laser_current_in_window <= stdl((laserCurrentGenerator_interp_yout >= laserCurrentGenerator_lower_window_1) and (laserCurrentGenerator_interp_yout <= laserCurrentGenerator_upper_window_1));
                end if;
            when "0011" =>
                laserCurrentGenerator_output_counter <= to_unsigned(4, 4);
                laserCurrentGenerator_interp_y0 <= laserCurrentGenerator_prev_level_2;
                laserCurrentGenerator_interp_y1 <= laserCurrentGenerator_current_level_2;
                laserCurrentGenerator_interp_beta <= laserCurrentGenerator_interp_2(LASER_CURRENT_GEN_ACC_WIDTH-1 downto (LASER_CURRENT_GEN_ACC_WIDTH - FPGA_REG_WIDTH));
            when "0100" =>
                laserCurrentGenerator_output_counter <= to_unsigned(5, 4);
                laser2_fine_ext <= laserCurrentGenerator_interp_yout;
                if (sel_laser = 1) then
                    ext_laser_current_in_window <= stdl((laserCurrentGenerator_interp_yout >= laserCurrentGenerator_lower_window_2) and (laserCurrentGenerator_interp_yout <= laserCurrentGenerator_upper_window_2));
                end if;
            when "0101" =>
                laserCurrentGenerator_output_counter <= to_unsigned(6, 4);
                laserCurrentGenerator_interp_y0 <= laserCurrentGenerator_prev_level_3;
                laserCurrentGenerator_interp_y1 <= laserCurrentGenerator_current_level_3;
                laserCurrentGenerator_interp_beta <= laserCurrentGenerator_interp_3(LASER_CURRENT_GEN_ACC_WIDTH-1 downto (LASER_CURRENT_GEN_ACC_WIDTH - FPGA_REG_WIDTH));
            when "0110" =>
                laserCurrentGenerator_output_counter <= to_unsigned(7, 4);
                laser3_fine_ext <= laserCurrentGenerator_interp_yout;
                if (sel_laser = 2) then
                    ext_laser_current_in_window <= stdl((laserCurrentGenerator_interp_yout >= laserCurrentGenerator_lower_window_3) and (laserCurrentGenerator_interp_yout <= laserCurrentGenerator_upper_window_3));
                end if;
            when "0111" =>
                laserCurrentGenerator_output_counter <= to_unsigned(8, 4);
                laserCurrentGenerator_interp_y0 <= laserCurrentGenerator_prev_level_4;
                laserCurrentGenerator_interp_y1 <= laserCurrentGenerator_current_level_4;
                laserCurrentGenerator_interp_beta <= laserCurrentGenerator_interp_4(LASER_CURRENT_GEN_ACC_WIDTH-1 downto (LASER_CURRENT_GEN_ACC_WIDTH - FPGA_REG_WIDTH));
            when others => -- "1000"
                laserCurrentGenerator_output_counter <= to_unsigned(0, 4);
                laser4_fine_ext <= laserCurrentGenerator_interp_yout;
                if (sel_laser = 3) then
                    ext_laser_current_in_window <= stdl((laserCurrentGenerator_interp_yout >= laserCurrentGenerator_lower_window_4) and (laserCurrentGenerator_interp_yout <= laserCurrentGenerator_upper_window_4));
                end if;
        end case;
    end if;
end process MAIN_LASERCURRENTGENERATOR_LOGIC;



dual_port_ram_2 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 10, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => laserCurrentGenerator_enA_laser2, wr_enableA => laserCurrentGenerator_dsp_wr_delayed,
    addressA => laserCurrentGenerator_addrA_laser2, rd_dataA => laserCurrentGenerator_rd_dataA_laser2, wr_dataA => laserCurrentGenerator_wr_dataA_laser2,
    clockB => clk0, enableB => laserCurrentGenerator_enB_laser2, wr_enableB => laserCurrentGenerator_wr_enB_laser2,
    addressB => laserCurrentGenerator_addrB_laser2, rd_dataB => laserCurrentGenerator_rd_dataB_laser2, wr_dataB => laserCurrentGenerator_wr_dataB_laser2
    );



dual_port_ram_1 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 10, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => laserCurrentGenerator_enA_laser1, wr_enableA => laserCurrentGenerator_dsp_wr_delayed,
    addressA => laserCurrentGenerator_addrA_laser1, rd_dataA => laserCurrentGenerator_rd_dataA_laser1, wr_dataA => laserCurrentGenerator_wr_dataA_laser1,
    clockB => clk0, enableB => laserCurrentGenerator_enB_laser1, wr_enableB => laserCurrentGenerator_wr_enB_laser1,
    addressB => laserCurrentGenerator_addrB_laser1, rd_dataB => laserCurrentGenerator_rd_dataB_laser1, wr_dataB => laserCurrentGenerator_wr_dataB_laser1
    );



laser_tuning_offset <= laserlocker_tuning_offset;
wlm_sim_actual <= laserlocker_options(LASERLOCKER_OPTIONS_SIM_ACTUAL_B);


MAIN_LASERLOCKER_LOGIC: process (clk0, reset) is
    variable t: integer;
    variable temp: std_logic;
begin
    if bool(reset) then
        laserlocker_cs <= to_unsigned(0, 16);
        laserlocker_options <= to_unsigned(0, 2);
        laserlocker_eta1 <= to_unsigned(0, 16);
        laserlocker_ref1 <= to_unsigned(0, 16);
        laserlocker_eta2 <= to_unsigned(0, 16);
        laserlocker_ref2 <= to_unsigned(0, 16);
        laserlocker_eta1_dark <= to_unsigned(0, 16);
        laserlocker_ref1_dark <= to_unsigned(0, 16);
        laserlocker_eta2_dark <= to_unsigned(0, 16);
        laserlocker_ref2_dark <= to_unsigned(0, 16);
        laserlocker_eta1_offset <= to_unsigned(0, 16);
        laserlocker_ref1_offset <= to_unsigned(0, 16);
        laserlocker_eta2_offset <= to_unsigned(0, 16);
        laserlocker_ref2_offset <= to_unsigned(0, 16);
        laserlocker_ratio1 <= to_unsigned(0, 16);
        laserlocker_ratio2 <= to_unsigned(0, 16);
        laserlocker_ratio1_center <= to_unsigned(0, 16);
        laserlocker_ratio1_multiplier <= to_unsigned(0, 16);
        laserlocker_ratio2_center <= to_unsigned(0, 16);
        laserlocker_ratio2_multiplier <= to_unsigned(0, 16);
        laserlocker_tuning_offset <= to_unsigned(32768, 16);
        laserlocker_lock_error <= to_unsigned(0, 16);
        laserlocker_wm_lock_window <= to_unsigned(0, 16);
        laserlocker_wm_int_gain <= to_unsigned(0, 16);
        laserlocker_wm_prop_gain <= to_unsigned(0, 16);
        laserlocker_wm_deriv_gain <= to_unsigned(0, 16);
        laserlocker_fine_current <= to_unsigned(0, 16);
        laserlocker_cycle_counter <= to_unsigned(MAX_CYCLES, 16);
        laserlocker_div_ce <= '0';
        laserlocker_div_num <= to_unsigned(0, 16);
        laserlocker_div_den <= to_unsigned(0, 16);
        laserlocker_prev_lock_error <= to_unsigned(0, 16);
        laserlocker_prev_lock_error_deriv <= to_unsigned(0, 16);
        laserlocker_deriv <= to_unsigned(0, 16);
        laserlocker_deriv2 <= to_unsigned(0, 16);
        laser_freq_ok <= '0';
        metadata_strobe <= '0';
        laserlocker_prbs_reg <= to_unsigned(1, 8);
        laserlocker_prbs_augment <= '0';
        laserlocker_awaiting_strobe <= '1';
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_cs_addr) then
                    if bool(dsp_wr) then
                        laserlocker_cs <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_cs, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_options_addr) then
                    if bool(dsp_wr) then
                        laserlocker_options <= resize(dsp_data_out, 2);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_options, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta1_addr) then
                    if bool(dsp_wr) then
                        laserlocker_eta1 <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_eta1, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref1_addr) then
                    if bool(dsp_wr) then
                        laserlocker_ref1 <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_ref1, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta2_addr) then
                    if bool(dsp_wr) then
                        laserlocker_eta2 <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_eta2, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref2_addr) then
                    if bool(dsp_wr) then
                        laserlocker_ref2 <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_ref2, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta1_dark_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_eta1_dark, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref1_dark_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_ref1_dark, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta2_dark_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_eta2_dark, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref2_dark_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_ref2_dark, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta1_offset_addr) then
                    if bool(dsp_wr) then
                        laserlocker_eta1_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_eta1_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref1_offset_addr) then
                    if bool(dsp_wr) then
                        laserlocker_ref1_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_ref1_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta2_offset_addr) then
                    if bool(dsp_wr) then
                        laserlocker_eta2_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_eta2_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref2_offset_addr) then
                    if bool(dsp_wr) then
                        laserlocker_ref2_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_ref2_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio1_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_ratio1, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio2_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_ratio2, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio1_center_addr) then
                    if bool(dsp_wr) then
                        laserlocker_ratio1_center <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_ratio1_center, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio1_multiplier_addr) then
                    if bool(dsp_wr) then
                        laserlocker_ratio1_multiplier <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_ratio1_multiplier, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio2_center_addr) then
                    if bool(dsp_wr) then
                        laserlocker_ratio2_center <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_ratio2_center, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio2_multiplier_addr) then
                    if bool(dsp_wr) then
                        laserlocker_ratio2_multiplier <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_ratio2_multiplier, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_tuning_offset_addr) then
                    if bool(dsp_wr) then
                        laserlocker_tuning_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_tuning_offset, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_lock_error_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_lock_error, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_wm_lock_window_addr) then
                    if bool(dsp_wr) then
                        laserlocker_wm_lock_window <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_wm_lock_window, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_wm_int_gain_addr) then
                    if bool(dsp_wr) then
                        laserlocker_wm_int_gain <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_wm_int_gain, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_wm_prop_gain_addr) then
                    if bool(dsp_wr) then
                        laserlocker_wm_prop_gain <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_wm_prop_gain, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_wm_deriv_gain_addr) then
                    if bool(dsp_wr) then
                        laserlocker_wm_deriv_gain <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_laserlocker <= resize(laserlocker_wm_deriv_gain, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_fine_current_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_fine_current, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_cycle_counter_addr) then
                    dsp_data_in_laserlocker <= resize(laserlocker_cycle_counter, 32);
                else
                    dsp_data_in_laserlocker <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_laserlocker <= to_unsigned(0, 32);
        end if;
        if bool(laserlocker_cs(LASERLOCKER_CS_RUN_B)) then
            if bool(laserlocker_cs(LASERLOCKER_CS_CONT_B)) then
                laserlocker_eta1 <= eta1;
                laserlocker_ref1 <= ref1;
                laserlocker_eta2 <= eta2;
                laserlocker_ref2 <= ref2;
                laserlocker_cs(LASERLOCKER_CS_ACC_EN_B) <= acc_en;
                laserlocker_cs(LASERLOCKER_CS_ADC_STROBE_B) <= wlm_data_available;
            end if;
            if bool(laserlocker_cs(LASERLOCKER_CS_TUNING_OFFSET_SEL_B)) then
                laserlocker_tuning_offset <= tuner_value;
            end if;
            if bool(laserlocker_cs(LASERLOCKER_CS_SAMPLE_DARK_B)) then
                laserlocker_eta1_dark <= laserlocker_eta1;
                laserlocker_ref1_dark <= laserlocker_ref1;
                laserlocker_eta2_dark <= laserlocker_eta2;
                laserlocker_ref2_dark <= laserlocker_ref2;
            end if;
            laserlocker_div_ce <= stdl((laserlocker_cycle_counter = 1) or (signed(resize(laserlocker_cycle_counter, 17)) = (DIV_LATENCY + 1)));
            if (laserlocker_cycle_counter = 0) then
                laserlocker_div_num <= (laserlocker_eta1 - laserlocker_eta1_offset);
                laserlocker_div_den <= (laserlocker_ref1 - laserlocker_ref1_offset);
            elsif (laserlocker_cycle_counter = DIV_LATENCY) then
                laserlocker_div_num <= (laserlocker_eta2 - laserlocker_eta2_offset);
                laserlocker_div_den <= (laserlocker_ref2 - laserlocker_ref2_offset);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (DIV_LATENCY + 1)) then
                laserlocker_ratio1 <= laserlocker_div_quot;
                ratio1 <= laserlocker_div_quot;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (DIV_LATENCY + 2)) then
                laserlocker_mult_a <= resize(unsigned((signed(resize(laserlocker_ratio1, 17)) - signed(resize(laserlocker_ratio1_center, 17))) mod FPGA_REG_MAXVAL), 16);
                laserlocker_mult_b <= laserlocker_ratio1_multiplier;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((DIV_LATENCY + 2) + MULT_LATENCY)) then
                laserlocker_lock_error <= ((laserlocker_lock_error + laserlocker_mult_p) mod FPGA_REG_MAXVAL);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((2 * DIV_LATENCY) + 1)) then
                laserlocker_ratio2 <= laserlocker_div_quot;
                ratio2 <= laserlocker_div_quot;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((2 * DIV_LATENCY) + 2)) then
                laserlocker_mult_a <= resize(unsigned((signed(resize(laserlocker_ratio2, 17)) - signed(resize(laserlocker_ratio2_center, 17))) mod FPGA_REG_MAXVAL), 16);
                laserlocker_mult_b <= laserlocker_ratio2_multiplier;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (((2 * DIV_LATENCY) + 2) + MULT_LATENCY)) then
                laserlocker_lock_error <= ((laserlocker_lock_error + laserlocker_mult_p) mod FPGA_REG_MAXVAL);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 2) + MULT_LATENCY) + 1)) then
                meta5 <= laserlocker_lock_error;
                if bool(laserlocker_cs(LASERLOCKER_CS_PRBS_B)) then
                    if bool(laserlocker_prbs_reg(0)) then
                        laserlocker_lock_error <= to_unsigned(256, 16);
                    else
                        laserlocker_lock_error <= to_unsigned(65280, 16);
                    end if;
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 2) + MULT_LATENCY) + 2)) then
                if (signed(laserlocker_lock_error) >= 0) then
                    laser_freq_ok <= stdl(laserlocker_lock_error <= laserlocker_wm_lock_window);
                else
                    laser_freq_ok <= stdl((-signed(laserlocker_lock_error)) <= signed(resize(laserlocker_wm_lock_window, 17)));
                end if;
                laserlocker_mult_a <= laserlocker_lock_error;
                laserlocker_mult_b <= laserlocker_wm_int_gain;
                laserlocker_deriv <= resize(unsigned((signed(resize(laserlocker_lock_error, 17)) - signed(resize(laserlocker_prev_lock_error, 17))) mod FPGA_REG_MAXVAL), 16);
                laserlocker_prev_lock_error <= laserlocker_lock_error;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 1) + (2 * MULT_LATENCY)) + 2)) then
                laserlocker_mult_a <= laserlocker_deriv;
                laserlocker_mult_b <= laserlocker_wm_prop_gain;
                laserlocker_deriv2 <= resize(unsigned((signed(resize(laserlocker_deriv, 17)) - signed(resize(laserlocker_prev_lock_error_deriv, 17))) mod FPGA_REG_MAXVAL), 16);
                laserlocker_prev_lock_error_deriv <= laserlocker_deriv;
                t := to_integer(signed(resize(laserlocker_fine_current, 17)) + signed(laserlocker_mult_p));
                if (t < 0) then
                    laserlocker_fine_current <= to_unsigned(0, 16);
                else
                    if (t >= 65535) then
                        laserlocker_fine_current <= to_unsigned(65535, 16);
                    else
                        laserlocker_fine_current <= to_unsigned(t, 16);
                    end if;
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 1) + (3 * MULT_LATENCY)) + 2)) then
                laserlocker_mult_a <= laserlocker_deriv2;
                laserlocker_mult_b <= laserlocker_wm_deriv_gain;
                t := to_integer(signed(resize(laserlocker_fine_current, 17)) + signed(laserlocker_mult_p));
                if (t < 0) then
                    laserlocker_fine_current <= to_unsigned(0, 16);
                else
                    if (t >= 65535) then
                        laserlocker_fine_current <= to_unsigned(65535, 16);
                    else
                        laserlocker_fine_current <= to_unsigned(t, 16);
                    end if;
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 1) + (4 * MULT_LATENCY)) + 2)) then
                t := to_integer(signed(resize(laserlocker_fine_current, 17)) + signed(laserlocker_mult_p));
                if (t < 0) then
                    laserlocker_fine_current <= to_unsigned(0, 16);
                else
                    if (t >= 65535) then
                        laserlocker_fine_current <= to_unsigned(65535, 16);
                    else
                        laserlocker_fine_current <= to_unsigned(t, 16);
                    end if;
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 1) + (4 * MULT_LATENCY)) + 3)) then
                laser_locking_pid <= laserlocker_fine_current;
                if bool(laserlocker_cs(LASERLOCKER_CS_PRBS_B)) then
                    if bool(laserlocker_prbs_reg(0)) then
                        laser_fine_current <= to_unsigned(33024, 16);
                    else
                        laser_fine_current <= to_unsigned(32512, 16);
                    end if;
                    temp := stdl((laserlocker_prbs_reg = 238) and (not bool(laserlocker_prbs_augment)));
                    laserlocker_prbs_augment <= temp;
                    if (not bool(temp)) then
                        if bool(laserlocker_prbs_reg(7)) then
                            laserlocker_prbs_reg <= unsigned'((laserlocker_prbs_reg(7-1 downto 0) xor to_unsigned(52, 7)) & to_unsigned(1, 1));
                        else
                            laserlocker_prbs_reg <= unsigned'(laserlocker_prbs_reg(7-1 downto 0) & to_unsigned(0, 1));
                        end if;
                    end if;
                else
                    laser_fine_current <= laserlocker_fine_current;
                    laserlocker_prbs_reg <= to_unsigned(1, 8);
                    laserlocker_prbs_augment <= '0';
                end if;
            end if;
            if (laserlocker_cycle_counter < MAX_CYCLES) then
                laserlocker_cycle_counter <= (laserlocker_cycle_counter + 1);
            else
                metadata_strobe <= '1';
                if bool(laserlocker_cs(LASERLOCKER_CS_ADC_STROBE_B)) then
                    if bool(laserlocker_awaiting_strobe) then
                        laserlocker_awaiting_strobe <= '0';
                        meta5 <= laserlocker_lock_error;
                        laserlocker_cycle_counter <= to_unsigned(0, 16);
                        metadata_strobe <= '0';
                        if bool(laserlocker_tuning_offset(15)) then
                            laserlocker_lock_error <= unsigned'('0' & '0' & '0' & '0' & laserlocker_tuning_offset(15-1 downto 3));
                        else
                            laserlocker_lock_error <= unsigned'('1' & '1' & '1' & '1' & laserlocker_tuning_offset(15-1 downto 3));
                        end if;
                    end if;
                else
                    laserlocker_awaiting_strobe <= '1';
                end if;
            end if;
            if (not bool(laserlocker_cs(LASERLOCKER_CS_ACC_EN_B))) then
                laserlocker_fine_current <= to_unsigned(32768, 16);
                laser_fine_current <= to_unsigned(32768, 16);
            end if;
            if bool(laserlocker_options(LASERLOCKER_OPTIONS_DIRECT_TUNE_B)) then
                laser_fine_current <= laserlocker_tuning_offset;
            end if;
            if (not bool(laserlocker_cs(LASERLOCKER_CS_CONT_B))) then
                laserlocker_cs(LASERLOCKER_CS_RUN_B) <= '0';
            end if;
            laserlocker_cs(LASERLOCKER_CS_CURRENT_OK_B) <= metadata_strobe;
            laserlocker_cs(LASERLOCKER_CS_LASER_FREQ_OK_B) <= laser_freq_ok;
        end if;
    end if;
end process MAIN_LASERLOCKER_LOGIC;



signed_mult18x18_4 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => laserlocker_signedMultiplier_a_s, B => laserlocker_signedMultiplier_b_s, P => laserlocker_signedMultiplier_p_s
    );



laserlocker_signedMultiplier_a_s <= signed(unsigned'(laserlocker_mult_a & '0' & '0'));
laserlocker_signedMultiplier_b_s <= signed(unsigned'(laserlocker_mult_b & '0' & '0'));
laserlocker_mult_p <= (unsigned'(laserlocker_signedMultiplier_p_s(35) & unsigned(laserlocker_signedMultiplier_p_s(34-1 downto 19))) mod 65536);
laserlocker_mult_o <= stdl(laserlocker_signedMultiplier_p_s(35) /= laserlocker_signedMultiplier_p_s(34));


MAIN_LASERLOCKER_DIVIDER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        laserlocker_divider_rfd <= '1';
        laserlocker_div_rfd <= '1';
        laserlocker_divider_Nreg <= to_unsigned(0, 17);
        laserlocker_divider_Dreg <= to_unsigned(0, 16);
        laserlocker_divider_Qreg <= to_unsigned(0, 16);
        laserlocker_div_quot <= to_unsigned(0, 16);
        laserlocker_divider_done <= '0';
        laserlocker_divider_i <= to_unsigned(width - 1, 4);
    elsif rising_edge(clk0) then
        if bool(laserlocker_divider_done) then
            laserlocker_div_quot <= laserlocker_divider_Qreg;
            laserlocker_divider_rfd <= '1';
            laserlocker_div_rfd <= '1';
            laserlocker_divider_done <= '0';
        elsif (bool(laserlocker_divider_rfd) and bool(laserlocker_div_ce)) then
            laserlocker_divider_Nreg <= resize(laserlocker_div_num, 17);
            laserlocker_divider_Dreg <= laserlocker_div_den;
            laserlocker_divider_rfd <= '0';
            laserlocker_div_rfd <= '0';
            laserlocker_divider_i <= to_unsigned(width - 1, 4);
            laserlocker_divider_done <= '0';
        elsif (not bool(laserlocker_divider_rfd)) then
            if (laserlocker_divider_Nreg >= laserlocker_divider_Dreg) then
                laserlocker_divider_Qreg(to_integer(laserlocker_divider_i)) <= '1';
                laserlocker_divider_Nreg <= resize(unsigned(shift_left((signed(resize(laserlocker_divider_Nreg, 18)) - signed(resize(laserlocker_divider_Dreg, 17))), 1)), 17);
            else
                laserlocker_divider_Qreg(to_integer(laserlocker_divider_i)) <= '0';
                laserlocker_divider_Nreg <= shift_left(laserlocker_divider_Nreg, 1);
            end if;
            if (laserlocker_divider_i = 0) then
                laserlocker_divider_done <= '1';
                laserlocker_divider_i <= to_unsigned(width - 1, 4);
            else
                laserlocker_divider_i <= (laserlocker_divider_i - 1);
            end if;
        end if;
    end if;
end process MAIN_LASERLOCKER_DIVIDER_LOGIC;


MAIN_PZTVALVEDAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pztValveDac_chanD_data <= to_unsigned(0, 16);
        pztValveDac_dac_ld <= '1';
    elsif rising_edge(clk0) then
        case pztValveDac_state is
            when IDLE =>
                if bool(pulse_100k) then
                    pztValveDac_chanD_data <= pzt_scaled;
                    pztValveDac_counter <= to_unsigned(0, 5);
                    pztValveDac_dac_ld <= '0';
                    pztValveDac_state <= WAIT_0;
                end if;
            when WAIT_0 =>
                if (not bool(clk_2M5)) then
                    if (signed(resize(pztValveDac_counter, 6)) < (CHAND_DATA_END - 1)) then
                        pztValveDac_counter <= (pztValveDac_counter + 1);
                        pztValveDac_state <= WAIT_1;
                    else
                        pztValveDac_dac_ld <= '1';
                        pztValveDac_state <= IDLE;
                    end if;
                end if;
            when WAIT_1 =>
                if bool(clk_2M5) then
                    pztValveDac_dac_ld <= '0';
                    pztValveDac_state <= WAIT_0;
                end if;
            when others =>
                pztValveDac_state <= IDLE;
        end case;
        pzt_valve_dac_sdi <= pztValveDac_dac_sdi;
        pzt_valve_dac_ld <= pztValveDac_dac_ld;
        pzt_valve_dac_sck <= clk_2M5;
    end if;
end process MAIN_PZTVALVEDAC_LOGIC;


MAIN_PZTVALVEDAC_COMB2: process (pztValveDac_chanD_data, pztValveDac_counter) is
begin
    pztValveDac_dac_sdi <= '1';
    if ((CHAND_CONTROL_START <= pztValveDac_counter) and (pztValveDac_counter < CHAND_CONTROL_END)) then
        case ((CHAND_CONTROL_END - 1) - to_integer(pztValveDac_counter)) is
            when 0 => pztValveDac_dac_sdi <= '1';
            when 1 => pztValveDac_dac_sdi <= '1';
            when 2 => pztValveDac_dac_sdi <= '0';
            when 3 => pztValveDac_dac_sdi <= '0';
            when 4 => pztValveDac_dac_sdi <= '1';
            when 5 => pztValveDac_dac_sdi <= '1';
            when 6 => pztValveDac_dac_sdi <= '0';
            when others => pztValveDac_dac_sdi <= '0';
        end case;
    elsif ((CHAND_DATA_START <= pztValveDac_counter) and (pztValveDac_counter < CHAND_DATA_END)) then
        pztValveDac_dac_sdi <= pztValveDac_chanD_data(((CHAND_DATA_END - 1) - to_integer(pztValveDac_counter)));
    else
        pztValveDac_dac_sdi <= '0';
    end if;
end process MAIN_PZTVALVEDAC_COMB2;



signed_mult18x18_7 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => scaler_mult_a_s, B => scaler_mult_b_s, P => scaler_mult_p_s
    );


MAIN_SCALER_MULT_COMB: process (scaler_a, scaler_b, scaler_mult_p_s) is
begin
    scaler_mult_a_s(17-1 downto 0) <= signed(scaler_a);
    scaler_mult_a_s(17) <= '0';
    scaler_mult_b_s(17-1 downto 0) <= signed(scaler_b);
    scaler_mult_b_s(17) <= '0';
    scaler_p <= unsigned(scaler_mult_p_s(34-1 downto 0));
end process MAIN_SCALER_MULT_COMB;


MAIN_SCALER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        scaler_scale1 <= to_unsigned(40000, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = scaler_scale1_addr) then
                    if bool(dsp_wr) then
                        scaler_scale1 <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_scaler <= resize(scaler_scale1, 32);
                else
                    dsp_data_in_scaler <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_scaler <= to_unsigned(0, 32);
        end if;
        scaler_a <= unsigned'(pzt & to_unsigned(0, 1));
        scaler_b <= unsigned'(scaler_scale1 & to_unsigned(0, 1));
        pzt_scaled <= scaler_p(34-1 downto 18);
    end if;
end process MAIN_SCALER_LOGIC;



intronix_clksel <= kernel_intronix_clksel;
intronix_1 <= kernel_intronix_1;
intronix_2 <= kernel_intronix_2;
intronix_3 <= kernel_intronix_3;
diag_1 <= kernel_diag_1;
config <= kernel_config;
dout <= unsigned'(kernel_dout_hi & kernel_dout_lo);
kernel_din <= din;
status_led(0) <= kernel_status_led(KERNEL_STATUS_LED_RED_B);
status_led(1) <= kernel_status_led(KERNEL_STATUS_LED_GREEN_B);
fan(0) <= kernel_fan(KERNEL_FAN_FAN1_B);
fan(1) <= kernel_fan(KERNEL_FAN_FAN2_B);


MAIN_KERNEL_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        kernel_control <= to_unsigned(control_init, 16);
        kernel_diag_1 <= to_unsigned(0, 8);
        kernel_config <= to_unsigned(0, 16);
        kernel_intronix_clksel <= to_unsigned(0, 5);
        kernel_intronix_1 <= to_unsigned(0, 8);
        kernel_intronix_2 <= to_unsigned(0, 8);
        kernel_intronix_3 <= to_unsigned(0, 8);
        kernel_overload <= to_unsigned(0, 16);
        i2c_reset <= '1';
        kernel_dout_hi <= to_unsigned(0, 8);
        kernel_dout_lo <= to_unsigned(0, 32);
        kernel_status_led <= to_unsigned(0, 16);
        kernel_fan <= to_unsigned(0, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_magic_code_addr) then
                    dsp_data_in_kernel <= unsigned'("11000000110111100000000000000001");
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_control_addr) then
                    if bool(dsp_wr) then
                        kernel_control <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_control, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_diag_1_addr) then
                    if bool(dsp_wr) then
                        kernel_diag_1 <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_diag_1, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_config_addr) then
                    if bool(dsp_wr) then
                        kernel_config <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_config, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_intronix_clksel_addr) then
                    if bool(dsp_wr) then
                        kernel_intronix_clksel <= resize(dsp_data_out, 5);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_intronix_clksel, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_intronix_1_addr) then
                    if bool(dsp_wr) then
                        kernel_intronix_1 <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_intronix_1, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_intronix_2_addr) then
                    if bool(dsp_wr) then
                        kernel_intronix_2 <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_intronix_2, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_intronix_3_addr) then
                    if bool(dsp_wr) then
                        kernel_intronix_3 <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_intronix_3, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_overload_addr) then
                    dsp_data_in_kernel <= resize(kernel_overload, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_dout_hi_addr) then
                    if bool(dsp_wr) then
                        kernel_dout_hi <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_dout_hi, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_dout_lo_addr) then
                    if bool(dsp_wr) then
                        kernel_dout_lo <= dsp_data_out;
                    end if;
                    dsp_data_in_kernel <= kernel_dout_lo;
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_din_addr) then
                    dsp_data_in_kernel <= resize(kernel_din, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_status_led_addr) then
                    if bool(dsp_wr) then
                        kernel_status_led <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_status_led, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_fan_addr) then
                    if bool(dsp_wr) then
                        kernel_fan <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_fan, 32);
                else
                    dsp_data_in_kernel <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_kernel <= to_unsigned(0, 32);
        end if;
        if bool(kernel_control(KERNEL_CONTROL_OVERLOAD_RESET_B)) then
            kernel_control(KERNEL_CONTROL_OVERLOAD_RESET_B) <= '0';
            kernel_overload <= overload_in;
        else
            kernel_overload <= (kernel_overload or overload_in);
        end if;
        if (kernel_overload /= 0) then
            overload_out <= '1';
        else
            overload_out <= '0';
        end if;
        i2c_reset <= kernel_control(KERNEL_CONTROL_I2C_RESET_B);
        dout_man <= kernel_control(KERNEL_CONTROL_DOUT_MAN_B);
    end if;
end process MAIN_KERNEL_LOGIC;


MAIN_COMB: process (lsr3_ss_temp, aux_pzt_dac_sck, lsr1_ss_temp, pwm_laser1_inv_out, dsp_data_in_pwm_hotbox, intronix_clksel, dsp_emif_ce, clk0, dsp_data_in_laserlocker, acq_done_irq, pwm_laser4_inv_out, config, lsr2_mosi_temp, rd_irq, rd_trig, lsr2_ss_temp, wmm_rd_out, dsp_data_in_dynamicpwm_inlet, dsp_data_in_scaler, channel_1, channel_3, channel_2, dsp_data_in_wlmsim, pwm_laser1_out, lsr4_ss_temp, aux_pzt_dac_ld, lsr3_mosi_temp, warm_box_pwm_out, filter_heater_pwm_out, pwm_laser2_inv_out, heater_pwm_out, engine1_pwm_out, pwm_laser4_out, dsp_data_in_rdman, dsp_data_in_lasercurrentgenerator, clk_2M5, clk_5M, engine2_pwm_out, dsp_data_in_rdsim, channel_4, lsr1_mosi_temp, dsp_data_in_pwm_warmbox, warm_box_tec_overload, lsr4_mosi_temp, dsp_data_in_kernel, dsp_data_in_twGen, dsp_data_in_rdmemory, dsp_data_in_pwm_laser3, dsp_data_in_pwm_laser2, dsp_data_in_pwm_laser1, hot_box_tec_overload, adc_clk, dsp_data_in_pwm_laser4, aux_pzt_dac_sdi, hot_box_pwm_out, status_led, pwm_laser2_out, dsp_data_in_inject, i2c_reset, counter, pwm_laser3_inv_out, dsp_data_in_dynamicpwm_outlet, pwm_laser3_out, dsp_data_in_pwm_engine2, dsp_data_in_pwm_engine1, dsp_data_in_pwm_filter_heater, fan, dsp_data_in_pwm_heater, diag_1) is
begin
    dsp_data_in <= (((((((((((((((((((((dsp_data_in_dynamicpwm_inlet or dsp_data_in_dynamicpwm_outlet) or dsp_data_in_inject) or dsp_data_in_kernel) or dsp_data_in_lasercurrentgenerator) or dsp_data_in_laserlocker) or dsp_data_in_pwm_heater) or dsp_data_in_pwm_hotbox) or dsp_data_in_pwm_engine1) or dsp_data_in_pwm_engine2) or dsp_data_in_pwm_laser1) or dsp_data_in_pwm_laser2) or dsp_data_in_pwm_laser3) or dsp_data_in_pwm_laser4) or dsp_data_in_rdman) or dsp_data_in_rdmemory) or dsp_data_in_rdsim) or dsp_data_in_twGen) or dsp_data_in_pwm_warmbox) or dsp_data_in_wlmsim) or dsp_data_in_scaler) or dsp_data_in_pwm_filter_heater);
    overload_in(OVERLOAD_WarmBoxTecBit) <= warm_box_tec_overload;
    overload_in(OVERLOAD_HotBoxTecBit) <= hot_box_tec_overload;
    intronix(8-1 downto 0) <= channel_1;
    intronix(16-1 downto 8) <= channel_2;
    intronix(24-1 downto 16) <= channel_3;
    intronix(33-1 downto 24) <= channel_4;
    if (intronix_clksel = 0) then
        intronix(33) <= clk0;
    elsif (intronix_clksel <= NSTAGES) then
        intronix(33) <= counter(to_integer(signed(resize(intronix_clksel, 6)) - 1));
    else
        intronix(33) <= '0';
    end if;
    monitor <= rd_trig;
    aux_din(3) <= rd_trig;
    ce2 <= dsp_emif_ce(2);
    lsr1_0 <= pwm_laser1_out;
    lsr1_1 <= pwm_laser1_inv_out;
    lsr2_0 <= pwm_laser2_out;
    lsr2_1 <= pwm_laser2_inv_out;
    lsr3_0 <= pwm_laser3_out;
    lsr3_1 <= pwm_laser3_inv_out;
    lsr4_0 <= pwm_laser4_out;
    lsr4_1 <= pwm_laser4_inv_out;
    warm_box_pwm <= warm_box_pwm_out;
    hot_box_pwm <= hot_box_pwm_out;
    heater_pwm <= heater_pwm_out;
    wmm_rd <= wmm_rd_out;
    rd_adc_clk <= adc_clk;
    rd_adc_oe <= '1';
    fpga_led <= counter(NSTAGES-1 downto (NSTAGES - 4));
    i2c_rst0 <= i2c_reset;
    i2c_rst1 <= i2c_reset;
    dsp_ext_int4 <= rd_irq;
    dsp_ext_int5 <= acq_done_irq;
    dsp_ext_int6 <= '0';
    dsp_ext_int7 <= '0';
    lsr1_sck <= stdl(bool(clk_5M) and (not bool(diag_1(4))));
    lsr2_sck <= stdl(bool(clk_5M) and (not bool(diag_1(5))));
    lsr3_sck <= stdl(bool(clk_5M) and (not bool(diag_1(6))));
    lsr4_sck <= stdl(bool(clk_5M) and (not bool(diag_1(7))));
    lsr1_ss <= stdl(bool(lsr1_ss_temp) and (not bool(diag_1(4))));
    lsr2_ss <= stdl(bool(lsr2_ss_temp) and (not bool(diag_1(5))));
    lsr3_ss <= stdl(bool(lsr3_ss_temp) and (not bool(diag_1(6))));
    lsr4_ss <= stdl(bool(lsr4_ss_temp) and (not bool(diag_1(7))));
    lsr1_mosi <= stdl(bool(lsr1_mosi_temp) and (not bool(diag_1(4))));
    lsr2_mosi <= stdl(bool(lsr2_mosi_temp) and (not bool(diag_1(5))));
    lsr3_mosi <= stdl(bool(lsr3_mosi_temp) and (not bool(diag_1(6))));
    lsr4_mosi <= stdl(bool(lsr4_mosi_temp) and (not bool(diag_1(7))));
    wmm_clk <= clk_2M5;
    chanC_data_in <= to_unsigned(0, 16);
    if bool(config(KERNEL_CONFIG_AUX_PZT_B)) then
        aux_din(0) <= aux_pzt_dac_sdi;
        aux_din(1) <= aux_pzt_dac_sck;
        aux_din(2) <= aux_pzt_dac_ld;
    end if;
    if bool(config(KERNEL_CONFIG_ENGINE1_TEC_B)) then
        aux_din(2) <= engine1_pwm_out;
    end if;
    if bool(config(KERNEL_CONFIG_ENGINE2_TEC_B)) then
        aux_din(3) <= engine2_pwm_out;
    end if;
    fp_led <= to_unsigned(0, 4);
    fp_led(0) <= status_led(0);
    fp_led(1) <= status_led(1);
    fp_led(2) <= fan(1);
    fp_lcd <= to_unsigned(0, 8);
    fp_lcd(1) <= filter_heater_pwm_out;
    fp_lcd(2) <= fan(0);
    fpga_program_enable <= '1';
    cyp_reset <= '0';
end process MAIN_COMB;


MAIN_RDMAN_COMB1: process (rd_adc, rdman_options, rdsim_value) is
begin
    if bool(rdman_options(RDMAN_OPTIONS_SIM_ACTUAL_B)) then
        rdman_rd_data <= rd_adc;
    else
        rdman_rd_data <= rdsim_value;
    end if;
end process MAIN_RDMAN_COMB1;


MAIN_RDMAN_COMB2: process (rdman_sel_fine_current_slope, ext_laser_current_in_window, extended_current_mode, laser_freq_ok, rdman_rd_data, rdman_laser_extra, tuner_slope, rdman_acq_done_irq, rdman_rd_adc_clk, tuner_in_window, rdman_rd_irq, rdman_rd_trig, rdman_options, rdman_bank) is
begin
    bank <= rdman_bank;
    rd_irq <= rdman_rd_irq;
    acq_done_irq <= rdman_acq_done_irq;
    rd_trig <= rdman_rd_trig;
    laser_extra <= rdman_laser_extra;
    adc_clk <= rdman_rd_adc_clk;
    if bool(extended_current_mode) then
        rdman_tuner_gating_conditions <= stdl(bool(ext_laser_current_in_window) and ((bool(rdman_sel_fine_current_slope) and bool(rdman_options(RDMAN_OPTIONS_UP_SLOPE_ENABLE_B))) or ((not bool(rdman_sel_fine_current_slope)) and bool(rdman_options(RDMAN_OPTIONS_DOWN_SLOPE_ENABLE_B)))));
    else
        rdman_tuner_gating_conditions <= stdl(bool(tuner_in_window) and ((bool(tuner_slope) and bool(rdman_options(RDMAN_OPTIONS_UP_SLOPE_ENABLE_B))) or ((not bool(tuner_slope)) and bool(rdman_options(RDMAN_OPTIONS_DOWN_SLOPE_ENABLE_B)))));
    end if;
    rdman_freq_gating_conditions <= stdl(bool(laser_freq_ok) or (not bool(rdman_options(RDMAN_OPTIONS_LOCK_ENABLE_B))));
    wr_data <= resize(rdman_rd_data, 18);
end process MAIN_RDMAN_COMB2;


MAIN_RDMAN_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        rdman_control <= to_unsigned(0, 16);
        rdman_status <= to_unsigned(0, 16);
        rdman_options <= to_unsigned(0, 16);
        rdman_param0 <= to_unsigned(0, 32);
        rdman_param1 <= to_unsigned(0, 32);
        rdman_param2 <= to_unsigned(0, 32);
        rdman_param3 <= to_unsigned(0, 32);
        rdman_param4 <= to_unsigned(0, 32);
        rdman_param5 <= to_unsigned(0, 32);
        rdman_param6 <= to_unsigned(0, 32);
        rdman_param7 <= to_unsigned(0, 32);
        rdman_param8 <= to_unsigned(0, 32);
        rdman_param9 <= to_unsigned(0, 32);
        rdman_data_addrcntr <= to_unsigned(0, 12);
        rdman_metadata_addrcntr <= to_unsigned(0, 12);
        rdman_param_addrcntr <= to_unsigned(0, 6);
        rdman_divisor <= to_unsigned(0, 16);
        rdman_num_samp <= to_unsigned(0, 12);
        rdman_threshold <= to_unsigned(0, 16);
        rdman_lock_duration <= to_unsigned(0, 16);
        rdman_precontrol_duration <= to_unsigned(0, 16);
        rdman_off_duration <= to_unsigned(0, 16);
        rdman_extra_duration <= to_unsigned(0, 16);
        rdman_timeout_duration <= to_unsigned(0, 32);
        rdman_tuner_at_ringdown <= to_unsigned(0, 16);
        rdman_metadata_addr_at_ringdown <= to_unsigned(0, 16);
        rdman_ringdown_data <= to_unsigned(0, 18);
        rdman_abort <= '0';
        rdman_acq_done_irq <= '0';
        rdman_bank <= '0';
        rdman_expiry_time <= to_unsigned(0, 32);
        rdman_init_flag <= '1';
        rdman_lapped <= '0';
        rdman_metadataAcqState <= IDLE;
        rdman_metadata_acq <= '0';
        rdman_paramState <= IDLE;
        rdman_param_acq <= '0';
        rdman_rd_adc_clk <= '0';
        rdman_rd_divider <= to_unsigned(0, 16);
        rdman_rd_irq <= '0';
        rdman_rd_trig <= '0';
        rdman_seqState <= IDLE;
        rdman_timeout <= '0';
        rdman_us_since_start <= to_unsigned(0, 32);
        rdman_us_timer_enable <= '0';
        acc_en <= '0';
        laser_locked <= '0';
        rdman_div50_counter <= to_unsigned(0, 6);
        rdman_us_after_ringdown <= to_unsigned(0, 17);
        rdman_sel_fine_current <= to_unsigned(0, 16);
        rdman_sel_fine_current_prev <= to_unsigned(0, 16);
        rdman_sel_fine_current_slope <= '0';
        rdman_ext_laser_level_counter <= to_unsigned(0, 16);
        rdman_ext_laser_sequence_id <= to_unsigned(0, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_control_addr) then
                if bool(dsp_wr) then
                    rdman_control <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_control, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_status_addr) then
                dsp_data_in_rdman <= resize(rdman_status, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_options_addr) then
                if bool(dsp_wr) then
                    rdman_options <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_options, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param0_addr) then
                if bool(dsp_wr) then
                    rdman_param0 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param0;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param1_addr) then
                if bool(dsp_wr) then
                    rdman_param1 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param1;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param2_addr) then
                if bool(dsp_wr) then
                    rdman_param2 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param2;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param3_addr) then
                if bool(dsp_wr) then
                    rdman_param3 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param3;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param4_addr) then
                if bool(dsp_wr) then
                    rdman_param4 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param4;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param5_addr) then
                if bool(dsp_wr) then
                    rdman_param5 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param5;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param6_addr) then
                if bool(dsp_wr) then
                    rdman_param6 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param6;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param7_addr) then
                if bool(dsp_wr) then
                    rdman_param7 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param7;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param8_addr) then
                if bool(dsp_wr) then
                    rdman_param8 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param8;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param9_addr) then
                if bool(dsp_wr) then
                    rdman_param9 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param9;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_data_addrcntr_addr) then
                dsp_data_in_rdman <= resize(rdman_data_addrcntr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_metadata_addrcntr_addr) then
                dsp_data_in_rdman <= resize(rdman_metadata_addrcntr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param_addrcntr_addr) then
                dsp_data_in_rdman <= resize(rdman_param_addrcntr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_divisor_addr) then
                if bool(dsp_wr) then
                    rdman_divisor <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_divisor, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_num_samp_addr) then
                if bool(dsp_wr) then
                    rdman_num_samp <= resize(dsp_data_out, 12);
                end if;
                dsp_data_in_rdman <= resize(rdman_num_samp, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_threshold_addr) then
                if bool(dsp_wr) then
                    rdman_threshold <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_threshold, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_lock_duration_addr) then
                if bool(dsp_wr) then
                    rdman_lock_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_lock_duration, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_precontrol_duration_addr) then
                if bool(dsp_wr) then
                    rdman_precontrol_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_precontrol_duration, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_off_duration_addr) then
                if bool(dsp_wr) then
                    rdman_off_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_off_duration, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_extra_duration_addr) then
                if bool(dsp_wr) then
                    rdman_extra_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_extra_duration, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_timeout_duration_addr) then
                if bool(dsp_wr) then
                    rdman_timeout_duration <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_timeout_duration;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_tuner_at_ringdown_addr) then
                dsp_data_in_rdman <= resize(rdman_tuner_at_ringdown, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_metadata_addr_at_ringdown_addr) then
                dsp_data_in_rdman <= resize(rdman_metadata_addr_at_ringdown, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_ringdown_data_addr) then
                dsp_data_in_rdman <= resize(rdman_ringdown_data, 32);
            else
                dsp_data_in_rdman <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_rdman <= to_unsigned(0, 32);
        end if;
        if bool(rdman_control(RDMAN_CONTROL_RUN_B)) then
            if (not bool(rdman_control(RDMAN_CONTROL_CONT_B))) then
                rdman_control(RDMAN_CONTROL_RUN_B) <= '0';
            end if;
            data_we <= '0';
            rdman_rd_adc_clk <= stdl((not bool(rdman_rd_adc_clk)));
            if bool(rdman_rd_adc_clk) then
                rdman_ringdown_data <= resize(rdman_rd_data, 18);
            end if;
            rdman_sel_fine_current <= sel_fine_current;
            rdman_ext_laser_level_counter <= ext_laser_level_counter;
            rdman_ext_laser_sequence_id <= ext_laser_sequence_id;
            if bool(rdman_status(RDMAN_STATUS_BUSY_B)) then
                rdman_control(RDMAN_CONTROL_START_RD_B) <= '0';
            end if;
            case rdman_seqState is
                when IDLE =>
                    rdman_status(RDMAN_STATUS_BUSY_B) <= '0';
                    rdman_us_since_start <= to_unsigned(0, 32);
                    rdman_metadata_acq <= '0';
                    rdman_param_acq <= '0';
                    rdman_us_timer_enable <= '0';
                    acc_en <= '0';
                    laser_locked <= '0';
                    if bool(rdman_options(RDMAN_OPTIONS_SCOPE_MODE_B)) then
                        rdman_status(RDMAN_STATUS_BUSY_B) <= '1';
                        rdman_seqState <= AWAIT_SWEEP_1;
                    elsif bool(rdman_control(RDMAN_CONTROL_START_RD_B)) then
                        rdman_status(RDMAN_STATUS_BUSY_B) <= '1';
                        rdman_seqState <= START_INJECT;
                    end if;
                when AWAIT_SWEEP_1 =>
                    rdman_abort <= '0';
                    rdman_timeout <= '0';
                    rdman_us_timer_enable <= '1';
                    if (bool(tuner_slope) /= bool(rdman_options(RDMAN_OPTIONS_SCOPE_SLOPE_B))) then
                        rdman_seqState <= AWAIT_SWEEP_2;
                    end if;
                when AWAIT_SWEEP_2 =>
                    if (bool(tuner_slope) = bool(rdman_options(RDMAN_OPTIONS_SCOPE_SLOPE_B))) then
                        rdman_data_addrcntr <= to_unsigned(0, 12);
                        rdman_rd_divider <= to_unsigned(0, 16);
                        rdman_seqState <= IN_RINGDOWN;
                    end if;
                when START_INJECT =>
                    rdman_abort <= '0';
                    rdman_timeout <= '0';
                    rdman_metadata_acq <= '1';
                    rdman_lapped <= '0';
                    rdman_us_timer_enable <= '1';
                    acc_en <= '0';
                    rdman_expiry_time <= resize(rdman_precontrol_duration, 32);
                    rdman_seqState <= WAIT_FOR_PRECONTROL;
                when WAIT_FOR_PRECONTROL =>
                    if (rdman_us_since_start >= rdman_expiry_time) then
                        if bool(rdman_options(RDMAN_OPTIONS_LOCK_ENABLE_B)) then
                            acc_en <= '1';
                            rdman_expiry_time <= (rdman_us_since_start + rdman_lock_duration);
                            rdman_seqState <= WAIT_FOR_LOCK;
                        else
                            rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                        end if;
                    end if;
                when WAIT_FOR_LOCK =>
                    acc_en <= '1';
                    if bool(laser_freq_ok) then
                        if (rdman_us_since_start >= rdman_expiry_time) then
                            laser_locked <= '1';
                            rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                        end if;
                    else
                        rdman_expiry_time <= (rdman_us_since_start + rdman_lock_duration);
                    end if;
                when WAIT_FOR_GATING_CONDITIONS =>
                    if (not bool(rdman_freq_gating_conditions)) then
                        laser_locked <= '0';
                        rdman_seqState <= WAIT_FOR_LOCK;
                    elsif bool(rdman_tuner_gating_conditions) then
                        rdman_seqState <= CHECK_BELOW_THRESHOLD;
                    end if;
                when CHECK_BELOW_THRESHOLD =>
                    if (rdman_rd_data < rdman_threshold) then
                        rdman_seqState <= WAIT_FOR_THRESHOLD;
                    else
                        rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                    end if;
                when WAIT_FOR_THRESHOLD =>
                    if (not bool(rdman_freq_gating_conditions)) then
                        laser_locked <= '0';
                        rdman_seqState <= WAIT_FOR_LOCK;
                    elsif (not bool(rdman_tuner_gating_conditions)) then
                        rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                    elsif (rdman_rd_data >= rdman_threshold) then
                        rdman_seqState <= IN_RINGDOWN;
                        rdman_rd_trig <= '1';
                        rdman_metadata_acq <= '0';
                        rdman_data_addrcntr <= to_unsigned(0, 12);
                        rdman_rd_divider <= to_unsigned(0, 16);
                        rdman_metadata_addr_at_ringdown <= resize(rdman_metadata_addrcntr, 16);
                        rdman_metadata_addr_at_ringdown((FPGA_REG_WIDTH - 1)) <= rdman_lapped;
                        if bool(extended_current_mode) then
                            rdman_tuner_at_ringdown <= sel_fine_current;
                        else
                            rdman_tuner_at_ringdown <= tuner_value;
                        end if;
                        rdman_us_timer_enable <= '0';
                        rdman_rd_irq <= '1';
                        rdman_init_flag <= '1';
                    end if;
                when IN_RINGDOWN =>
                    rdman_param_acq <= '1';
                    if bool(rdman_rd_adc_clk) then
                        if ((rdman_data_addrcntr = rdman_num_samp) and (not bool(rdman_init_flag))) then
                            rdman_seqState <= CHECK_PARAMS_DONE;
                            if bool(rdman_bank) then
                                rdman_status(RDMAN_STATUS_BANK1_IN_USE_B) <= '1';
                            else
                                rdman_status(RDMAN_STATUS_BANK0_IN_USE_B) <= '1';
                            end if;
                        elsif (rdman_rd_divider = rdman_divisor) then
                            rdman_rd_divider <= to_unsigned(0, 16);
                            rdman_data_addrcntr <= ((rdman_data_addrcntr + 1) mod 4096);
                            rdman_init_flag <= '0';
                            data_we <= '1';
                        else
                            rdman_rd_divider <= ((rdman_rd_divider + 1) mod 65536);
                        end if;
                    end if;
                when CHECK_PARAMS_DONE =>
                    if (rdman_paramState = DONE) then
                        rdman_seqState <= ACQ_DONE;
                        rdman_metadataAcqState <= IDLE;
                        rdman_paramState <= IDLE;
                    end if;
                when ACQ_DONE =>
                    rdman_bank <= stdl((not bool(rdman_bank)));
                    rdman_acq_done_irq <= '1';
                    rdman_seqState <= WAIT_RD_DONE_1;
                when WAIT_RD_DONE_1 =>
                    rdman_seqState <= WAIT_RD_DONE_2;
                when WAIT_RD_DONE_2 =>
                    if ((rdman_div50_counter = 0) and (rdman_us_after_ringdown = 0)) then
                        rdman_seqState <= IDLE;
                    end if;
                when others =>
                    rdman_seqState <= IDLE;
            end case;
            case rdman_paramState is
                when IDLE =>
                    param_we <= '0';
                    if bool(rdman_param_acq) then
                        rdman_param_addrcntr <= to_unsigned(0, 6);
                        rdman_paramState <= STORING;
                    end if;
                when STORING =>
                    param_we <= '1';
                    rdman_param_addrcntr <= (rdman_param_addrcntr + 1);
                    if (rdman_param_addrcntr(4-1 downto 0) = 0) then
                        wr_param <= rdman_param0;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 1) then
                        wr_param <= rdman_param1;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 2) then
                        wr_param <= rdman_param2;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 3) then
                        wr_param <= rdman_param3;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 4) then
                        wr_param <= rdman_param4;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 5) then
                        wr_param <= rdman_param5;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 6) then
                        wr_param <= rdman_param6;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 7) then
                        wr_param <= rdman_param7;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 8) then
                        wr_param <= rdman_param8;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 9) then
                        wr_param <= rdman_param9;
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 10) then
                        wr_param <= resize(rdman_tuner_at_ringdown, 32);
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 11) then
                        wr_param <= resize(rdman_metadata_addr_at_ringdown, 32);
                    elsif (rdman_param_addrcntr(4-1 downto 0) = 12) then
                        wr_param <= resize(rdman_ext_laser_level_counter, 32);
                    else
                        wr_param <= resize(rdman_ext_laser_sequence_id, 32);
                        rdman_paramState <= DONE;
                    end if;
                when DONE =>
                    rdman_param_acq <= '0';
                    param_we <= '0';
                when others =>
                    rdman_paramState <= IDLE;
            end case;
            case rdman_metadataAcqState is
                when IDLE =>
                    meta_we <= '0';
                    rdman_metadata_addrcntr <= to_unsigned(0, 12);
                    rdman_metadataAcqState <= AWAIT_STROBE;
                when AWAIT_STROBE =>
                    if (bool(rdman_metadata_acq) and bool(metadata_strobe)) then
                        rdman_metadataAcqState <= ACQUIRING;
                        rdman_sel_fine_current_slope <= stdl(rdman_sel_fine_current >= rdman_sel_fine_current_prev);
                        rdman_sel_fine_current_prev <= rdman_sel_fine_current;
                    end if;
                when ACQUIRING =>
                    if (not bool(rdman_metadata_acq)) then
                        rdman_metadataAcqState <= DONE;
                    else
                        meta_we <= '1';
                        if (signed(resize(rdman_metadata_addrcntr, 13)) < ((8 * META_SIZE) - 1)) then
                            rdman_metadata_addrcntr <= (rdman_metadata_addrcntr + 1);
                        else
                            rdman_metadata_addrcntr <= to_unsigned(4 * META_SIZE, 12);
                            rdman_lapped <= '1';
                        end if;
                        if (rdman_metadata_addrcntr(3-1 downto 0) = 0) then
                            wr_meta <= ratio1;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 1) then
                            wr_meta <= ratio2;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 2) then
                            wr_meta <= pzt;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 3) then
                            wr_meta <= laser_tuning_offset;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 4) then
                            wr_meta <= sel_fine_current;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 5) then
                            wr_meta <= meta5;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 6) then
                            wr_meta <= laser_locking_pid;
                        else
                            wr_meta <= meta7;
                            rdman_metadataAcqState <= DONE;
                        end if;
                    end if;
                when DONE =>
                    meta_we <= '0';
                    if (not bool(metadata_strobe)) then
                        rdman_metadataAcqState <= AWAIT_STROBE;
                    end if;
                when others =>
                    rdman_metadataAcqState <= IDLE;
            end case;
            if (bool(rdman_us_timer_enable) and bool(pulse_1M)) then
                rdman_us_since_start <= (rdman_us_since_start + 1);
                if (rdman_us_since_start >= rdman_timeout_duration) then
                    rdman_timeout <= '1';
                    rdman_metadata_acq <= '0';
                    rdman_param_acq <= '0';
                    rdman_us_timer_enable <= '0';
                    rdman_metadataAcqState <= IDLE;
                    rdman_paramState <= IDLE;
                    rdman_rd_trig <= '1';
                    rdman_rd_irq <= '1';
                    rdman_seqState <= WAIT_RD_DONE_1;
                end if;
            end if;
            if bool(rdman_control(RDMAN_CONTROL_ABORT_RD_B)) then
                rdman_control(RDMAN_CONTROL_ABORT_RD_B) <= '0';
                rdman_rd_trig <= '1';
                rdman_abort <= '1';
                rdman_rd_irq <= '1';
                rdman_acq_done_irq <= '0';
                rdman_metadata_acq <= '0';
                rdman_param_acq <= '0';
                rdman_us_timer_enable <= '0';
                rdman_seqState <= WAIT_RD_DONE_1;
                rdman_metadataAcqState <= IDLE;
                rdman_paramState <= IDLE;
            end if;
            if bool(rdman_control(RDMAN_CONTROL_RESET_RDMAN_B)) then
                rdman_control(RDMAN_CONTROL_RESET_RDMAN_B) <= '0';
                rdman_rd_trig <= '1';
                rdman_abort <= '0';
                rdman_rd_irq <= '0';
                rdman_acq_done_irq <= '0';
                rdman_metadata_acq <= '0';
                rdman_param_acq <= '0';
                rdman_us_timer_enable <= '0';
                rdman_seqState <= WAIT_RD_DONE_1;
                rdman_metadataAcqState <= IDLE;
                rdman_paramState <= IDLE;
            end if;
            if bool(rdman_control(RDMAN_CONTROL_RD_IRQ_ACK_B)) then
                rdman_control(RDMAN_CONTROL_RD_IRQ_ACK_B) <= '0';
                rdman_rd_irq <= '0';
            end if;
            if bool(rdman_control(RDMAN_CONTROL_ACQ_DONE_ACK_B)) then
                rdman_control(RDMAN_CONTROL_ACQ_DONE_ACK_B) <= '0';
                rdman_acq_done_irq <= '0';
            end if;
            if bool(rdman_control(RDMAN_CONTROL_BANK0_CLEAR_B)) then
                rdman_control(RDMAN_CONTROL_BANK0_CLEAR_B) <= '0';
                rdman_status(RDMAN_STATUS_BANK0_IN_USE_B) <= '0';
            end if;
            if bool(rdman_control(RDMAN_CONTROL_BANK1_CLEAR_B)) then
                rdman_control(RDMAN_CONTROL_BANK1_CLEAR_B) <= '0';
                rdman_status(RDMAN_STATUS_BANK1_IN_USE_B) <= '0';
            end if;
            data_addr <= rdman_data_addrcntr;
            meta_addr <= rdman_metadata_addrcntr;
            param_addr <= rdman_param_addrcntr;
        end if;
        if ((rdman_div50_counter = 0) and (rdman_us_after_ringdown = 0)) then
            if bool(rdman_rd_trig) then
                rdman_div50_counter <= (rdman_div50_counter + 1);
            end if;
        else
            if (signed(resize(rdman_div50_counter, 7)) = (50 - 1)) then
                rdman_div50_counter <= to_unsigned(0, 6);
                rdman_us_after_ringdown <= (rdman_us_after_ringdown + 1);
            else
                rdman_div50_counter <= (rdman_div50_counter + 1);
            end if;
        end if;
        if (rdman_us_after_ringdown >= rdman_off_duration) then
            rdman_rd_trig <= '0';
            rdman_laser_extra <= '1';
        end if;
        if (rdman_us_after_ringdown >= (rdman_off_duration + rdman_extra_duration)) then
            rdman_laser_extra <= '0';
            rdman_div50_counter <= to_unsigned(0, 6);
            rdman_us_after_ringdown <= to_unsigned(0, 17);
        end if;
        rdman_status(RDMAN_STATUS_ACQ_DONE_B) <= rdman_acq_done_irq;
        rdman_status(RDMAN_STATUS_BANK_B) <= rdman_bank;
        rdman_status(RDMAN_STATUS_LAPPED_B) <= rdman_lapped;
        rdman_status(RDMAN_STATUS_RD_IRQ_B) <= rdman_rd_irq;
        rdman_status(RDMAN_STATUS_SHUTDOWN_B) <= rdman_rd_trig;
        rdman_status(RDMAN_STATUS_ABORTED_B) <= rdman_abort;
        rdman_status(RDMAN_STATUS_TIMEOUT_B) <= rdman_timeout;
    end if;
end process MAIN_RDMAN_LOGIC;



pwm_laser4_out <= pwm_laser4_pwm;
pwm_laser4_inv_out <= (pwm_laser4_pwm xor pwm_laser4_cs(PWM_CS_CONT_B));
pwm_laser4_temp <= (resize(pwm_laser4_dither_cntr, 9) + resize(pwm_laser4_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_LASER4_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_laser4_cs <= to_unsigned(0, 16);
        pwm_laser4_pulse_width <= to_unsigned(0, 16);
        pwm_laser4_main_cntr <= to_unsigned(0, 8);
        pwm_laser4_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 20) then
                if bool(dsp_wr) then
                    pwm_laser4_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser4 <= resize(pwm_laser4_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 21) then
                if bool(dsp_wr) then
                    pwm_laser4_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser4 <= resize(pwm_laser4_pulse_width, 32);
            else
                dsp_data_in_pwm_laser4 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_laser4 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_laser4_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_laser4_cs(PWM_CS_CONT_B))) then
                pwm_laser4_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_laser4_pwm <= '0';
            if (pwm_laser4_main_cntr < pwm_laser4_pulse_width(width-1 downto (width - main_width))) then
                pwm_laser4_pwm <= '1';
            elsif (pwm_laser4_main_cntr = pwm_laser4_pulse_width(width-1 downto dither_width)) then
                if (pwm_laser4_temp >= mod_dither) then
                    pwm_laser4_pwm <= '1';
                    pwm_laser4_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_laser4_dither_cntr <= resize(pwm_laser4_temp - mod_dither, 8);
                else
                    pwm_laser4_dither_cntr <= resize(pwm_laser4_temp, 8);
                end if;
            end if;
            pwm_laser4_main_cntr <= ((pwm_laser4_main_cntr + 1) mod mod_main);
        end if;
        pwm_laser4_cs(PWM_CS_PWM_OUT_B) <= pwm_laser4_pwm;
    end if;
end process MAIN_PWM_LASER4_LOGIC;



pwm_laser3_out <= pwm_laser3_pwm;
pwm_laser3_inv_out <= (pwm_laser3_pwm xor pwm_laser3_cs(PWM_CS_CONT_B));
pwm_laser3_temp <= (resize(pwm_laser3_dither_cntr, 9) + resize(pwm_laser3_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_LASER3_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_laser3_cs <= to_unsigned(0, 16);
        pwm_laser3_pulse_width <= to_unsigned(0, 16);
        pwm_laser3_main_cntr <= to_unsigned(0, 8);
        pwm_laser3_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 18) then
                if bool(dsp_wr) then
                    pwm_laser3_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser3 <= resize(pwm_laser3_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 19) then
                if bool(dsp_wr) then
                    pwm_laser3_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser3 <= resize(pwm_laser3_pulse_width, 32);
            else
                dsp_data_in_pwm_laser3 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_laser3 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_laser3_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_laser3_cs(PWM_CS_CONT_B))) then
                pwm_laser3_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_laser3_pwm <= '0';
            if (pwm_laser3_main_cntr < pwm_laser3_pulse_width(width-1 downto (width - main_width))) then
                pwm_laser3_pwm <= '1';
            elsif (pwm_laser3_main_cntr = pwm_laser3_pulse_width(width-1 downto dither_width)) then
                if (pwm_laser3_temp >= mod_dither) then
                    pwm_laser3_pwm <= '1';
                    pwm_laser3_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_laser3_dither_cntr <= resize(pwm_laser3_temp - mod_dither, 8);
                else
                    pwm_laser3_dither_cntr <= resize(pwm_laser3_temp, 8);
                end if;
            end if;
            pwm_laser3_main_cntr <= ((pwm_laser3_main_cntr + 1) mod mod_main);
        end if;
        pwm_laser3_cs(PWM_CS_PWM_OUT_B) <= pwm_laser3_pwm;
    end if;
end process MAIN_PWM_LASER3_LOGIC;



pwm_laser1_out <= pwm_laser1_pwm;
pwm_laser1_inv_out <= (pwm_laser1_pwm xor pwm_laser1_cs(PWM_CS_CONT_B));
pwm_laser1_temp <= (resize(pwm_laser1_dither_cntr, 9) + resize(pwm_laser1_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_LASER1_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_laser1_cs <= to_unsigned(0, 16);
        pwm_laser1_pulse_width <= to_unsigned(0, 16);
        pwm_laser1_main_cntr <= to_unsigned(0, 8);
        pwm_laser1_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 14) then
                if bool(dsp_wr) then
                    pwm_laser1_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser1 <= resize(pwm_laser1_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 15) then
                if bool(dsp_wr) then
                    pwm_laser1_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser1 <= resize(pwm_laser1_pulse_width, 32);
            else
                dsp_data_in_pwm_laser1 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_laser1 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_laser1_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_laser1_cs(PWM_CS_CONT_B))) then
                pwm_laser1_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_laser1_pwm <= '0';
            if (pwm_laser1_main_cntr < pwm_laser1_pulse_width(width-1 downto (width - main_width))) then
                pwm_laser1_pwm <= '1';
            elsif (pwm_laser1_main_cntr = pwm_laser1_pulse_width(width-1 downto dither_width)) then
                if (pwm_laser1_temp >= mod_dither) then
                    pwm_laser1_pwm <= '1';
                    pwm_laser1_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_laser1_dither_cntr <= resize(pwm_laser1_temp - mod_dither, 8);
                else
                    pwm_laser1_dither_cntr <= resize(pwm_laser1_temp, 8);
                end if;
            end if;
            pwm_laser1_main_cntr <= ((pwm_laser1_main_cntr + 1) mod mod_main);
        end if;
        pwm_laser1_cs(PWM_CS_PWM_OUT_B) <= pwm_laser1_pwm;
    end if;
end process MAIN_PWM_LASER1_LOGIC;


MAIN_DYNAMICPWMINLET_COMB: process (dynamicPwmInlet_cs, dynamicPwmInlet_dither_cntr, dynamicPwmInlet_pwm, dynamicPwmInlet_pulse_width) is
begin
    if bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_ENABLE_B)) then
        inlet_valve_pwm <= dynamicPwmInlet_pwm;
    else
        inlet_valve_pwm <= '0';
    end if;
    dynamicPwmInlet_temp <= (resize(dynamicPwmInlet_dither_cntr, 9) + resize(dynamicPwmInlet_pulse_width(dither_width-1 downto 0), 9));
end process MAIN_DYNAMICPWMINLET_COMB;


MAIN_DYNAMICPWMINLET_LOGIC: process (clk0, reset) is
    variable value: unsigned(23 downto 0);
begin
    if bool(reset) then
        dynamicPwmInlet_cs <= to_unsigned(0, 16);
        dynamicPwmInlet_delta <= to_signed(0, 16);
        dynamicPwmInlet_high <= to_unsigned(0, 16);
        dynamicPwmInlet_low <= to_unsigned(0, 16);
        dynamicPwmInlet_slope <= to_unsigned(0, 16);
        dynamicPwmInlet_pulse_width <= to_unsigned(32768, 16);
        dynamicPwmInlet_main_cntr <= to_unsigned(0, 8);
        dynamicPwmInlet_dither_cntr <= to_unsigned(0, 8);
        dynamicPwmInlet_acc((FPGA_REG_WIDTH + extra)-1 downto 0) <= to_unsigned(0, 24);
        dynamicPwmInlet_up <= '0';
        dynamicPwmInlet_extra0 <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 141) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_cs <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(dynamicPwmInlet_cs, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 142) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_delta <= resize(signed(dsp_data_out), 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(unsigned(dynamicPwmInlet_delta(FPGA_REG_WIDTH-1 downto 0)), 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 143) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_high <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(dynamicPwmInlet_high, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 144) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_low <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(dynamicPwmInlet_low, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 145) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_slope <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(dynamicPwmInlet_slope, 32);
                else
                    dsp_data_in_dynamicpwm_inlet <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_dynamicpwm_inlet <= to_unsigned(0, 32);
        end if;
        if bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_RUN_B)) then
            if (not bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_CONT_B))) then
                dynamicPwmInlet_cs(DYNAMICPWM_CS_RUN_B) <= '0';
            end if;
            value := resize(dynamicPwmInlet_acc((FPGA_REG_WIDTH + extra)-1 downto extra), 24);
            if bool(pulse_100k) then
                if bool(dynamicPwmInlet_up) then
                    if ((dynamicPwmInlet_acc + dynamicPwmInlet_slope) > unsigned'(dynamicPwmInlet_high & dynamicPwmInlet_extra0)) then
                        dynamicPwmInlet_acc <= unsigned'(dynamicPwmInlet_high & dynamicPwmInlet_extra0);
                        dynamicPwmInlet_up <= '0';
                    else
                        dynamicPwmInlet_acc <= (dynamicPwmInlet_acc + dynamicPwmInlet_slope);
                    end if;
                else
                    if ((signed(resize(dynamicPwmInlet_acc, 25)) - signed(resize(dynamicPwmInlet_slope, 17))) < signed(resize(unsigned'(dynamicPwmInlet_low & dynamicPwmInlet_extra0), 25))) then
                        dynamicPwmInlet_acc <= unsigned'(dynamicPwmInlet_low & dynamicPwmInlet_extra0);
                        dynamicPwmInlet_up <= '1';
                    else
                        dynamicPwmInlet_acc <= (dynamicPwmInlet_acc - dynamicPwmInlet_slope);
                    end if;
                end if;
                if bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_USE_COMPARATOR_B)) then
                    if (dynamicPwmInlet_delta > 0) then
                        if bool(inlet_valve_comparator) then
                            if ((signed(resize(dynamicPwmInlet_pulse_width, 17)) + dynamicPwmInlet_delta) < MAX_WIDTH) then
                                dynamicPwmInlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmInlet_pulse_width, 17)) + dynamicPwmInlet_delta), 16);
                            else
                                dynamicPwmInlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
                            end if;
                        else
                            if ((signed(resize(dynamicPwmInlet_pulse_width, 17)) - dynamicPwmInlet_delta) > MIN_WIDTH) then
                                dynamicPwmInlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmInlet_pulse_width, 17)) - dynamicPwmInlet_delta), 16);
                            else
                                dynamicPwmInlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
                            end if;
                        end if;
                    else
                        if bool(inlet_valve_comparator) then
                            if ((signed(resize(dynamicPwmInlet_pulse_width, 17)) + dynamicPwmInlet_delta) > MIN_WIDTH) then
                                dynamicPwmInlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmInlet_pulse_width, 17)) + dynamicPwmInlet_delta), 16);
                            else
                                dynamicPwmInlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
                            end if;
                        else
                            if ((signed(resize(dynamicPwmInlet_pulse_width, 17)) - dynamicPwmInlet_delta) < MAX_WIDTH) then
                                dynamicPwmInlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmInlet_pulse_width, 17)) - dynamicPwmInlet_delta), 16);
                            else
                                dynamicPwmInlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
                            end if;
                        end if;
                    end if;
                else
                    dynamicPwmInlet_pulse_width <= resize(value, 16);
                end if;
            end if;
            if (dynamicPwmInlet_acc > unsigned'(dynamicPwmInlet_high & dynamicPwmInlet_extra0)) then
                dynamicPwmInlet_acc <= unsigned'(dynamicPwmInlet_high & dynamicPwmInlet_extra0);
            end if;
            if (dynamicPwmInlet_acc < unsigned'(dynamicPwmInlet_low & dynamicPwmInlet_extra0)) then
                dynamicPwmInlet_acc <= unsigned'(dynamicPwmInlet_low & dynamicPwmInlet_extra0);
            end if;
            if (dynamicPwmInlet_pulse_width > MAX_WIDTH) then
                dynamicPwmInlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
            end if;
            if (dynamicPwmInlet_pulse_width < MIN_WIDTH) then
                dynamicPwmInlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
            end if;
            dynamicPwmInlet_pwm <= dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_INVERT_B);
            if (dynamicPwmInlet_main_cntr < dynamicPwmInlet_pulse_width(width-1 downto (width - main_width))) then
                dynamicPwmInlet_pwm <= stdl((not bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_INVERT_B))));
            elsif (dynamicPwmInlet_main_cntr = dynamicPwmInlet_pulse_width(width-1 downto dither_width)) then
                if (dynamicPwmInlet_temp >= mod_dither) then
                    dynamicPwmInlet_pwm <= stdl((not bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_INVERT_B))));
                    dynamicPwmInlet_dither_cntr <= resize(dynamicPwmInlet_temp - mod_dither, 8);
                else
                    dynamicPwmInlet_dither_cntr <= resize(dynamicPwmInlet_temp, 8);
                end if;
            end if;
            dynamicPwmInlet_main_cntr <= ((dynamicPwmInlet_main_cntr + 1) mod mod_main);
            inlet_valve_dac <= resize(value, 16);
        end if;
        dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_OUT_B) <= dynamicPwmInlet_pwm;
    end if;
end process MAIN_DYNAMICPWMINLET_LOGIC;



warm_box_pwm_out <= pwm_warmbox_pwm;
warm_box_pwm_inv <= (pwm_warmbox_pwm xor pwm_warmbox_cs(PWM_CS_CONT_B));
pwm_warmbox_temp <= (resize(pwm_warmbox_dither_cntr, 9) + resize(pwm_warmbox_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_WARMBOX_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_warmbox_cs <= to_unsigned(0, 16);
        pwm_warmbox_pulse_width <= to_unsigned(0, 16);
        pwm_warmbox_main_cntr <= to_unsigned(0, 8);
        pwm_warmbox_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 22) then
                if bool(dsp_wr) then
                    pwm_warmbox_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_warmbox <= resize(pwm_warmbox_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 23) then
                if bool(dsp_wr) then
                    pwm_warmbox_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_warmbox <= resize(pwm_warmbox_pulse_width, 32);
            else
                dsp_data_in_pwm_warmbox <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_warmbox <= to_unsigned(0, 32);
        end if;
        if bool(pwm_warmbox_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_warmbox_cs(PWM_CS_CONT_B))) then
                pwm_warmbox_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_warmbox_pwm <= '0';
            if (pwm_warmbox_main_cntr < pwm_warmbox_pulse_width(width-1 downto (width - main_width))) then
                pwm_warmbox_pwm <= '1';
            elsif (pwm_warmbox_main_cntr = pwm_warmbox_pulse_width(width-1 downto dither_width)) then
                if (pwm_warmbox_temp >= mod_dither) then
                    pwm_warmbox_pwm <= '1';
                    pwm_warmbox_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_warmbox_dither_cntr <= resize(pwm_warmbox_temp - mod_dither, 8);
                else
                    pwm_warmbox_dither_cntr <= resize(pwm_warmbox_temp, 8);
                end if;
            end if;
            pwm_warmbox_main_cntr <= ((pwm_warmbox_main_cntr + 1) mod mod_main);
        end if;
        pwm_warmbox_cs(PWM_CS_PWM_OUT_B) <= pwm_warmbox_pwm;
    end if;
end process MAIN_PWM_WARMBOX_LOGIC;



hot_box_pwm_out <= pwm_hotbox_pwm;
hot_box_pwm_inv <= (pwm_hotbox_pwm xor pwm_hotbox_cs(PWM_CS_CONT_B));
pwm_hotbox_temp <= (resize(pwm_hotbox_dither_cntr, 9) + resize(pwm_hotbox_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_HOTBOX_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_hotbox_cs <= to_unsigned(0, 16);
        pwm_hotbox_pulse_width <= to_unsigned(0, 16);
        pwm_hotbox_main_cntr <= to_unsigned(0, 8);
        pwm_hotbox_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 24) then
                if bool(dsp_wr) then
                    pwm_hotbox_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_hotbox <= resize(pwm_hotbox_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 25) then
                if bool(dsp_wr) then
                    pwm_hotbox_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_hotbox <= resize(pwm_hotbox_pulse_width, 32);
            else
                dsp_data_in_pwm_hotbox <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_hotbox <= to_unsigned(0, 32);
        end if;
        if bool(pwm_hotbox_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_hotbox_cs(PWM_CS_CONT_B))) then
                pwm_hotbox_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_hotbox_pwm <= '0';
            if (pwm_hotbox_main_cntr < pwm_hotbox_pulse_width(width-1 downto (width - main_width))) then
                pwm_hotbox_pwm <= '1';
            elsif (pwm_hotbox_main_cntr = pwm_hotbox_pulse_width(width-1 downto dither_width)) then
                if (pwm_hotbox_temp >= mod_dither) then
                    pwm_hotbox_pwm <= '1';
                    pwm_hotbox_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_hotbox_dither_cntr <= resize(pwm_hotbox_temp - mod_dither, 8);
                else
                    pwm_hotbox_dither_cntr <= resize(pwm_hotbox_temp, 8);
                end if;
            end if;
            pwm_hotbox_main_cntr <= ((pwm_hotbox_main_cntr + 1) mod mod_main);
        end if;
        pwm_hotbox_cs(PWM_CS_PWM_OUT_B) <= pwm_hotbox_pwm;
    end if;
end process MAIN_PWM_HOTBOX_LOGIC;



engine1_pwm_out <= pwm_engine1_pwm;
engine1_pwm_inv <= (pwm_engine1_pwm xor pwm_engine1_cs(PWM_CS_CONT_B));
pwm_engine1_temp <= (resize(pwm_engine1_dither_cntr, 9) + resize(pwm_engine1_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_ENGINE1_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_engine1_cs <= to_unsigned(0, 16);
        pwm_engine1_pulse_width <= to_unsigned(0, 16);
        pwm_engine1_main_cntr <= to_unsigned(0, 8);
        pwm_engine1_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 26) then
                if bool(dsp_wr) then
                    pwm_engine1_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_engine1 <= resize(pwm_engine1_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 27) then
                if bool(dsp_wr) then
                    pwm_engine1_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_engine1 <= resize(pwm_engine1_pulse_width, 32);
            else
                dsp_data_in_pwm_engine1 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_engine1 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_engine1_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_engine1_cs(PWM_CS_CONT_B))) then
                pwm_engine1_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_engine1_pwm <= '0';
            if (pwm_engine1_main_cntr < pwm_engine1_pulse_width(width-1 downto (width - main_width))) then
                pwm_engine1_pwm <= '1';
            elsif (pwm_engine1_main_cntr = pwm_engine1_pulse_width(width-1 downto dither_width)) then
                if (pwm_engine1_temp >= mod_dither) then
                    pwm_engine1_pwm <= '1';
                    pwm_engine1_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_engine1_dither_cntr <= resize(pwm_engine1_temp - mod_dither, 8);
                else
                    pwm_engine1_dither_cntr <= resize(pwm_engine1_temp, 8);
                end if;
            end if;
            pwm_engine1_main_cntr <= ((pwm_engine1_main_cntr + 1) mod mod_main);
        end if;
        pwm_engine1_cs(PWM_CS_PWM_OUT_B) <= pwm_engine1_pwm;
    end if;
end process MAIN_PWM_ENGINE1_LOGIC;



pwm_laser2_out <= pwm_laser2_pwm;
pwm_laser2_inv_out <= (pwm_laser2_pwm xor pwm_laser2_cs(PWM_CS_CONT_B));
pwm_laser2_temp <= (resize(pwm_laser2_dither_cntr, 9) + resize(pwm_laser2_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_LASER2_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_laser2_cs <= to_unsigned(0, 16);
        pwm_laser2_pulse_width <= to_unsigned(0, 16);
        pwm_laser2_main_cntr <= to_unsigned(0, 8);
        pwm_laser2_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 16) then
                if bool(dsp_wr) then
                    pwm_laser2_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser2 <= resize(pwm_laser2_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 17) then
                if bool(dsp_wr) then
                    pwm_laser2_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser2 <= resize(pwm_laser2_pulse_width, 32);
            else
                dsp_data_in_pwm_laser2 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_laser2 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_laser2_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_laser2_cs(PWM_CS_CONT_B))) then
                pwm_laser2_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_laser2_pwm <= '0';
            if (pwm_laser2_main_cntr < pwm_laser2_pulse_width(width-1 downto (width - main_width))) then
                pwm_laser2_pwm <= '1';
            elsif (pwm_laser2_main_cntr = pwm_laser2_pulse_width(width-1 downto dither_width)) then
                if (pwm_laser2_temp >= mod_dither) then
                    pwm_laser2_pwm <= '1';
                    pwm_laser2_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_laser2_dither_cntr <= resize(pwm_laser2_temp - mod_dither, 8);
                else
                    pwm_laser2_dither_cntr <= resize(pwm_laser2_temp, 8);
                end if;
            end if;
            pwm_laser2_main_cntr <= ((pwm_laser2_main_cntr + 1) mod mod_main);
        end if;
        pwm_laser2_cs(PWM_CS_PWM_OUT_B) <= pwm_laser2_pwm;
    end if;
end process MAIN_PWM_LASER2_LOGIC;



heater_pwm_out <= pwm_heater_pwm;
heater_pwm_inv <= (pwm_heater_pwm xor pwm_heater_cs(PWM_CS_CONT_B));
pwm_heater_temp <= (resize(pwm_heater_dither_cntr, 9) + resize(pwm_heater_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_HEATER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_heater_cs <= to_unsigned(0, 16);
        pwm_heater_pulse_width <= to_unsigned(0, 16);
        pwm_heater_main_cntr <= to_unsigned(0, 8);
        pwm_heater_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 30) then
                if bool(dsp_wr) then
                    pwm_heater_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_heater <= resize(pwm_heater_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 31) then
                if bool(dsp_wr) then
                    pwm_heater_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_heater <= resize(pwm_heater_pulse_width, 32);
            else
                dsp_data_in_pwm_heater <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_heater <= to_unsigned(0, 32);
        end if;
        if bool(pwm_heater_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_heater_cs(PWM_CS_CONT_B))) then
                pwm_heater_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_heater_pwm <= '0';
            if (pwm_heater_main_cntr < pwm_heater_pulse_width(width-1 downto (width - main_width))) then
                pwm_heater_pwm <= '1';
            elsif (pwm_heater_main_cntr = pwm_heater_pulse_width(width-1 downto dither_width)) then
                if (pwm_heater_temp >= mod_dither) then
                    pwm_heater_pwm <= '1';
                    pwm_heater_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_heater_dither_cntr <= resize(pwm_heater_temp - mod_dither, 8);
                else
                    pwm_heater_dither_cntr <= resize(pwm_heater_temp, 8);
                end if;
            end if;
            pwm_heater_main_cntr <= ((pwm_heater_main_cntr + 1) mod mod_main);
        end if;
        pwm_heater_cs(PWM_CS_PWM_OUT_B) <= pwm_heater_pwm;
    end if;
end process MAIN_PWM_HEATER_LOGIC;


MAIN_CLKGEN_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        clk_10M <= '0';
        clkgen_div5 <= to_unsigned(0, 3);
        clkgen_div25 <= to_unsigned(0, 5);
        clkgen_ff1 <= '0';
        clkgen_ff2 <= '0';
    elsif rising_edge(clk0) then
        pulse_100k <= '0';
        pulse_1M <= '0';
        if (clkgen_div5 = 4) then
            clkgen_div5 <= to_unsigned(0, 3);
            clkgen_ff1 <= stdl((not bool(clkgen_ff1)));
            if bool(clkgen_ff1) then
                if (clkgen_div1M = 4) then
                    clkgen_div1M <= to_unsigned(0, 3);
                    pulse_1M <= '1';
                else
                    clkgen_div1M <= (clkgen_div1M + 1);
                end if;
                clkgen_ff2 <= stdl((not bool(clkgen_ff2)));
                if bool(clkgen_ff2) then
                    if (clkgen_div25 = 24) then
                        clkgen_div25 <= to_unsigned(0, 5);
                        pulse_100k <= '1';
                    else
                        clkgen_div25 <= (clkgen_div25 + 1);
                    end if;
                end if;
            end if;
        else
            clkgen_div5 <= (clkgen_div5 + 1);
        end if;
        clk_10M <= stdl((clkgen_div5 = 2) or (clkgen_div5 = 3));
    end if;
end process MAIN_CLKGEN_LOGIC;



clk_5M <= clkgen_ff1;
clk_2M5 <= clkgen_ff2;

end architecture MyHDL;
