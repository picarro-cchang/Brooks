-- File: main.vhd
-- Generated by MyHDL 0.9.0
-- Date: Wed Oct 26 16:30:55 2022


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_090.all;

entity main is
    port (
        clk0: in std_logic;
        clk180: in std_logic;
        clk3f: in std_logic;
        clk3f180: in std_logic;
        clk_locked: in std_logic;
        reset: in std_logic;
        intronix: out unsigned(33 downto 0);
        fpga_led: out unsigned(3 downto 0);
        dsp_emif_we: in std_logic;
        dsp_emif_re: in std_logic;
        dsp_emif_oe: in std_logic;
        dsp_emif_ardy: out std_logic;
        dsp_emif_ea: in unsigned(19 downto 0);
        dsp_emif_din: out unsigned(31 downto 0);
        dsp_emif_dout: in unsigned(31 downto 0);
        dsp_emif_ddir: out std_logic;
        dsp_emif_be: in unsigned(3 downto 0);
        dsp_emif_ce: in unsigned(3 downto 0);
        dsp_eclk: in std_logic;
        lsr1_0: out std_logic;
        lsr1_1: out std_logic;
        lsr2_0: out std_logic;
        lsr2_1: out std_logic;
        lsr3_0: out std_logic;
        lsr3_1: out std_logic;
        lsr4_0: out std_logic;
        lsr4_1: out std_logic;
        lc1: in std_logic;
        lc2: in std_logic;
        lc3: in std_logic;
        lc4: in std_logic;
        lsr1_sck: out std_logic;
        lsr1_ss: out std_logic;
        lsr1_rd: out std_logic;
        lsr1_mosi: out std_logic;
        lsr1_miso: in std_logic;
        lsr1_disable: out std_logic;
        lsr2_sck: out std_logic;
        lsr2_ss: out std_logic;
        lsr2_rd: out std_logic;
        lsr2_mosi: out std_logic;
        lsr2_miso: in std_logic;
        lsr2_disable: out std_logic;
        lsr3_sck: out std_logic;
        lsr3_ss: out std_logic;
        lsr3_rd: out std_logic;
        lsr3_mosi: out std_logic;
        lsr3_miso: in std_logic;
        lsr3_disable: out std_logic;
        lsr4_sck: out std_logic;
        lsr4_ss: out std_logic;
        lsr4_rd: out std_logic;
        lsr4_mosi: out std_logic;
        lsr4_miso: in std_logic;
        lsr4_disable: out std_logic;
        sw1: out std_logic;
        sw2: out std_logic;
        sw3: out std_logic;
        sw4: out std_logic;
        i2c_rst0: out std_logic;
        i2c_rst1: out std_logic;
        i2c_scl0: in std_logic;
        i2c_sda0: in std_logic;
        i2c_scl1: in std_logic;
        i2c_sda1: in std_logic;
        fp_lcd: out unsigned(7 downto 0);
        fp_led: out unsigned(3 downto 0);
        fp_rs_n: in std_logic;
        rd_adc: in unsigned(15 downto 0);
        rd_adc_clk: out std_logic;
        rd_adc_oe: out std_logic;
        monitor: out std_logic;
        dsp_ext_int4: out std_logic;
        dsp_ext_int5: out std_logic;
        dsp_ext_int6: out std_logic;
        dsp_ext_int7: out std_logic;
        usb_internal_connected: in std_logic;
        usb_rear_connected: in std_logic;
        fpga_program_enable: out std_logic;
        cyp_reset: out std_logic;
        pzt_valve_dac_ld: out std_logic;
        pzt_valve_dac_sck: out std_logic;
        pzt_valve_dac_sdi: out std_logic;
        inlet_valve_pwm: out std_logic;
        outlet_valve_pwm: out std_logic;
        inlet_valve_comparator: in std_logic;
        outlet_valve_comparator: in std_logic;
        heater_pwm: out std_logic;
        hot_box_pwm: out std_logic;
        hot_box_tec_overload: in std_logic;
        warm_box_pwm: out std_logic;
        warm_box_tec_overload: in std_logic;
        wmm_refl1: in std_logic;
        wmm_refl2: in std_logic;
        wmm_tran1: in std_logic;
        wmm_tran2: in std_logic;
        wmm_busy1: in std_logic;
        wmm_busy2: in std_logic;
        wmm_rd: out std_logic;
        wmm_convst: out std_logic;
        wmm_clk: out std_logic;
        dout_man: out std_logic;
        dout: out unsigned(39 downto 0);
        din: in unsigned(23 downto 0);
        aux_din: out unsigned(3 downto 0);
        aux_dout: in unsigned(3 downto 0)
    );
end entity main;


architecture MyHDL of main is


constant min_sync_counter_for_transfer: integer := 100;
constant rdman_param8_addr: integer := 82;
constant rdman_param6_addr: integer := 80;
constant rdman_param4_addr: integer := 78;
constant INJECT_CONTROL_LASER_CURRENT_ENABLE_W: integer := 4;
constant RDMAN_STATUS_BUSY_B: integer := 10;
constant RDMAN_CONTROL_RESET_RDMAN_B: integer := 4;
constant inject_laser4_extra_coarse_scale_addr: integer := 130;
constant RDMAN_CONTROL_ACQ_DONE_ACK_B: integer := 8;
constant kernel_intronix_1_addr: integer := 5;
constant kernel_din_addr: integer := 11;
constant INJECT_CONTROL_LASER_CURRENT_ENABLE_B: integer := 3;
constant inject_laser2_fine_current_range_addr: integer := 124;
constant RDMAN_STATUS_BANK_B: integer := 3;
constant laserlocker_ref1_addr: integer := 46;
constant SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_B: integer := 0;
constant SGDBRMANAGER_CONFIG_MODE_B: integer := 0;
constant KERNEL_CONFIG_AUX_PZT_B: integer := 0;
constant TWGen_sweep_high_addr: integer := 109;
constant INJECT_CONTROL_MANUAL_LASER_ENABLE_B: integer := 7;
constant laserlocker_eta2_dark_addr: integer := 51;
constant max_sync_counter_for_transfer: integer := 400;
constant inject_laser1_coarse_current_addr: integer := 115;
constant MAX_WIDTH: integer := 64535;
constant inject_laser4_fine_current_range_addr: integer := 126;
constant CHANB_DATA_START: integer := 34;
constant SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_W: integer := 4;
constant OVERLOAD_HotBoxTecBit: integer := 1;
constant RDMEM_RESERVED_BANK_ADDR_WIDTH: integer := 12;
constant inject_laser2_fine_current_addr: integer := 120;
constant SGDBRCURRENTSOURCE_CSR_CPOL_B: integer := 3;
constant INJECT_CONTROL_LASER_SELECT_B: integer := 1;
constant SGDBRMANAGER_CONFIG_SELECT_W: integer := 2;
constant rdman_metadata_addrcntr_addr: integer := 91;
constant rdman_param11_addr: integer := 85;
constant PWM_CS_CONT_B: integer := 1;
constant inject_control2_addr: integer := 114;
constant INJECT_CONTROL_LASER_SHUTDOWN_ENABLE_B: integer := 12;
constant RDMAN_CONTROL_START_RD_B: integer := 2;
constant rdman_extra_duration_addr: integer := 99;
constant inject_laser1_fine_current_range_addr: integer := 123;
constant SGDBRCURRENTSOURCE_CSR_SELECT_B: integer := 1;
constant rdman_lock_duration_addr: integer := 96;
constant HIGH: integer := 1;
constant TWGen_sweep_low_addr: integer := 108;
constant SGDBRMANAGER_SGDBR_PRESENT_SGDBR_B_PRESENT_B: integer := 1;
constant EMIF_DATA_WIDTH: integer := 2**5;
constant inject_laser4_fine_current_addr: integer := 122;
constant laserlocker_wm_deriv_gain_addr: integer := 68;
constant INJECT_CONTROL_MANUAL_LASER_ENABLE_W: integer := 4;
constant laserlocker_lock_error_addr: integer := 2**6;
constant rdman_control_addr: integer := 71;
constant kernel_intronix_2_addr: integer := 6;
constant KERNEL_CONTROL_DOUT_MAN_B: integer := 3;
constant SGDBRMANAGER_CONFIG_SELECT_B: integer := 1;
constant RDMEM_DATA_WIDTH: integer := 18;
constant laserlocker_ratio1_multiplier_addr: integer := 60;
constant dynamicpwm_slope_addr: integer := 157;
constant RDMAN_STATUS_RD_IRQ_B: integer := 1;
constant LASERLOCKER_OPTIONS_RATIO_OUT_SEL_W: integer := 2;
constant CHANB_CONTROL_START: integer := 26;
constant inject_control_addr: integer := 113;
constant KERNEL_CONTROL_I2C_RESET_B: integer := 2;
constant MULT_LATENCY: integer := 2;
constant rdman_options_addr: integer := 73;
constant inject_laser1_extra_offset_addr: integer := 135;
constant laserlocker_wm_lock_window_addr: integer := 65;
constant SGDBRMANAGER_CSR_START_SCAN_B: integer := 0;
constant SGDBRMANAGER_SGDBR_PRESENT_SGDBR_A_PRESENT_B: integer := 0;
constant KERNEL_CONFIG_ENGINE2_TEC_B: integer := 2;
constant inject_laser2_extra_coarse_scale_addr: integer := 2**7;
constant LASERLOCKER_CS_RUN_B: integer := 0;
constant rdman_param5_addr: integer := 79;
constant kernel_intronix_clksel_addr: integer := 4;
constant laserlocker_cs_addr: integer := 43;
constant inject_laser3_coarse_current_addr: integer := 117;
constant laserlocker_tuning_offset_addr: integer := 2**6-1;
constant laserlocker_ref2_dark_addr: integer := 52;
constant INJECT_CONTROL2_EXTRA_MODE_B: integer := 2;
constant CHANB_DATA_END: integer := 50;
constant inject_laser3_fine_current_range_addr: integer := 125;
constant TWGEN_CS_RUN_B: integer := 0;
constant mod_main: integer := 2**8;
constant rdman_param3_addr: integer := 77;
constant TWGen_cs_addr: integer := 105;
constant MIN_WIDTH: integer := 1000;
constant KERNEL_FAN_FAN1_B: integer := 0;
constant inject_laser2_extra_offset_addr: integer := 136;
constant CHANA_CONTROL_END: integer := 9;
constant laserlocker_eta2_offset_addr: integer := 55;
constant dynamicpwm_low_addr: integer := 156;
constant LASERLOCKER_CS_TUNING_OFFSET_SEL_B: integer := 6;
constant laserlocker_ratio2_addr: integer := 58;
constant CHANA_DATA_START: integer := 9;
constant rdman_off_duration_addr: integer := 98;
constant OPTICAL_SWITCH_WIDTH: integer := 100;
constant TWGEN_CS_CONT_B: integer := 1;
constant LASERLOCKER_CS_SAMPLE_DARK_B: integer := 4;
constant FPGA_REG_MASK: integer := 1;
constant INJECT_CONTROL2_EXTINGUISH_DESELECTED_B: integer := 1;
constant CHANB_CONTROL_END: integer := 34;
constant sgdbrmanager_scan_address_addr: integer := 200;
constant dynamicpwm_delta_addr: integer := 154;
constant rdman_param_addrcntr_addr: integer := 92;
constant KERNEL_FAN_FAN2_B: integer := 1;
constant RDMAN_OPTIONS_SCOPE_MODE_B: integer := 5;
constant TWGen_window_low_addr: integer := 110;
constant CHAND_DATA_END: integer := 25;
constant SGDBRMANAGER_SGDBR_PRESENT_SGDBR_D_PRESENT_B: integer := 3;
constant RDMAN_STATUS_ACQ_DONE_B: integer := 2;
constant laserlocker_eta1_addr: integer := 45;
constant sgdbrcurrentsource_mosi_data_addr: integer := 185;
constant META_SIZE: integer := 2**9;
constant TWGen_slope_down_addr: integer := 106;
constant kernel_magic_code_addr: integer := 0;
constant laserlocker_ratio2_center_addr: integer := 61;
constant INJECT_CONTROL2_EXTENDED_CURRENT_MODE_B: integer := 4;
constant mod_dither: integer := 2**8;
constant KERNEL_CONFIG_ENGINE1_TEC_B: integer := 1;
constant INJECT_CONTROL2_EXTRA_ENABLE_B: integer := 3;
constant inject_laser2_extra_fine_scale_addr: integer := 132;
constant TWGen_slope_up_addr: integer := 107;
constant main_width: integer := 8;
constant pwm_pulse_width_addr: integer := 2**5;
constant DYNAMICPWM_CS_RUN_B: integer := 0;
constant laserlocker_ref1_dark_addr: integer := 50;
constant laserlocker_fine_current_addr: integer := 69;
constant DYNAMICPWM_CS_CONT_B: integer := 1;
constant sgdbrmanager_csr_addr: integer := 195;
constant CHANA_CONTROL_START: integer := 1;
constant SGDBRCURRENTSOURCE_CSR_DESELECT_B: integer := 2;
constant PWM_CS_PWM_OUT_B: integer := 2;
constant sgdbrcurrentsource_miso_data_addr: integer := 186;
constant SGDBRMANAGER_CSR_SCAN_ACTIVE_B: integer := 2;
constant INJECT_CONTROL_SOA_PRESENT_B: integer := 14;
constant INJECT_CONTROL_LASER_SELECT_W: integer := 2;
constant laserlocker_eta2_addr: integer := 47;
constant extra: integer := 8;
constant laserlocker_ref1_offset_addr: integer := 54;
constant rdman_status_addr: integer := 72;
constant INJECT_CONTROL2_OPTICAL_SWITCH_SELECT_B: integer := 9;
constant TWGEN_CS_RESET_B: integer := 2;
constant LASERLOCKER_CS_CONT_B: integer := 1;
constant kernel_intronix_3_addr: integer := 7;
constant rdman_param7_addr: integer := 81;
constant rdman_param12_addr: integer := 86;
constant LASERLOCKER_CS_LASER_FREQ_OK_B: integer := 7;
constant KERNEL_STATUS_LED_GREEN_B: integer := 1;
constant inject_laser3_fine_current_addr: integer := 121;
constant INJECT_CONTROL2_OPTICAL_SWITCH_SELECT_W: integer := 2;
constant SGDBRCURRENTSOURCE_CSR_DONE_B: integer := 5;
constant SGDBRMANAGER_SGDBR_PRESENT_SGDBR_C_PRESENT_B: integer := 2;
constant TWGen_pzt_offset_addr: integer := 112;
constant sgdbrmanager_scan_samples_addr: integer := 197;
constant kernel_sel_detector_mode_addr: integer := 14;
constant rdman_param1_addr: integer := 75;
constant inject_laser3_extra_offset_addr: integer := 137;
constant MASK: integer := 2**16-1;
constant inject_laser1_extra_fine_scale_addr: integer := 131;
constant kernel_fan_addr: integer := 13;
constant TWGen_acc_addr: integer := 104;
constant SGDBRCURRENTSOURCE_CSR_MISO_B: integer := 6;
constant width: integer := 2**4;
constant CHAND_DATA_START: integer := 9;
constant laserlocker_ratio1_addr: integer := 57;
constant rdman_param14_addr: integer := 88;
constant RDMAN_OPTIONS_LOCK_ENABLE_B: integer := 0;
constant SGDBRCURRENTSOURCE_CSR_RESET_B: integer := 0;
constant DYNAMICPWM_CS_PWM_INVERT_B: integer := 5;
constant rdman_ringdown_data_addr: integer := 103;
constant rdman_num_samp_addr: integer := 94;
constant RDMAN_STATUS_SHUTDOWN_B: integer := 0;
constant OVERLOAD_WarmBoxTecBit: integer := 0;
constant sgdbrmanager_sgdbr_present_addr: integer := 201;
constant RDMAN_STATUS_LAPPED_B: integer := 6;
constant INJECT_CONTROL_MANUAL_SOA_ENABLE_B: integer := 11;
constant sgdbrmanager_delay_samples_addr: integer := 199;
constant laserlocker_wm_prop_gain_addr: integer := 67;
constant kernel_dout_hi_addr: integer := 9;
constant dynamicpwm_high_addr: integer := 155;
constant RDMAN_OPTIONS_UP_SLOPE_ENABLE_B: integer := 1;
constant kernel_config_addr: integer := 3;
constant inject_laser4_extra_fine_scale_addr: integer := 134;
constant TWGEN_CS_TUNE_PZT_B: integer := 3;
constant inject_laser4_extra_offset_addr: integer := 138;
constant rdman_divisor_addr: integer := 93;
constant inject_laser1_fine_current_addr: integer := 119;
constant SGDBRCURRENTSOURCE_SYNC_REGISTER_SOURCE_B: integer := 4;
constant SGDBRCURRENTSOURCE_CSR_CPHA_B: integer := 4;
constant INJECT_CONTROL_SOA_SHUTDOWN_ENABLE_B: integer := 13;
constant KERNEL_CONTROL_OVERLOAD_RESET_B: integer := 1;
constant KERNEL_STATUS_LED_RED_B: integer := 0;
constant kernel_dout_lo_addr: integer := 10;
constant RDMAN_OPTIONS_SCOPE_SLOPE_B: integer := 6;
constant DYNAMICPWM_CS_PWM_ENABLE_B: integer := 2;
constant rdman_param0_addr: integer := 74;
constant DATA_BANK_ADDR_WIDTH: integer := 12;
constant RDMAN_STATUS_BANK1_IN_USE_B: integer := 5;
constant laserlocker_ref2_addr: integer := 48;
constant RDMAN_OPTIONS_DOWN_SLOPE_ENABLE_B: integer := 2;
constant FPGA_REG_WIDTH: integer := 2**4;
constant scaler_scale1_addr: integer := 158;
constant rdman_data_addrcntr_addr: integer := 90;
constant ADC_CYCLE: integer := 21;
constant laserlocker_ratio2_multiplier_addr: integer := 62;
constant ADC_LAST_CYCLE: integer := 19;
constant RDMAN_CONTROL_RD_IRQ_ACK_B: integer := 7;
constant LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B: integer := 2;
constant CHAND_CONTROL_END: integer := 9;
constant NSTAGES: integer := 28;
constant RDMAN_CONTROL_BANK0_CLEAR_B: integer := 5;
constant RDMEM_META_WIDTH: integer := 2**4;
constant dither_width: integer := 8;
constant PWM_CS_RUN_B: integer := 0;
constant sgdbrmanager_config_addr: integer := 196;
constant pwm_cs_addr: integer := 2**5-1;
constant kernel_diag_1_addr: integer := 2;
constant RDMAN_CONTROL_CONT_B: integer := 1;
constant rdman_tuner_at_ringdown_addr: integer := 101;
constant sgdbrcurrentsource_miso_delay_addr: integer := 184;
constant kernel_overload_addr: integer := 8;
constant SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B: integer := 7;
constant num_of_clock_pulses: integer := 2**5;
constant rdman_param13_addr: integer := 87;
constant MAX_CYCLES: integer := 54;
constant LOW: integer := 0;
constant RDMAN_CONTROL_RUN_B: integer := 0;
constant LASERLOCKER_CS_PRBS_B: integer := 2;
constant DIV_LATENCY: integer := 19;
constant ADC_DATA_WIDTH: integer := 2**4;
constant TWGen_window_high_addr: integer := 111;
constant inject_laser2_coarse_current_addr: integer := 116;
constant kernel_control_addr: integer := 1;
constant control_init: integer := 4;
constant sgdbrmanager_sample_time_addr: integer := 198;
constant sgdbrcurrentsource_sync_register_addr: integer := 187;
constant CHAND_CONTROL_START: integer := 1;
constant laserlocker_ratio1_center_addr: integer := 59;
constant META_BANK_ADDR_WIDTH: integer := 12;
constant laserlocker_options_addr: integer := 44;
constant INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_B: integer := 5;
constant INJECT_CONTROL_MODE_B: integer := 0;
constant inject_laser4_coarse_current_addr: integer := 118;
constant RDMAN_STATUS_BANK0_IN_USE_B: integer := 4;
constant max_delay: integer := 2**4;
constant DYNAMICPWM_CS_USE_COMPARATOR_B: integer := 3;
constant INJECT_CONTROL2_FIBER_AMP_PRESENT_B: integer := 0;
constant RDMAN_STATUS_ABORTED_B: integer := 9;
constant CHANA_DATA_END: integer := 25;
constant rdman_param10_addr: integer := 84;
constant INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_W: integer := 4;
constant rdman_param9_addr: integer := 83;
constant SWITCH_4WAY_XTALATCH: integer := 2;
constant sgdbrcurrentsource_max_sync_current_addr: integer := 188;
constant LASERLOCKER_OPTIONS_MANUAL_LOCK_B: integer := 4;
constant laserlocker_eta1_offset_addr: integer := 53;
constant kernel_status_led_addr: integer := 12;
constant RDMAN_STATUS_TIMEOUT_B: integer := 8;
constant LASERLOCKER_OPTIONS_SIM_ACTUAL_B: integer := 0;
constant inject_laser3_extra_fine_scale_addr: integer := 133;
constant laserlocker_wm_int_gain_addr: integer := 66;
constant laserlocker_ref2_offset_addr: integer := 56;
constant RDMAN_CONTROL_BANK1_CLEAR_B: integer := 6;
constant EMIF_ADDR_WIDTH: integer := 20;
constant rdman_timeout_duration_addr: integer := 100;
constant ADC_START_CYCLE: integer := 4;
constant rdman_param2_addr: integer := 76;
constant PARAM_BANK_ADDR_WIDTH: integer := 6;
constant RDMAN_CONTROL_ABORT_RD_B: integer := 3;
constant sgdbrcurrentsource_csr_addr: integer := 183;
constant LASERLOCKER_OPTIONS_DIRECT_TUNE_B: integer := 1;
constant dynamicpwm_cs_addr: integer := 153;
constant laserlocker_cycle_counter_addr: integer := 70;
constant rdman_precontrol_duration_addr: integer := 97;
constant SGDBRMANAGER_CSR_DONE_B: integer := 1;
constant LASERLOCKER_CS_ACC_EN_B: integer := 3;
constant inject_laser3_extra_coarse_scale_addr: integer := 129;
constant rdman_threshold_addr: integer := 95;
constant rdman_param15_addr: integer := 89;
constant RDMAN_OPTIONS_SIM_ACTUAL_B: integer := 4;
constant LASERLOCKER_CS_CURRENT_OK_B: integer := 8;
constant rdman_metadata_addr_at_ringdown_addr: integer := 102;
constant DYNAMICPWM_CS_PWM_OUT_B: integer := 4;
constant inject_laser1_extra_coarse_scale_addr: integer := 2**7-1;
constant laserlocker_eta1_dark_addr: integer := 49;
constant sck_divisor: integer := 1;
constant SWITCH_2WAY_XTALATCH: integer := 0;
constant LASERLOCKER_CS_ADC_STROBE_B: integer := 5;
constant RDMEM_PARAM_WIDTH: integer := 2**5;


type t_enum_MetadataAcqState_7 is (
    IDLE,
    AWAIT_STROBE,
    ACQUIRING,
    DONE
);
type t_enum_OptSwitchState_12 is (
    IDLE,
    PULSING_1,
    SELECTED_1,
    PULSING_2,
    SELECTED_2
);
type t_enum_ParamState_8 is (
    IDLE,
    STORING,
    DONE
);
type t_enum_SeqState_14 is (
    READ_PB_WFM0,
    READ_PB_WFM1,
    WRITE_PB_DATA,
    AWAIT_REC_STROBE,
    READ_REC_DATA,
    WRITE_REC_WFM0,
    WRITE_REC_WFM2,
    WRITE_REC_WFM1,
    WRITE_REC_WFM3,
    ADVANCE_ADDRESS
);
type t_enum_SeqState_9 is (
    IDLE,
    START_INJECT,
    WAIT_FOR_PRECONTROL,
    WAIT_FOR_LOCK,
    WAIT_FOR_GATING_CONDITIONS,
    CHECK_BELOW_THRESHOLD,
    WAIT_FOR_THRESHOLD,
    IN_RINGDOWN,
    CHECK_PARAMS_DONE,
    ACQ_DONE,
    AWAIT_SWEEP_1,
    AWAIT_SWEEP_2,
    WAIT_RD_DONE_1,
    WAIT_RD_DONE_2
);
type t_enum_SwitchPulserState_13 is (
    START,
    PULSING,
    WAITING
);
type t_enum_t_EnumType_2 is (
    NORMAL,
    PENDING,
    SYNC_UPDATE
);
type t_enum_t_EnumType_3 is (
    NORMAL,
    PENDING,
    SYNC_UPDATE
);
type t_enum_t_EnumType_4 is (
    NORMAL,
    PENDING,
    SYNC_UPDATE
);
type t_enum_t_EnumType_6 is (
    NORMAL,
    PENDING,
    SYNC_UPDATE
);
type t_enum_t_State_1 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
type t_enum_t_State_10 is (
    INIT,
    WRITE1,
    WRITE2,
    READ1,
    READ2,
    IDLE
);
type t_enum_t_State_11 is (
    IDLE,
    WAIT_1,
    WAIT_0
);
type t_enum_t_State_5 is (
    IDLE,
    WAIT_1,
    WAIT_0
);

signal rdsim_value: unsigned(15 downto 0);
signal sgdbr_b_mosi: std_logic;
signal laser2_fine_ext: unsigned(15 downto 0);
signal data_addr: unsigned(11 downto 0);
signal dsp_data_in_pwm_laser4: unsigned(31 downto 0);
signal lsr3_mosi_temp: std_logic;
signal ce2: std_logic;
signal heater_pwm_inv: std_logic;
signal rd_irq: std_logic;
signal laser_freq_ok: std_logic;
signal sgdbr_d_sync_strobe_in: std_logic;
signal sgdbr_d_resetn: std_logic;
signal pulse_100k: std_logic;
signal adc_clk: std_logic;
signal sgdbr_c_sck: std_logic;
signal sgdbr_b_miso: std_logic;
signal sgdbr_b_resetn: std_logic;
signal ref2_actual: unsigned(15 downto 0);
signal channel_4: unsigned(8 downto 0);
signal sgdbr_d_miso: std_logic;
signal dsp_data_in_rdman: unsigned(31 downto 0);
signal engine1_pwm_inv: std_logic;
signal lsr4_disable_temp: std_logic;
signal meta6: unsigned(15 downto 0);
signal scan_active_out: std_logic;
signal fan: unsigned(1 downto 0);
signal dsp_data_in_twGen: unsigned(31 downto 0);
signal eta2_actual: unsigned(15 downto 0);
signal heater_pwm_out: std_logic;
signal bank: std_logic;
signal tuner_in_window: std_logic;
signal wlm_data_available: std_logic;
signal inlet_valve_dac: unsigned(15 downto 0);
signal meta_addr: unsigned(11 downto 0);
signal chanC_data_in: unsigned(15 downto 0);
signal i2c_reset: std_logic;
signal dsp_data_in_dynamicpwm_outlet: unsigned(31 downto 0);
signal sgdbr_b_sck: std_logic;
signal lsr1_disable_temp: std_logic;
signal dsp_data_in_sgdbrcurrentsource_b: unsigned(31 downto 0);
signal dsp_data_in_sgdbrcurrentsource_a: unsigned(31 downto 0);
signal dsp_data_in_sgdbrcurrentsource_d: unsigned(31 downto 0);
signal lsr3_disable_temp: std_logic;
signal intronix_clksel: unsigned(4 downto 0);
signal lsr2_disable_temp: std_logic;
signal ratio1: unsigned(15 downto 0);
signal pwm_laser4_inv_out: std_logic;
signal sgdbr_present: unsigned(3 downto 0);
signal pb_wfm_sel: std_logic;
signal lsr2_ss_temp: std_logic;
signal sgdbr_b_sync_register: unsigned(3 downto 0);
signal sgdbr_b_done: std_logic;
signal dsp_data_in_dynamicpwm_inlet: unsigned(31 downto 0);
signal pulse_1M: std_logic;
signal channel_3: unsigned(7 downto 0);
signal channel_2: unsigned(7 downto 0);
signal pwm_laser1_out: std_logic;
signal wr_data: unsigned(17 downto 0);
signal sgdbr_a_csn: std_logic;
signal tuner_slope: std_logic;
signal data_we: std_logic;
signal laser_tuning_offset: unsigned(15 downto 0);
signal engine2_pwm_out: std_logic;
signal laser_fine_current: unsigned(15 downto 0);
signal lsr1_mosi_temp: std_logic;
signal warm_box_pwm_inv: std_logic;
signal sgdbr_c_csn: std_logic;
signal dsp_data_in_sgdbrcurrentsource_c: unsigned(31 downto 0);
signal param_addr: unsigned(5 downto 0);
signal sgdbr_mode: std_logic;
signal sgdbr_c_done: std_logic;
signal aux_pzt_dac_sdi: std_logic;
signal laser1_fine_ext: unsigned(15 downto 0);
signal dsp_data_in_pwm_heater: unsigned(31 downto 0);
signal eta2: unsigned(15 downto 0);
signal laser4_fine_ext: unsigned(15 downto 0);
signal dsp_data_in_inject: unsigned(31 downto 0);
signal dsp_data_in_analyzermemory: unsigned(31 downto 0);
signal dsp_data_in_pwm_engine2: unsigned(31 downto 0);
signal laser_locked: std_logic;
signal pb_data: unsigned(15 downto 0);
signal eta1_actual: unsigned(15 downto 0);
signal sgdbr_d_done: std_logic;
signal lsr3_ss_temp: std_logic;
signal channel_1: unsigned(7 downto 0);
signal lsr1_ss_temp: std_logic;
signal hot_box_pwm_inv: std_logic;
signal dsp_wr: std_logic;
signal pwm_laser1_inv_out: std_logic;
signal metadata_strobe: std_logic;
signal ext_laser_sequence_id: unsigned(15 downto 0);
signal sgdbr_b_csn: std_logic;
signal filter_heater_pwm_inv_out: std_logic;
signal dsp_data_in_laserlocker: unsigned(31 downto 0);
signal pb0_out: unsigned(15 downto 0);
signal lsr2_mosi_temp: std_logic;
signal sgdbr_c_miso: std_logic;
signal aux_pzt_dac_ld: std_logic;
signal laser_locking_pid: unsigned(15 downto 0);
signal lsr4_mosi_temp: std_logic;
signal param_we: std_logic;
signal aux_pzt_dac_sck: std_logic;
signal rec_addr: unsigned(11 downto 0);
signal extended_current_mode: std_logic;
signal warm_box_pwm_out: std_logic;
signal filter_heater_pwm_out: std_logic;
signal engine1_pwm_out: std_logic;
signal sgdbr_a_miso: std_logic;
signal meta5: unsigned(15 downto 0);
signal average2: unsigned(15 downto 0);
signal laser_extra: std_logic;
signal sgdbr_c_mosi: std_logic;
signal sgdbr_d_sync_register: unsigned(3 downto 0);
signal rec_data: unsigned(17 downto 0);
signal dsp_data_in_sgdbrmanager: unsigned(31 downto 0);
signal dsp_data_out: unsigned(31 downto 0);
signal sel_laser: unsigned(1 downto 0);
signal rec_we: std_logic;
signal sel_coarse_current: unsigned(15 downto 0);
signal clk_10M: std_logic;
signal dsp_data_in_kernel: unsigned(31 downto 0);
signal wr_meta: unsigned(15 downto 0);
signal sgdbr_a_mosi: std_logic;
signal dsp_data_in_pwm_laser3: unsigned(31 downto 0);
signal dsp_data_in_pwm_laser2: unsigned(31 downto 0);
signal dsp_data_in_pwm_laser1: unsigned(31 downto 0);
signal sgdbr_d_sck: std_logic;
signal eta1: unsigned(15 downto 0);
signal status_led: unsigned(1 downto 0);
signal dsp_addr: unsigned(19 downto 0);
signal data_available_actual: std_logic;
signal dsp_data_in: unsigned(31 downto 0);
signal pb_strobe_out: std_logic;
signal pwm_laser3_inv_out: std_logic;
signal wlm_sim_actual: std_logic;
signal ext_laser_level_counter: unsigned(15 downto 0);
signal meta: unsigned(15 downto 0);
signal rec_wfm_sel: std_logic;
signal ext_laser_current_in_window: std_logic;
signal diag_1: unsigned(7 downto 0);
signal sync_current_in: unsigned(15 downto 0);
signal sgdbr_a_done: std_logic;
signal pzt: unsigned(15 downto 0);
signal sgdbr_a_resetn: std_logic;
signal sgdbr_c_sync_register: unsigned(3 downto 0);
signal dsp_data_in_pwm_hotbox: unsigned(31 downto 0);
signal engine2_pwm_inv: std_logic;
signal outlet_valve_dac: unsigned(15 downto 0);
signal hot_box_pwm_out: std_logic;
signal sgdbr_a_sck: std_logic;
signal sel_detector: std_logic;
signal acq_done_irq: std_logic;
signal sel_fine_current: unsigned(15 downto 0);
signal sgdbr_select: unsigned(1 downto 0);
signal intronix_1: unsigned(7 downto 0);
signal intronix_2: unsigned(7 downto 0);
signal overload_out: std_logic;
signal dsp_data_in_scaler: unsigned(31 downto 0);
signal sgdbr_d_mosi: std_logic;
signal clk_5M: std_logic;
signal dsp_data_in_pwm_engine1: unsigned(31 downto 0);
signal tuner_value: unsigned(15 downto 0);
signal meta1: unsigned(15 downto 0);
signal sgdbr_c_resetn: std_logic;
signal pwm_laser4_out: std_logic;
signal config: unsigned(15 downto 0);
signal wr_param: unsigned(31 downto 0);
signal laser3_fine_ext: unsigned(15 downto 0);
signal intronix_3: unsigned(7 downto 0);
signal wmm_rd_out: std_logic;
signal lsr4_ss_temp: std_logic;
signal ref1: unsigned(15 downto 0);
signal meta_we: std_logic;
signal ref2: unsigned(15 downto 0);
signal pb1_out: unsigned(15 downto 0);
signal sgdbr_c_sync_strobe_in: std_logic;
signal pzt_scaled: unsigned(15 downto 0);
signal clk_2M5: std_logic;
signal ref1_actual: unsigned(15 downto 0);
signal param: unsigned(31 downto 0);
signal data: unsigned(17 downto 0);
signal sgdbr_a_sync_strobe_in: std_logic;
signal pwm_laser2_out: std_logic;
signal sgdbr_b_sync_strobe_in: std_logic;
signal sgdbr_a_sync_register: unsigned(3 downto 0);
signal counter: unsigned(27 downto 0);
signal pwm_laser2_inv_out: std_logic;
signal overload_in: unsigned(15 downto 0);
signal pwm_laser3_out: std_logic;
signal dsp_data_in_pwm_filter_heater: unsigned(31 downto 0);
signal rd_trig: std_logic;
signal sgdbr_d_csn: std_logic;
signal dsp_data_in_pwm_warmbox: unsigned(31 downto 0);
signal acc_en: std_logic;
signal scaler_a: unsigned(16 downto 0);
signal scaler_b: unsigned(16 downto 0);
signal scaler_scale1: unsigned(15 downto 0);
signal scaler_p: unsigned(33 downto 0);
signal scaler_mult_a_s: signed (17 downto 0);
signal scaler_mult_b_s: signed (17 downto 0);
signal scaler_mult_p_s: signed (35 downto 0);
signal dynamicPwmOutlet_slope: unsigned(15 downto 0);
signal dynamicPwmOutlet_high: unsigned(15 downto 0);
signal dynamicPwmOutlet_cs: unsigned(15 downto 0);
signal dynamicPwmOutlet_extra0: unsigned(7 downto 0);
signal dynamicPwmOutlet_low: unsigned(15 downto 0);
signal dynamicPwmOutlet_main_cntr: unsigned(7 downto 0);
signal dynamicPwmOutlet_acc: unsigned(23 downto 0);
signal dynamicPwmOutlet_delta: signed (15 downto 0);
signal dynamicPwmOutlet_pwm: std_logic;
signal dynamicPwmOutlet_temp: unsigned(8 downto 0);
signal dynamicPwmOutlet_up: std_logic;
signal dynamicPwmOutlet_dither_cntr: unsigned(7 downto 0);
signal dynamicPwmOutlet_pulse_width: unsigned(15 downto 0);
signal dynamicPwmInlet_slope: unsigned(15 downto 0);
signal dynamicPwmInlet_high: unsigned(15 downto 0);
signal dynamicPwmInlet_cs: unsigned(15 downto 0);
signal dynamicPwmInlet_extra0: unsigned(7 downto 0);
signal dynamicPwmInlet_low: unsigned(15 downto 0);
signal dynamicPwmInlet_main_cntr: unsigned(7 downto 0);
signal dynamicPwmInlet_acc: unsigned(23 downto 0);
signal dynamicPwmInlet_delta: signed (15 downto 0);
signal dynamicPwmInlet_pwm: std_logic;
signal dynamicPwmInlet_temp: unsigned(8 downto 0);
signal dynamicPwmInlet_up: std_logic;
signal dynamicPwmInlet_dither_cntr: unsigned(7 downto 0);
signal dynamicPwmInlet_pulse_width: unsigned(15 downto 0);
signal auxPztDac_dac_sdi: std_logic;
signal auxPztDac_counter: unsigned(4 downto 0);
signal auxPztDac_chanD_data: unsigned(15 downto 0);
signal auxPztDac_state: t_enum_t_State_5;
signal auxPztDac_dac_ld: std_logic;
signal pztValveDac_dac_sdi: std_logic;
signal pztValveDac_counter: unsigned(4 downto 0);
signal pztValveDac_chanD_data: unsigned(15 downto 0);
signal pztValveDac_state: t_enum_t_State_5;
signal pztValveDac_dac_ld: std_logic;
signal wlmadcreader_counter: unsigned(4 downto 0);
signal wlmadcreader_ref1: unsigned(15 downto 0);
signal wlmadcreader_ref2: unsigned(15 downto 0);
signal wlmadcreader_state: t_enum_t_State_1;
signal wlmadcreader_eta2: unsigned(15 downto 0);
signal wlmadcreader_eta1: unsigned(15 downto 0);
signal twGen_slope: std_logic;
signal twGen_pzt_offset: unsigned(15 downto 0);
signal twGen_cs: unsigned(15 downto 0);
signal twGen_extra0: unsigned(8 downto 0);
signal twGen_sweep_low: unsigned(15 downto 0);
signal twGen_acc: unsigned(24 downto 0);
signal twGen_window_high: unsigned(15 downto 0);
signal twGen_slope_down: unsigned(15 downto 0);
signal twGen_sweep_high: unsigned(15 downto 0);
signal twGen_slope_up: unsigned(15 downto 0);
signal twGen_window_low: unsigned(15 downto 0);
signal sgdbrCurrentSourceD_sck_phase: std_logic;
signal sgdbrCurrentSourceD_extra_active: std_logic;
signal sgdbrCurrentSourceD_miso_buff_b: unsigned(31 downto 0);
signal sgdbrCurrentSourceD_access_type: t_enum_t_EnumType_4;
signal sgdbrCurrentSourceD_miso_buff_a: unsigned(31 downto 0);
signal sgdbrCurrentSourceD_extra_counter: unsigned(2 downto 0);
signal sgdbrCurrentSourceD_miso_delay: unsigned(3 downto 0);
signal sgdbrCurrentSourceD_sck_divider: unsigned(5 downto 0);
signal sgdbrCurrentSourceD_csn: std_logic;
signal sgdbrCurrentSourceD_edge_strobe: std_logic;
signal sgdbrCurrentSourceD_ok_to_transfer: std_logic;
signal sgdbrCurrentSourceD_sync_strobe_prev: std_logic;
signal sgdbrCurrentSourceD_csr: unsigned(15 downto 0);
signal sgdbrCurrentSourceD_mosi_data: unsigned(31 downto 0);
signal sgdbrCurrentSourceD_data_clk: std_logic;
signal sgdbrCurrentSourceD_sync_register: unsigned(4 downto 0);
signal sgdbrCurrentSourceD_sync_counter: unsigned(9 downto 0);
signal sgdbrCurrentSourceD_spi_active: std_logic;
signal sgdbrCurrentSourceD_sck_active: std_logic;
signal sgdbrCurrentSourceD_transfer_pending: std_logic;
signal sgdbrCurrentSourceD_miso_data: unsigned(31 downto 0);
signal sgdbrCurrentSourceD_miso_shift: std_logic;
signal sgdbrCurrentSourceD_mosi_buff: unsigned(31 downto 0);
signal sgdbrCurrentSourceD_delay_sr_a: unsigned(7 downto 0);
signal sgdbrCurrentSourceD_clock_counter: unsigned(5 downto 0);
signal sgdbrCurrentSourceD_delay_sr_b: unsigned(7 downto 0);
signal sgdbrCurrentSourceD_max_sync_current: unsigned(15 downto 0);
signal sgdbrCurrentSourceC_sck_phase: std_logic;
signal sgdbrCurrentSourceC_extra_active: std_logic;
signal sgdbrCurrentSourceC_miso_buff_b: unsigned(31 downto 0);
signal sgdbrCurrentSourceC_access_type: t_enum_t_EnumType_2;
signal sgdbrCurrentSourceC_miso_buff_a: unsigned(31 downto 0);
signal sgdbrCurrentSourceC_extra_counter: unsigned(2 downto 0);
signal sgdbrCurrentSourceC_miso_delay: unsigned(3 downto 0);
signal sgdbrCurrentSourceC_sck_divider: unsigned(5 downto 0);
signal sgdbrCurrentSourceC_csn: std_logic;
signal sgdbrCurrentSourceC_edge_strobe: std_logic;
signal sgdbrCurrentSourceC_ok_to_transfer: std_logic;
signal sgdbrCurrentSourceC_sync_strobe_prev: std_logic;
signal sgdbrCurrentSourceC_csr: unsigned(15 downto 0);
signal sgdbrCurrentSourceC_mosi_data: unsigned(31 downto 0);
signal sgdbrCurrentSourceC_data_clk: std_logic;
signal sgdbrCurrentSourceC_sync_register: unsigned(4 downto 0);
signal sgdbrCurrentSourceC_sync_counter: unsigned(9 downto 0);
signal sgdbrCurrentSourceC_spi_active: std_logic;
signal sgdbrCurrentSourceC_sck_active: std_logic;
signal sgdbrCurrentSourceC_transfer_pending: std_logic;
signal sgdbrCurrentSourceC_miso_data: unsigned(31 downto 0);
signal sgdbrCurrentSourceC_miso_shift: std_logic;
signal sgdbrCurrentSourceC_mosi_buff: unsigned(31 downto 0);
signal sgdbrCurrentSourceC_delay_sr_a: unsigned(7 downto 0);
signal sgdbrCurrentSourceC_clock_counter: unsigned(5 downto 0);
signal sgdbrCurrentSourceC_delay_sr_b: unsigned(7 downto 0);
signal sgdbrCurrentSourceC_max_sync_current: unsigned(15 downto 0);
signal sgdbrCurrentSourceB_sck_phase: std_logic;
signal sgdbrCurrentSourceB_extra_active: std_logic;
signal sgdbrCurrentSourceB_miso_buff_b: unsigned(31 downto 0);
signal sgdbrCurrentSourceB_access_type: t_enum_t_EnumType_3;
signal sgdbrCurrentSourceB_miso_buff_a: unsigned(31 downto 0);
signal sgdbrCurrentSourceB_extra_counter: unsigned(2 downto 0);
signal sgdbrCurrentSourceB_miso_delay: unsigned(3 downto 0);
signal sgdbrCurrentSourceB_sck_divider: unsigned(5 downto 0);
signal sgdbrCurrentSourceB_csn: std_logic;
signal sgdbrCurrentSourceB_edge_strobe: std_logic;
signal sgdbrCurrentSourceB_ok_to_transfer: std_logic;
signal sgdbrCurrentSourceB_sync_strobe_prev: std_logic;
signal sgdbrCurrentSourceB_csr: unsigned(15 downto 0);
signal sgdbrCurrentSourceB_mosi_data: unsigned(31 downto 0);
signal sgdbrCurrentSourceB_data_clk: std_logic;
signal sgdbrCurrentSourceB_sync_register: unsigned(4 downto 0);
signal sgdbrCurrentSourceB_sync_counter: unsigned(9 downto 0);
signal sgdbrCurrentSourceB_spi_active: std_logic;
signal sgdbrCurrentSourceB_sck_active: std_logic;
signal sgdbrCurrentSourceB_transfer_pending: std_logic;
signal sgdbrCurrentSourceB_miso_data: unsigned(31 downto 0);
signal sgdbrCurrentSourceB_miso_shift: std_logic;
signal sgdbrCurrentSourceB_mosi_buff: unsigned(31 downto 0);
signal sgdbrCurrentSourceB_delay_sr_a: unsigned(7 downto 0);
signal sgdbrCurrentSourceB_clock_counter: unsigned(5 downto 0);
signal sgdbrCurrentSourceB_delay_sr_b: unsigned(7 downto 0);
signal sgdbrCurrentSourceB_max_sync_current: unsigned(15 downto 0);
signal sgdbrCurrentSourceA_sck_phase: std_logic;
signal sgdbrCurrentSourceA_extra_active: std_logic;
signal sgdbrCurrentSourceA_miso_buff_b: unsigned(31 downto 0);
signal sgdbrCurrentSourceA_access_type: t_enum_t_EnumType_6;
signal sgdbrCurrentSourceA_miso_buff_a: unsigned(31 downto 0);
signal sgdbrCurrentSourceA_extra_counter: unsigned(2 downto 0);
signal sgdbrCurrentSourceA_miso_delay: unsigned(3 downto 0);
signal sgdbrCurrentSourceA_sck_divider: unsigned(5 downto 0);
signal sgdbrCurrentSourceA_csn: std_logic;
signal sgdbrCurrentSourceA_edge_strobe: std_logic;
signal sgdbrCurrentSourceA_ok_to_transfer: std_logic;
signal sgdbrCurrentSourceA_sync_strobe_prev: std_logic;
signal sgdbrCurrentSourceA_csr: unsigned(15 downto 0);
signal sgdbrCurrentSourceA_mosi_data: unsigned(31 downto 0);
signal sgdbrCurrentSourceA_data_clk: std_logic;
signal sgdbrCurrentSourceA_sync_register: unsigned(4 downto 0);
signal sgdbrCurrentSourceA_sync_counter: unsigned(9 downto 0);
signal sgdbrCurrentSourceA_spi_active: std_logic;
signal sgdbrCurrentSourceA_sck_active: std_logic;
signal sgdbrCurrentSourceA_transfer_pending: std_logic;
signal sgdbrCurrentSourceA_miso_data: unsigned(31 downto 0);
signal sgdbrCurrentSourceA_miso_shift: std_logic;
signal sgdbrCurrentSourceA_mosi_buff: unsigned(31 downto 0);
signal sgdbrCurrentSourceA_delay_sr_a: unsigned(7 downto 0);
signal sgdbrCurrentSourceA_clock_counter: unsigned(5 downto 0);
signal sgdbrCurrentSourceA_delay_sr_b: unsigned(7 downto 0);
signal sgdbrCurrentSourceA_max_sync_current: unsigned(15 downto 0);
signal sgdbrmanager_seq_state: t_enum_SeqState_14;
signal sgdbrmanager_scan_address: unsigned(11 downto 0);
signal sgdbrmanager_config: unsigned(2 downto 0);
signal sgdbrmanager_sgdbr_present: unsigned(3 downto 0);
signal sgdbrmanager_holdoff_counter: unsigned(15 downto 0);
signal sgdbrmanager_sample_time_counter: unsigned(15 downto 0);
signal sgdbrmanager_delay_samples: unsigned(15 downto 0);
signal sgdbrmanager_pb1: unsigned(15 downto 0);
signal sgdbrmanager_scan_samples: unsigned(12 downto 0);
signal sgdbrmanager_sel_rec_23: std_logic;
signal sgdbrmanager_rec_strobe_edge: std_logic;
signal sgdbrmanager_pb0: unsigned(15 downto 0);
signal sgdbrmanager_mem_flag: std_logic;
signal sgdbrmanager_sample_time: unsigned(15 downto 0);
signal sgdbrmanager_csr: unsigned(2 downto 0);
signal sgdbrmanager_posEdge_ff: std_logic;
signal analyzermemory_wr_dataB: unsigned(17 downto 0);
signal analyzermemory_wr_dataA: unsigned(17 downto 0);
signal analyzermemory_rd_metaB: unsigned(15 downto 0);
signal analyzermemory_wr_paramA: unsigned(31 downto 0);
signal analyzermemory_enB_data: std_logic;
signal analyzermemory_param_addrB: unsigned(6 downto 0);
signal analyzermemory_param_addrA: unsigned(6 downto 0);
signal analyzermemory_weB_meta: std_logic;
signal analyzermemory_weB_data: std_logic;
signal analyzermemory_enB_param: std_logic;
signal analyzermemory_meta_addrB: unsigned(12 downto 0);
signal analyzermemory_meta_addrA: unsigned(12 downto 0);
signal analyzermemory_rd_dataA: unsigned(17 downto 0);
signal analyzermemory_enA_param: std_logic;
signal analyzermemory_enA_data: std_logic;
signal analyzermemory_data_addrA: unsigned(12 downto 0);
signal analyzermemory_data_addrB: unsigned(12 downto 0);
signal analyzermemory_rd_metaA: unsigned(15 downto 0);
signal analyzermemory_wr_metaA: unsigned(15 downto 0);
signal analyzermemory_rd_paramA: unsigned(31 downto 0);
signal analyzermemory_enB_meta: std_logic;
signal analyzermemory_wr_enable: std_logic;
signal analyzermemory_enA_meta: std_logic;
signal rdman_lapped: std_logic;
signal rdman_rd_adc_clk: std_logic;
signal rdman_threshold: unsigned(15 downto 0);
signal rdman_rd_irq: std_logic;
signal rdman_timeout_duration: unsigned(31 downto 0);
signal rdman_off_duration: unsigned(15 downto 0);
signal rdman_num_samp: unsigned(11 downto 0);
signal rdman_param_acq: std_logic;
signal rdman_bank: std_logic;
signal rdman_param15: unsigned(31 downto 0);
signal rdman_param14: unsigned(31 downto 0);
signal rdman_param13: unsigned(31 downto 0);
signal rdman_param12: unsigned(31 downto 0);
signal rdman_param11: unsigned(31 downto 0);
signal rdman_param10: unsigned(31 downto 0);
signal rdman_timeout: std_logic;
signal rdman_metadataAcqState: t_enum_MetadataAcqState_7;
signal rdman_us_since_start: unsigned(31 downto 0);
signal rdman_metadata_addrcntr: unsigned(11 downto 0);
signal rdman_abort: std_logic;
signal rdman_ringdown_data: unsigned(17 downto 0);
signal rdman_tuner_gating_conditions: std_logic;
signal rdman_rd_data: unsigned(15 downto 0);
signal rdman_us_timer_enable: std_logic;
signal rdman_param2: unsigned(31 downto 0);
signal rdman_data_addrcntr: unsigned(11 downto 0);
signal rdman_sel_fine_current_slope: std_logic;
signal rdman_us_after_ringdown: unsigned(16 downto 0);
signal rdman_ext_laser_level_counter: unsigned(15 downto 0);
signal rdman_metadata_addr_at_ringdown: unsigned(15 downto 0);
signal rdman_paramState: t_enum_ParamState_8;
signal rdman_options: unsigned(15 downto 0);
signal rdman_ext_laser_sequence_id: unsigned(15 downto 0);
signal rdman_freq_gating_conditions: std_logic;
signal rdman_metadata_acq: std_logic;
signal rdman_rd_trig: std_logic;
signal rdman_expiry_time: unsigned(31 downto 0);
signal rdman_div50_counter: unsigned(5 downto 0);
signal rdman_rd_divider: unsigned(15 downto 0);
signal rdman_divisor: unsigned(15 downto 0);
signal rdman_precontrol_duration: unsigned(15 downto 0);
signal rdman_param7: unsigned(31 downto 0);
signal rdman_param6: unsigned(31 downto 0);
signal rdman_param5: unsigned(31 downto 0);
signal rdman_param4: unsigned(31 downto 0);
signal rdman_param3: unsigned(31 downto 0);
signal rdman_lock_duration: unsigned(15 downto 0);
signal rdman_param1: unsigned(31 downto 0);
signal rdman_param0: unsigned(31 downto 0);
signal rdman_sel_fine_current_prev: unsigned(15 downto 0);
signal rdman_param9: unsigned(31 downto 0);
signal rdman_param8: unsigned(31 downto 0);
signal rdman_control: unsigned(15 downto 0);
signal rdman_seqState: t_enum_SeqState_9;
signal rdman_param_addrcntr: unsigned(5 downto 0);
signal rdman_acq_done_irq: std_logic;
signal rdman_sel_fine_current: unsigned(15 downto 0);
signal rdman_status: unsigned(15 downto 0);
signal rdman_laser_extra: std_logic;
signal rdman_init_flag: std_logic;
signal rdman_extra_duration: unsigned(15 downto 0);
signal rdman_tuner_at_ringdown: unsigned(15 downto 0);
signal pwm_filter_heater_temp: unsigned(8 downto 0);
signal pwm_filter_heater_pulse_width: unsigned(15 downto 0);
signal pwm_filter_heater_cs: unsigned(15 downto 0);
signal pwm_filter_heater_dither_cntr: unsigned(7 downto 0);
signal pwm_filter_heater_pwm: std_logic;
signal pwm_filter_heater_main_cntr: unsigned(7 downto 0);
signal pwm_heater_temp: unsigned(8 downto 0);
signal pwm_heater_pulse_width: unsigned(15 downto 0);
signal pwm_heater_cs: unsigned(15 downto 0);
signal pwm_heater_dither_cntr: unsigned(7 downto 0);
signal pwm_heater_pwm: std_logic;
signal pwm_heater_main_cntr: unsigned(7 downto 0);
signal pwm_engine2_temp: unsigned(8 downto 0);
signal pwm_engine2_pulse_width: unsigned(15 downto 0);
signal pwm_engine2_cs: unsigned(15 downto 0);
signal pwm_engine2_dither_cntr: unsigned(7 downto 0);
signal pwm_engine2_pwm: std_logic;
signal pwm_engine2_main_cntr: unsigned(7 downto 0);
signal pwm_engine1_temp: unsigned(8 downto 0);
signal pwm_engine1_pulse_width: unsigned(15 downto 0);
signal pwm_engine1_cs: unsigned(15 downto 0);
signal pwm_engine1_dither_cntr: unsigned(7 downto 0);
signal pwm_engine1_pwm: std_logic;
signal pwm_engine1_main_cntr: unsigned(7 downto 0);
signal pwm_hotbox_temp: unsigned(8 downto 0);
signal pwm_hotbox_pulse_width: unsigned(15 downto 0);
signal pwm_hotbox_cs: unsigned(15 downto 0);
signal pwm_hotbox_dither_cntr: unsigned(7 downto 0);
signal pwm_hotbox_pwm: std_logic;
signal pwm_hotbox_main_cntr: unsigned(7 downto 0);
signal pwm_warmbox_temp: unsigned(8 downto 0);
signal pwm_warmbox_pulse_width: unsigned(15 downto 0);
signal pwm_warmbox_cs: unsigned(15 downto 0);
signal pwm_warmbox_dither_cntr: unsigned(7 downto 0);
signal pwm_warmbox_pwm: std_logic;
signal pwm_warmbox_main_cntr: unsigned(7 downto 0);
signal pwm_laser4_temp: unsigned(8 downto 0);
signal pwm_laser4_pulse_width: unsigned(15 downto 0);
signal pwm_laser4_cs: unsigned(15 downto 0);
signal pwm_laser4_dither_cntr: unsigned(7 downto 0);
signal pwm_laser4_pwm: std_logic;
signal pwm_laser4_main_cntr: unsigned(7 downto 0);
signal pwm_laser3_temp: unsigned(8 downto 0);
signal pwm_laser3_pulse_width: unsigned(15 downto 0);
signal pwm_laser3_cs: unsigned(15 downto 0);
signal pwm_laser3_dither_cntr: unsigned(7 downto 0);
signal pwm_laser3_pwm: std_logic;
signal pwm_laser3_main_cntr: unsigned(7 downto 0);
signal pwm_laser2_temp: unsigned(8 downto 0);
signal pwm_laser2_pulse_width: unsigned(15 downto 0);
signal pwm_laser2_cs: unsigned(15 downto 0);
signal pwm_laser2_dither_cntr: unsigned(7 downto 0);
signal pwm_laser2_pwm: std_logic;
signal pwm_laser2_main_cntr: unsigned(7 downto 0);
signal pwm_laser1_temp: unsigned(8 downto 0);
signal pwm_laser1_pulse_width: unsigned(15 downto 0);
signal pwm_laser1_cs: unsigned(15 downto 0);
signal pwm_laser1_dither_cntr: unsigned(7 downto 0);
signal pwm_laser1_pwm: std_logic;
signal pwm_laser1_main_cntr: unsigned(7 downto 0);
signal laserlocker_ref1_offset: unsigned(15 downto 0);
signal laserlocker_fine_current: unsigned(15 downto 0);
signal laserlocker_div_num: unsigned(15 downto 0);
signal laserlocker_sat: signed (17 downto 0);
signal laserlocker_div_quot: unsigned(15 downto 0);
signal laserlocker_cs: unsigned(15 downto 0);
signal laserlocker_ratio1: unsigned(15 downto 0);
signal laserlocker_ratio2: unsigned(15 downto 0);
signal laserlocker_ratio2_multiplier: unsigned(15 downto 0);
signal laserlocker_ref1_dark: unsigned(15 downto 0);
signal laserlocker_prev_lock_error_deriv: unsigned(15 downto 0);
signal laserlocker_div_ce: std_logic;
signal laserlocker_deriv: unsigned(15 downto 0);
signal laserlocker_eta2_dark: unsigned(15 downto 0);
signal laserlocker_prbs_augment: std_logic;
signal laserlocker_awaiting_strobe: std_logic;
signal laserlocker_ratio1_center: unsigned(15 downto 0);
signal laserlocker_cycle_counter: unsigned(15 downto 0);
signal laserlocker_ratio2_center: unsigned(15 downto 0);
signal laserlocker_wm_deriv_gain: unsigned(15 downto 0);
signal laserlocker_prev_lock_error: unsigned(15 downto 0);
signal laserlocker_ref2: unsigned(15 downto 0);
signal laserlocker_eta2_offset: unsigned(15 downto 0);
signal laserlocker_mult_p: unsigned(15 downto 0);
signal laserlocker_eta1_dark: unsigned(15 downto 0);
signal laserlocker_ref1: unsigned(15 downto 0);
signal laserlocker_div_den: unsigned(15 downto 0);
signal laserlocker_ratio1_multiplier: unsigned(15 downto 0);
signal laserlocker_lock_error: unsigned(15 downto 0);
signal laserlocker_mult_a: unsigned(15 downto 0);
signal laserlocker_wm_prop_gain: unsigned(15 downto 0);
signal laserlocker_mult_b: unsigned(15 downto 0);
signal laserlocker_ref2_dark: unsigned(15 downto 0);
signal laserlocker_mult_o: std_logic;
signal laserlocker_eta1_offset: unsigned(15 downto 0);
signal laserlocker_eta1: unsigned(15 downto 0);
signal laserlocker_ref2_offset: unsigned(15 downto 0);
signal laserlocker_prbs_reg: unsigned(7 downto 0);
signal laserlocker_eta2: unsigned(15 downto 0);
signal laserlocker_tuning_offset: unsigned(15 downto 0);
signal laserlocker_div_rfd: std_logic;
signal laserlocker_wm_lock_window: unsigned(15 downto 0);
signal laserlocker_deriv2: unsigned(15 downto 0);
signal laserlocker_options: unsigned(4 downto 0);
signal laserlocker_wm_int_gain: unsigned(15 downto 0);
signal laserlocker_signedMultiplier_a_s: signed (17 downto 0);
signal laserlocker_signedMultiplier_p_s: signed (35 downto 0);
signal laserlocker_signedMultiplier_b_s: signed (17 downto 0);
signal laserlocker_divider_Nreg: unsigned(16 downto 0);
signal laserlocker_divider_i: unsigned(3 downto 0);
signal laserlocker_divider_Qreg: unsigned(15 downto 0);
signal laserlocker_divider_done: std_logic;
signal laserlocker_divider_rfd: std_logic;
signal laserlocker_divider_Dreg: unsigned(15 downto 0);
signal kernel_control: unsigned(15 downto 0);
signal kernel_intronix_clksel: unsigned(4 downto 0);
signal kernel_intronix_1: unsigned(7 downto 0);
signal kernel_intronix_2: unsigned(7 downto 0);
signal kernel_overload: unsigned(15 downto 0);
signal kernel_dout_hi: unsigned(7 downto 0);
signal kernel_dout_lo: unsigned(31 downto 0);
signal kernel_config: unsigned(15 downto 0);
signal kernel_intronix_3: unsigned(7 downto 0);
signal kernel_din: unsigned(23 downto 0);
signal kernel_sel_detector_mode: unsigned(3 downto 0);
signal kernel_fan: unsigned(15 downto 0);
signal kernel_status_led: unsigned(15 downto 0);
signal kernel_diag_1: unsigned(7 downto 0);
signal inject_extra_enable: std_logic;
signal inject_laser3_extra_fine_scale: unsigned(15 downto 0);
signal inject_last_sel: unsigned(1 downto 0);
signal inject_laser4_fine_current: unsigned(15 downto 0);
signal inject_laser1_fine: unsigned(15 downto 0);
signal inject_extinguish_deselected: std_logic;
signal inject_laser4_coarse_current: unsigned(15 downto 0);
signal inject_optSwitchState: t_enum_OptSwitchState_12;
signal inject_sw4_4way: std_logic;
signal inject_cs_mult_p: unsigned(33 downto 0);
signal inject_disable_soa_with_laser_mask: unsigned(3 downto 0);
signal inject_laser1_fine_current: unsigned(15 downto 0);
signal inject_manual_laser_en: unsigned(3 downto 0);
signal inject_laser3_coarse_current: unsigned(15 downto 0);
signal inject_control2: unsigned(15 downto 0);
signal inject_mode: std_logic;
signal inject_laser4_fine_current_range: unsigned(15 downto 0);
signal inject_sel: unsigned(1 downto 0);
signal inject_pulse_counter: unsigned(6 downto 0);
signal inject_edge_strobe: std_logic;
signal inject_laser2_extra_offset: unsigned(15 downto 0);
signal inject_laser1_coarse_current: unsigned(15 downto 0);
signal inject_sw2_2way: std_logic;
signal inject_laser1_coarse: unsigned(15 downto 0);
signal inject_laser3_extra_offset: unsigned(15 downto 0);
signal inject_extra_mode: std_logic;
signal inject_optical_switch_counter: unsigned(6 downto 0);
signal inject_laser2_extra_coarse_scale: unsigned(15 downto 0);
signal inject_use_extra: std_logic;
signal inject_laser3_fine: unsigned(15 downto 0);
signal inject_laser3_fine_current: unsigned(15 downto 0);
signal inject_strobe_prev: std_logic;
signal inject_laser2_extra_fine_scale: unsigned(15 downto 0);
signal inject_extra_current_counter: unsigned(3 downto 0);
signal inject_laser3_extra_coarse_scale: unsigned(15 downto 0);
signal inject_laser3_coarse: unsigned(15 downto 0);
signal inject_laser3_fine_current_range: unsigned(15 downto 0);
signal inject_fs_mult_p: unsigned(33 downto 0);
signal inject_fs_mult_b: unsigned(16 downto 0);
signal inject_fs_mult_a: unsigned(16 downto 0);
signal inject_control: unsigned(15 downto 0);
signal inject_laser2_coarse: unsigned(15 downto 0);
signal inject_sw1_2way: std_logic;
signal inject_laser_current_en: unsigned(3 downto 0);
signal inject_soa_present: std_logic;
signal inject_laser4_extra_coarse_scale: unsigned(15 downto 0);
signal inject_laser_shutdown_en: std_logic;
signal inject_laser1_extra_fine_scale: unsigned(15 downto 0);
signal inject_cs_mult_b: unsigned(16 downto 0);
signal inject_dac_strobe: std_logic;
signal inject_laser4_coarse_scaled: unsigned(15 downto 0);
signal inject_laser2_coarse_current: unsigned(15 downto 0);
signal inject_laser2_fine_current_range: unsigned(15 downto 0);
signal inject_laser2_fine_current: unsigned(15 downto 0);
signal inject_soa_shutdown_en: std_logic;
signal inject_laser1_extra_coarse_scale: unsigned(15 downto 0);
signal inject_laser3_coarse_scaled: unsigned(15 downto 0);
signal inject_manual_soa_en: std_logic;
signal inject_laser2_coarse_scaled: unsigned(15 downto 0);
signal inject_laser4_extra_offset: unsigned(15 downto 0);
signal inject_switchPulserState: t_enum_SwitchPulserState_13;
signal inject_use_extra_r: std_logic;
signal inject_laser4_coarse: unsigned(15 downto 0);
signal inject_cs_mult_a: unsigned(16 downto 0);
signal inject_extended_mode: std_logic;
signal inject_laser4_extra_fine_scale: unsigned(15 downto 0);
signal inject_laser2_fine: unsigned(15 downto 0);
signal inject_laser1_coarse_scaled: unsigned(15 downto 0);
signal inject_laser4_fine: unsigned(15 downto 0);
signal inject_laser1_fine_current_range: unsigned(15 downto 0);
signal inject_laser1_extra_offset: unsigned(15 downto 0);
signal inject_laser4_dac_counter: unsigned(5 downto 0);
signal inject_laser4_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser4_dac_state: t_enum_t_State_11;
signal inject_laser4_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser3_dac_counter: unsigned(5 downto 0);
signal inject_laser3_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser3_dac_state: t_enum_t_State_11;
signal inject_laser3_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser2_dac_counter: unsigned(5 downto 0);
signal inject_laser2_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser2_dac_state: t_enum_t_State_11;
signal inject_laser2_dac_chanB_data: unsigned(15 downto 0);
signal inject_laser1_dac_counter: unsigned(5 downto 0);
signal inject_laser1_dac_chanA_data: unsigned(15 downto 0);
signal inject_laser1_dac_state: t_enum_t_State_11;
signal inject_laser1_dac_chanB_data: unsigned(15 downto 0);
signal inject_fine_scale_multiplier_a_s: signed (17 downto 0);
signal inject_fine_scale_multiplier_b_s: signed (17 downto 0);
signal inject_fine_scale_multiplier_p_s: signed (35 downto 0);
signal inject_coarse_scale_multiplier_a_s: signed (17 downto 0);
signal inject_coarse_scale_multiplier_b_s: signed (17 downto 0);
signal inject_coarse_scale_multiplier_p_s: signed (35 downto 0);
signal clkgen_div1M: unsigned(2 downto 0);
signal clkgen_ff2: std_logic;
signal clkgen_ff1: std_logic;
signal clkgen_div5: unsigned(2 downto 0);
signal clkgen_div25: unsigned(4 downto 0);
signal dsp_interface_done_wr_d: std_logic;
signal dsp_interface_done_wr: std_logic;
signal dsp_interface_done_rd_d: std_logic;
signal dsp_interface_ce_h: std_logic;
signal dsp_interface_done_rd: std_logic;
signal dsp_interface_we_h: std_logic;
signal dsp_interface_re_h: std_logic;

begin


rdsim_value <= to_unsigned(0, 16);
laser2_fine_ext <= to_unsigned(0, 16);
laser1_fine_ext <= to_unsigned(0, 16);
eta2 <= to_unsigned(0, 16);
laser4_fine_ext <= to_unsigned(0, 16);
ext_laser_sequence_id <= to_unsigned(0, 16);
eta1 <= to_unsigned(0, 16);
ext_laser_level_counter <= to_unsigned(0, 16);
ext_laser_current_in_window <= '0';
laser3_fine_ext <= to_unsigned(0, 16);
ref1 <= to_unsigned(0, 16);
ref2 <= to_unsigned(0, 16);



MAIN_DYNAMICPWMOUTLET_COMB: process (dynamicPwmOutlet_cs, dynamicPwmOutlet_dither_cntr, dynamicPwmOutlet_pwm, dynamicPwmOutlet_pulse_width) is
begin
    if bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_ENABLE_B)) then
        outlet_valve_pwm <= dynamicPwmOutlet_pwm;
    else
        outlet_valve_pwm <= '0';
    end if;
    dynamicPwmOutlet_temp <= (resize(dynamicPwmOutlet_dither_cntr, 9) + resize(dynamicPwmOutlet_pulse_width(dither_width-1 downto 0), 9));
end process MAIN_DYNAMICPWMOUTLET_COMB;


MAIN_DYNAMICPWMOUTLET_LOGIC: process (clk0, reset) is
    variable value: unsigned(23 downto 0);
begin
    if bool(reset) then
        dynamicPwmOutlet_cs <= to_unsigned(0, 16);
        dynamicPwmOutlet_delta <= to_signed(0, 16);
        dynamicPwmOutlet_high <= to_unsigned(0, 16);
        dynamicPwmOutlet_low <= to_unsigned(0, 16);
        dynamicPwmOutlet_slope <= to_unsigned(0, 16);
        dynamicPwmOutlet_pulse_width <= to_unsigned(32768, 16);
        dynamicPwmOutlet_main_cntr <= to_unsigned(0, 8);
        dynamicPwmOutlet_dither_cntr <= to_unsigned(0, 8);
        dynamicPwmOutlet_acc((FPGA_REG_WIDTH + extra)-1 downto 0) <= to_unsigned(0, 24);
        dynamicPwmOutlet_up <= '0';
        dynamicPwmOutlet_extra0 <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_cs_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_cs <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(dynamicPwmOutlet_cs, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_delta_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_delta <= resize(signed(dsp_data_out), 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(unsigned(dynamicPwmOutlet_delta(FPGA_REG_WIDTH-1 downto 0)), 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_high_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_high <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(dynamicPwmOutlet_high, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_low_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_low <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(dynamicPwmOutlet_low, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = dynamicpwm_slope_addr) then
                    if bool(dsp_wr) then
                        dynamicPwmOutlet_slope <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_outlet <= resize(dynamicPwmOutlet_slope, 32);
                else
                    dsp_data_in_dynamicpwm_outlet <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_dynamicpwm_outlet <= to_unsigned(0, 32);
        end if;
        if bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_RUN_B)) then
            if (not bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_CONT_B))) then
                dynamicPwmOutlet_cs(DYNAMICPWM_CS_RUN_B) <= '0';
            end if;
            value := resize(dynamicPwmOutlet_acc((FPGA_REG_WIDTH + extra)-1 downto extra), 24);
            if bool(pulse_100k) then
                if bool(dynamicPwmOutlet_up) then
                    if ((dynamicPwmOutlet_acc + dynamicPwmOutlet_slope) > unsigned'(dynamicPwmOutlet_high & dynamicPwmOutlet_extra0)) then
                        dynamicPwmOutlet_acc <= unsigned'(dynamicPwmOutlet_high & dynamicPwmOutlet_extra0);
                        dynamicPwmOutlet_up <= '0';
                    else
                        dynamicPwmOutlet_acc <= (dynamicPwmOutlet_acc + dynamicPwmOutlet_slope);
                    end if;
                else
                    if ((signed(resize(dynamicPwmOutlet_acc, 25)) - signed(resize(dynamicPwmOutlet_slope, 17))) < signed(resize(unsigned'(dynamicPwmOutlet_low & dynamicPwmOutlet_extra0), 25))) then
                        dynamicPwmOutlet_acc <= unsigned'(dynamicPwmOutlet_low & dynamicPwmOutlet_extra0);
                        dynamicPwmOutlet_up <= '1';
                    else
                        dynamicPwmOutlet_acc <= (dynamicPwmOutlet_acc - dynamicPwmOutlet_slope);
                    end if;
                end if;
                if bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_USE_COMPARATOR_B)) then
                    if (dynamicPwmOutlet_delta > 0) then
                        if bool(outlet_valve_comparator) then
                            if ((signed(resize(dynamicPwmOutlet_pulse_width, 17)) + dynamicPwmOutlet_delta) < MAX_WIDTH) then
                                dynamicPwmOutlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmOutlet_pulse_width, 17)) + dynamicPwmOutlet_delta), 16);
                            else
                                dynamicPwmOutlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
                            end if;
                        else
                            if ((signed(resize(dynamicPwmOutlet_pulse_width, 17)) - dynamicPwmOutlet_delta) > MIN_WIDTH) then
                                dynamicPwmOutlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmOutlet_pulse_width, 17)) - dynamicPwmOutlet_delta), 16);
                            else
                                dynamicPwmOutlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
                            end if;
                        end if;
                    else
                        if bool(outlet_valve_comparator) then
                            if ((signed(resize(dynamicPwmOutlet_pulse_width, 17)) + dynamicPwmOutlet_delta) > MIN_WIDTH) then
                                dynamicPwmOutlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmOutlet_pulse_width, 17)) + dynamicPwmOutlet_delta), 16);
                            else
                                dynamicPwmOutlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
                            end if;
                        else
                            if ((signed(resize(dynamicPwmOutlet_pulse_width, 17)) - dynamicPwmOutlet_delta) < MAX_WIDTH) then
                                dynamicPwmOutlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmOutlet_pulse_width, 17)) - dynamicPwmOutlet_delta), 16);
                            else
                                dynamicPwmOutlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
                            end if;
                        end if;
                    end if;
                else
                    dynamicPwmOutlet_pulse_width <= resize(value, 16);
                end if;
            end if;
            if (dynamicPwmOutlet_acc > unsigned'(dynamicPwmOutlet_high & dynamicPwmOutlet_extra0)) then
                dynamicPwmOutlet_acc <= unsigned'(dynamicPwmOutlet_high & dynamicPwmOutlet_extra0);
            end if;
            if (dynamicPwmOutlet_acc < unsigned'(dynamicPwmOutlet_low & dynamicPwmOutlet_extra0)) then
                dynamicPwmOutlet_acc <= unsigned'(dynamicPwmOutlet_low & dynamicPwmOutlet_extra0);
            end if;
            if (dynamicPwmOutlet_pulse_width > MAX_WIDTH) then
                dynamicPwmOutlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
            end if;
            if (dynamicPwmOutlet_pulse_width < MIN_WIDTH) then
                dynamicPwmOutlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
            end if;
            dynamicPwmOutlet_pwm <= dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_INVERT_B);
            if (dynamicPwmOutlet_main_cntr < dynamicPwmOutlet_pulse_width(width-1 downto (width - main_width))) then
                dynamicPwmOutlet_pwm <= stdl((not bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_INVERT_B))));
            elsif (dynamicPwmOutlet_main_cntr = dynamicPwmOutlet_pulse_width(width-1 downto dither_width)) then
                if (dynamicPwmOutlet_temp >= mod_dither) then
                    dynamicPwmOutlet_pwm <= stdl((not bool(dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_INVERT_B))));
                    dynamicPwmOutlet_dither_cntr <= resize(dynamicPwmOutlet_temp - mod_dither, 8);
                else
                    dynamicPwmOutlet_dither_cntr <= resize(dynamicPwmOutlet_temp, 8);
                end if;
            end if;
            dynamicPwmOutlet_main_cntr <= ((dynamicPwmOutlet_main_cntr + 1) mod mod_main);
            outlet_valve_dac <= resize(value, 16);
        end if;
        dynamicPwmOutlet_cs(DYNAMICPWM_CS_PWM_OUT_B) <= dynamicPwmOutlet_pwm;
    end if;
end process MAIN_DYNAMICPWMOUTLET_LOGIC;


MAIN_WLMADCREADER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        wlmadcreader_counter <= to_unsigned(ADC_CYCLE, 5);
        eta1_actual <= to_unsigned(0, 16);
        ref1_actual <= to_unsigned(0, 16);
        eta2_actual <= to_unsigned(0, 16);
        ref2_actual <= to_unsigned(0, 16);
        wlmadcreader_state <= IDLE;
    elsif rising_edge(clk0) then
        data_available_actual <= '0';
        case wlmadcreader_state is
            when IDLE =>
                wlmadcreader_counter <= to_unsigned(ADC_CYCLE, 5);
                wlmadcreader_eta1 <= to_unsigned(0, 16);
                wlmadcreader_ref1 <= to_unsigned(0, 16);
                wlmadcreader_eta2 <= to_unsigned(0, 16);
                wlmadcreader_ref2 <= to_unsigned(0, 16);
                if bool(pulse_100k) then
                    wlmadcreader_counter <= to_unsigned(0, 5);
                    wlmadcreader_state <= WAIT_1;
                end if;
            when WAIT_0 =>
                if (not bool(clk_2M5)) then
                    if ((wlmadcreader_counter >= ADC_START_CYCLE) and (wlmadcreader_counter <= ADC_LAST_CYCLE)) then
                        wlmadcreader_eta1((ADC_LAST_CYCLE - to_integer(wlmadcreader_counter))) <= wmm_refl1;
                        wlmadcreader_ref1((ADC_LAST_CYCLE - to_integer(wlmadcreader_counter))) <= wmm_tran1;
                        wlmadcreader_eta2((ADC_LAST_CYCLE - to_integer(wlmadcreader_counter))) <= wmm_refl2;
                        wlmadcreader_ref2((ADC_LAST_CYCLE - to_integer(wlmadcreader_counter))) <= wmm_tran2;
                    end if;
                    if (signed(resize(wlmadcreader_counter, 6)) = (ADC_CYCLE - 1)) then
                        data_available_actual <= '1';
                    end if;
                    wlmadcreader_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_2M5) then
                    if (signed(resize(wlmadcreader_counter, 6)) = (ADC_CYCLE - 2)) then
                        eta1_actual((ADC_DATA_WIDTH - 1)) <= stdl((not bool(wlmadcreader_eta1((ADC_DATA_WIDTH - 1)))));
                        ref1_actual((ADC_DATA_WIDTH - 1)) <= stdl((not bool(wlmadcreader_ref1((ADC_DATA_WIDTH - 1)))));
                        eta2_actual((ADC_DATA_WIDTH - 1)) <= stdl((not bool(wlmadcreader_eta2((ADC_DATA_WIDTH - 1)))));
                        ref2_actual((ADC_DATA_WIDTH - 1)) <= stdl((not bool(wlmadcreader_ref2((ADC_DATA_WIDTH - 1)))));
                        eta1_actual((ADC_DATA_WIDTH - 1)-1 downto 0) <= wlmadcreader_eta1((ADC_DATA_WIDTH - 1)-1 downto 0);
                        ref1_actual((ADC_DATA_WIDTH - 1)-1 downto 0) <= wlmadcreader_ref1((ADC_DATA_WIDTH - 1)-1 downto 0);
                        eta2_actual((ADC_DATA_WIDTH - 1)-1 downto 0) <= wlmadcreader_eta2((ADC_DATA_WIDTH - 1)-1 downto 0);
                        ref2_actual((ADC_DATA_WIDTH - 1)-1 downto 0) <= wlmadcreader_ref2((ADC_DATA_WIDTH - 1)-1 downto 0);
                    end if;
                    if (wlmadcreader_counter < ADC_CYCLE) then
                        wlmadcreader_counter <= (wlmadcreader_counter + 1);
                        wlmadcreader_state <= WAIT_0;
                    else
                        wlmadcreader_state <= IDLE;
                    end if;
                end if;
            when others =>
                wlmadcreader_state <= IDLE;
        end case;
        wmm_rd_out <= stdl(wlmadcreader_counter = 1);
        wmm_convst <= stdl(wlmadcreader_counter = 1);
    end if;
end process MAIN_WLMADCREADER_LOGIC;



signed_mult18x18_4 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => scaler_mult_a_s, B => scaler_mult_b_s, P => scaler_mult_p_s
    );


MAIN_SCALER_MULT_COMB: process (scaler_a, scaler_b, scaler_mult_p_s) is
begin
    scaler_mult_a_s(17-1 downto 0) <= signed(scaler_a);
    scaler_mult_a_s(17) <= '0';
    scaler_mult_b_s(17-1 downto 0) <= signed(scaler_b);
    scaler_mult_b_s(17) <= '0';
    scaler_p <= unsigned(scaler_mult_p_s(34-1 downto 0));
end process MAIN_SCALER_MULT_COMB;


MAIN_SCALER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        scaler_scale1 <= to_unsigned(40000, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = scaler_scale1_addr) then
                    if bool(dsp_wr) then
                        scaler_scale1 <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_scaler <= resize(scaler_scale1, 32);
                else
                    dsp_data_in_scaler <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_scaler <= to_unsigned(0, 32);
        end if;
        scaler_a <= unsigned'(pzt & to_unsigned(0, 1));
        scaler_b <= unsigned'(scaler_scale1 & to_unsigned(0, 1));
        pzt_scaled <= scaler_p(34-1 downto 18);
    end if;
end process MAIN_SCALER_LOGIC;



heater_pwm_out <= pwm_heater_pwm;
heater_pwm_inv <= (pwm_heater_pwm xor pwm_heater_cs(PWM_CS_CONT_B));
pwm_heater_temp <= (resize(pwm_heater_dither_cntr, 9) + resize(pwm_heater_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_HEATER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_heater_cs <= to_unsigned(0, 16);
        pwm_heater_pulse_width <= to_unsigned(0, 16);
        pwm_heater_main_cntr <= to_unsigned(0, 8);
        pwm_heater_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = pwm_cs_addr) then
                if bool(dsp_wr) then
                    pwm_heater_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_heater <= resize(pwm_heater_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = pwm_pulse_width_addr) then
                if bool(dsp_wr) then
                    pwm_heater_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_heater <= resize(pwm_heater_pulse_width, 32);
            else
                dsp_data_in_pwm_heater <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_heater <= to_unsigned(0, 32);
        end if;
        if bool(pwm_heater_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_heater_cs(PWM_CS_CONT_B))) then
                pwm_heater_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_heater_pwm <= '0';
            if (pwm_heater_main_cntr < pwm_heater_pulse_width(width-1 downto (width - main_width))) then
                pwm_heater_pwm <= '1';
            elsif (pwm_heater_main_cntr = pwm_heater_pulse_width(width-1 downto dither_width)) then
                if (pwm_heater_temp >= mod_dither) then
                    pwm_heater_pwm <= '1';
                    pwm_heater_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_heater_dither_cntr <= resize(pwm_heater_temp - mod_dither, 8);
                else
                    pwm_heater_dither_cntr <= resize(pwm_heater_temp, 8);
                end if;
            end if;
            pwm_heater_main_cntr <= ((pwm_heater_main_cntr + 1) mod mod_main);
        end if;
        pwm_heater_cs(PWM_CS_PWM_OUT_B) <= pwm_heater_pwm;
    end if;
end process MAIN_PWM_HEATER_LOGIC;


MAIN_SGDBRCURRENTSOURCEC_LOGIC: process (clk0, reset) is
    variable b: natural;
    variable w: natural;
begin
    if bool(reset) then
        sgdbrCurrentSourceC_csr <= to_unsigned(0, 16);
        sgdbrCurrentSourceC_miso_delay <= to_unsigned(0, 4);
        sgdbrCurrentSourceC_mosi_data <= to_unsigned(0, 32);
        sgdbrCurrentSourceC_miso_data <= to_unsigned(0, 32);
        sgdbrCurrentSourceC_sync_register <= to_unsigned(0, 5);
        sgdbrCurrentSourceC_max_sync_current <= to_unsigned(0, 16);
        sgdbrCurrentSourceC_clock_counter <= to_unsigned(0, 6);
        sgdbrCurrentSourceC_sck_divider <= to_unsigned(0, 6);
        sgdbrCurrentSourceC_sck_active <= '0';
        sgdbrCurrentSourceC_sck_phase <= '0';
        sgdbrCurrentSourceC_data_clk <= '0';
        sgdbrCurrentSourceC_spi_active <= '0';
        sgdbrCurrentSourceC_csn <= '1';
        sgdbrCurrentSourceC_miso_buff_b <= to_unsigned(0, 32);
        sgdbr_c_done <= '0';
        sgdbrCurrentSourceC_delay_sr_a <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrcurrentsource_csr_addr) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceC_csr <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrcurrentsource_c <= resize(sgdbrCurrentSourceC_csr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrcurrentsource_miso_delay_addr) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceC_miso_delay <= resize(dsp_data_out, 4);
                end if;
                dsp_data_in_sgdbrcurrentsource_c <= resize(sgdbrCurrentSourceC_miso_delay, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrcurrentsource_mosi_data_addr) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceC_mosi_data <= dsp_data_out;
                    sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '0';
                    sgdbr_c_done <= '0';
                    if (bool(sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B)) and (not bool(sgdbrCurrentSourceC_ok_to_transfer))) then
                        sgdbrCurrentSourceC_access_type <= PENDING;
                        sgdbrCurrentSourceC_transfer_pending <= '1';
                    elsif (not bool(sgdbrCurrentSourceC_spi_active)) then
                        sgdbrCurrentSourceC_access_type <= NORMAL;
                        sgdbrCurrentSourceC_mosi_buff <= dsp_data_out;
                        sgdbrCurrentSourceC_spi_active <= '1';
                        sgdbrCurrentSourceC_sck_phase <= '0';
                        sgdbrCurrentSourceC_extra_active <= '0';
                        sgdbrCurrentSourceC_miso_data <= to_unsigned(0, 32);
                        sgdbrCurrentSourceC_sck_divider <= to_unsigned(0, 6);
                    end if;
                end if;
                dsp_data_in_sgdbrcurrentsource_c <= sgdbrCurrentSourceC_mosi_data;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrcurrentsource_miso_data_addr) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceC_miso_data <= dsp_data_out;
                end if;
                dsp_data_in_sgdbrcurrentsource_c <= sgdbrCurrentSourceC_miso_data;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrcurrentsource_sync_register_addr) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceC_sync_register <= resize(dsp_data_out, 5);
                end if;
                dsp_data_in_sgdbrcurrentsource_c <= resize(sgdbrCurrentSourceC_sync_register, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrcurrentsource_max_sync_current_addr) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceC_max_sync_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrcurrentsource_c <= resize(sgdbrCurrentSourceC_max_sync_current, 32);
            else
                dsp_data_in_sgdbrcurrentsource_c <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_sgdbrcurrentsource_c <= to_unsigned(0, 32);
        end if;
        sgdbrCurrentSourceC_sync_strobe_prev <= sgdbr_c_sync_strobe_in;
        sgdbrCurrentSourceC_edge_strobe <= stdl(bool(sgdbr_c_sync_strobe_in) and (not bool(sgdbrCurrentSourceC_sync_strobe_prev)));
        if bool(sgdbrCurrentSourceC_edge_strobe) then
            sgdbrCurrentSourceC_sync_counter <= to_unsigned(0, 10);
        else
            sgdbrCurrentSourceC_sync_counter <= (sgdbrCurrentSourceC_sync_counter + 1);
        end if;
        if (bool(sgdbrCurrentSourceC_transfer_pending) and bool(sgdbrCurrentSourceC_ok_to_transfer) and (not bool(sgdbrCurrentSourceC_spi_active))) then
            sgdbrCurrentSourceC_access_type <= PENDING;
            sgdbrCurrentSourceC_transfer_pending <= '0';
            sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '0';
            sgdbr_c_done <= '0';
            sgdbrCurrentSourceC_mosi_buff <= sgdbrCurrentSourceC_mosi_data;
            sgdbrCurrentSourceC_spi_active <= '1';
            sgdbrCurrentSourceC_sck_phase <= '0';
            sgdbrCurrentSourceC_extra_active <= '0';
            sgdbrCurrentSourceC_sck_divider <= to_unsigned(0, 6);
        end if;
        if (bool(sgdbrCurrentSourceC_edge_strobe) and bool(sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B)) and (not bool(sgdbrCurrentSourceC_spi_active))) then
            sgdbrCurrentSourceC_access_type <= SYNC_UPDATE;
            sgdbrCurrentSourceC_mosi_buff <= to_unsigned(0, 32);
            if (sync_current_in < sgdbrCurrentSourceC_max_sync_current) then
                sgdbrCurrentSourceC_mosi_buff(16-1 downto 0) <= sync_current_in;
            else
                sgdbrCurrentSourceC_mosi_buff(16-1 downto 0) <= sgdbrCurrentSourceC_max_sync_current;
            end if;
            if bool(sgdbrCurrentSourceC_sync_register(SGDBRCURRENTSOURCE_SYNC_REGISTER_SOURCE_B)) then
                b := SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_B;
                w := SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_W;
                sgdbrCurrentSourceC_mosi_buff(27-1 downto 24) <= resize(sgdbrCurrentSourceC_sync_register((b + w)-1 downto b), 3);
            else
                sgdbrCurrentSourceC_mosi_buff(27-1 downto 24) <= resize(sgdbr_c_sync_register, 3);
            end if;
            sgdbrCurrentSourceC_spi_active <= '1';
            sgdbrCurrentSourceC_sck_phase <= '0';
            sgdbrCurrentSourceC_extra_active <= '0';
            sgdbrCurrentSourceC_sck_divider <= to_unsigned(0, 6);
        end if;
        sgdbrCurrentSourceC_delay_sr_a <= sgdbrCurrentSourceC_delay_sr_b;
        if bool(sgdbrCurrentSourceC_delay_sr_b(to_integer(sgdbrCurrentSourceC_miso_delay(4-1 downto 1)))) then
            sgdbrCurrentSourceC_miso_buff_b(32-1 downto 1) <= sgdbrCurrentSourceC_miso_buff_b((32 - 1)-1 downto 0);
            sgdbrCurrentSourceC_miso_buff_b(0) <= sgdbr_c_miso;
        end if;
        sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_MISO_B) <= sgdbr_c_miso;
        if bool(sgdbrCurrentSourceC_spi_active) then
            if ((sgdbrCurrentSourceC_sck_divider + 1) < sck_divisor) then
                sgdbrCurrentSourceC_sck_divider <= (sgdbrCurrentSourceC_sck_divider + 1);
            else
                sgdbrCurrentSourceC_sck_divider <= to_unsigned(0, 6);
                sgdbrCurrentSourceC_sck_phase <= stdl((not bool(sgdbrCurrentSourceC_sck_phase)));
                if bool(sgdbrCurrentSourceC_sck_phase) then
                    if (sgdbrCurrentSourceC_clock_counter < num_of_clock_pulses) then
                        sgdbrCurrentSourceC_clock_counter <= (sgdbrCurrentSourceC_clock_counter + 1);
                    else
                        sgdbrCurrentSourceC_clock_counter <= to_unsigned(0, 6);
                        sgdbrCurrentSourceC_spi_active <= '0';
                        if (sgdbrCurrentSourceC_access_type /= SYNC_UPDATE) then
                            sgdbrCurrentSourceC_extra_active <= '1';
                            sgdbrCurrentSourceC_extra_counter <= to_unsigned(0, 3);
                        end if;
                    end if;
                end if;
            end if;
            if (sgdbrCurrentSourceC_sck_divider = 0) then
                sgdbrCurrentSourceC_data_clk <= stdl(bool(sgdbrCurrentSourceC_sck_phase) and bool(sgdbrCurrentSourceC_sck_active));
                if (sgdbrCurrentSourceC_clock_counter < num_of_clock_pulses) then
                    if (sgdbrCurrentSourceC_sck_phase = sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)) then
                        sgdbr_c_mosi <= sgdbrCurrentSourceC_mosi_buff(to_integer((num_of_clock_pulses - signed(resize(sgdbrCurrentSourceC_clock_counter, 7))) - 1));
                    end if;
                end if;
                if (sgdbrCurrentSourceC_clock_counter = 0) then
                    if (not bool(sgdbrCurrentSourceC_sck_phase)) then
                        sgdbrCurrentSourceC_csn <= '0';
                        sgdbrCurrentSourceC_sck_active <= '1';
                    end if;
                elsif (sgdbrCurrentSourceC_clock_counter = num_of_clock_pulses) then
                    if (not bool(sgdbrCurrentSourceC_sck_phase)) then
                        sgdbrCurrentSourceC_sck_active <= '0';
                    else
                        sgdbrCurrentSourceC_csn <= '1';
                    end if;
                end if;
            end if;
        end if;
        if bool(sgdbrCurrentSourceC_extra_active) then
            if (sgdbrCurrentSourceC_extra_counter = sgdbrCurrentSourceC_miso_delay(4-1 downto 1)) then
                sgdbrCurrentSourceC_extra_active <= '0';
                sgdbrCurrentSourceC_extra_counter <= to_unsigned(0, 3);
                if (not bool(sgdbrCurrentSourceC_transfer_pending)) then
                    sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '1';
                    sgdbr_c_done <= '1';
                end if;
                if bool(sgdbrCurrentSourceC_miso_delay(0)) then
                    sgdbrCurrentSourceC_miso_data <= sgdbrCurrentSourceC_miso_buff_a(num_of_clock_pulses-1 downto 0);
                else
                    sgdbrCurrentSourceC_miso_data <= sgdbrCurrentSourceC_miso_buff_b(num_of_clock_pulses-1 downto 0);
                end if;
            else
                sgdbrCurrentSourceC_extra_counter <= (sgdbrCurrentSourceC_extra_counter + 1);
            end if;
        end if;
    end if;
end process MAIN_SGDBRCURRENTSOURCEC_LOGIC;



sgdbr_c_sck <= stdl(sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_CPOL_B) /= sgdbrCurrentSourceC_data_clk);
sgdbr_c_csn <= stdl((bool(sgdbrCurrentSourceC_csn) and (not bool(sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_SELECT_B)))) or bool(sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_DESELECT_B)));
sgdbr_c_resetn <= stdl((not bool(sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_RESET_B))));
sgdbrCurrentSourceC_miso_shift <= stdl(bool(sgdbrCurrentSourceC_spi_active) and (sgdbrCurrentSourceC_sck_divider = 0) and (((sgdbrCurrentSourceC_clock_counter < num_of_clock_pulses) and bool(sgdbrCurrentSourceC_sck_phase) and (not bool(sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)))) or ((sgdbrCurrentSourceC_clock_counter > 0) and (not bool(sgdbrCurrentSourceC_sck_phase)) and bool(sgdbrCurrentSourceC_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)))));
sgdbrCurrentSourceC_ok_to_transfer <= stdl((sgdbrCurrentSourceC_sync_counter >= min_sync_counter_for_transfer) and (sgdbrCurrentSourceC_sync_counter <= max_sync_counter_for_transfer));


MAIN_SGDBRCURRENTSOURCEC_HALF_STEPS: process (clk0, reset) is
begin
    if bool(reset) then
        sgdbrCurrentSourceC_delay_sr_b <= to_unsigned(0, 8);
        sgdbrCurrentSourceC_miso_buff_a <= to_unsigned(0, 32);
    elsif falling_edge(clk0) then
        sgdbrCurrentSourceC_delay_sr_b(0) <= sgdbrCurrentSourceC_miso_shift;
        sgdbrCurrentSourceC_delay_sr_b(8-1 downto 1) <= sgdbrCurrentSourceC_delay_sr_a(((max_delay / 2) - 1)-1 downto 0);
        if bool(sgdbrCurrentSourceC_delay_sr_a(to_integer(sgdbrCurrentSourceC_miso_delay(4-1 downto 1)))) then
            sgdbrCurrentSourceC_miso_buff_a(32-1 downto 1) <= sgdbrCurrentSourceC_miso_buff_a((32 - 1)-1 downto 0);
            sgdbrCurrentSourceC_miso_buff_a(0) <= sgdbr_c_miso;
        end if;
    end if;
end process MAIN_SGDBRCURRENTSOURCEC_HALF_STEPS;


MAIN_SGDBRCURRENTSOURCEB_LOGIC: process (clk0, reset) is
    variable b: natural;
    variable w: natural;
begin
    if bool(reset) then
        sgdbrCurrentSourceB_csr <= to_unsigned(0, 16);
        sgdbrCurrentSourceB_miso_delay <= to_unsigned(0, 4);
        sgdbrCurrentSourceB_mosi_data <= to_unsigned(0, 32);
        sgdbrCurrentSourceB_miso_data <= to_unsigned(0, 32);
        sgdbrCurrentSourceB_sync_register <= to_unsigned(0, 5);
        sgdbrCurrentSourceB_max_sync_current <= to_unsigned(0, 16);
        sgdbrCurrentSourceB_clock_counter <= to_unsigned(0, 6);
        sgdbrCurrentSourceB_sck_divider <= to_unsigned(0, 6);
        sgdbrCurrentSourceB_sck_active <= '0';
        sgdbrCurrentSourceB_sck_phase <= '0';
        sgdbrCurrentSourceB_data_clk <= '0';
        sgdbrCurrentSourceB_spi_active <= '0';
        sgdbrCurrentSourceB_csn <= '1';
        sgdbrCurrentSourceB_miso_buff_b <= to_unsigned(0, 32);
        sgdbr_b_done <= '0';
        sgdbrCurrentSourceB_delay_sr_a <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 177) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceB_csr <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrcurrentsource_b <= resize(sgdbrCurrentSourceB_csr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 178) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceB_miso_delay <= resize(dsp_data_out, 4);
                end if;
                dsp_data_in_sgdbrcurrentsource_b <= resize(sgdbrCurrentSourceB_miso_delay, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 179) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceB_mosi_data <= dsp_data_out;
                    sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '0';
                    sgdbr_b_done <= '0';
                    if (bool(sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B)) and (not bool(sgdbrCurrentSourceB_ok_to_transfer))) then
                        sgdbrCurrentSourceB_access_type <= PENDING;
                        sgdbrCurrentSourceB_transfer_pending <= '1';
                    elsif (not bool(sgdbrCurrentSourceB_spi_active)) then
                        sgdbrCurrentSourceB_access_type <= NORMAL;
                        sgdbrCurrentSourceB_mosi_buff <= dsp_data_out;
                        sgdbrCurrentSourceB_spi_active <= '1';
                        sgdbrCurrentSourceB_sck_phase <= '0';
                        sgdbrCurrentSourceB_extra_active <= '0';
                        sgdbrCurrentSourceB_miso_data <= to_unsigned(0, 32);
                        sgdbrCurrentSourceB_sck_divider <= to_unsigned(0, 6);
                    end if;
                end if;
                dsp_data_in_sgdbrcurrentsource_b <= sgdbrCurrentSourceB_mosi_data;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 180) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceB_miso_data <= dsp_data_out;
                end if;
                dsp_data_in_sgdbrcurrentsource_b <= sgdbrCurrentSourceB_miso_data;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 181) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceB_sync_register <= resize(dsp_data_out, 5);
                end if;
                dsp_data_in_sgdbrcurrentsource_b <= resize(sgdbrCurrentSourceB_sync_register, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 182) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceB_max_sync_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrcurrentsource_b <= resize(sgdbrCurrentSourceB_max_sync_current, 32);
            else
                dsp_data_in_sgdbrcurrentsource_b <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_sgdbrcurrentsource_b <= to_unsigned(0, 32);
        end if;
        sgdbrCurrentSourceB_sync_strobe_prev <= sgdbr_b_sync_strobe_in;
        sgdbrCurrentSourceB_edge_strobe <= stdl(bool(sgdbr_b_sync_strobe_in) and (not bool(sgdbrCurrentSourceB_sync_strobe_prev)));
        if bool(sgdbrCurrentSourceB_edge_strobe) then
            sgdbrCurrentSourceB_sync_counter <= to_unsigned(0, 10);
        else
            sgdbrCurrentSourceB_sync_counter <= (sgdbrCurrentSourceB_sync_counter + 1);
        end if;
        if (bool(sgdbrCurrentSourceB_transfer_pending) and bool(sgdbrCurrentSourceB_ok_to_transfer) and (not bool(sgdbrCurrentSourceB_spi_active))) then
            sgdbrCurrentSourceB_access_type <= PENDING;
            sgdbrCurrentSourceB_transfer_pending <= '0';
            sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '0';
            sgdbr_b_done <= '0';
            sgdbrCurrentSourceB_mosi_buff <= sgdbrCurrentSourceB_mosi_data;
            sgdbrCurrentSourceB_spi_active <= '1';
            sgdbrCurrentSourceB_sck_phase <= '0';
            sgdbrCurrentSourceB_extra_active <= '0';
            sgdbrCurrentSourceB_sck_divider <= to_unsigned(0, 6);
        end if;
        if (bool(sgdbrCurrentSourceB_edge_strobe) and bool(sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B)) and (not bool(sgdbrCurrentSourceB_spi_active))) then
            sgdbrCurrentSourceB_access_type <= SYNC_UPDATE;
            sgdbrCurrentSourceB_mosi_buff <= to_unsigned(0, 32);
            if (sync_current_in < sgdbrCurrentSourceB_max_sync_current) then
                sgdbrCurrentSourceB_mosi_buff(16-1 downto 0) <= sync_current_in;
            else
                sgdbrCurrentSourceB_mosi_buff(16-1 downto 0) <= sgdbrCurrentSourceB_max_sync_current;
            end if;
            if bool(sgdbrCurrentSourceB_sync_register(SGDBRCURRENTSOURCE_SYNC_REGISTER_SOURCE_B)) then
                b := SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_B;
                w := SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_W;
                sgdbrCurrentSourceB_mosi_buff(27-1 downto 24) <= resize(sgdbrCurrentSourceB_sync_register((b + w)-1 downto b), 3);
            else
                sgdbrCurrentSourceB_mosi_buff(27-1 downto 24) <= resize(sgdbr_b_sync_register, 3);
            end if;
            sgdbrCurrentSourceB_spi_active <= '1';
            sgdbrCurrentSourceB_sck_phase <= '0';
            sgdbrCurrentSourceB_extra_active <= '0';
            sgdbrCurrentSourceB_sck_divider <= to_unsigned(0, 6);
        end if;
        sgdbrCurrentSourceB_delay_sr_a <= sgdbrCurrentSourceB_delay_sr_b;
        if bool(sgdbrCurrentSourceB_delay_sr_b(to_integer(sgdbrCurrentSourceB_miso_delay(4-1 downto 1)))) then
            sgdbrCurrentSourceB_miso_buff_b(32-1 downto 1) <= sgdbrCurrentSourceB_miso_buff_b((32 - 1)-1 downto 0);
            sgdbrCurrentSourceB_miso_buff_b(0) <= sgdbr_b_miso;
        end if;
        sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_MISO_B) <= sgdbr_b_miso;
        if bool(sgdbrCurrentSourceB_spi_active) then
            if ((sgdbrCurrentSourceB_sck_divider + 1) < sck_divisor) then
                sgdbrCurrentSourceB_sck_divider <= (sgdbrCurrentSourceB_sck_divider + 1);
            else
                sgdbrCurrentSourceB_sck_divider <= to_unsigned(0, 6);
                sgdbrCurrentSourceB_sck_phase <= stdl((not bool(sgdbrCurrentSourceB_sck_phase)));
                if bool(sgdbrCurrentSourceB_sck_phase) then
                    if (sgdbrCurrentSourceB_clock_counter < num_of_clock_pulses) then
                        sgdbrCurrentSourceB_clock_counter <= (sgdbrCurrentSourceB_clock_counter + 1);
                    else
                        sgdbrCurrentSourceB_clock_counter <= to_unsigned(0, 6);
                        sgdbrCurrentSourceB_spi_active <= '0';
                        if (sgdbrCurrentSourceB_access_type /= SYNC_UPDATE) then
                            sgdbrCurrentSourceB_extra_active <= '1';
                            sgdbrCurrentSourceB_extra_counter <= to_unsigned(0, 3);
                        end if;
                    end if;
                end if;
            end if;
            if (sgdbrCurrentSourceB_sck_divider = 0) then
                sgdbrCurrentSourceB_data_clk <= stdl(bool(sgdbrCurrentSourceB_sck_phase) and bool(sgdbrCurrentSourceB_sck_active));
                if (sgdbrCurrentSourceB_clock_counter < num_of_clock_pulses) then
                    if (sgdbrCurrentSourceB_sck_phase = sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)) then
                        sgdbr_b_mosi <= sgdbrCurrentSourceB_mosi_buff(to_integer((num_of_clock_pulses - signed(resize(sgdbrCurrentSourceB_clock_counter, 7))) - 1));
                    end if;
                end if;
                if (sgdbrCurrentSourceB_clock_counter = 0) then
                    if (not bool(sgdbrCurrentSourceB_sck_phase)) then
                        sgdbrCurrentSourceB_csn <= '0';
                        sgdbrCurrentSourceB_sck_active <= '1';
                    end if;
                elsif (sgdbrCurrentSourceB_clock_counter = num_of_clock_pulses) then
                    if (not bool(sgdbrCurrentSourceB_sck_phase)) then
                        sgdbrCurrentSourceB_sck_active <= '0';
                    else
                        sgdbrCurrentSourceB_csn <= '1';
                    end if;
                end if;
            end if;
        end if;
        if bool(sgdbrCurrentSourceB_extra_active) then
            if (sgdbrCurrentSourceB_extra_counter = sgdbrCurrentSourceB_miso_delay(4-1 downto 1)) then
                sgdbrCurrentSourceB_extra_active <= '0';
                sgdbrCurrentSourceB_extra_counter <= to_unsigned(0, 3);
                if (not bool(sgdbrCurrentSourceB_transfer_pending)) then
                    sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '1';
                    sgdbr_b_done <= '1';
                end if;
                if bool(sgdbrCurrentSourceB_miso_delay(0)) then
                    sgdbrCurrentSourceB_miso_data <= sgdbrCurrentSourceB_miso_buff_a(num_of_clock_pulses-1 downto 0);
                else
                    sgdbrCurrentSourceB_miso_data <= sgdbrCurrentSourceB_miso_buff_b(num_of_clock_pulses-1 downto 0);
                end if;
            else
                sgdbrCurrentSourceB_extra_counter <= (sgdbrCurrentSourceB_extra_counter + 1);
            end if;
        end if;
    end if;
end process MAIN_SGDBRCURRENTSOURCEB_LOGIC;



sgdbr_b_sck <= stdl(sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_CPOL_B) /= sgdbrCurrentSourceB_data_clk);
sgdbr_b_csn <= stdl((bool(sgdbrCurrentSourceB_csn) and (not bool(sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_SELECT_B)))) or bool(sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_DESELECT_B)));
sgdbr_b_resetn <= stdl((not bool(sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_RESET_B))));
sgdbrCurrentSourceB_miso_shift <= stdl(bool(sgdbrCurrentSourceB_spi_active) and (sgdbrCurrentSourceB_sck_divider = 0) and (((sgdbrCurrentSourceB_clock_counter < num_of_clock_pulses) and bool(sgdbrCurrentSourceB_sck_phase) and (not bool(sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)))) or ((sgdbrCurrentSourceB_clock_counter > 0) and (not bool(sgdbrCurrentSourceB_sck_phase)) and bool(sgdbrCurrentSourceB_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)))));
sgdbrCurrentSourceB_ok_to_transfer <= stdl((sgdbrCurrentSourceB_sync_counter >= min_sync_counter_for_transfer) and (sgdbrCurrentSourceB_sync_counter <= max_sync_counter_for_transfer));


MAIN_SGDBRCURRENTSOURCEB_HALF_STEPS: process (clk0, reset) is
begin
    if bool(reset) then
        sgdbrCurrentSourceB_delay_sr_b <= to_unsigned(0, 8);
        sgdbrCurrentSourceB_miso_buff_a <= to_unsigned(0, 32);
    elsif falling_edge(clk0) then
        sgdbrCurrentSourceB_delay_sr_b(0) <= sgdbrCurrentSourceB_miso_shift;
        sgdbrCurrentSourceB_delay_sr_b(8-1 downto 1) <= sgdbrCurrentSourceB_delay_sr_a(((max_delay / 2) - 1)-1 downto 0);
        if bool(sgdbrCurrentSourceB_delay_sr_a(to_integer(sgdbrCurrentSourceB_miso_delay(4-1 downto 1)))) then
            sgdbrCurrentSourceB_miso_buff_a(32-1 downto 1) <= sgdbrCurrentSourceB_miso_buff_a((32 - 1)-1 downto 0);
            sgdbrCurrentSourceB_miso_buff_a(0) <= sgdbr_b_miso;
        end if;
    end if;
end process MAIN_SGDBRCURRENTSOURCEB_HALF_STEPS;


MAIN_SGDBRCURRENTSOURCED_LOGIC: process (clk0, reset) is
    variable b: natural;
    variable w: natural;
begin
    if bool(reset) then
        sgdbrCurrentSourceD_csr <= to_unsigned(0, 16);
        sgdbrCurrentSourceD_miso_delay <= to_unsigned(0, 4);
        sgdbrCurrentSourceD_mosi_data <= to_unsigned(0, 32);
        sgdbrCurrentSourceD_miso_data <= to_unsigned(0, 32);
        sgdbrCurrentSourceD_sync_register <= to_unsigned(0, 5);
        sgdbrCurrentSourceD_max_sync_current <= to_unsigned(0, 16);
        sgdbrCurrentSourceD_clock_counter <= to_unsigned(0, 6);
        sgdbrCurrentSourceD_sck_divider <= to_unsigned(0, 6);
        sgdbrCurrentSourceD_sck_active <= '0';
        sgdbrCurrentSourceD_sck_phase <= '0';
        sgdbrCurrentSourceD_data_clk <= '0';
        sgdbrCurrentSourceD_spi_active <= '0';
        sgdbrCurrentSourceD_csn <= '1';
        sgdbrCurrentSourceD_miso_buff_b <= to_unsigned(0, 32);
        sgdbr_d_done <= '0';
        sgdbrCurrentSourceD_delay_sr_a <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 189) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceD_csr <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrcurrentsource_d <= resize(sgdbrCurrentSourceD_csr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 190) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceD_miso_delay <= resize(dsp_data_out, 4);
                end if;
                dsp_data_in_sgdbrcurrentsource_d <= resize(sgdbrCurrentSourceD_miso_delay, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 191) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceD_mosi_data <= dsp_data_out;
                    sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '0';
                    sgdbr_d_done <= '0';
                    if (bool(sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B)) and (not bool(sgdbrCurrentSourceD_ok_to_transfer))) then
                        sgdbrCurrentSourceD_access_type <= PENDING;
                        sgdbrCurrentSourceD_transfer_pending <= '1';
                    elsif (not bool(sgdbrCurrentSourceD_spi_active)) then
                        sgdbrCurrentSourceD_access_type <= NORMAL;
                        sgdbrCurrentSourceD_mosi_buff <= dsp_data_out;
                        sgdbrCurrentSourceD_spi_active <= '1';
                        sgdbrCurrentSourceD_sck_phase <= '0';
                        sgdbrCurrentSourceD_extra_active <= '0';
                        sgdbrCurrentSourceD_miso_data <= to_unsigned(0, 32);
                        sgdbrCurrentSourceD_sck_divider <= to_unsigned(0, 6);
                    end if;
                end if;
                dsp_data_in_sgdbrcurrentsource_d <= sgdbrCurrentSourceD_mosi_data;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 192) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceD_miso_data <= dsp_data_out;
                end if;
                dsp_data_in_sgdbrcurrentsource_d <= sgdbrCurrentSourceD_miso_data;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 193) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceD_sync_register <= resize(dsp_data_out, 5);
                end if;
                dsp_data_in_sgdbrcurrentsource_d <= resize(sgdbrCurrentSourceD_sync_register, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 194) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceD_max_sync_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrcurrentsource_d <= resize(sgdbrCurrentSourceD_max_sync_current, 32);
            else
                dsp_data_in_sgdbrcurrentsource_d <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_sgdbrcurrentsource_d <= to_unsigned(0, 32);
        end if;
        sgdbrCurrentSourceD_sync_strobe_prev <= sgdbr_d_sync_strobe_in;
        sgdbrCurrentSourceD_edge_strobe <= stdl(bool(sgdbr_d_sync_strobe_in) and (not bool(sgdbrCurrentSourceD_sync_strobe_prev)));
        if bool(sgdbrCurrentSourceD_edge_strobe) then
            sgdbrCurrentSourceD_sync_counter <= to_unsigned(0, 10);
        else
            sgdbrCurrentSourceD_sync_counter <= (sgdbrCurrentSourceD_sync_counter + 1);
        end if;
        if (bool(sgdbrCurrentSourceD_transfer_pending) and bool(sgdbrCurrentSourceD_ok_to_transfer) and (not bool(sgdbrCurrentSourceD_spi_active))) then
            sgdbrCurrentSourceD_access_type <= PENDING;
            sgdbrCurrentSourceD_transfer_pending <= '0';
            sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '0';
            sgdbr_d_done <= '0';
            sgdbrCurrentSourceD_mosi_buff <= sgdbrCurrentSourceD_mosi_data;
            sgdbrCurrentSourceD_spi_active <= '1';
            sgdbrCurrentSourceD_sck_phase <= '0';
            sgdbrCurrentSourceD_extra_active <= '0';
            sgdbrCurrentSourceD_sck_divider <= to_unsigned(0, 6);
        end if;
        if (bool(sgdbrCurrentSourceD_edge_strobe) and bool(sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B)) and (not bool(sgdbrCurrentSourceD_spi_active))) then
            sgdbrCurrentSourceD_access_type <= SYNC_UPDATE;
            sgdbrCurrentSourceD_mosi_buff <= to_unsigned(0, 32);
            if (sync_current_in < sgdbrCurrentSourceD_max_sync_current) then
                sgdbrCurrentSourceD_mosi_buff(16-1 downto 0) <= sync_current_in;
            else
                sgdbrCurrentSourceD_mosi_buff(16-1 downto 0) <= sgdbrCurrentSourceD_max_sync_current;
            end if;
            if bool(sgdbrCurrentSourceD_sync_register(SGDBRCURRENTSOURCE_SYNC_REGISTER_SOURCE_B)) then
                b := SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_B;
                w := SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_W;
                sgdbrCurrentSourceD_mosi_buff(27-1 downto 24) <= resize(sgdbrCurrentSourceD_sync_register((b + w)-1 downto b), 3);
            else
                sgdbrCurrentSourceD_mosi_buff(27-1 downto 24) <= resize(sgdbr_d_sync_register, 3);
            end if;
            sgdbrCurrentSourceD_spi_active <= '1';
            sgdbrCurrentSourceD_sck_phase <= '0';
            sgdbrCurrentSourceD_extra_active <= '0';
            sgdbrCurrentSourceD_sck_divider <= to_unsigned(0, 6);
        end if;
        sgdbrCurrentSourceD_delay_sr_a <= sgdbrCurrentSourceD_delay_sr_b;
        if bool(sgdbrCurrentSourceD_delay_sr_b(to_integer(sgdbrCurrentSourceD_miso_delay(4-1 downto 1)))) then
            sgdbrCurrentSourceD_miso_buff_b(32-1 downto 1) <= sgdbrCurrentSourceD_miso_buff_b((32 - 1)-1 downto 0);
            sgdbrCurrentSourceD_miso_buff_b(0) <= sgdbr_d_miso;
        end if;
        sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_MISO_B) <= sgdbr_d_miso;
        if bool(sgdbrCurrentSourceD_spi_active) then
            if ((sgdbrCurrentSourceD_sck_divider + 1) < sck_divisor) then
                sgdbrCurrentSourceD_sck_divider <= (sgdbrCurrentSourceD_sck_divider + 1);
            else
                sgdbrCurrentSourceD_sck_divider <= to_unsigned(0, 6);
                sgdbrCurrentSourceD_sck_phase <= stdl((not bool(sgdbrCurrentSourceD_sck_phase)));
                if bool(sgdbrCurrentSourceD_sck_phase) then
                    if (sgdbrCurrentSourceD_clock_counter < num_of_clock_pulses) then
                        sgdbrCurrentSourceD_clock_counter <= (sgdbrCurrentSourceD_clock_counter + 1);
                    else
                        sgdbrCurrentSourceD_clock_counter <= to_unsigned(0, 6);
                        sgdbrCurrentSourceD_spi_active <= '0';
                        if (sgdbrCurrentSourceD_access_type /= SYNC_UPDATE) then
                            sgdbrCurrentSourceD_extra_active <= '1';
                            sgdbrCurrentSourceD_extra_counter <= to_unsigned(0, 3);
                        end if;
                    end if;
                end if;
            end if;
            if (sgdbrCurrentSourceD_sck_divider = 0) then
                sgdbrCurrentSourceD_data_clk <= stdl(bool(sgdbrCurrentSourceD_sck_phase) and bool(sgdbrCurrentSourceD_sck_active));
                if (sgdbrCurrentSourceD_clock_counter < num_of_clock_pulses) then
                    if (sgdbrCurrentSourceD_sck_phase = sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)) then
                        sgdbr_d_mosi <= sgdbrCurrentSourceD_mosi_buff(to_integer((num_of_clock_pulses - signed(resize(sgdbrCurrentSourceD_clock_counter, 7))) - 1));
                    end if;
                end if;
                if (sgdbrCurrentSourceD_clock_counter = 0) then
                    if (not bool(sgdbrCurrentSourceD_sck_phase)) then
                        sgdbrCurrentSourceD_csn <= '0';
                        sgdbrCurrentSourceD_sck_active <= '1';
                    end if;
                elsif (sgdbrCurrentSourceD_clock_counter = num_of_clock_pulses) then
                    if (not bool(sgdbrCurrentSourceD_sck_phase)) then
                        sgdbrCurrentSourceD_sck_active <= '0';
                    else
                        sgdbrCurrentSourceD_csn <= '1';
                    end if;
                end if;
            end if;
        end if;
        if bool(sgdbrCurrentSourceD_extra_active) then
            if (sgdbrCurrentSourceD_extra_counter = sgdbrCurrentSourceD_miso_delay(4-1 downto 1)) then
                sgdbrCurrentSourceD_extra_active <= '0';
                sgdbrCurrentSourceD_extra_counter <= to_unsigned(0, 3);
                if (not bool(sgdbrCurrentSourceD_transfer_pending)) then
                    sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '1';
                    sgdbr_d_done <= '1';
                end if;
                if bool(sgdbrCurrentSourceD_miso_delay(0)) then
                    sgdbrCurrentSourceD_miso_data <= sgdbrCurrentSourceD_miso_buff_a(num_of_clock_pulses-1 downto 0);
                else
                    sgdbrCurrentSourceD_miso_data <= sgdbrCurrentSourceD_miso_buff_b(num_of_clock_pulses-1 downto 0);
                end if;
            else
                sgdbrCurrentSourceD_extra_counter <= (sgdbrCurrentSourceD_extra_counter + 1);
            end if;
        end if;
    end if;
end process MAIN_SGDBRCURRENTSOURCED_LOGIC;



sgdbr_d_sck <= stdl(sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_CPOL_B) /= sgdbrCurrentSourceD_data_clk);
sgdbr_d_csn <= stdl((bool(sgdbrCurrentSourceD_csn) and (not bool(sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_SELECT_B)))) or bool(sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_DESELECT_B)));
sgdbr_d_resetn <= stdl((not bool(sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_RESET_B))));
sgdbrCurrentSourceD_miso_shift <= stdl(bool(sgdbrCurrentSourceD_spi_active) and (sgdbrCurrentSourceD_sck_divider = 0) and (((sgdbrCurrentSourceD_clock_counter < num_of_clock_pulses) and bool(sgdbrCurrentSourceD_sck_phase) and (not bool(sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)))) or ((sgdbrCurrentSourceD_clock_counter > 0) and (not bool(sgdbrCurrentSourceD_sck_phase)) and bool(sgdbrCurrentSourceD_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)))));
sgdbrCurrentSourceD_ok_to_transfer <= stdl((sgdbrCurrentSourceD_sync_counter >= min_sync_counter_for_transfer) and (sgdbrCurrentSourceD_sync_counter <= max_sync_counter_for_transfer));


MAIN_SGDBRCURRENTSOURCED_HALF_STEPS: process (clk0, reset) is
begin
    if bool(reset) then
        sgdbrCurrentSourceD_delay_sr_b <= to_unsigned(0, 8);
        sgdbrCurrentSourceD_miso_buff_a <= to_unsigned(0, 32);
    elsif falling_edge(clk0) then
        sgdbrCurrentSourceD_delay_sr_b(0) <= sgdbrCurrentSourceD_miso_shift;
        sgdbrCurrentSourceD_delay_sr_b(8-1 downto 1) <= sgdbrCurrentSourceD_delay_sr_a(((max_delay / 2) - 1)-1 downto 0);
        if bool(sgdbrCurrentSourceD_delay_sr_a(to_integer(sgdbrCurrentSourceD_miso_delay(4-1 downto 1)))) then
            sgdbrCurrentSourceD_miso_buff_a(32-1 downto 1) <= sgdbrCurrentSourceD_miso_buff_a((32 - 1)-1 downto 0);
            sgdbrCurrentSourceD_miso_buff_a(0) <= sgdbr_d_miso;
        end if;
    end if;
end process MAIN_SGDBRCURRENTSOURCED_HALF_STEPS;


MAIN_CLKGEN_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        clk_10M <= '0';
        clkgen_div5 <= to_unsigned(0, 3);
        clkgen_div25 <= to_unsigned(0, 5);
        clkgen_ff1 <= '0';
        clkgen_ff2 <= '0';
    elsif rising_edge(clk0) then
        pulse_100k <= '0';
        pulse_1M <= '0';
        if (clkgen_div5 = 4) then
            clkgen_div5 <= to_unsigned(0, 3);
            clkgen_ff1 <= stdl((not bool(clkgen_ff1)));
            if bool(clkgen_ff1) then
                if (clkgen_div1M = 4) then
                    clkgen_div1M <= to_unsigned(0, 3);
                    pulse_1M <= '1';
                else
                    clkgen_div1M <= (clkgen_div1M + 1);
                end if;
                clkgen_ff2 <= stdl((not bool(clkgen_ff2)));
                if bool(clkgen_ff2) then
                    if (clkgen_div25 = 24) then
                        clkgen_div25 <= to_unsigned(0, 5);
                        pulse_100k <= '1';
                    else
                        clkgen_div25 <= (clkgen_div25 + 1);
                    end if;
                end if;
            end if;
        else
            clkgen_div5 <= (clkgen_div5 + 1);
        end if;
        clk_10M <= stdl((clkgen_div5 = 2) or (clkgen_div5 = 3));
    end if;
end process MAIN_CLKGEN_LOGIC;



clk_5M <= clkgen_ff1;
clk_2M5 <= clkgen_ff2;



warm_box_pwm_out <= pwm_warmbox_pwm;
warm_box_pwm_inv <= (pwm_warmbox_pwm xor pwm_warmbox_cs(PWM_CS_CONT_B));
pwm_warmbox_temp <= (resize(pwm_warmbox_dither_cntr, 9) + resize(pwm_warmbox_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_WARMBOX_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_warmbox_cs <= to_unsigned(0, 16);
        pwm_warmbox_pulse_width <= to_unsigned(0, 16);
        pwm_warmbox_main_cntr <= to_unsigned(0, 8);
        pwm_warmbox_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 23) then
                if bool(dsp_wr) then
                    pwm_warmbox_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_warmbox <= resize(pwm_warmbox_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 24) then
                if bool(dsp_wr) then
                    pwm_warmbox_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_warmbox <= resize(pwm_warmbox_pulse_width, 32);
            else
                dsp_data_in_pwm_warmbox <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_warmbox <= to_unsigned(0, 32);
        end if;
        if bool(pwm_warmbox_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_warmbox_cs(PWM_CS_CONT_B))) then
                pwm_warmbox_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_warmbox_pwm <= '0';
            if (pwm_warmbox_main_cntr < pwm_warmbox_pulse_width(width-1 downto (width - main_width))) then
                pwm_warmbox_pwm <= '1';
            elsif (pwm_warmbox_main_cntr = pwm_warmbox_pulse_width(width-1 downto dither_width)) then
                if (pwm_warmbox_temp >= mod_dither) then
                    pwm_warmbox_pwm <= '1';
                    pwm_warmbox_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_warmbox_dither_cntr <= resize(pwm_warmbox_temp - mod_dither, 8);
                else
                    pwm_warmbox_dither_cntr <= resize(pwm_warmbox_temp, 8);
                end if;
            end if;
            pwm_warmbox_main_cntr <= ((pwm_warmbox_main_cntr + 1) mod mod_main);
        end if;
        pwm_warmbox_cs(PWM_CS_PWM_OUT_B) <= pwm_warmbox_pwm;
    end if;
end process MAIN_PWM_WARMBOX_LOGIC;


MAIN_AUXPZTDAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        auxPztDac_chanD_data <= to_unsigned(0, 16);
        auxPztDac_dac_ld <= '1';
    elsif rising_edge(clk0) then
        case auxPztDac_state is
            when IDLE =>
                if bool(pulse_100k) then
                    auxPztDac_chanD_data <= laser_fine_current;
                    auxPztDac_counter <= to_unsigned(0, 5);
                    auxPztDac_dac_ld <= '0';
                    auxPztDac_state <= WAIT_0;
                end if;
            when WAIT_0 =>
                if (not bool(clk_2M5)) then
                    if (signed(resize(auxPztDac_counter, 6)) < (CHAND_DATA_END - 1)) then
                        auxPztDac_counter <= (auxPztDac_counter + 1);
                        auxPztDac_state <= WAIT_1;
                    else
                        auxPztDac_dac_ld <= '1';
                        auxPztDac_state <= IDLE;
                    end if;
                end if;
            when WAIT_1 =>
                if bool(clk_2M5) then
                    auxPztDac_dac_ld <= '0';
                    auxPztDac_state <= WAIT_0;
                end if;
            when others =>
                auxPztDac_state <= IDLE;
        end case;
        aux_pzt_dac_sdi <= auxPztDac_dac_sdi;
        aux_pzt_dac_ld <= auxPztDac_dac_ld;
        aux_pzt_dac_sck <= clk_2M5;
    end if;
end process MAIN_AUXPZTDAC_LOGIC;


MAIN_AUXPZTDAC_COMB2: process (auxPztDac_chanD_data, auxPztDac_counter) is
begin
    auxPztDac_dac_sdi <= '1';
    if ((CHAND_CONTROL_START <= auxPztDac_counter) and (auxPztDac_counter < CHAND_CONTROL_END)) then
        case ((CHAND_CONTROL_END - 1) - to_integer(auxPztDac_counter)) is
            when 0 => auxPztDac_dac_sdi <= '1';
            when 1 => auxPztDac_dac_sdi <= '1';
            when 2 => auxPztDac_dac_sdi <= '0';
            when 3 => auxPztDac_dac_sdi <= '0';
            when 4 => auxPztDac_dac_sdi <= '1';
            when 5 => auxPztDac_dac_sdi <= '1';
            when 6 => auxPztDac_dac_sdi <= '0';
            when others => auxPztDac_dac_sdi <= '0';
        end case;
    elsif ((CHAND_DATA_START <= auxPztDac_counter) and (auxPztDac_counter < CHAND_DATA_END)) then
        auxPztDac_dac_sdi <= auxPztDac_chanD_data(((CHAND_DATA_END - 1) - to_integer(auxPztDac_counter)));
    else
        auxPztDac_dac_sdi <= '0';
    end if;
end process MAIN_AUXPZTDAC_COMB2;


MAIN_SGDBRCURRENTSOURCEA_LOGIC: process (clk0, reset) is
    variable b: natural;
    variable w: natural;
begin
    if bool(reset) then
        sgdbrCurrentSourceA_csr <= to_unsigned(0, 16);
        sgdbrCurrentSourceA_miso_delay <= to_unsigned(0, 4);
        sgdbrCurrentSourceA_mosi_data <= to_unsigned(0, 32);
        sgdbrCurrentSourceA_miso_data <= to_unsigned(0, 32);
        sgdbrCurrentSourceA_sync_register <= to_unsigned(0, 5);
        sgdbrCurrentSourceA_max_sync_current <= to_unsigned(0, 16);
        sgdbrCurrentSourceA_clock_counter <= to_unsigned(0, 6);
        sgdbrCurrentSourceA_sck_divider <= to_unsigned(0, 6);
        sgdbrCurrentSourceA_sck_active <= '0';
        sgdbrCurrentSourceA_sck_phase <= '0';
        sgdbrCurrentSourceA_data_clk <= '0';
        sgdbrCurrentSourceA_spi_active <= '0';
        sgdbrCurrentSourceA_csn <= '1';
        sgdbrCurrentSourceA_miso_buff_b <= to_unsigned(0, 32);
        sgdbr_a_done <= '0';
        sgdbrCurrentSourceA_delay_sr_a <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 171) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceA_csr <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrcurrentsource_a <= resize(sgdbrCurrentSourceA_csr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 172) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceA_miso_delay <= resize(dsp_data_out, 4);
                end if;
                dsp_data_in_sgdbrcurrentsource_a <= resize(sgdbrCurrentSourceA_miso_delay, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 173) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceA_mosi_data <= dsp_data_out;
                    sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '0';
                    sgdbr_a_done <= '0';
                    if (bool(sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B)) and (not bool(sgdbrCurrentSourceA_ok_to_transfer))) then
                        sgdbrCurrentSourceA_access_type <= PENDING;
                        sgdbrCurrentSourceA_transfer_pending <= '1';
                    elsif (not bool(sgdbrCurrentSourceA_spi_active)) then
                        sgdbrCurrentSourceA_access_type <= NORMAL;
                        sgdbrCurrentSourceA_mosi_buff <= dsp_data_out;
                        sgdbrCurrentSourceA_spi_active <= '1';
                        sgdbrCurrentSourceA_sck_phase <= '0';
                        sgdbrCurrentSourceA_extra_active <= '0';
                        sgdbrCurrentSourceA_miso_data <= to_unsigned(0, 32);
                        sgdbrCurrentSourceA_sck_divider <= to_unsigned(0, 6);
                    end if;
                end if;
                dsp_data_in_sgdbrcurrentsource_a <= sgdbrCurrentSourceA_mosi_data;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 174) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceA_miso_data <= dsp_data_out;
                end if;
                dsp_data_in_sgdbrcurrentsource_a <= sgdbrCurrentSourceA_miso_data;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 175) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceA_sync_register <= resize(dsp_data_out, 5);
                end if;
                dsp_data_in_sgdbrcurrentsource_a <= resize(sgdbrCurrentSourceA_sync_register, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 176) then
                if bool(dsp_wr) then
                    sgdbrCurrentSourceA_max_sync_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrcurrentsource_a <= resize(sgdbrCurrentSourceA_max_sync_current, 32);
            else
                dsp_data_in_sgdbrcurrentsource_a <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_sgdbrcurrentsource_a <= to_unsigned(0, 32);
        end if;
        sgdbrCurrentSourceA_sync_strobe_prev <= sgdbr_a_sync_strobe_in;
        sgdbrCurrentSourceA_edge_strobe <= stdl(bool(sgdbr_a_sync_strobe_in) and (not bool(sgdbrCurrentSourceA_sync_strobe_prev)));
        if bool(sgdbrCurrentSourceA_edge_strobe) then
            sgdbrCurrentSourceA_sync_counter <= to_unsigned(0, 10);
        else
            sgdbrCurrentSourceA_sync_counter <= (sgdbrCurrentSourceA_sync_counter + 1);
        end if;
        if (bool(sgdbrCurrentSourceA_transfer_pending) and bool(sgdbrCurrentSourceA_ok_to_transfer) and (not bool(sgdbrCurrentSourceA_spi_active))) then
            sgdbrCurrentSourceA_access_type <= PENDING;
            sgdbrCurrentSourceA_transfer_pending <= '0';
            sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '0';
            sgdbr_a_done <= '0';
            sgdbrCurrentSourceA_mosi_buff <= sgdbrCurrentSourceA_mosi_data;
            sgdbrCurrentSourceA_spi_active <= '1';
            sgdbrCurrentSourceA_sck_phase <= '0';
            sgdbrCurrentSourceA_extra_active <= '0';
            sgdbrCurrentSourceA_sck_divider <= to_unsigned(0, 6);
        end if;
        if (bool(sgdbrCurrentSourceA_edge_strobe) and bool(sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_SYNC_UPDATE_B)) and (not bool(sgdbrCurrentSourceA_spi_active))) then
            sgdbrCurrentSourceA_access_type <= SYNC_UPDATE;
            sgdbrCurrentSourceA_mosi_buff <= to_unsigned(0, 32);
            if (sync_current_in < sgdbrCurrentSourceA_max_sync_current) then
                sgdbrCurrentSourceA_mosi_buff(16-1 downto 0) <= sync_current_in;
            else
                sgdbrCurrentSourceA_mosi_buff(16-1 downto 0) <= sgdbrCurrentSourceA_max_sync_current;
            end if;
            if bool(sgdbrCurrentSourceA_sync_register(SGDBRCURRENTSOURCE_SYNC_REGISTER_SOURCE_B)) then
                b := SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_B;
                w := SGDBRCURRENTSOURCE_SYNC_REGISTER_REG_SELECT_W;
                sgdbrCurrentSourceA_mosi_buff(27-1 downto 24) <= resize(sgdbrCurrentSourceA_sync_register((b + w)-1 downto b), 3);
            else
                sgdbrCurrentSourceA_mosi_buff(27-1 downto 24) <= resize(sgdbr_a_sync_register, 3);
            end if;
            sgdbrCurrentSourceA_spi_active <= '1';
            sgdbrCurrentSourceA_sck_phase <= '0';
            sgdbrCurrentSourceA_extra_active <= '0';
            sgdbrCurrentSourceA_sck_divider <= to_unsigned(0, 6);
        end if;
        sgdbrCurrentSourceA_delay_sr_a <= sgdbrCurrentSourceA_delay_sr_b;
        if bool(sgdbrCurrentSourceA_delay_sr_b(to_integer(sgdbrCurrentSourceA_miso_delay(4-1 downto 1)))) then
            sgdbrCurrentSourceA_miso_buff_b(32-1 downto 1) <= sgdbrCurrentSourceA_miso_buff_b((32 - 1)-1 downto 0);
            sgdbrCurrentSourceA_miso_buff_b(0) <= sgdbr_a_miso;
        end if;
        sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_MISO_B) <= sgdbr_a_miso;
        if bool(sgdbrCurrentSourceA_spi_active) then
            if ((sgdbrCurrentSourceA_sck_divider + 1) < sck_divisor) then
                sgdbrCurrentSourceA_sck_divider <= (sgdbrCurrentSourceA_sck_divider + 1);
            else
                sgdbrCurrentSourceA_sck_divider <= to_unsigned(0, 6);
                sgdbrCurrentSourceA_sck_phase <= stdl((not bool(sgdbrCurrentSourceA_sck_phase)));
                if bool(sgdbrCurrentSourceA_sck_phase) then
                    if (sgdbrCurrentSourceA_clock_counter < num_of_clock_pulses) then
                        sgdbrCurrentSourceA_clock_counter <= (sgdbrCurrentSourceA_clock_counter + 1);
                    else
                        sgdbrCurrentSourceA_clock_counter <= to_unsigned(0, 6);
                        sgdbrCurrentSourceA_spi_active <= '0';
                        if (sgdbrCurrentSourceA_access_type /= SYNC_UPDATE) then
                            sgdbrCurrentSourceA_extra_active <= '1';
                            sgdbrCurrentSourceA_extra_counter <= to_unsigned(0, 3);
                        end if;
                    end if;
                end if;
            end if;
            if (sgdbrCurrentSourceA_sck_divider = 0) then
                sgdbrCurrentSourceA_data_clk <= stdl(bool(sgdbrCurrentSourceA_sck_phase) and bool(sgdbrCurrentSourceA_sck_active));
                if (sgdbrCurrentSourceA_clock_counter < num_of_clock_pulses) then
                    if (sgdbrCurrentSourceA_sck_phase = sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)) then
                        sgdbr_a_mosi <= sgdbrCurrentSourceA_mosi_buff(to_integer((num_of_clock_pulses - signed(resize(sgdbrCurrentSourceA_clock_counter, 7))) - 1));
                    end if;
                end if;
                if (sgdbrCurrentSourceA_clock_counter = 0) then
                    if (not bool(sgdbrCurrentSourceA_sck_phase)) then
                        sgdbrCurrentSourceA_csn <= '0';
                        sgdbrCurrentSourceA_sck_active <= '1';
                    end if;
                elsif (sgdbrCurrentSourceA_clock_counter = num_of_clock_pulses) then
                    if (not bool(sgdbrCurrentSourceA_sck_phase)) then
                        sgdbrCurrentSourceA_sck_active <= '0';
                    else
                        sgdbrCurrentSourceA_csn <= '1';
                    end if;
                end if;
            end if;
        end if;
        if bool(sgdbrCurrentSourceA_extra_active) then
            if (sgdbrCurrentSourceA_extra_counter = sgdbrCurrentSourceA_miso_delay(4-1 downto 1)) then
                sgdbrCurrentSourceA_extra_active <= '0';
                sgdbrCurrentSourceA_extra_counter <= to_unsigned(0, 3);
                if (not bool(sgdbrCurrentSourceA_transfer_pending)) then
                    sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_DONE_B) <= '1';
                    sgdbr_a_done <= '1';
                end if;
                if bool(sgdbrCurrentSourceA_miso_delay(0)) then
                    sgdbrCurrentSourceA_miso_data <= sgdbrCurrentSourceA_miso_buff_a(num_of_clock_pulses-1 downto 0);
                else
                    sgdbrCurrentSourceA_miso_data <= sgdbrCurrentSourceA_miso_buff_b(num_of_clock_pulses-1 downto 0);
                end if;
            else
                sgdbrCurrentSourceA_extra_counter <= (sgdbrCurrentSourceA_extra_counter + 1);
            end if;
        end if;
    end if;
end process MAIN_SGDBRCURRENTSOURCEA_LOGIC;



sgdbr_a_sck <= stdl(sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_CPOL_B) /= sgdbrCurrentSourceA_data_clk);
sgdbr_a_csn <= stdl((bool(sgdbrCurrentSourceA_csn) and (not bool(sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_SELECT_B)))) or bool(sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_DESELECT_B)));
sgdbr_a_resetn <= stdl((not bool(sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_RESET_B))));
sgdbrCurrentSourceA_miso_shift <= stdl(bool(sgdbrCurrentSourceA_spi_active) and (sgdbrCurrentSourceA_sck_divider = 0) and (((sgdbrCurrentSourceA_clock_counter < num_of_clock_pulses) and bool(sgdbrCurrentSourceA_sck_phase) and (not bool(sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)))) or ((sgdbrCurrentSourceA_clock_counter > 0) and (not bool(sgdbrCurrentSourceA_sck_phase)) and bool(sgdbrCurrentSourceA_csr(SGDBRCURRENTSOURCE_CSR_CPHA_B)))));
sgdbrCurrentSourceA_ok_to_transfer <= stdl((sgdbrCurrentSourceA_sync_counter >= min_sync_counter_for_transfer) and (sgdbrCurrentSourceA_sync_counter <= max_sync_counter_for_transfer));


MAIN_SGDBRCURRENTSOURCEA_HALF_STEPS: process (clk0, reset) is
begin
    if bool(reset) then
        sgdbrCurrentSourceA_delay_sr_b <= to_unsigned(0, 8);
        sgdbrCurrentSourceA_miso_buff_a <= to_unsigned(0, 32);
    elsif falling_edge(clk0) then
        sgdbrCurrentSourceA_delay_sr_b(0) <= sgdbrCurrentSourceA_miso_shift;
        sgdbrCurrentSourceA_delay_sr_b(8-1 downto 1) <= sgdbrCurrentSourceA_delay_sr_a(((max_delay / 2) - 1)-1 downto 0);
        if bool(sgdbrCurrentSourceA_delay_sr_a(to_integer(sgdbrCurrentSourceA_miso_delay(4-1 downto 1)))) then
            sgdbrCurrentSourceA_miso_buff_a(32-1 downto 1) <= sgdbrCurrentSourceA_miso_buff_a((32 - 1)-1 downto 0);
            sgdbrCurrentSourceA_miso_buff_a(0) <= sgdbr_a_miso;
        end if;
    end if;
end process MAIN_SGDBRCURRENTSOURCEA_HALF_STEPS;


MAIN_RDMAN_COMB1: process (rd_adc, rdman_options, rdsim_value) is
begin
    if bool(rdman_options(RDMAN_OPTIONS_SIM_ACTUAL_B)) then
        rdman_rd_data <= rd_adc;
    else
        rdman_rd_data <= rdsim_value;
    end if;
end process MAIN_RDMAN_COMB1;


MAIN_RDMAN_COMB2: process (rdman_sel_fine_current_slope, ext_laser_current_in_window, extended_current_mode, laser_freq_ok, rdman_rd_data, rdman_laser_extra, tuner_slope, rdman_acq_done_irq, rdman_rd_adc_clk, tuner_in_window, rdman_rd_irq, rdman_rd_trig, rdman_options, rdman_bank) is
begin
    bank <= rdman_bank;
    rd_irq <= rdman_rd_irq;
    acq_done_irq <= rdman_acq_done_irq;
    rd_trig <= rdman_rd_trig;
    laser_extra <= rdman_laser_extra;
    adc_clk <= rdman_rd_adc_clk;
    if bool(extended_current_mode) then
        rdman_tuner_gating_conditions <= stdl(bool(ext_laser_current_in_window) and ((bool(rdman_sel_fine_current_slope) and bool(rdman_options(RDMAN_OPTIONS_UP_SLOPE_ENABLE_B))) or ((not bool(rdman_sel_fine_current_slope)) and bool(rdman_options(RDMAN_OPTIONS_DOWN_SLOPE_ENABLE_B)))));
    else
        rdman_tuner_gating_conditions <= stdl(bool(tuner_in_window) and ((bool(tuner_slope) and bool(rdman_options(RDMAN_OPTIONS_UP_SLOPE_ENABLE_B))) or ((not bool(tuner_slope)) and bool(rdman_options(RDMAN_OPTIONS_DOWN_SLOPE_ENABLE_B)))));
    end if;
    rdman_freq_gating_conditions <= stdl(bool(laser_freq_ok) or (not bool(rdman_options(RDMAN_OPTIONS_LOCK_ENABLE_B))));
    wr_data <= resize(rdman_rd_data, 18);
end process MAIN_RDMAN_COMB2;


MAIN_RDMAN_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        rdman_control <= to_unsigned(0, 16);
        rdman_status <= to_unsigned(0, 16);
        rdman_options <= to_unsigned(0, 16);
        rdman_param0 <= to_unsigned(0, 32);
        rdman_param1 <= to_unsigned(0, 32);
        rdman_param2 <= to_unsigned(0, 32);
        rdman_param3 <= to_unsigned(0, 32);
        rdman_param4 <= to_unsigned(0, 32);
        rdman_param5 <= to_unsigned(0, 32);
        rdman_param6 <= to_unsigned(0, 32);
        rdman_param7 <= to_unsigned(0, 32);
        rdman_param8 <= to_unsigned(0, 32);
        rdman_param9 <= to_unsigned(0, 32);
        rdman_param10 <= to_unsigned(0, 32);
        rdman_param11 <= to_unsigned(0, 32);
        rdman_param12 <= to_unsigned(0, 32);
        rdman_param13 <= to_unsigned(0, 32);
        rdman_param14 <= to_unsigned(0, 32);
        rdman_param15 <= to_unsigned(0, 32);
        rdman_data_addrcntr <= to_unsigned(0, 12);
        rdman_metadata_addrcntr <= to_unsigned(0, 12);
        rdman_param_addrcntr <= to_unsigned(0, 6);
        rdman_divisor <= to_unsigned(0, 16);
        rdman_num_samp <= to_unsigned(0, 12);
        rdman_threshold <= to_unsigned(0, 16);
        rdman_lock_duration <= to_unsigned(0, 16);
        rdman_precontrol_duration <= to_unsigned(0, 16);
        rdman_off_duration <= to_unsigned(0, 16);
        rdman_extra_duration <= to_unsigned(0, 16);
        rdman_timeout_duration <= to_unsigned(0, 32);
        rdman_tuner_at_ringdown <= to_unsigned(0, 16);
        rdman_metadata_addr_at_ringdown <= to_unsigned(0, 16);
        rdman_ringdown_data <= to_unsigned(0, 18);
        rdman_abort <= '0';
        rdman_acq_done_irq <= '0';
        rdman_bank <= '0';
        rdman_expiry_time <= to_unsigned(0, 32);
        rdman_init_flag <= '1';
        rdman_lapped <= '0';
        rdman_metadataAcqState <= IDLE;
        rdman_metadata_acq <= '0';
        rdman_paramState <= IDLE;
        rdman_param_acq <= '0';
        rdman_rd_adc_clk <= '0';
        rdman_rd_divider <= to_unsigned(0, 16);
        rdman_rd_irq <= '0';
        rdman_rd_trig <= '0';
        rdman_seqState <= IDLE;
        rdman_timeout <= '0';
        rdman_us_since_start <= to_unsigned(0, 32);
        rdman_us_timer_enable <= '0';
        acc_en <= '0';
        laser_locked <= '0';
        rdman_div50_counter <= to_unsigned(0, 6);
        rdman_us_after_ringdown <= to_unsigned(0, 17);
        rdman_sel_fine_current <= to_unsigned(0, 16);
        rdman_sel_fine_current_prev <= to_unsigned(0, 16);
        rdman_sel_fine_current_slope <= '0';
        rdman_ext_laser_level_counter <= to_unsigned(0, 16);
        rdman_ext_laser_sequence_id <= to_unsigned(0, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_control_addr) then
                if bool(dsp_wr) then
                    rdman_control <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_control, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_status_addr) then
                dsp_data_in_rdman <= resize(rdman_status, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_options_addr) then
                if bool(dsp_wr) then
                    rdman_options <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_options, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param0_addr) then
                if bool(dsp_wr) then
                    rdman_param0 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param0;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param1_addr) then
                if bool(dsp_wr) then
                    rdman_param1 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param1;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param2_addr) then
                if bool(dsp_wr) then
                    rdman_param2 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param2;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param3_addr) then
                if bool(dsp_wr) then
                    rdman_param3 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param3;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param4_addr) then
                if bool(dsp_wr) then
                    rdman_param4 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param4;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param5_addr) then
                if bool(dsp_wr) then
                    rdman_param5 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param5;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param6_addr) then
                if bool(dsp_wr) then
                    rdman_param6 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param6;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param7_addr) then
                if bool(dsp_wr) then
                    rdman_param7 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param7;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param8_addr) then
                if bool(dsp_wr) then
                    rdman_param8 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param8;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param9_addr) then
                if bool(dsp_wr) then
                    rdman_param9 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param9;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param10_addr) then
                if bool(dsp_wr) then
                    rdman_param10 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param10;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param11_addr) then
                if bool(dsp_wr) then
                    rdman_param11 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param11;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param12_addr) then
                if bool(dsp_wr) then
                    rdman_param12 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param12;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param13_addr) then
                if bool(dsp_wr) then
                    rdman_param13 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param13;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param14_addr) then
                if bool(dsp_wr) then
                    rdman_param14 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param14;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param15_addr) then
                if bool(dsp_wr) then
                    rdman_param15 <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_param15;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_data_addrcntr_addr) then
                dsp_data_in_rdman <= resize(rdman_data_addrcntr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_metadata_addrcntr_addr) then
                dsp_data_in_rdman <= resize(rdman_metadata_addrcntr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_param_addrcntr_addr) then
                dsp_data_in_rdman <= resize(rdman_param_addrcntr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_divisor_addr) then
                if bool(dsp_wr) then
                    rdman_divisor <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_divisor, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_num_samp_addr) then
                if bool(dsp_wr) then
                    rdman_num_samp <= resize(dsp_data_out, 12);
                end if;
                dsp_data_in_rdman <= resize(rdman_num_samp, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_threshold_addr) then
                if bool(dsp_wr) then
                    rdman_threshold <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_threshold, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_lock_duration_addr) then
                if bool(dsp_wr) then
                    rdman_lock_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_lock_duration, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_precontrol_duration_addr) then
                if bool(dsp_wr) then
                    rdman_precontrol_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_precontrol_duration, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_off_duration_addr) then
                if bool(dsp_wr) then
                    rdman_off_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_off_duration, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_extra_duration_addr) then
                if bool(dsp_wr) then
                    rdman_extra_duration <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_rdman <= resize(rdman_extra_duration, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_timeout_duration_addr) then
                if bool(dsp_wr) then
                    rdman_timeout_duration <= dsp_data_out;
                end if;
                dsp_data_in_rdman <= rdman_timeout_duration;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_tuner_at_ringdown_addr) then
                dsp_data_in_rdman <= resize(rdman_tuner_at_ringdown, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_metadata_addr_at_ringdown_addr) then
                dsp_data_in_rdman <= resize(rdman_metadata_addr_at_ringdown, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = rdman_ringdown_data_addr) then
                dsp_data_in_rdman <= resize(rdman_ringdown_data, 32);
            else
                dsp_data_in_rdman <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_rdman <= to_unsigned(0, 32);
        end if;
        if bool(rdman_control(RDMAN_CONTROL_RUN_B)) then
            if (not bool(rdman_control(RDMAN_CONTROL_CONT_B))) then
                rdman_control(RDMAN_CONTROL_RUN_B) <= '0';
            end if;
            data_we <= '0';
            rdman_rd_adc_clk <= stdl((not bool(rdman_rd_adc_clk)));
            if bool(rdman_rd_adc_clk) then
                rdman_ringdown_data <= resize(rdman_rd_data, 18);
            end if;
            rdman_sel_fine_current <= sel_fine_current;
            rdman_ext_laser_level_counter <= ext_laser_level_counter;
            rdman_ext_laser_sequence_id <= ext_laser_sequence_id;
            if bool(rdman_status(RDMAN_STATUS_BUSY_B)) then
                rdman_control(RDMAN_CONTROL_START_RD_B) <= '0';
            end if;
            case rdman_seqState is
                when IDLE =>
                    rdman_status(RDMAN_STATUS_BUSY_B) <= '0';
                    rdman_us_since_start <= to_unsigned(0, 32);
                    rdman_metadata_acq <= '0';
                    rdman_param_acq <= '0';
                    rdman_us_timer_enable <= '0';
                    acc_en <= '0';
                    laser_locked <= '0';
                    if bool(rdman_options(RDMAN_OPTIONS_SCOPE_MODE_B)) then
                        rdman_status(RDMAN_STATUS_BUSY_B) <= '1';
                        rdman_seqState <= AWAIT_SWEEP_1;
                    elsif bool(rdman_control(RDMAN_CONTROL_START_RD_B)) then
                        rdman_status(RDMAN_STATUS_BUSY_B) <= '1';
                        rdman_seqState <= START_INJECT;
                    end if;
                when AWAIT_SWEEP_1 =>
                    rdman_abort <= '0';
                    rdman_timeout <= '0';
                    rdman_us_timer_enable <= '1';
                    if (bool(tuner_slope) /= bool(rdman_options(RDMAN_OPTIONS_SCOPE_SLOPE_B))) then
                        rdman_seqState <= AWAIT_SWEEP_2;
                    end if;
                when AWAIT_SWEEP_2 =>
                    if (bool(tuner_slope) = bool(rdman_options(RDMAN_OPTIONS_SCOPE_SLOPE_B))) then
                        rdman_data_addrcntr <= to_unsigned(0, 12);
                        rdman_rd_divider <= to_unsigned(0, 16);
                        rdman_seqState <= IN_RINGDOWN;
                    end if;
                when START_INJECT =>
                    rdman_abort <= '0';
                    rdman_timeout <= '0';
                    rdman_metadata_acq <= '1';
                    rdman_lapped <= '0';
                    rdman_us_timer_enable <= '1';
                    acc_en <= '0';
                    rdman_expiry_time <= resize(rdman_precontrol_duration, 32);
                    rdman_seqState <= WAIT_FOR_PRECONTROL;
                when WAIT_FOR_PRECONTROL =>
                    if (rdman_us_since_start >= rdman_expiry_time) then
                        if bool(rdman_options(RDMAN_OPTIONS_LOCK_ENABLE_B)) then
                            acc_en <= '1';
                            rdman_expiry_time <= (rdman_us_since_start + rdman_lock_duration);
                            rdman_seqState <= WAIT_FOR_LOCK;
                        else
                            rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                        end if;
                    end if;
                when WAIT_FOR_LOCK =>
                    acc_en <= '1';
                    if bool(laser_freq_ok) then
                        if (rdman_us_since_start >= rdman_expiry_time) then
                            laser_locked <= '1';
                            rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                        end if;
                    else
                        rdman_expiry_time <= (rdman_us_since_start + rdman_lock_duration);
                    end if;
                when WAIT_FOR_GATING_CONDITIONS =>
                    if (not bool(rdman_freq_gating_conditions)) then
                        laser_locked <= '0';
                        rdman_seqState <= WAIT_FOR_LOCK;
                    elsif bool(rdman_tuner_gating_conditions) then
                        rdman_seqState <= CHECK_BELOW_THRESHOLD;
                    end if;
                when CHECK_BELOW_THRESHOLD =>
                    if (rdman_rd_data < rdman_threshold) then
                        rdman_seqState <= WAIT_FOR_THRESHOLD;
                    else
                        rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                    end if;
                when WAIT_FOR_THRESHOLD =>
                    if (not bool(rdman_freq_gating_conditions)) then
                        laser_locked <= '0';
                        rdman_seqState <= WAIT_FOR_LOCK;
                    elsif (not bool(rdman_tuner_gating_conditions)) then
                        rdman_seqState <= WAIT_FOR_GATING_CONDITIONS;
                    elsif (rdman_rd_data >= rdman_threshold) then
                        rdman_seqState <= IN_RINGDOWN;
                        rdman_rd_trig <= '1';
                        rdman_metadata_acq <= '0';
                        rdman_data_addrcntr <= to_unsigned(0, 12);
                        rdman_rd_divider <= to_unsigned(0, 16);
                        rdman_metadata_addr_at_ringdown <= resize(rdman_metadata_addrcntr, 16);
                        rdman_metadata_addr_at_ringdown((FPGA_REG_WIDTH - 1)) <= rdman_lapped;
                        if bool(extended_current_mode) then
                            rdman_tuner_at_ringdown <= sel_fine_current;
                        else
                            rdman_tuner_at_ringdown <= tuner_value;
                        end if;
                        rdman_us_timer_enable <= '0';
                        rdman_rd_irq <= '1';
                        rdman_init_flag <= '1';
                    end if;
                when IN_RINGDOWN =>
                    rdman_param_acq <= '1';
                    if bool(rdman_rd_adc_clk) then
                        if ((rdman_data_addrcntr = rdman_num_samp) and (not bool(rdman_init_flag))) then
                            rdman_seqState <= CHECK_PARAMS_DONE;
                            if bool(rdman_bank) then
                                rdman_status(RDMAN_STATUS_BANK1_IN_USE_B) <= '1';
                            else
                                rdman_status(RDMAN_STATUS_BANK0_IN_USE_B) <= '1';
                            end if;
                        elsif (rdman_rd_divider = rdman_divisor) then
                            rdman_rd_divider <= to_unsigned(0, 16);
                            rdman_data_addrcntr <= ((rdman_data_addrcntr + 1) mod 4096);
                            rdman_init_flag <= '0';
                            data_we <= '1';
                        else
                            rdman_rd_divider <= ((rdman_rd_divider + 1) mod 65536);
                        end if;
                    end if;
                when CHECK_PARAMS_DONE =>
                    if (rdman_paramState = DONE) then
                        rdman_seqState <= ACQ_DONE;
                        rdman_metadataAcqState <= IDLE;
                        rdman_paramState <= IDLE;
                    end if;
                when ACQ_DONE =>
                    rdman_bank <= stdl((not bool(rdman_bank)));
                    rdman_acq_done_irq <= '1';
                    rdman_seqState <= WAIT_RD_DONE_1;
                when WAIT_RD_DONE_1 =>
                    rdman_seqState <= WAIT_RD_DONE_2;
                when WAIT_RD_DONE_2 =>
                    if ((rdman_div50_counter = 0) and (rdman_us_after_ringdown = 0)) then
                        rdman_seqState <= IDLE;
                    end if;
                when others =>
                    rdman_seqState <= IDLE;
            end case;
            case rdman_paramState is
                when IDLE =>
                    param_we <= '0';
                    if bool(rdman_param_acq) then
                        rdman_param_addrcntr <= to_unsigned(0, 6);
                        rdman_paramState <= STORING;
                    end if;
                when STORING =>
                    param_we <= '1';
                    rdman_param_addrcntr <= (rdman_param_addrcntr + 1);
                    if (rdman_param_addrcntr(5-1 downto 0) = 0) then
                        wr_param <= rdman_param0;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 1) then
                        wr_param <= rdman_param1;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 2) then
                        wr_param <= rdman_param2;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 3) then
                        wr_param <= rdman_param3;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 4) then
                        wr_param <= rdman_param4;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 5) then
                        wr_param <= rdman_param5;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 6) then
                        wr_param <= rdman_param6;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 7) then
                        wr_param <= rdman_param7;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 8) then
                        wr_param <= rdman_param8;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 9) then
                        wr_param <= rdman_param9;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 10) then
                        wr_param <= resize(rdman_tuner_at_ringdown, 32);
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 11) then
                        wr_param <= resize(rdman_metadata_addr_at_ringdown, 32);
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 12) then
                        wr_param <= resize(rdman_ext_laser_level_counter, 32);
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 13) then
                        wr_param <= resize(rdman_ext_laser_sequence_id, 32);
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 14) then
                        wr_param <= rdman_param10;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 15) then
                        wr_param <= rdman_param11;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 16) then
                        wr_param <= rdman_param12;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 17) then
                        wr_param <= rdman_param13;
                    elsif (rdman_param_addrcntr(5-1 downto 0) = 18) then
                        wr_param <= rdman_param14;
                    else
                        wr_param <= rdman_param15;
                        rdman_paramState <= DONE;
                    end if;
                when DONE =>
                    rdman_param_acq <= '0';
                    param_we <= '0';
                when others =>
                    rdman_paramState <= IDLE;
            end case;
            case rdman_metadataAcqState is
                when IDLE =>
                    meta_we <= '0';
                    rdman_metadata_addrcntr <= to_unsigned(0, 12);
                    rdman_metadataAcqState <= AWAIT_STROBE;
                when AWAIT_STROBE =>
                    if (bool(rdman_metadata_acq) and bool(metadata_strobe)) then
                        rdman_metadataAcqState <= ACQUIRING;
                        rdman_sel_fine_current_slope <= stdl(rdman_sel_fine_current >= rdman_sel_fine_current_prev);
                        rdman_sel_fine_current_prev <= rdman_sel_fine_current;
                    end if;
                when ACQUIRING =>
                    if (not bool(rdman_metadata_acq)) then
                        rdman_metadataAcqState <= DONE;
                    else
                        meta_we <= '1';
                        if (signed(resize(rdman_metadata_addrcntr, 13)) < ((8 * META_SIZE) - 1)) then
                            rdman_metadata_addrcntr <= (rdman_metadata_addrcntr + 1);
                        else
                            rdman_metadata_addrcntr <= to_unsigned(4 * META_SIZE, 12);
                            rdman_lapped <= '1';
                        end if;
                        if (rdman_metadata_addrcntr(3-1 downto 0) = 0) then
                            wr_meta <= ratio1;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 1) then
                            wr_meta <= meta1;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 2) then
                            wr_meta <= pzt;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 3) then
                            wr_meta <= laser_tuning_offset;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 4) then
                            wr_meta <= sel_fine_current;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 5) then
                            wr_meta <= meta5;
                        elsif (rdman_metadata_addrcntr(3-1 downto 0) = 6) then
                            wr_meta <= meta6;
                        else
                            wr_meta <= average2;
                            rdman_metadataAcqState <= DONE;
                        end if;
                    end if;
                when DONE =>
                    meta_we <= '0';
                    if (not bool(metadata_strobe)) then
                        rdman_metadataAcqState <= AWAIT_STROBE;
                    end if;
                when others =>
                    rdman_metadataAcqState <= IDLE;
            end case;
            if (bool(rdman_us_timer_enable) and bool(pulse_1M)) then
                rdman_us_since_start <= (rdman_us_since_start + 1);
                if (rdman_us_since_start >= rdman_timeout_duration) then
                    rdman_timeout <= '1';
                    rdman_metadata_acq <= '0';
                    rdman_param_acq <= '0';
                    rdman_us_timer_enable <= '0';
                    rdman_metadataAcqState <= IDLE;
                    rdman_paramState <= IDLE;
                    rdman_rd_trig <= '1';
                    rdman_rd_irq <= '1';
                    rdman_seqState <= WAIT_RD_DONE_1;
                end if;
            end if;
            if bool(rdman_control(RDMAN_CONTROL_ABORT_RD_B)) then
                rdman_control(RDMAN_CONTROL_ABORT_RD_B) <= '0';
                rdman_rd_trig <= '1';
                rdman_abort <= '1';
                rdman_rd_irq <= '1';
                rdman_acq_done_irq <= '0';
                rdman_metadata_acq <= '0';
                rdman_param_acq <= '0';
                rdman_us_timer_enable <= '0';
                rdman_seqState <= WAIT_RD_DONE_1;
                rdman_metadataAcqState <= IDLE;
                rdman_paramState <= IDLE;
            end if;
            if bool(rdman_control(RDMAN_CONTROL_RESET_RDMAN_B)) then
                rdman_control(RDMAN_CONTROL_RESET_RDMAN_B) <= '0';
                rdman_rd_trig <= '1';
                rdman_abort <= '0';
                rdman_rd_irq <= '0';
                rdman_acq_done_irq <= '0';
                rdman_metadata_acq <= '0';
                rdman_param_acq <= '0';
                rdman_us_timer_enable <= '0';
                rdman_seqState <= WAIT_RD_DONE_1;
                rdman_metadataAcqState <= IDLE;
                rdman_paramState <= IDLE;
            end if;
            if bool(rdman_control(RDMAN_CONTROL_RD_IRQ_ACK_B)) then
                rdman_control(RDMAN_CONTROL_RD_IRQ_ACK_B) <= '0';
                rdman_rd_irq <= '0';
            end if;
            if bool(rdman_control(RDMAN_CONTROL_ACQ_DONE_ACK_B)) then
                rdman_control(RDMAN_CONTROL_ACQ_DONE_ACK_B) <= '0';
                rdman_acq_done_irq <= '0';
            end if;
            if bool(rdman_control(RDMAN_CONTROL_BANK0_CLEAR_B)) then
                rdman_control(RDMAN_CONTROL_BANK0_CLEAR_B) <= '0';
                rdman_status(RDMAN_STATUS_BANK0_IN_USE_B) <= '0';
            end if;
            if bool(rdman_control(RDMAN_CONTROL_BANK1_CLEAR_B)) then
                rdman_control(RDMAN_CONTROL_BANK1_CLEAR_B) <= '0';
                rdman_status(RDMAN_STATUS_BANK1_IN_USE_B) <= '0';
            end if;
            data_addr <= rdman_data_addrcntr;
            meta_addr <= rdman_metadata_addrcntr;
            param_addr <= rdman_param_addrcntr;
        end if;
        if ((rdman_div50_counter = 0) and (rdman_us_after_ringdown = 0)) then
            if bool(rdman_rd_trig) then
                rdman_div50_counter <= (rdman_div50_counter + 1);
            end if;
        else
            if (signed(resize(rdman_div50_counter, 7)) = (50 - 1)) then
                rdman_div50_counter <= to_unsigned(0, 6);
                rdman_us_after_ringdown <= (rdman_us_after_ringdown + 1);
            else
                rdman_div50_counter <= (rdman_div50_counter + 1);
            end if;
        end if;
        if (rdman_us_after_ringdown >= rdman_off_duration) then
            rdman_rd_trig <= '0';
            rdman_laser_extra <= '1';
        end if;
        if (rdman_us_after_ringdown >= (rdman_off_duration + rdman_extra_duration)) then
            rdman_laser_extra <= '0';
            rdman_div50_counter <= to_unsigned(0, 6);
            rdman_us_after_ringdown <= to_unsigned(0, 17);
        end if;
        rdman_status(RDMAN_STATUS_ACQ_DONE_B) <= rdman_acq_done_irq;
        rdman_status(RDMAN_STATUS_BANK_B) <= rdman_bank;
        rdman_status(RDMAN_STATUS_LAPPED_B) <= rdman_lapped;
        rdman_status(RDMAN_STATUS_RD_IRQ_B) <= rdman_rd_irq;
        rdman_status(RDMAN_STATUS_SHUTDOWN_B) <= rdman_rd_trig;
        rdman_status(RDMAN_STATUS_ABORTED_B) <= rdman_abort;
        rdman_status(RDMAN_STATUS_TIMEOUT_B) <= rdman_timeout;
    end if;
end process MAIN_RDMAN_LOGIC;


MAIN_PZTVALVEDAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pztValveDac_chanD_data <= to_unsigned(0, 16);
        pztValveDac_dac_ld <= '1';
    elsif rising_edge(clk0) then
        case pztValveDac_state is
            when IDLE =>
                if bool(pulse_100k) then
                    pztValveDac_chanD_data <= pzt_scaled;
                    pztValveDac_counter <= to_unsigned(0, 5);
                    pztValveDac_dac_ld <= '0';
                    pztValveDac_state <= WAIT_0;
                end if;
            when WAIT_0 =>
                if (not bool(clk_2M5)) then
                    if (signed(resize(pztValveDac_counter, 6)) < (CHAND_DATA_END - 1)) then
                        pztValveDac_counter <= (pztValveDac_counter + 1);
                        pztValveDac_state <= WAIT_1;
                    else
                        pztValveDac_dac_ld <= '1';
                        pztValveDac_state <= IDLE;
                    end if;
                end if;
            when WAIT_1 =>
                if bool(clk_2M5) then
                    pztValveDac_dac_ld <= '0';
                    pztValveDac_state <= WAIT_0;
                end if;
            when others =>
                pztValveDac_state <= IDLE;
        end case;
        pzt_valve_dac_sdi <= pztValveDac_dac_sdi;
        pzt_valve_dac_ld <= pztValveDac_dac_ld;
        pzt_valve_dac_sck <= clk_2M5;
    end if;
end process MAIN_PZTVALVEDAC_LOGIC;


MAIN_PZTVALVEDAC_COMB2: process (pztValveDac_chanD_data, pztValveDac_counter) is
begin
    pztValveDac_dac_sdi <= '1';
    if ((CHAND_CONTROL_START <= pztValveDac_counter) and (pztValveDac_counter < CHAND_CONTROL_END)) then
        case ((CHAND_CONTROL_END - 1) - to_integer(pztValveDac_counter)) is
            when 0 => pztValveDac_dac_sdi <= '1';
            when 1 => pztValveDac_dac_sdi <= '1';
            when 2 => pztValveDac_dac_sdi <= '0';
            when 3 => pztValveDac_dac_sdi <= '0';
            when 4 => pztValveDac_dac_sdi <= '1';
            when 5 => pztValveDac_dac_sdi <= '1';
            when 6 => pztValveDac_dac_sdi <= '0';
            when others => pztValveDac_dac_sdi <= '0';
        end case;
    elsif ((CHAND_DATA_START <= pztValveDac_counter) and (pztValveDac_counter < CHAND_DATA_END)) then
        pztValveDac_dac_sdi <= pztValveDac_chanD_data(((CHAND_DATA_END - 1) - to_integer(pztValveDac_counter)));
    else
        pztValveDac_dac_sdi <= '0';
    end if;
end process MAIN_PZTVALVEDAC_COMB2;



pwm_laser2_out <= pwm_laser2_pwm;
pwm_laser2_inv_out <= (pwm_laser2_pwm xor pwm_laser2_cs(PWM_CS_CONT_B));
pwm_laser2_temp <= (resize(pwm_laser2_dither_cntr, 9) + resize(pwm_laser2_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_LASER2_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_laser2_cs <= to_unsigned(0, 16);
        pwm_laser2_pulse_width <= to_unsigned(0, 16);
        pwm_laser2_main_cntr <= to_unsigned(0, 8);
        pwm_laser2_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 17) then
                if bool(dsp_wr) then
                    pwm_laser2_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser2 <= resize(pwm_laser2_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 18) then
                if bool(dsp_wr) then
                    pwm_laser2_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser2 <= resize(pwm_laser2_pulse_width, 32);
            else
                dsp_data_in_pwm_laser2 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_laser2 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_laser2_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_laser2_cs(PWM_CS_CONT_B))) then
                pwm_laser2_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_laser2_pwm <= '0';
            if (pwm_laser2_main_cntr < pwm_laser2_pulse_width(width-1 downto (width - main_width))) then
                pwm_laser2_pwm <= '1';
            elsif (pwm_laser2_main_cntr = pwm_laser2_pulse_width(width-1 downto dither_width)) then
                if (pwm_laser2_temp >= mod_dither) then
                    pwm_laser2_pwm <= '1';
                    pwm_laser2_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_laser2_dither_cntr <= resize(pwm_laser2_temp - mod_dither, 8);
                else
                    pwm_laser2_dither_cntr <= resize(pwm_laser2_temp, 8);
                end if;
            end if;
            pwm_laser2_main_cntr <= ((pwm_laser2_main_cntr + 1) mod mod_main);
        end if;
        pwm_laser2_cs(PWM_CS_PWM_OUT_B) <= pwm_laser2_pwm;
    end if;
end process MAIN_PWM_LASER2_LOGIC;



hot_box_pwm_out <= pwm_hotbox_pwm;
hot_box_pwm_inv <= (pwm_hotbox_pwm xor pwm_hotbox_cs(PWM_CS_CONT_B));
pwm_hotbox_temp <= (resize(pwm_hotbox_dither_cntr, 9) + resize(pwm_hotbox_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_HOTBOX_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_hotbox_cs <= to_unsigned(0, 16);
        pwm_hotbox_pulse_width <= to_unsigned(0, 16);
        pwm_hotbox_main_cntr <= to_unsigned(0, 8);
        pwm_hotbox_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 25) then
                if bool(dsp_wr) then
                    pwm_hotbox_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_hotbox <= resize(pwm_hotbox_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 26) then
                if bool(dsp_wr) then
                    pwm_hotbox_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_hotbox <= resize(pwm_hotbox_pulse_width, 32);
            else
                dsp_data_in_pwm_hotbox <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_hotbox <= to_unsigned(0, 32);
        end if;
        if bool(pwm_hotbox_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_hotbox_cs(PWM_CS_CONT_B))) then
                pwm_hotbox_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_hotbox_pwm <= '0';
            if (pwm_hotbox_main_cntr < pwm_hotbox_pulse_width(width-1 downto (width - main_width))) then
                pwm_hotbox_pwm <= '1';
            elsif (pwm_hotbox_main_cntr = pwm_hotbox_pulse_width(width-1 downto dither_width)) then
                if (pwm_hotbox_temp >= mod_dither) then
                    pwm_hotbox_pwm <= '1';
                    pwm_hotbox_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_hotbox_dither_cntr <= resize(pwm_hotbox_temp - mod_dither, 8);
                else
                    pwm_hotbox_dither_cntr <= resize(pwm_hotbox_temp, 8);
                end if;
            end if;
            pwm_hotbox_main_cntr <= ((pwm_hotbox_main_cntr + 1) mod mod_main);
        end if;
        pwm_hotbox_cs(PWM_CS_PWM_OUT_B) <= pwm_hotbox_pwm;
    end if;
end process MAIN_PWM_HOTBOX_LOGIC;



filter_heater_pwm_out <= pwm_filter_heater_pwm;
filter_heater_pwm_inv_out <= (pwm_filter_heater_pwm xor pwm_filter_heater_cs(PWM_CS_CONT_B));
pwm_filter_heater_temp <= (resize(pwm_filter_heater_dither_cntr, 9) + resize(pwm_filter_heater_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_FILTER_HEATER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_filter_heater_cs <= to_unsigned(0, 16);
        pwm_filter_heater_pulse_width <= to_unsigned(0, 16);
        pwm_filter_heater_main_cntr <= to_unsigned(0, 8);
        pwm_filter_heater_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 33) then
                if bool(dsp_wr) then
                    pwm_filter_heater_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_filter_heater <= resize(pwm_filter_heater_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 34) then
                if bool(dsp_wr) then
                    pwm_filter_heater_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_filter_heater <= resize(pwm_filter_heater_pulse_width, 32);
            else
                dsp_data_in_pwm_filter_heater <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_filter_heater <= to_unsigned(0, 32);
        end if;
        if bool(pwm_filter_heater_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_filter_heater_cs(PWM_CS_CONT_B))) then
                pwm_filter_heater_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_filter_heater_pwm <= '0';
            if (pwm_filter_heater_main_cntr < pwm_filter_heater_pulse_width(width-1 downto (width - main_width))) then
                pwm_filter_heater_pwm <= '1';
            elsif (pwm_filter_heater_main_cntr = pwm_filter_heater_pulse_width(width-1 downto dither_width)) then
                if (pwm_filter_heater_temp >= mod_dither) then
                    pwm_filter_heater_pwm <= '1';
                    pwm_filter_heater_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_filter_heater_dither_cntr <= resize(pwm_filter_heater_temp - mod_dither, 8);
                else
                    pwm_filter_heater_dither_cntr <= resize(pwm_filter_heater_temp, 8);
                end if;
            end if;
            pwm_filter_heater_main_cntr <= ((pwm_filter_heater_main_cntr + 1) mod mod_main);
        end if;
        pwm_filter_heater_cs(PWM_CS_PWM_OUT_B) <= pwm_filter_heater_pwm;
    end if;
end process MAIN_PWM_FILTER_HEATER_LOGIC;


MAIN_KERNEL_COMB: process (kernel_status_led, kernel_dout_lo, din, kernel_intronix_clksel, kernel_sel_detector_mode, kernel_dout_hi, sel_laser, kernel_fan, kernel_intronix_3, kernel_config, kernel_intronix_1, kernel_intronix_2, kernel_diag_1) is
begin
    intronix_clksel <= kernel_intronix_clksel;
    intronix_1 <= kernel_intronix_1;
    intronix_2 <= kernel_intronix_2;
    intronix_3 <= kernel_intronix_3;
    diag_1 <= kernel_diag_1;
    config <= kernel_config;
    dout <= unsigned'(kernel_dout_hi & kernel_dout_lo);
    kernel_din <= din;
    status_led(0) <= kernel_status_led(KERNEL_STATUS_LED_RED_B);
    status_led(1) <= kernel_status_led(KERNEL_STATUS_LED_GREEN_B);
    fan(0) <= kernel_fan(KERNEL_FAN_FAN1_B);
    fan(1) <= kernel_fan(KERNEL_FAN_FAN2_B);
    sel_detector <= stdl((bool(kernel_sel_detector_mode(0)) and (sel_laser = 0)) or (bool(kernel_sel_detector_mode(1)) and (sel_laser = 1)) or (bool(kernel_sel_detector_mode(2)) and (sel_laser = 2)) or (bool(kernel_sel_detector_mode(3)) and (sel_laser = 3)));
end process MAIN_KERNEL_COMB;


MAIN_KERNEL_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        kernel_control <= to_unsigned(control_init, 16);
        kernel_diag_1 <= to_unsigned(0, 8);
        kernel_config <= to_unsigned(0, 16);
        kernel_intronix_clksel <= to_unsigned(0, 5);
        kernel_intronix_1 <= to_unsigned(0, 8);
        kernel_intronix_2 <= to_unsigned(0, 8);
        kernel_intronix_3 <= to_unsigned(0, 8);
        kernel_overload <= to_unsigned(0, 16);
        i2c_reset <= '1';
        kernel_dout_hi <= to_unsigned(0, 8);
        kernel_dout_lo <= to_unsigned(0, 32);
        kernel_status_led <= to_unsigned(0, 16);
        kernel_fan <= to_unsigned(0, 16);
        kernel_sel_detector_mode <= to_unsigned(0, 4);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_magic_code_addr) then
                    dsp_data_in_kernel <= unsigned'("11000000110111100000000000000001");
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_control_addr) then
                    if bool(dsp_wr) then
                        kernel_control <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_control, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_diag_1_addr) then
                    if bool(dsp_wr) then
                        kernel_diag_1 <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_diag_1, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_config_addr) then
                    if bool(dsp_wr) then
                        kernel_config <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_config, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_intronix_clksel_addr) then
                    if bool(dsp_wr) then
                        kernel_intronix_clksel <= resize(dsp_data_out, 5);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_intronix_clksel, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_intronix_1_addr) then
                    if bool(dsp_wr) then
                        kernel_intronix_1 <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_intronix_1, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_intronix_2_addr) then
                    if bool(dsp_wr) then
                        kernel_intronix_2 <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_intronix_2, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_intronix_3_addr) then
                    if bool(dsp_wr) then
                        kernel_intronix_3 <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_intronix_3, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_overload_addr) then
                    dsp_data_in_kernel <= resize(kernel_overload, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_dout_hi_addr) then
                    if bool(dsp_wr) then
                        kernel_dout_hi <= resize(dsp_data_out, 8);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_dout_hi, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_dout_lo_addr) then
                    if bool(dsp_wr) then
                        kernel_dout_lo <= dsp_data_out;
                    end if;
                    dsp_data_in_kernel <= kernel_dout_lo;
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_din_addr) then
                    dsp_data_in_kernel <= resize(kernel_din, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_status_led_addr) then
                    if bool(dsp_wr) then
                        kernel_status_led <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_status_led, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_fan_addr) then
                    if bool(dsp_wr) then
                        kernel_fan <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_fan, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = kernel_sel_detector_mode_addr) then
                    if bool(dsp_wr) then
                        kernel_sel_detector_mode <= resize(dsp_data_out, 4);
                    end if;
                    dsp_data_in_kernel <= resize(kernel_sel_detector_mode, 32);
                else
                    dsp_data_in_kernel <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_kernel <= to_unsigned(0, 32);
        end if;
        if bool(kernel_control(KERNEL_CONTROL_OVERLOAD_RESET_B)) then
            kernel_control(KERNEL_CONTROL_OVERLOAD_RESET_B) <= '0';
            kernel_overload <= overload_in;
        else
            kernel_overload <= (kernel_overload or overload_in);
        end if;
        if (kernel_overload /= 0) then
            overload_out <= '1';
        else
            overload_out <= '0';
        end if;
        i2c_reset <= kernel_control(KERNEL_CONTROL_I2C_RESET_B);
        dout_man <= kernel_control(KERNEL_CONTROL_DOUT_MAN_B);
    end if;
end process MAIN_KERNEL_LOGIC;


MAIN_DSP_INTERFACE_LOGIC: process (clk0, reset) is
    variable dsp_addr_v: unsigned(19 downto 0);
    variable done_rd_v: std_logic;
    variable dsp_wr_v: std_logic;
    variable dsp_data_out_v: unsigned(31 downto 0);
    variable done_wr_v: std_logic;
    variable state_v: t_enum_t_State_10;
begin
    if bool(reset) then
        dsp_addr_v := to_unsigned(0, 20);
        dsp_data_out_v := to_unsigned(0, 32);
        dsp_wr_v := '0';
        done_rd_v := '0';
        done_wr_v := '0';
        state_v := INIT;
    elsif rising_edge(clk0) then
        dsp_wr_v := '0';
        case state_v is
            when INIT =>
                done_rd_v := '0';
                done_wr_v := '0';
                if bool(dsp_interface_ce_h) then
                    dsp_addr_v := dsp_emif_ea;
                    if bool(dsp_interface_re_h) then
                        state_v := READ1;
                    elsif bool(dsp_interface_we_h) then
                        state_v := WRITE1;
                    end if;
                end if;
            when WRITE1 =>
                dsp_data_out_v := dsp_emif_dout;
                dsp_wr_v := '1';
                done_wr_v := '1';
                state_v := WRITE2;
            when WRITE2 =>
                if (not bool(dsp_emif_we)) then
                    done_wr_v := '0';
                    state_v := IDLE;
                end if;
            when READ1 =>
                done_rd_v := '1';
                state_v := READ2;
            when READ2 =>
                if (not bool(dsp_emif_re)) then
                    done_rd_v := '0';
                    state_v := IDLE;
                end if;
            when others => -- IDLE
                state_v := INIT;
        end case;
    end if;
    dsp_addr <= dsp_addr_v;
    dsp_data_out <= dsp_data_out_v;
    dsp_wr <= dsp_wr_v;
    dsp_interface_done_rd_d <= done_rd_v;
    dsp_interface_done_wr_d <= done_wr_v;
end process MAIN_DSP_INTERFACE_LOGIC;



dsp_emif_ddir <= stdl(bool(dsp_emif_oe) and bool(ce2));
dsp_emif_ardy <= stdl((not bool(ce2)) or bool(dsp_interface_done_rd) or bool(dsp_interface_done_wr));
dsp_emif_din <= dsp_data_in;


MAIN_DSP_INTERFACE_HARDEN: process (clk0) is
begin
    if rising_edge(clk0) then
        dsp_interface_ce_h <= ce2;
        dsp_interface_we_h <= dsp_emif_we;
        dsp_interface_re_h <= dsp_emif_re;
    end if;
end process MAIN_DSP_INTERFACE_HARDEN;


MAIN_DSP_INTERFACE_MAKE_DONE_WR: process (clk0, dsp_emif_we) is
begin
    if (dsp_emif_we = '0') then
        dsp_interface_done_wr <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_wr <= dsp_interface_done_wr_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_WR;


MAIN_DSP_INTERFACE_MAKE_DONE_RD: process (clk0, dsp_emif_re) is
begin
    if (dsp_emif_re = '0') then
        dsp_interface_done_rd <= '0';
    elsif rising_edge(clk0) then
        dsp_interface_done_rd <= dsp_interface_done_rd_d;
    end if;
end process MAIN_DSP_INTERFACE_MAKE_DONE_RD;


MAIN_COMB: process (sgdbr_b_mosi, clk_5M, dsp_data_in_pwm_laser3, lsr1_miso, rd_irq, sgdbr_d_sck, sgdbr_c_sck, dsp_data_in_pwm_laser4, dsp_data_in_rdman, lsr4_disable_temp, sgdbr_d_mosi, warm_box_tec_overload, sgdbr_a_csn, dsp_data_in_twGen, data_available_actual, heater_pwm_out, hot_box_tec_overload, metadata_strobe, i2c_reset, sgdbr_b_sck, lsr3_miso, dsp_data_in_sgdbrcurrentsource_b, dsp_data_in_sgdbrcurrentsource_c, dsp_data_in_sgdbrcurrentsource_a, dsp_data_in_sgdbrcurrentsource_d, lsr3_disable_temp, intronix_clksel, lsr2_disable_temp, pwm_laser4_inv_out, sgdbr_present, lsr2_ss_temp, dsp_data_in_analyzermemory, dsp_data_in_dynamicpwm_inlet, channel_1, channel_3, channel_2, pwm_laser1_out, lsr4_ss_temp, sgdbr_b_csn, laser_fine_current, lsr4_miso, lsr1_mosi_temp, engine2_pwm_out, sgdbr_c_csn, lsr2_mosi_temp, sgdbr_mode, aux_pzt_dac_sdi, dsp_data_in_inject, dsp_emif_ce, dsp_data_in_pwm_engine2, dsp_data_in_pwm_engine1, lsr1_disable_temp, lsr3_ss_temp, clk_2M5, pwm_laser1_inv_out, dsp_data_in_laserlocker, pb0_out, rd_trig, aux_pzt_dac_ld, lsr4_mosi_temp, aux_pzt_dac_sck, warm_box_pwm_out, filter_heater_pwm_out, engine1_pwm_out, sgdbr_a_mosi, sgdbr_c_mosi, dsp_data_in_sgdbrmanager, sgdbr_select, dsp_data_in_kernel, clk0, dsp_data_in_pwm_laser2, dsp_data_in_pwm_laser1, adc_clk, lsr2_miso, status_led, pb_strobe_out, pwm_laser3_inv_out, dsp_data_in_pwm_heater, sgdbr_a_resetn, dsp_data_in_pwm_hotbox, dsp_data_in_dynamicpwm_outlet, hot_box_pwm_out, sgdbr_a_sck, acq_done_irq, dsp_data_in_scaler, lsr3_mosi_temp, sgdbr_d_resetn, sgdbr_b_resetn, sgdbr_c_resetn, pwm_laser4_out, config, wmm_rd_out, channel_4, sel_detector, dsp_data_in_pwm_warmbox, lsr1_ss_temp, sgdbr_d_csn, pwm_laser2_out, counter, pwm_laser2_inv_out, pwm_laser3_out, dsp_data_in_pwm_filter_heater, fan) is
begin
    dsp_data_in <= (((((((((((((((((((((((dsp_data_in_analyzermemory or dsp_data_in_dynamicpwm_inlet) or dsp_data_in_dynamicpwm_outlet) or dsp_data_in_inject) or dsp_data_in_kernel) or dsp_data_in_laserlocker) or dsp_data_in_pwm_heater) or dsp_data_in_pwm_hotbox) or dsp_data_in_pwm_engine1) or dsp_data_in_pwm_engine2) or dsp_data_in_pwm_laser1) or dsp_data_in_pwm_laser2) or dsp_data_in_pwm_laser3) or dsp_data_in_pwm_laser4) or dsp_data_in_rdman) or dsp_data_in_sgdbrcurrentsource_a) or dsp_data_in_sgdbrcurrentsource_b) or dsp_data_in_sgdbrcurrentsource_c) or dsp_data_in_sgdbrcurrentsource_d) or dsp_data_in_sgdbrmanager) or dsp_data_in_twGen) or dsp_data_in_pwm_warmbox) or dsp_data_in_scaler) or dsp_data_in_pwm_filter_heater);
    wlm_data_available <= data_available_actual;
    overload_in(OVERLOAD_WarmBoxTecBit) <= warm_box_tec_overload;
    overload_in(OVERLOAD_HotBoxTecBit) <= hot_box_tec_overload;
    intronix(8-1 downto 0) <= channel_1;
    intronix(16-1 downto 8) <= channel_2;
    intronix(24-1 downto 16) <= channel_3;
    intronix(33-1 downto 24) <= channel_4;
    if (intronix_clksel = 0) then
        intronix(33) <= clk0;
    elsif (intronix_clksel <= NSTAGES) then
        intronix(33) <= counter(to_integer(signed(resize(intronix_clksel, 6)) - 1));
    else
        intronix(33) <= '0';
    end if;
    monitor <= rd_trig;
    aux_din <= to_unsigned(0, 4);
    aux_din(3) <= rd_trig;
    ce2 <= dsp_emif_ce(2);
    lsr1_0 <= pwm_laser1_out;
    lsr1_1 <= pwm_laser1_inv_out;
    lsr2_0 <= pwm_laser2_out;
    lsr2_1 <= pwm_laser2_inv_out;
    lsr3_0 <= pwm_laser3_out;
    lsr3_1 <= pwm_laser3_inv_out;
    lsr4_0 <= pwm_laser4_out;
    lsr4_1 <= pwm_laser4_inv_out;
    warm_box_pwm <= warm_box_pwm_out;
    hot_box_pwm <= hot_box_pwm_out;
    heater_pwm <= heater_pwm_out;
    wmm_rd <= wmm_rd_out;
    rd_adc_clk <= adc_clk;
    rd_adc_oe <= '1';
    fpga_led <= counter(NSTAGES-1 downto (NSTAGES - 4));
    i2c_rst0 <= i2c_reset;
    i2c_rst1 <= i2c_reset;
    dsp_ext_int4 <= rd_irq;
    dsp_ext_int5 <= acq_done_irq;
    dsp_ext_int6 <= '0';
    dsp_ext_int7 <= '0';
    wmm_clk <= clk_2M5;
    chanC_data_in <= to_unsigned(0, 16);
    if bool(config(KERNEL_CONFIG_AUX_PZT_B)) then
        aux_din(0) <= aux_pzt_dac_sdi;
        aux_din(1) <= aux_pzt_dac_sck;
        aux_din(2) <= aux_pzt_dac_ld;
    end if;
    if bool(config(KERNEL_CONFIG_ENGINE1_TEC_B)) then
        aux_din(2) <= engine1_pwm_out;
    end if;
    if bool(config(KERNEL_CONFIG_ENGINE2_TEC_B)) then
        aux_din(3) <= engine2_pwm_out;
    end if;
    fp_led <= to_unsigned(0, 4);
    fp_led(0) <= status_led(0);
    fp_led(1) <= status_led(1);
    fp_led(2) <= fan(1);
    fp_lcd <= to_unsigned(0, 8);
    fp_lcd(1) <= filter_heater_pwm_out;
    fp_lcd(2) <= fan(0);
    fp_lcd(3) <= sel_detector;
    fpga_program_enable <= '1';
    cyp_reset <= '0';
    sgdbr_a_miso <= '0';
    if bool(sgdbr_present(0)) then
        sgdbr_a_miso <= lsr1_miso;
        lsr1_sck <= sgdbr_a_sck;
        lsr1_ss <= stdl((not bool(sgdbr_a_csn)));
        lsr1_mosi <= sgdbr_a_mosi;
        lsr1_disable <= sgdbr_a_resetn;
    else
        lsr1_sck <= clk_5M;
        lsr1_ss <= lsr1_ss_temp;
        lsr1_mosi <= lsr1_mosi_temp;
        lsr1_disable <= lsr1_disable_temp;
    end if;
    sgdbr_c_miso <= '0';
    if bool(sgdbr_present(2)) then
        sgdbr_c_miso <= lsr2_miso;
        lsr2_sck <= sgdbr_c_sck;
        lsr2_ss <= stdl((not bool(sgdbr_c_csn)));
        lsr2_mosi <= sgdbr_c_mosi;
        lsr2_disable <= sgdbr_c_resetn;
    else
        lsr2_sck <= clk_5M;
        lsr2_ss <= lsr2_ss_temp;
        lsr2_mosi <= lsr2_mosi_temp;
        lsr2_disable <= lsr2_disable_temp;
    end if;
    sgdbr_b_miso <= '0';
    if bool(sgdbr_present(1)) then
        sgdbr_b_miso <= lsr3_miso;
        lsr3_sck <= sgdbr_b_sck;
        lsr3_ss <= stdl((not bool(sgdbr_b_csn)));
        lsr3_mosi <= sgdbr_b_mosi;
        lsr3_disable <= sgdbr_b_resetn;
    else
        lsr3_sck <= clk_5M;
        lsr3_ss <= lsr3_ss_temp;
        lsr3_mosi <= lsr3_mosi_temp;
        lsr3_disable <= lsr3_disable_temp;
    end if;
    sgdbr_d_miso <= '0';
    if bool(sgdbr_present(3)) then
        sgdbr_d_miso <= lsr4_miso;
        lsr4_sck <= sgdbr_d_sck;
        lsr4_ss <= stdl((not bool(sgdbr_d_csn)));
        lsr4_mosi <= sgdbr_d_mosi;
        lsr4_disable <= sgdbr_d_resetn;
    else
        lsr4_sck <= clk_5M;
        lsr4_ss <= lsr4_ss_temp;
        lsr4_mosi <= lsr4_mosi_temp;
        lsr4_disable <= lsr4_disable_temp;
    end if;
    sgdbr_a_sync_register <= to_unsigned(5, 4);
    sgdbr_b_sync_register <= to_unsigned(5, 4);
    sgdbr_c_sync_register <= to_unsigned(5, 4);
    sgdbr_d_sync_register <= to_unsigned(5, 4);
    if bool(sgdbr_mode) then
        sync_current_in <= pb0_out;
        sgdbr_a_sync_strobe_in <= '0';
        sgdbr_b_sync_strobe_in <= '0';
        sgdbr_c_sync_strobe_in <= '0';
        sgdbr_d_sync_strobe_in <= '0';
        case sgdbr_select is
            when "00" =>
                sgdbr_a_sync_strobe_in <= pb_strobe_out;
            when "01" =>
                sgdbr_b_sync_strobe_in <= pb_strobe_out;
            when "10" =>
                sgdbr_c_sync_strobe_in <= pb_strobe_out;
            when others =>
                sgdbr_d_sync_strobe_in <= pb_strobe_out;
        end case;
    else
        sync_current_in <= laser_fine_current;
        sgdbr_a_sync_strobe_in <= '0';
        sgdbr_b_sync_strobe_in <= '0';
        sgdbr_c_sync_strobe_in <= '0';
        sgdbr_d_sync_strobe_in <= '0';
        case sgdbr_select is
            when "00" =>
                sgdbr_a_sync_strobe_in <= metadata_strobe;
            when "01" =>
                sgdbr_b_sync_strobe_in <= metadata_strobe;
            when "10" =>
                sgdbr_c_sync_strobe_in <= metadata_strobe;
            when others =>
                sgdbr_d_sync_strobe_in <= metadata_strobe;
        end case;
    end if;
end process MAIN_COMB;



dual_port_ram_2 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 16)
    port map (
    clockA => clk0, enableA => analyzermemory_enA_meta, wr_enableA => analyzermemory_wr_enable,
    addressA => analyzermemory_meta_addrA, rd_dataA => analyzermemory_rd_metaA, wr_dataA => analyzermemory_wr_metaA,
    clockB => clk0, enableB => analyzermemory_enB_meta, wr_enableB => analyzermemory_weB_meta,
    addressB => analyzermemory_meta_addrB, rd_dataB => analyzermemory_rd_metaB, wr_dataB => wr_meta
    );


MAIN_ANALYZERMEMORY_COMB: process (analyzermemory_rd_dataA, dsp_data_out, analyzermemory_rd_metaB, meta_addr, dsp_wr, rec_data, rec_addr, data_addr, analyzermemory_rd_paramA, dsp_addr, data_we, sgdbr_mode, meta_we, analyzermemory_rd_metaA, param_addr, rec_we, pb_wfm_sel, wr_data, bank, rec_wfm_sel) is
    variable sel_meta: std_logic;
    variable sel_data_and_metadata: std_logic;
    variable sel_param: std_logic;
    variable sel_data: std_logic;
begin
    sel_data_and_metadata := stdl((dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 6) or (dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 2));
    analyzermemory_wr_enable <= stdl(bool(dsp_wr) and (not bool(sel_data_and_metadata)));
    analyzermemory_enB_data <= '1';
    sel_data := stdl((dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 4) or (dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 0) or bool(sel_data_and_metadata));
    analyzermemory_data_addrA(DATA_BANK_ADDR_WIDTH-1 downto 0) <= dsp_addr(DATA_BANK_ADDR_WIDTH-1 downto 0);
    analyzermemory_data_addrA(DATA_BANK_ADDR_WIDTH) <= dsp_addr((RDMEM_RESERVED_BANK_ADDR_WIDTH + 2));
    analyzermemory_enA_data <= sel_data;
    if (sgdbr_mode = '0') then
        analyzermemory_data_addrB(DATA_BANK_ADDR_WIDTH-1 downto 0) <= data_addr;
        analyzermemory_data_addrB(DATA_BANK_ADDR_WIDTH) <= bank;
        analyzermemory_weB_data <= data_we;
        analyzermemory_wr_dataB <= wr_data;
    else
        analyzermemory_data_addrB(DATA_BANK_ADDR_WIDTH-1 downto 0) <= rec_addr;
        analyzermemory_data_addrB(DATA_BANK_ADDR_WIDTH) <= rec_wfm_sel;
        analyzermemory_weB_data <= rec_we;
        analyzermemory_wr_dataB <= rec_data;
    end if;
    analyzermemory_wr_dataA <= dsp_data_out(RDMEM_DATA_WIDTH-1 downto 0);
    analyzermemory_enB_meta <= '1';
    sel_meta := stdl((dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 5) or (dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 1) or bool(sel_data_and_metadata));
    analyzermemory_meta_addrA(META_BANK_ADDR_WIDTH-1 downto 0) <= dsp_addr(META_BANK_ADDR_WIDTH-1 downto 0);
    analyzermemory_meta_addrA(META_BANK_ADDR_WIDTH) <= dsp_addr((RDMEM_RESERVED_BANK_ADDR_WIDTH + 2));
    analyzermemory_enA_meta <= sel_meta;
    if (sgdbr_mode = '0') then
        analyzermemory_meta_addrB(META_BANK_ADDR_WIDTH-1 downto 0) <= meta_addr;
        analyzermemory_meta_addrB(META_BANK_ADDR_WIDTH) <= bank;
        analyzermemory_weB_meta <= meta_we;
        meta <= analyzermemory_rd_metaB;
        pb_data <= to_unsigned(0, 16);
    else
        analyzermemory_meta_addrB(META_BANK_ADDR_WIDTH-1 downto 0) <= rec_addr;
        analyzermemory_meta_addrB(META_BANK_ADDR_WIDTH) <= pb_wfm_sel;
        analyzermemory_weB_meta <= '0';
        meta <= to_unsigned(0, 16);
        pb_data <= analyzermemory_rd_metaB;
    end if;
    analyzermemory_wr_metaA <= dsp_data_out(RDMEM_META_WIDTH-1 downto 0);
    analyzermemory_enB_param <= '1';
    sel_param := stdl((dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 7) or (dsp_addr(20-1 downto RDMEM_RESERVED_BANK_ADDR_WIDTH) = 3));
    analyzermemory_param_addrA(PARAM_BANK_ADDR_WIDTH-1 downto 0) <= dsp_addr(PARAM_BANK_ADDR_WIDTH-1 downto 0);
    analyzermemory_param_addrA(PARAM_BANK_ADDR_WIDTH) <= dsp_addr((RDMEM_RESERVED_BANK_ADDR_WIDTH + 2));
    analyzermemory_enA_param <= sel_param;
    analyzermemory_param_addrB(PARAM_BANK_ADDR_WIDTH-1 downto 0) <= param_addr;
    analyzermemory_param_addrB(PARAM_BANK_ADDR_WIDTH) <= bank;
    analyzermemory_wr_paramA <= dsp_data_out(RDMEM_PARAM_WIDTH-1 downto 0);
    if bool(sel_data_and_metadata) then
        dsp_data_in_analyzermemory(FPGA_REG_WIDTH-1 downto 0) <= analyzermemory_rd_dataA(FPGA_REG_WIDTH-1 downto 0);
        dsp_data_in_analyzermemory(EMIF_DATA_WIDTH-1 downto FPGA_REG_WIDTH) <= analyzermemory_rd_metaA(FPGA_REG_WIDTH-1 downto 0);
    elsif bool(sel_data) then
        dsp_data_in_analyzermemory <= resize(analyzermemory_rd_dataA(RDMEM_DATA_WIDTH-1 downto 0), 32);
    elsif bool(sel_meta) then
        dsp_data_in_analyzermemory <= resize(analyzermemory_rd_metaA(RDMEM_META_WIDTH-1 downto 0), 32);
    elsif bool(sel_param) then
        dsp_data_in_analyzermemory <= analyzermemory_rd_paramA(RDMEM_PARAM_WIDTH-1 downto 0);
    else
        dsp_data_in_analyzermemory <= to_unsigned(0, 32);
    end if;
end process MAIN_ANALYZERMEMORY_COMB;



dual_port_ram_3 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 7, DATA_WIDTH => 32)
    port map (
    clockA => clk0, enableA => analyzermemory_enA_param, wr_enableA => analyzermemory_wr_enable,
    addressA => analyzermemory_param_addrA, rd_dataA => analyzermemory_rd_paramA, wr_dataA => analyzermemory_wr_paramA,
    clockB => clk0, enableB => analyzermemory_enB_param, wr_enableB => param_we,
    addressB => analyzermemory_param_addrB, rd_dataB => param, wr_dataB => wr_param
    );



dual_port_ram_1 : entity work.DualPortRamRw_e(Behavioral)
    generic map(ADDR_WIDTH => 13, DATA_WIDTH => 18)
    port map (
    clockA => clk0, enableA => analyzermemory_enA_data, wr_enableA => analyzermemory_wr_enable,
    addressA => analyzermemory_data_addrA, rd_dataA => analyzermemory_rd_dataA, wr_dataA => analyzermemory_wr_dataA,
    clockB => clk0, enableB => analyzermemory_enB_data, wr_enableB => analyzermemory_weB_data,
    addressB => analyzermemory_data_addrB, rd_dataB => data, wr_dataB => analyzermemory_wr_dataB
    );


MAIN_LOGIC: process (clk0, reset) is
    variable eta1_adc_high: unsigned(15 downto 0);
    variable ratio2_high: unsigned(15 downto 0);
    variable rd_adc_low: unsigned(7 downto 0);
    variable tuner_low: unsigned(15 downto 0);
    variable ref1_adc_low: unsigned(15 downto 0);
    variable tuner_high: unsigned(15 downto 0);
    variable eta2_adc_low: unsigned(15 downto 0);
    variable wlm_adc: unsigned(7 downto 0);
    variable lock_error_high: unsigned(15 downto 0);
    variable system_clocks: unsigned(7 downto 0);
    variable i2c_signals: unsigned(7 downto 0);
    variable eta1_adc_low: unsigned(15 downto 0);
    variable ratio1_high: unsigned(15 downto 0);
    variable rd_adc_high: unsigned(15 downto 0);
    variable ref2_adc_low: unsigned(15 downto 0);
    variable eta2_adc_high: unsigned(15 downto 0);
    variable ratio2_low: unsigned(15 downto 0);
    variable rd_sim_high: unsigned(15 downto 0);
    variable pzt_high: unsigned(15 downto 0);
    variable lock_error_low: unsigned(15 downto 0);
    variable pwm_signals: unsigned(7 downto 0);
    variable ratio1_low: unsigned(15 downto 0);
    variable ref2_adc_high: unsigned(15 downto 0);
    variable ref1_adc_high: unsigned(15 downto 0);
    variable sel_fine_current_low: unsigned(15 downto 0);
    variable pzt_low: unsigned(15 downto 0);
    variable rd_sim_low: unsigned(7 downto 0);
    variable sel_fine_current_high: unsigned(15 downto 0);
begin
    if bool(reset) then
        counter <= to_unsigned(0, 28);
        channel_1 <= to_unsigned(0, 8);
        channel_2 <= to_unsigned(0, 8);
        channel_3 <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        counter <= (counter + 1);
        tuner_low := resize(tuner_value(8-1 downto 0), 16);
        tuner_high := resize(tuner_value(16-1 downto 8), 16);
        rd_adc_low := unsigned'(rd_adc(6-1 downto 0) & '0' & '0');
        rd_adc_high := resize(rd_adc(14-1 downto 6), 16);
        rd_sim_low := unsigned'(rdsim_value(6-1 downto 0) & '0' & '0');
        rd_sim_high := resize(rdsim_value(14-1 downto 6), 16);
        sel_fine_current_low := resize(sel_fine_current(8-1 downto 0), 16);
        sel_fine_current_high := resize(sel_fine_current(16-1 downto 8), 16);
        lock_error_low := resize(meta5(8-1 downto 0), 16);
        lock_error_high := resize(meta5(16-1 downto 8), 16);
        ratio1_low := resize(ratio1(8-1 downto 0), 16);
        ratio1_high := resize(ratio1(16-1 downto 8), 16);
        ratio2_low := resize(meta1(8-1 downto 0), 16);
        ratio2_high := resize(meta1(16-1 downto 8), 16);
        pzt_low := resize(pzt(8-1 downto 0), 16);
        pzt_high := resize(pzt(16-1 downto 8), 16);
        eta1_adc_low := resize(eta1_actual(8-1 downto 0), 16);
        eta1_adc_high := resize(eta1_actual(16-1 downto 8), 16);
        ref1_adc_low := resize(ref1_actual(8-1 downto 0), 16);
        ref1_adc_high := resize(ref1_actual(16-1 downto 8), 16);
        eta2_adc_low := resize(eta2_actual(8-1 downto 0), 16);
        eta2_adc_high := resize(eta2_actual(16-1 downto 8), 16);
        ref2_adc_low := resize(ref2_actual(8-1 downto 0), 16);
        ref2_adc_high := resize(ref2_actual(16-1 downto 8), 16);
        wlm_adc := unsigned'(wmm_busy2 & wmm_busy1 & wmm_rd_out & clk_2M5 & wmm_tran2 & wmm_refl2 & wmm_tran1 & wmm_refl1);
        system_clocks := unsigned'(data_we & clk_10M & clk_5M & clk_2M5 & pulse_1M & pulse_100k & wlm_data_available & metadata_strobe);
        pwm_signals := unsigned'(engine2_pwm_out & engine1_pwm_out & hot_box_pwm_out & warm_box_pwm_out & pwm_laser4_out & pwm_laser3_out & pwm_laser2_out & pwm_laser1_out);
        i2c_signals := unsigned'(heater_pwm_out & '0' & '0' & '0' & i2c_scl0 & i2c_sda0 & i2c_scl1 & i2c_sda1);
        case intronix_1 is
            when "00000000" =>
                channel_1 <= resize(tuner_low, 8);
            when "00000001" =>
                channel_1 <= resize(tuner_high, 8);
            when "00000010" =>
                channel_1 <= rd_adc_low;
            when "00000011" =>
                channel_1 <= resize(rd_adc_high, 8);
            when "00000100" =>
                channel_1 <= rd_sim_low;
            when "00000101" =>
                channel_1 <= resize(rd_sim_high, 8);
            when "00000110" =>
                channel_1 <= resize(sel_fine_current_low, 8);
            when "00000111" =>
                channel_1 <= resize(sel_fine_current_high, 8);
            when "00001000" =>
                channel_1 <= resize(lock_error_low, 8);
            when "00001001" =>
                channel_1 <= resize(lock_error_high, 8);
            when "00001010" =>
                channel_1 <= resize(ratio1_low, 8);
            when "00001011" =>
                channel_1 <= resize(ratio1_high, 8);
            when "00001100" =>
                channel_1 <= resize(ratio2_low, 8);
            when "00001101" =>
                channel_1 <= resize(ratio2_high, 8);
            when "00001110" =>
                channel_1 <= resize(pzt_low, 8);
            when "00001111" =>
                channel_1 <= resize(pzt_high, 8);
            when "00010000" =>
                channel_1 <= resize(eta1_adc_low, 8);
            when "00010001" =>
                channel_1 <= resize(eta1_adc_high, 8);
            when "00010010" =>
                channel_1 <= resize(ref1_adc_low, 8);
            when "00010011" =>
                channel_1 <= resize(ref1_adc_high, 8);
            when "00010100" =>
                channel_1 <= resize(eta2_adc_low, 8);
            when "00010101" =>
                channel_1 <= resize(eta2_adc_high, 8);
            when "00010110" =>
                channel_1 <= resize(ref2_adc_low, 8);
            when "00010111" =>
                channel_1 <= resize(ref2_adc_high, 8);
            when "00011000" =>
                channel_1 <= wlm_adc;
            when "00011001" =>
                channel_1 <= system_clocks;
            when "00011010" =>
                channel_1 <= pwm_signals;
            when others =>
                channel_1 <= i2c_signals;
        end case;
        case intronix_2 is
            when "00000000" =>
                channel_2 <= resize(tuner_low, 8);
            when "00000001" =>
                channel_2 <= resize(tuner_high, 8);
            when "00000010" =>
                channel_2 <= rd_adc_low;
            when "00000011" =>
                channel_2 <= resize(rd_adc_high, 8);
            when "00000100" =>
                channel_2 <= rd_sim_low;
            when "00000101" =>
                channel_2 <= resize(rd_sim_high, 8);
            when "00000110" =>
                channel_2 <= resize(sel_fine_current_low, 8);
            when "00000111" =>
                channel_2 <= resize(sel_fine_current_high, 8);
            when "00001000" =>
                channel_2 <= resize(lock_error_low, 8);
            when "00001001" =>
                channel_2 <= resize(lock_error_high, 8);
            when "00001010" =>
                channel_2 <= resize(ratio1_low, 8);
            when "00001011" =>
                channel_2 <= resize(ratio1_high, 8);
            when "00001100" =>
                channel_2 <= resize(ratio2_low, 8);
            when "00001101" =>
                channel_2 <= resize(ratio2_high, 8);
            when "00001110" =>
                channel_2 <= resize(pzt_low, 8);
            when "00001111" =>
                channel_2 <= resize(pzt_high, 8);
            when "00010000" =>
                channel_2 <= resize(eta1_adc_low, 8);
            when "00010001" =>
                channel_2 <= resize(eta1_adc_high, 8);
            when "00010010" =>
                channel_2 <= resize(ref1_adc_low, 8);
            when "00010011" =>
                channel_2 <= resize(ref1_adc_high, 8);
            when "00010100" =>
                channel_2 <= resize(eta2_adc_low, 8);
            when "00010101" =>
                channel_2 <= resize(eta2_adc_high, 8);
            when "00010110" =>
                channel_2 <= resize(ref2_adc_low, 8);
            when "00010111" =>
                channel_2 <= resize(ref2_adc_high, 8);
            when "00011000" =>
                channel_2 <= wlm_adc;
            when "00011001" =>
                channel_2 <= system_clocks;
            when "00011010" =>
                channel_2 <= pwm_signals;
            when others =>
                channel_2 <= i2c_signals;
        end case;
        case intronix_3 is
            when "00000000" =>
                channel_3 <= resize(tuner_low, 8);
            when "00000001" =>
                channel_3 <= resize(tuner_high, 8);
            when "00000010" =>
                channel_3 <= rd_adc_low;
            when "00000011" =>
                channel_3 <= resize(rd_adc_high, 8);
            when "00000100" =>
                channel_3 <= rd_sim_low;
            when "00000101" =>
                channel_3 <= resize(rd_sim_high, 8);
            when "00000110" =>
                channel_3 <= resize(sel_fine_current_low, 8);
            when "00000111" =>
                channel_3 <= resize(sel_fine_current_high, 8);
            when "00001000" =>
                channel_3 <= resize(lock_error_low, 8);
            when "00001001" =>
                channel_3 <= resize(lock_error_high, 8);
            when "00001010" =>
                channel_3 <= resize(ratio1_low, 8);
            when "00001011" =>
                channel_3 <= resize(ratio1_high, 8);
            when "00001100" =>
                channel_3 <= resize(ratio2_low, 8);
            when "00001101" =>
                channel_3 <= resize(ratio2_high, 8);
            when "00001110" =>
                channel_3 <= resize(pzt_low, 8);
            when "00001111" =>
                channel_3 <= resize(pzt_high, 8);
            when "00010000" =>
                channel_3 <= resize(eta1_adc_low, 8);
            when "00010001" =>
                channel_3 <= resize(eta1_adc_high, 8);
            when "00010010" =>
                channel_3 <= resize(ref1_adc_low, 8);
            when "00010011" =>
                channel_3 <= resize(ref1_adc_high, 8);
            when "00010100" =>
                channel_3 <= resize(eta2_adc_low, 8);
            when "00010101" =>
                channel_3 <= resize(eta2_adc_high, 8);
            when "00010110" =>
                channel_3 <= resize(ref2_adc_low, 8);
            when "00010111" =>
                channel_3 <= resize(ref2_adc_high, 8);
            when "00011000" =>
                channel_3 <= wlm_adc;
            when "00011001" =>
                channel_3 <= system_clocks;
            when "00011010" =>
                channel_3 <= pwm_signals;
            when others =>
                channel_3 <= i2c_signals;
        end case;
        channel_4 <= unsigned'(rd_trig & diag_1(4-1 downto 0) & bank & laser_locked & acc_en & tuner_in_window);
    end if;
end process MAIN_LOGIC;



laser_tuning_offset <= laserlocker_tuning_offset;
wlm_sim_actual <= laserlocker_options(LASERLOCKER_OPTIONS_SIM_ACTUAL_B);


MAIN_LASERLOCKER_LOGIC: process (clk0, reset) is
    variable temp: std_logic;
begin
    if bool(reset) then
        laserlocker_cs <= to_unsigned(0, 16);
        laserlocker_options <= to_unsigned(0, 5);
        laserlocker_eta1 <= to_unsigned(0, 16);
        laserlocker_ref1 <= to_unsigned(0, 16);
        laserlocker_eta2 <= to_unsigned(0, 16);
        laserlocker_ref2 <= to_unsigned(0, 16);
        laserlocker_eta1_dark <= to_unsigned(0, 16);
        laserlocker_ref1_dark <= to_unsigned(0, 16);
        laserlocker_eta2_dark <= to_unsigned(0, 16);
        laserlocker_ref2_dark <= to_unsigned(0, 16);
        laserlocker_eta1_offset <= to_unsigned(0, 16);
        laserlocker_ref1_offset <= to_unsigned(0, 16);
        laserlocker_eta2_offset <= to_unsigned(0, 16);
        laserlocker_ref2_offset <= to_unsigned(0, 16);
        laserlocker_ratio1 <= to_unsigned(0, 16);
        laserlocker_ratio2 <= to_unsigned(0, 16);
        laserlocker_ratio1_center <= to_unsigned(0, 16);
        laserlocker_ratio1_multiplier <= to_unsigned(0, 16);
        laserlocker_ratio2_center <= to_unsigned(0, 16);
        laserlocker_ratio2_multiplier <= to_unsigned(0, 16);
        laserlocker_tuning_offset <= to_unsigned(32768, 16);
        laserlocker_lock_error <= to_unsigned(0, 16);
        laserlocker_wm_lock_window <= to_unsigned(0, 16);
        laserlocker_wm_int_gain <= to_unsigned(0, 16);
        laserlocker_wm_prop_gain <= to_unsigned(0, 16);
        laserlocker_wm_deriv_gain <= to_unsigned(0, 16);
        laserlocker_fine_current <= to_unsigned(0, 16);
        laserlocker_cycle_counter <= to_unsigned(MAX_CYCLES, 16);
        laserlocker_div_ce <= '0';
        laserlocker_div_num <= to_unsigned(0, 16);
        laserlocker_div_den <= to_unsigned(0, 16);
        laserlocker_prev_lock_error <= to_unsigned(0, 16);
        laserlocker_prev_lock_error_deriv <= to_unsigned(0, 16);
        laserlocker_deriv <= to_unsigned(0, 16);
        laserlocker_deriv2 <= to_unsigned(0, 16);
        laser_freq_ok <= '0';
        metadata_strobe <= '0';
        laserlocker_prbs_reg <= to_unsigned(1, 8);
        laserlocker_prbs_augment <= '0';
        laserlocker_awaiting_strobe <= '1';
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_cs_addr) then
                if bool(dsp_wr) then
                    laserlocker_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_options_addr) then
                if bool(dsp_wr) then
                    laserlocker_options <= resize(dsp_data_out, 5);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_options, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta1_addr) then
                if bool(dsp_wr) then
                    laserlocker_eta1 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_eta1, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref1_addr) then
                if bool(dsp_wr) then
                    laserlocker_ref1 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ref1, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta2_addr) then
                if bool(dsp_wr) then
                    laserlocker_eta2 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_eta2, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref2_addr) then
                if bool(dsp_wr) then
                    laserlocker_ref2 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ref2, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta1_dark_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_eta1_dark, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref1_dark_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_ref1_dark, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta2_dark_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_eta2_dark, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref2_dark_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_ref2_dark, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta1_offset_addr) then
                if bool(dsp_wr) then
                    laserlocker_eta1_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_eta1_offset, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref1_offset_addr) then
                if bool(dsp_wr) then
                    laserlocker_ref1_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ref1_offset, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_eta2_offset_addr) then
                if bool(dsp_wr) then
                    laserlocker_eta2_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_eta2_offset, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ref2_offset_addr) then
                if bool(dsp_wr) then
                    laserlocker_ref2_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ref2_offset, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio1_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_ratio1, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio2_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_ratio2, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio1_center_addr) then
                if bool(dsp_wr) then
                    laserlocker_ratio1_center <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ratio1_center, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio1_multiplier_addr) then
                if bool(dsp_wr) then
                    laserlocker_ratio1_multiplier <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ratio1_multiplier, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio2_center_addr) then
                if bool(dsp_wr) then
                    laserlocker_ratio2_center <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ratio2_center, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_ratio2_multiplier_addr) then
                if bool(dsp_wr) then
                    laserlocker_ratio2_multiplier <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_ratio2_multiplier, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_tuning_offset_addr) then
                if bool(dsp_wr) then
                    laserlocker_tuning_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_tuning_offset, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_lock_error_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_lock_error, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_wm_lock_window_addr) then
                if bool(dsp_wr) then
                    laserlocker_wm_lock_window <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_wm_lock_window, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_wm_int_gain_addr) then
                if bool(dsp_wr) then
                    laserlocker_wm_int_gain <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_wm_int_gain, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_wm_prop_gain_addr) then
                if bool(dsp_wr) then
                    laserlocker_wm_prop_gain <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_wm_prop_gain, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_wm_deriv_gain_addr) then
                if bool(dsp_wr) then
                    laserlocker_wm_deriv_gain <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_laserlocker <= resize(laserlocker_wm_deriv_gain, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_fine_current_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_fine_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = laserlocker_cycle_counter_addr) then
                dsp_data_in_laserlocker <= resize(laserlocker_cycle_counter, 32);
            else
                dsp_data_in_laserlocker <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_laserlocker <= to_unsigned(0, 32);
        end if;
        if bool(laserlocker_cs(LASERLOCKER_CS_RUN_B)) then
            if bool(laserlocker_cs(LASERLOCKER_CS_CONT_B)) then
                laserlocker_eta1 <= eta1;
                laserlocker_ref1 <= ref1;
                laserlocker_eta2 <= eta2;
                laserlocker_ref2 <= ref2;
                laserlocker_cs(LASERLOCKER_CS_ACC_EN_B) <= acc_en;
                laserlocker_cs(LASERLOCKER_CS_ADC_STROBE_B) <= wlm_data_available;
                if (not bool(laserlocker_options(LASERLOCKER_OPTIONS_MANUAL_LOCK_B))) then
                    laserlocker_cs(LASERLOCKER_CS_ACC_EN_B) <= acc_en;
                end if;
            end if;
            if bool(laserlocker_cs(LASERLOCKER_CS_TUNING_OFFSET_SEL_B)) then
                laserlocker_tuning_offset <= tuner_value;
            end if;
            if bool(laserlocker_cs(LASERLOCKER_CS_SAMPLE_DARK_B)) then
                laserlocker_eta1_dark <= laserlocker_eta1;
                laserlocker_ref1_dark <= laserlocker_ref1;
                laserlocker_eta2_dark <= laserlocker_eta2;
                laserlocker_ref2_dark <= laserlocker_ref2;
            end if;
            laserlocker_div_ce <= stdl((laserlocker_cycle_counter = 1) or (signed(resize(laserlocker_cycle_counter, 17)) = (DIV_LATENCY + 1)));
            if (laserlocker_cycle_counter = 0) then
                laserlocker_div_num <= (laserlocker_eta1 - laserlocker_eta1_offset);
                laserlocker_div_den <= (laserlocker_ref1 - laserlocker_ref1_offset);
                if (laserlocker_options((LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B + LASERLOCKER_OPTIONS_RATIO_OUT_SEL_W)-1 downto LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B) = 1) then
                    ratio1 <= (laserlocker_eta1 - laserlocker_eta1_offset);
                    meta1 <= (laserlocker_ref1 - laserlocker_ref1_offset);
                end if;
            elsif (laserlocker_cycle_counter = 1) then
                meta6 <= (shift_right(laserlocker_div_num, 1) + shift_right(laserlocker_div_den, 1));
            elsif (laserlocker_cycle_counter = DIV_LATENCY) then
                laserlocker_div_num <= (laserlocker_eta2 - laserlocker_eta2_offset);
                laserlocker_div_den <= (laserlocker_ref2 - laserlocker_ref2_offset);
                if (laserlocker_options((LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B + LASERLOCKER_OPTIONS_RATIO_OUT_SEL_W)-1 downto LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B) = 2) then
                    ratio1 <= (laserlocker_eta2 - laserlocker_eta2_offset);
                    meta1 <= (laserlocker_ref2 - laserlocker_ref2_offset);
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (DIV_LATENCY + 1)) then
                average2 <= (shift_right(laserlocker_div_num, 1) + shift_right(laserlocker_div_den, 1));
                laserlocker_ratio1 <= laserlocker_div_quot;
                if (laserlocker_options((LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B + LASERLOCKER_OPTIONS_RATIO_OUT_SEL_W)-1 downto LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B) = 0) then
                    ratio1 <= laserlocker_div_quot;
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (DIV_LATENCY + 3)) then
                laserlocker_mult_a <= (laserlocker_ratio1 - laserlocker_ratio1_center);
                laserlocker_mult_b <= laserlocker_ratio1_multiplier;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((DIV_LATENCY + 3) + MULT_LATENCY)) then
                laserlocker_lock_error <= (laserlocker_lock_error + laserlocker_mult_p);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((2 * DIV_LATENCY) + 1)) then
                laserlocker_ratio2 <= laserlocker_div_quot;
                if (laserlocker_options((LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B + LASERLOCKER_OPTIONS_RATIO_OUT_SEL_W)-1 downto LASERLOCKER_OPTIONS_RATIO_OUT_SEL_B) = 0) then
                    meta1 <= laserlocker_div_quot;
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((2 * DIV_LATENCY) + 3)) then
                laserlocker_mult_a <= (laserlocker_ratio2 - laserlocker_ratio2_center);
                laserlocker_mult_b <= laserlocker_ratio2_multiplier;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = (((2 * DIV_LATENCY) + 3) + MULT_LATENCY)) then
                laserlocker_lock_error <= (laserlocker_lock_error + laserlocker_mult_p);
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + MULT_LATENCY) + 1)) then
                meta5 <= laserlocker_lock_error;
                if bool(laserlocker_cs(LASERLOCKER_CS_PRBS_B)) then
                    if bool(laserlocker_prbs_reg(0)) then
                        laserlocker_lock_error <= to_unsigned(256, 16);
                    else
                        laserlocker_lock_error <= to_unsigned(65280, 16);
                    end if;
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + MULT_LATENCY) + 2)) then
                if (signed(laserlocker_lock_error) >= 0) then
                    laser_freq_ok <= stdl(laserlocker_lock_error <= laserlocker_wm_lock_window);
                else
                    laser_freq_ok <= stdl((-signed(laserlocker_lock_error)) <= signed(resize(laserlocker_wm_lock_window, 17)));
                end if;
                laserlocker_mult_a <= laserlocker_lock_error;
                laserlocker_mult_b <= laserlocker_wm_int_gain;
                laserlocker_deriv <= (laserlocker_lock_error - laserlocker_prev_lock_error);
                laserlocker_prev_lock_error <= laserlocker_lock_error;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + (2 * MULT_LATENCY)) + 2)) then
                laserlocker_mult_a <= laserlocker_deriv;
                laserlocker_mult_b <= laserlocker_wm_prop_gain;
                laserlocker_deriv2 <= (laserlocker_deriv - laserlocker_prev_lock_error_deriv);
                laserlocker_prev_lock_error_deriv <= laserlocker_deriv;
                laserlocker_sat <= (signed(resize(laserlocker_fine_current, 18)) + resize(signed(laserlocker_mult_p), 18));
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + (2 * MULT_LATENCY)) + 3)) then
                if (laserlocker_sat < 0) then
                    laserlocker_fine_current <= to_unsigned(0, 16);
                elsif (laserlocker_sat >= 65535) then
                    laserlocker_fine_current <= to_unsigned(65535, 16);
                else
                    laserlocker_fine_current <= resize(unsigned(laserlocker_sat), 16);
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + (3 * MULT_LATENCY)) + 2)) then
                laserlocker_mult_a <= laserlocker_deriv2;
                laserlocker_mult_b <= laserlocker_wm_deriv_gain;
                laserlocker_sat <= (signed(resize(laserlocker_fine_current, 18)) + resize(signed(laserlocker_mult_p), 18));
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + (3 * MULT_LATENCY)) + 3)) then
                if (laserlocker_sat < 0) then
                    laserlocker_fine_current <= to_unsigned(0, 16);
                elsif (laserlocker_sat >= 65535) then
                    laserlocker_fine_current <= to_unsigned(65535, 16);
                else
                    laserlocker_fine_current <= resize(unsigned(laserlocker_sat), 16);
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + (4 * MULT_LATENCY)) + 2)) then
                laserlocker_sat <= (signed(resize(laserlocker_fine_current, 18)) + resize(signed(laserlocker_mult_p), 18));
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + (4 * MULT_LATENCY)) + 3)) then
                if (laserlocker_sat < 0) then
                    laserlocker_fine_current <= to_unsigned(0, 16);
                elsif (laserlocker_sat >= 65535) then
                    laserlocker_fine_current <= to_unsigned(65535, 16);
                else
                    laserlocker_fine_current <= resize(unsigned(laserlocker_sat), 16);
                end if;
            elsif (signed(resize(laserlocker_cycle_counter, 17)) = ((((2 * DIV_LATENCY) + 3) + (4 * MULT_LATENCY)) + 4)) then
                laser_locking_pid <= laserlocker_fine_current;
                if bool(laserlocker_cs(LASERLOCKER_CS_PRBS_B)) then
                    if bool(laserlocker_prbs_reg(0)) then
                        laser_fine_current <= to_unsigned(33024, 16);
                    else
                        laser_fine_current <= to_unsigned(32512, 16);
                    end if;
                    temp := stdl((laserlocker_prbs_reg = 238) and (not bool(laserlocker_prbs_augment)));
                    laserlocker_prbs_augment <= temp;
                    if (not bool(temp)) then
                        if bool(laserlocker_prbs_reg(7)) then
                            laserlocker_prbs_reg <= unsigned'((laserlocker_prbs_reg(7-1 downto 0) xor to_unsigned(52, 7)) & to_unsigned(1, 1));
                        else
                            laserlocker_prbs_reg <= unsigned'(laserlocker_prbs_reg(7-1 downto 0) & to_unsigned(0, 1));
                        end if;
                    end if;
                else
                    laser_fine_current <= laserlocker_fine_current;
                    laserlocker_prbs_reg <= to_unsigned(1, 8);
                    laserlocker_prbs_augment <= '0';
                end if;
            end if;
            if (laserlocker_cycle_counter < MAX_CYCLES) then
                laserlocker_cycle_counter <= (laserlocker_cycle_counter + 1);
            else
                metadata_strobe <= '1';
                if bool(laserlocker_cs(LASERLOCKER_CS_ADC_STROBE_B)) then
                    if bool(laserlocker_awaiting_strobe) then
                        laserlocker_awaiting_strobe <= '0';
                        meta5 <= laserlocker_lock_error;
                        laserlocker_cycle_counter <= to_unsigned(0, 16);
                        metadata_strobe <= '0';
                        if bool(laserlocker_tuning_offset(15)) then
                            laserlocker_lock_error <= unsigned'('0' & '0' & '0' & '0' & laserlocker_tuning_offset(15-1 downto 3));
                        else
                            laserlocker_lock_error <= unsigned'('1' & '1' & '1' & '1' & laserlocker_tuning_offset(15-1 downto 3));
                        end if;
                    end if;
                else
                    laserlocker_awaiting_strobe <= '1';
                end if;
            end if;
            if (not bool(laserlocker_cs(LASERLOCKER_CS_ACC_EN_B))) then
                laserlocker_fine_current <= to_unsigned(32768, 16);
                laser_fine_current <= to_unsigned(32768, 16);
            end if;
            if bool(laserlocker_options(LASERLOCKER_OPTIONS_DIRECT_TUNE_B)) then
                laser_fine_current <= laserlocker_tuning_offset;
            end if;
            if (not bool(laserlocker_cs(LASERLOCKER_CS_CONT_B))) then
                laserlocker_cs(LASERLOCKER_CS_RUN_B) <= '0';
            end if;
            laserlocker_cs(LASERLOCKER_CS_CURRENT_OK_B) <= metadata_strobe;
            laserlocker_cs(LASERLOCKER_CS_LASER_FREQ_OK_B) <= laser_freq_ok;
        end if;
    end if;
end process MAIN_LASERLOCKER_LOGIC;



signed_mult18x18_3 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => laserlocker_signedMultiplier_a_s, B => laserlocker_signedMultiplier_b_s, P => laserlocker_signedMultiplier_p_s
    );



laserlocker_signedMultiplier_a_s <= signed(unsigned'(laserlocker_mult_a & '0' & '0'));
laserlocker_signedMultiplier_b_s <= signed(unsigned'(laserlocker_mult_b & '0' & '0'));
laserlocker_mult_p <= (unsigned'(laserlocker_signedMultiplier_p_s(35) & unsigned(laserlocker_signedMultiplier_p_s(34-1 downto 19))) mod 65536);
laserlocker_mult_o <= stdl(laserlocker_signedMultiplier_p_s(35) /= laserlocker_signedMultiplier_p_s(34));


MAIN_LASERLOCKER_DIVIDER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        laserlocker_divider_rfd <= '1';
        laserlocker_div_rfd <= '1';
        laserlocker_divider_Nreg <= to_unsigned(0, 17);
        laserlocker_divider_Dreg <= to_unsigned(0, 16);
        laserlocker_divider_Qreg <= to_unsigned(0, 16);
        laserlocker_div_quot <= to_unsigned(0, 16);
        laserlocker_divider_done <= '0';
        laserlocker_divider_i <= to_unsigned(width - 1, 4);
    elsif rising_edge(clk0) then
        if bool(laserlocker_divider_done) then
            laserlocker_div_quot <= laserlocker_divider_Qreg;
            laserlocker_divider_rfd <= '1';
            laserlocker_div_rfd <= '1';
            laserlocker_divider_done <= '0';
        elsif (bool(laserlocker_divider_rfd) and bool(laserlocker_div_ce)) then
            laserlocker_divider_Nreg <= resize(laserlocker_div_num, 17);
            laserlocker_divider_Dreg <= laserlocker_div_den;
            laserlocker_divider_rfd <= '0';
            laserlocker_div_rfd <= '0';
            laserlocker_divider_i <= to_unsigned(width - 1, 4);
            laserlocker_divider_done <= '0';
        elsif (not bool(laserlocker_divider_rfd)) then
            if (laserlocker_divider_Nreg >= laserlocker_divider_Dreg) then
                laserlocker_divider_Qreg(to_integer(laserlocker_divider_i)) <= '1';
                laserlocker_divider_Nreg <= resize(unsigned(shift_left((signed(resize(laserlocker_divider_Nreg, 18)) - signed(resize(laserlocker_divider_Dreg, 17))), 1)), 17);
            else
                laserlocker_divider_Qreg(to_integer(laserlocker_divider_i)) <= '0';
                laserlocker_divider_Nreg <= shift_left(laserlocker_divider_Nreg, 1);
            end if;
            if (laserlocker_divider_i = 0) then
                laserlocker_divider_done <= '1';
                laserlocker_divider_i <= to_unsigned(width - 1, 4);
            else
                laserlocker_divider_i <= (laserlocker_divider_i - 1);
            end if;
        end if;
    end if;
end process MAIN_LASERLOCKER_DIVIDER_LOGIC;



engine1_pwm_out <= pwm_engine1_pwm;
engine1_pwm_inv <= (pwm_engine1_pwm xor pwm_engine1_cs(PWM_CS_CONT_B));
pwm_engine1_temp <= (resize(pwm_engine1_dither_cntr, 9) + resize(pwm_engine1_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_ENGINE1_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_engine1_cs <= to_unsigned(0, 16);
        pwm_engine1_pulse_width <= to_unsigned(0, 16);
        pwm_engine1_main_cntr <= to_unsigned(0, 8);
        pwm_engine1_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 27) then
                if bool(dsp_wr) then
                    pwm_engine1_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_engine1 <= resize(pwm_engine1_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 28) then
                if bool(dsp_wr) then
                    pwm_engine1_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_engine1 <= resize(pwm_engine1_pulse_width, 32);
            else
                dsp_data_in_pwm_engine1 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_engine1 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_engine1_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_engine1_cs(PWM_CS_CONT_B))) then
                pwm_engine1_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_engine1_pwm <= '0';
            if (pwm_engine1_main_cntr < pwm_engine1_pulse_width(width-1 downto (width - main_width))) then
                pwm_engine1_pwm <= '1';
            elsif (pwm_engine1_main_cntr = pwm_engine1_pulse_width(width-1 downto dither_width)) then
                if (pwm_engine1_temp >= mod_dither) then
                    pwm_engine1_pwm <= '1';
                    pwm_engine1_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_engine1_dither_cntr <= resize(pwm_engine1_temp - mod_dither, 8);
                else
                    pwm_engine1_dither_cntr <= resize(pwm_engine1_temp, 8);
                end if;
            end if;
            pwm_engine1_main_cntr <= ((pwm_engine1_main_cntr + 1) mod mod_main);
        end if;
        pwm_engine1_cs(PWM_CS_PWM_OUT_B) <= pwm_engine1_pwm;
    end if;
end process MAIN_PWM_ENGINE1_LOGIC;



engine2_pwm_out <= pwm_engine2_pwm;
engine2_pwm_inv <= (pwm_engine2_pwm xor pwm_engine2_cs(PWM_CS_CONT_B));
pwm_engine2_temp <= (resize(pwm_engine2_dither_cntr, 9) + resize(pwm_engine2_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_ENGINE2_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_engine2_cs <= to_unsigned(0, 16);
        pwm_engine2_pulse_width <= to_unsigned(0, 16);
        pwm_engine2_main_cntr <= to_unsigned(0, 8);
        pwm_engine2_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 29) then
                if bool(dsp_wr) then
                    pwm_engine2_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_engine2 <= resize(pwm_engine2_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 30) then
                if bool(dsp_wr) then
                    pwm_engine2_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_engine2 <= resize(pwm_engine2_pulse_width, 32);
            else
                dsp_data_in_pwm_engine2 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_engine2 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_engine2_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_engine2_cs(PWM_CS_CONT_B))) then
                pwm_engine2_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_engine2_pwm <= '0';
            if (pwm_engine2_main_cntr < pwm_engine2_pulse_width(width-1 downto (width - main_width))) then
                pwm_engine2_pwm <= '1';
            elsif (pwm_engine2_main_cntr = pwm_engine2_pulse_width(width-1 downto dither_width)) then
                if (pwm_engine2_temp >= mod_dither) then
                    pwm_engine2_pwm <= '1';
                    pwm_engine2_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_engine2_dither_cntr <= resize(pwm_engine2_temp - mod_dither, 8);
                else
                    pwm_engine2_dither_cntr <= resize(pwm_engine2_temp, 8);
                end if;
            end if;
            pwm_engine2_main_cntr <= ((pwm_engine2_main_cntr + 1) mod mod_main);
        end if;
        pwm_engine2_cs(PWM_CS_PWM_OUT_B) <= pwm_engine2_pwm;
    end if;
end process MAIN_PWM_ENGINE2_LOGIC;


MAIN_INJECT_COMB1: process (inject_control, inject_sw1_2way, inject_laser2_fine, inject_sw4_4way, inject_laser3_coarse_current, inject_laser3_fine, inject_laser1_fine, inject_control2, inject_laser2_coarse_current, pwm_laser4_out, inject_sw2_2way, inject_laser1_coarse_current, inject_laser4_fine, inject_laser4_coarse_current) is
    variable e: std_logic;
    variable ext_mode: std_logic;
    variable bl: natural;
    variable m: std_logic;
    variable bh: integer;
    variable s: unsigned(15 downto 0);
begin
    s := resize(inject_control((INJECT_CONTROL_LASER_SELECT_B + INJECT_CONTROL_LASER_SELECT_W)-1 downto INJECT_CONTROL_LASER_SELECT_B), 16);
    m := inject_control(INJECT_CONTROL_MODE_B);
    e := inject_control2(INJECT_CONTROL2_EXTINGUISH_DESELECTED_B);
    ext_mode := inject_control2(INJECT_CONTROL2_EXTENDED_CURRENT_MODE_B);
    inject_mode <= m;
    inject_sel <= resize(s, 2);
    inject_extinguish_deselected <= e;
    inject_extended_mode <= ext_mode;
    extended_current_mode <= ext_mode;
    bl := INJECT_CONTROL2_OPTICAL_SWITCH_SELECT_B;
    bh := (bl + INJECT_CONTROL2_OPTICAL_SWITCH_SELECT_W);
    if (inject_control2(bh-1 downto bl) = SWITCH_4WAY_XTALATCH) then
        sw1 <= s(0);
        sw2 <= s(1);
    elsif (inject_control2(bh-1 downto bl) = SWITCH_2WAY_XTALATCH) then
        sw1 <= inject_sw1_2way;
        sw2 <= inject_sw2_2way;
    else
        sw1 <= stdl((s(2-1 downto 0) = 2) or (s(2-1 downto 0) = 1));
        sw2 <= stdl((s(2-1 downto 0) = 2) or (s(2-1 downto 0) = 1));
    end if;
    sw4 <= inject_sw4_4way;
    if bool(inject_control2(INJECT_CONTROL2_FIBER_AMP_PRESENT_B)) then
        sw4 <= pwm_laser4_out;
    end if;
    inject_laser_current_en <= inject_control((INJECT_CONTROL_LASER_CURRENT_ENABLE_B + INJECT_CONTROL_LASER_CURRENT_ENABLE_W)-1 downto INJECT_CONTROL_LASER_CURRENT_ENABLE_B);
    inject_manual_laser_en <= inject_control((INJECT_CONTROL_MANUAL_LASER_ENABLE_B + INJECT_CONTROL_MANUAL_LASER_ENABLE_W)-1 downto INJECT_CONTROL_MANUAL_LASER_ENABLE_B);
    inject_manual_soa_en <= inject_control(INJECT_CONTROL_MANUAL_SOA_ENABLE_B);
    inject_laser_shutdown_en <= inject_control(INJECT_CONTROL_LASER_SHUTDOWN_ENABLE_B);
    inject_soa_shutdown_en <= inject_control(INJECT_CONTROL_SOA_SHUTDOWN_ENABLE_B);
    inject_soa_present <= inject_control(INJECT_CONTROL_SOA_PRESENT_B);
    inject_extra_mode <= inject_control2(INJECT_CONTROL2_EXTRA_MODE_B);
    inject_extra_enable <= inject_control2(INJECT_CONTROL2_EXTRA_ENABLE_B);
    inject_disable_soa_with_laser_mask <= inject_control2((INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_B + INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_W)-1 downto INJECT_CONTROL2_DISABLE_SOA_WITH_LASER_B);
    sel_laser <= resize(s, 2);
    if (s = 0) then
        sel_coarse_current <= inject_laser1_coarse_current;
        sel_fine_current <= inject_laser1_fine;
    elsif (s = 1) then
        sel_coarse_current <= inject_laser2_coarse_current;
        sel_fine_current <= inject_laser2_fine;
    elsif (s = 2) then
        sel_coarse_current <= inject_laser3_coarse_current;
        sel_fine_current <= inject_laser3_fine;
    elsif (s = 3) then
        sel_coarse_current <= inject_laser4_coarse_current;
        sel_fine_current <= inject_laser4_fine;
    end if;
end process MAIN_INJECT_COMB1;


MAIN_INJECT_COMB2: process (inject_extra_enable, inject_manual_laser_en, inject_extinguish_deselected, inject_laser3_coarse_current, laser_extra, rd_trig, inject_disable_soa_with_laser_mask, inject_manual_soa_en, inject_laser2_coarse_current, inject_laser_current_en, inject_soa_present, inject_laser1_coarse_current, inject_extra_mode, inject_soa_shutdown_en, inject_laser4_coarse_current, inject_sel, inject_laser_shutdown_en, inject_mode) is
    variable laser_shutdown: std_logic;
begin
    lsr1_disable_temp <= stdl((not bool(inject_laser_current_en(0))));
    lsr2_disable_temp <= stdl((not bool(inject_laser_current_en(1))));
    lsr3_disable_temp <= stdl((not bool(inject_laser_current_en(2))));
    lsr4_disable_temp <= stdl((not bool(inject_laser_current_en(3))));
    inject_laser1_coarse <= inject_laser1_coarse_current;
    inject_laser2_coarse <= inject_laser2_coarse_current;
    inject_laser3_coarse <= inject_laser3_coarse_current;
    inject_laser4_coarse <= inject_laser4_coarse_current;
    sw3 <= stdl((not bool(inject_manual_soa_en)));
    laser_shutdown := stdl(bool(rd_trig) and bool(inject_laser_shutdown_en));
    if bool(inject_mode) then
        sw3 <= stdl(bool(rd_trig) and bool(inject_soa_shutdown_en));
        lsr1_rd <= laser_shutdown;
        lsr2_rd <= laser_shutdown;
        lsr3_rd <= laser_shutdown;
        lsr4_rd <= laser_shutdown;
        if bool(inject_extinguish_deselected) then
            case inject_sel is
                when "00" =>
                    inject_laser2_coarse <= to_unsigned(0, 16);
                    inject_laser3_coarse <= to_unsigned(0, 16);
                    inject_laser4_coarse <= to_unsigned(0, 16);
                when "01" =>
                    inject_laser1_coarse <= to_unsigned(0, 16);
                    inject_laser3_coarse <= to_unsigned(0, 16);
                    inject_laser4_coarse <= to_unsigned(0, 16);
                when "10" =>
                    inject_laser1_coarse <= to_unsigned(0, 16);
                    inject_laser2_coarse <= to_unsigned(0, 16);
                    inject_laser4_coarse <= to_unsigned(0, 16);
                when others =>
                    inject_laser1_coarse <= to_unsigned(0, 16);
                    inject_laser2_coarse <= to_unsigned(0, 16);
                    inject_laser3_coarse <= to_unsigned(0, 16);
            end case;
        end if;
    else
        lsr1_rd <= stdl((not bool(inject_manual_laser_en(0))));
        lsr2_rd <= stdl((not bool(inject_manual_laser_en(1))));
        lsr3_rd <= stdl((not bool(inject_manual_laser_en(2))));
        lsr4_rd <= stdl((not bool(inject_manual_laser_en(3))));
    end if;
    if ((not bool(inject_soa_present)) or ((inject_sel = 0) and bool(inject_disable_soa_with_laser_mask(0))) or ((inject_sel = 1) and bool(inject_disable_soa_with_laser_mask(1))) or ((inject_sel = 2) and bool(inject_disable_soa_with_laser_mask(2))) or ((inject_sel = 3) and bool(inject_disable_soa_with_laser_mask(3)))) then
        sw3 <= '1';
    end if;
    if bool(inject_extra_mode) then
        inject_use_extra <= inject_extra_enable;
    else
        inject_use_extra <= stdl(bool(inject_laser_shutdown_en) and bool(laser_extra));
    end if;
end process MAIN_INJECT_COMB2;



signed_mult18x18_2 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => inject_fine_scale_multiplier_a_s, B => inject_fine_scale_multiplier_b_s, P => inject_fine_scale_multiplier_p_s
    );


MAIN_INJECT_FINE_SCALE_MULTIPLIER_COMB: process (inject_fs_mult_a, inject_fs_mult_b, inject_fine_scale_multiplier_p_s) is
begin
    inject_fine_scale_multiplier_a_s(17-1 downto 0) <= signed(inject_fs_mult_a);
    inject_fine_scale_multiplier_a_s(17) <= '0';
    inject_fine_scale_multiplier_b_s(17-1 downto 0) <= signed(inject_fs_mult_b);
    inject_fine_scale_multiplier_b_s(17) <= '0';
    inject_fs_mult_p <= unsigned(inject_fine_scale_multiplier_p_s(34-1 downto 0));
end process MAIN_INJECT_FINE_SCALE_MULTIPLIER_COMB;


MAIN_INJECT_LASER3_DAC_COMB2: process (inject_laser3_dac_counter, inject_laser3_dac_chanB_data, inject_laser3_dac_chanA_data) is
begin
    if ((CHANA_CONTROL_START <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < CHANA_CONTROL_END)) then
        case ((CHANA_CONTROL_END - 1) - to_integer(inject_laser3_dac_counter)) is
            when 0 => lsr3_mosi_temp <= '0';
            when 1 => lsr3_mosi_temp <= '0';
            when 2 => lsr3_mosi_temp <= '0';
            when 3 => lsr3_mosi_temp <= '0';
            when 4 => lsr3_mosi_temp <= '0';
            when 5 => lsr3_mosi_temp <= '0';
            when 6 => lsr3_mosi_temp <= '0';
            when others => lsr3_mosi_temp <= '0';
        end case;
    elsif ((CHANA_DATA_START <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < CHANA_DATA_END)) then
        lsr3_mosi_temp <= inject_laser3_dac_chanA_data(((CHANA_DATA_END - 1) - to_integer(inject_laser3_dac_counter)));
    elsif ((CHANB_CONTROL_START <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < CHANB_CONTROL_END)) then
        case ((CHANB_CONTROL_END - 1) - to_integer(inject_laser3_dac_counter)) is
            when 0 => lsr3_mosi_temp <= '0';
            when 1 => lsr3_mosi_temp <= '0';
            when 2 => lsr3_mosi_temp <= '1';
            when 3 => lsr3_mosi_temp <= '0';
            when 4 => lsr3_mosi_temp <= '1';
            when 5 => lsr3_mosi_temp <= '1';
            when 6 => lsr3_mosi_temp <= '0';
            when others => lsr3_mosi_temp <= '0';
        end case;
    elsif ((CHANB_DATA_START <= inject_laser3_dac_counter) and (inject_laser3_dac_counter < CHANB_DATA_END)) then
        lsr3_mosi_temp <= inject_laser3_dac_chanB_data(((CHANB_DATA_END - 1) - to_integer(inject_laser3_dac_counter)));
    else
        lsr3_mosi_temp <= '0';
    end if;
end process MAIN_INJECT_LASER3_DAC_COMB2;


MAIN_INJECT_LASER3_DAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_laser3_dac_counter <= to_unsigned(0, 6);
        lsr3_ss_temp <= '0';
    elsif rising_edge(clk0) then
        case inject_laser3_dac_state is
            when IDLE =>
                lsr3_ss_temp <= '0';
                if bool(inject_dac_strobe) then
                    inject_laser3_dac_chanA_data <= inject_laser3_coarse_scaled;
                    inject_laser3_dac_chanB_data <= inject_laser3_fine;
                    inject_laser3_dac_counter <= to_unsigned(0, 6);
                    lsr3_ss_temp <= '1';
                    inject_laser3_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_5M) then
                    if (inject_laser3_dac_counter < 49) then
                        if (inject_laser3_dac_counter = 24) then
                            lsr3_ss_temp <= '0';
                        end if;
                        inject_laser3_dac_counter <= (inject_laser3_dac_counter + 1);
                        inject_laser3_dac_state <= WAIT_0;
                    else
                        lsr3_ss_temp <= '0';
                        inject_laser3_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not bool(clk_5M)) then
                    lsr3_ss_temp <= '1';
                    inject_laser3_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser3_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER3_DAC_LOGIC;


MAIN_INJECT_LOGIC: process (clk0, reset) is
    variable bl: natural;
    variable bh: integer;
begin
    if bool(reset) then
        inject_control <= to_unsigned(0, 16);
        inject_control2 <= to_unsigned(0, 16);
        inject_laser1_coarse_current <= to_unsigned(0, 16);
        inject_laser2_coarse_current <= to_unsigned(0, 16);
        inject_laser3_coarse_current <= to_unsigned(0, 16);
        inject_laser4_coarse_current <= to_unsigned(0, 16);
        inject_laser1_fine_current <= to_unsigned(32768, 16);
        inject_laser2_fine_current <= to_unsigned(32768, 16);
        inject_laser3_fine_current <= to_unsigned(32768, 16);
        inject_laser4_fine_current <= to_unsigned(32768, 16);
        inject_laser1_fine_current_range <= to_unsigned(32767, 16);
        inject_laser2_fine_current_range <= to_unsigned(32767, 16);
        inject_laser3_fine_current_range <= to_unsigned(32767, 16);
        inject_laser4_fine_current_range <= to_unsigned(32767, 16);
        inject_laser1_extra_coarse_scale <= to_unsigned(0, 16);
        inject_laser2_extra_coarse_scale <= to_unsigned(0, 16);
        inject_laser3_extra_coarse_scale <= to_unsigned(0, 16);
        inject_laser4_extra_coarse_scale <= to_unsigned(0, 16);
        inject_laser1_extra_fine_scale <= to_unsigned(0, 16);
        inject_laser2_extra_fine_scale <= to_unsigned(0, 16);
        inject_laser3_extra_fine_scale <= to_unsigned(0, 16);
        inject_laser4_extra_fine_scale <= to_unsigned(0, 16);
        inject_laser1_extra_offset <= to_unsigned(0, 16);
        inject_laser2_extra_offset <= to_unsigned(0, 16);
        inject_laser3_extra_offset <= to_unsigned(0, 16);
        inject_laser4_extra_offset <= to_unsigned(0, 16);
        inject_strobe_prev <= metadata_strobe;
        inject_edge_strobe <= '0';
        inject_dac_strobe <= '0';
        inject_optical_switch_counter <= to_unsigned(0, 7);
        inject_pulse_counter <= to_unsigned(0, 7);
        inject_extra_current_counter <= to_unsigned(0, 4);
        inject_optSwitchState <= IDLE;
        inject_switchPulserState <= START;
        inject_sw4_4way <= '1';
        inject_use_extra_r <= '0';
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_control_addr) then
                if bool(dsp_wr) then
                    inject_control <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_control, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_control2_addr) then
                if bool(dsp_wr) then
                    inject_control2 <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_control2, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_coarse_current_addr) then
                if bool(dsp_wr) then
                    inject_laser1_coarse_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser1_coarse_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_coarse_current_addr) then
                if bool(dsp_wr) then
                    inject_laser2_coarse_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser2_coarse_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_coarse_current_addr) then
                if bool(dsp_wr) then
                    inject_laser3_coarse_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser3_coarse_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_coarse_current_addr) then
                if bool(dsp_wr) then
                    inject_laser4_coarse_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser4_coarse_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_fine_current_addr) then
                if bool(dsp_wr) then
                    inject_laser1_fine_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser1_fine_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_fine_current_addr) then
                if bool(dsp_wr) then
                    inject_laser2_fine_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser2_fine_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_fine_current_addr) then
                if bool(dsp_wr) then
                    inject_laser3_fine_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser3_fine_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_fine_current_addr) then
                if bool(dsp_wr) then
                    inject_laser4_fine_current <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser4_fine_current, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_fine_current_range_addr) then
                if bool(dsp_wr) then
                    inject_laser1_fine_current_range <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser1_fine_current_range, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_fine_current_range_addr) then
                if bool(dsp_wr) then
                    inject_laser2_fine_current_range <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser2_fine_current_range, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_fine_current_range_addr) then
                if bool(dsp_wr) then
                    inject_laser3_fine_current_range <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser3_fine_current_range, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_fine_current_range_addr) then
                if bool(dsp_wr) then
                    inject_laser4_fine_current_range <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser4_fine_current_range, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_extra_coarse_scale_addr) then
                if bool(dsp_wr) then
                    inject_laser1_extra_coarse_scale <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser1_extra_coarse_scale, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_extra_coarse_scale_addr) then
                if bool(dsp_wr) then
                    inject_laser2_extra_coarse_scale <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser2_extra_coarse_scale, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_extra_coarse_scale_addr) then
                if bool(dsp_wr) then
                    inject_laser3_extra_coarse_scale <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser3_extra_coarse_scale, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_extra_coarse_scale_addr) then
                if bool(dsp_wr) then
                    inject_laser4_extra_coarse_scale <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser4_extra_coarse_scale, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_extra_fine_scale_addr) then
                if bool(dsp_wr) then
                    inject_laser1_extra_fine_scale <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser1_extra_fine_scale, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_extra_fine_scale_addr) then
                if bool(dsp_wr) then
                    inject_laser2_extra_fine_scale <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser2_extra_fine_scale, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_extra_fine_scale_addr) then
                if bool(dsp_wr) then
                    inject_laser3_extra_fine_scale <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser3_extra_fine_scale, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_extra_fine_scale_addr) then
                if bool(dsp_wr) then
                    inject_laser4_extra_fine_scale <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser4_extra_fine_scale, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser1_extra_offset_addr) then
                if bool(dsp_wr) then
                    inject_laser1_extra_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser1_extra_offset, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser2_extra_offset_addr) then
                if bool(dsp_wr) then
                    inject_laser2_extra_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser2_extra_offset, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser3_extra_offset_addr) then
                if bool(dsp_wr) then
                    inject_laser3_extra_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser3_extra_offset, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = inject_laser4_extra_offset_addr) then
                if bool(dsp_wr) then
                    inject_laser4_extra_offset <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_inject <= resize(inject_laser4_extra_offset, 32);
            else
                dsp_data_in_inject <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_inject <= to_unsigned(0, 32);
        end if;
        inject_edge_strobe <= stdl(bool(metadata_strobe) and (not bool(inject_strobe_prev)));
        inject_strobe_prev <= metadata_strobe;
        if bool(inject_mode) then
            if bool(inject_extended_mode) then
                inject_laser1_fine <= laser1_fine_ext;
                inject_laser2_fine <= laser2_fine_ext;
                inject_laser3_fine <= laser3_fine_ext;
                inject_laser4_fine <= laser4_fine_ext;
            else
                if (laser_fine_current > (32768 + inject_laser1_fine_current_range)) then
                    inject_laser1_fine <= (32768 + inject_laser1_fine_current_range);
                elsif (signed(resize(laser_fine_current, 17)) < (32768 - signed(resize(inject_laser1_fine_current_range, 17)))) then
                    inject_laser1_fine <= (32768 - inject_laser1_fine_current_range);
                else
                    inject_laser1_fine <= laser_fine_current;
                end if;
                if (laser_fine_current > (32768 + inject_laser2_fine_current_range)) then
                    inject_laser2_fine <= (32768 + inject_laser2_fine_current_range);
                elsif (signed(resize(laser_fine_current, 17)) < (32768 - signed(resize(inject_laser2_fine_current_range, 17)))) then
                    inject_laser2_fine <= (32768 - inject_laser2_fine_current_range);
                else
                    inject_laser2_fine <= laser_fine_current;
                end if;
                if (laser_fine_current > (32768 + inject_laser3_fine_current_range)) then
                    inject_laser3_fine <= (32768 + inject_laser3_fine_current_range);
                elsif (signed(resize(laser_fine_current, 17)) < (32768 - signed(resize(inject_laser3_fine_current_range, 17)))) then
                    inject_laser3_fine <= (32768 - inject_laser3_fine_current_range);
                else
                    inject_laser3_fine <= laser_fine_current;
                end if;
                if (laser_fine_current > (32768 + inject_laser4_fine_current_range)) then
                    inject_laser4_fine <= (32768 + inject_laser4_fine_current_range);
                elsif (signed(resize(laser_fine_current, 17)) < (32768 - signed(resize(inject_laser4_fine_current_range, 17)))) then
                    inject_laser4_fine <= (32768 - inject_laser4_fine_current_range);
                else
                    inject_laser4_fine <= laser_fine_current;
                end if;
                if bool(inject_extinguish_deselected) then
                    case inject_sel is
                        when "00" =>
                            inject_laser2_fine <= to_unsigned(0, 16);
                            inject_laser3_fine <= to_unsigned(0, 16);
                            inject_laser4_fine <= to_unsigned(0, 16);
                        when "01" =>
                            inject_laser1_fine <= to_unsigned(0, 16);
                            inject_laser3_fine <= to_unsigned(0, 16);
                            inject_laser4_fine <= to_unsigned(0, 16);
                        when "10" =>
                            inject_laser1_fine <= to_unsigned(0, 16);
                            inject_laser2_fine <= to_unsigned(0, 16);
                            inject_laser4_fine <= to_unsigned(0, 16);
                        when others =>
                            inject_laser1_fine <= to_unsigned(0, 16);
                            inject_laser2_fine <= to_unsigned(0, 16);
                            inject_laser3_fine <= to_unsigned(0, 16);
                    end case;
                end if;
            end if;
        else
            inject_laser1_fine <= inject_laser1_fine_current;
            inject_laser2_fine <= inject_laser2_fine_current;
            inject_laser3_fine <= inject_laser3_fine_current;
            inject_laser4_fine <= inject_laser4_fine_current;
        end if;
        case inject_optSwitchState is
            when IDLE =>
                inject_sw1_2way <= '0';
                inject_sw2_2way <= '0';
                if ((inject_sel = 0) or (inject_sel = 3)) then
                    inject_optSwitchState <= PULSING_1;
                    inject_optical_switch_counter <= to_unsigned(0, 7);
                else
                    inject_optSwitchState <= PULSING_2;
                    inject_optical_switch_counter <= to_unsigned(0, 7);
                end if;
            when PULSING_1 =>
                inject_sw1_2way <= '1';
                inject_sw2_2way <= '0';
                if bool(inject_edge_strobe) then
                    if (signed(resize(inject_optical_switch_counter, 8)) >= (OPTICAL_SWITCH_WIDTH - 1)) then
                        inject_optSwitchState <= SELECTED_1;
                        inject_optical_switch_counter <= to_unsigned(0, 7);
                    else
                        inject_optical_switch_counter <= (inject_optical_switch_counter + 1);
                    end if;
                end if;
            when SELECTED_1 =>
                inject_sw1_2way <= '0';
                inject_sw2_2way <= '0';
                if ((inject_sel = 1) or (inject_sel = 2)) then
                    inject_optSwitchState <= PULSING_2;
                    inject_optical_switch_counter <= to_unsigned(0, 7);
                end if;
            when PULSING_2 =>
                inject_sw1_2way <= '0';
                inject_sw2_2way <= '1';
                if bool(inject_edge_strobe) then
                    if (signed(resize(inject_optical_switch_counter, 8)) >= (OPTICAL_SWITCH_WIDTH - 1)) then
                        inject_optSwitchState <= SELECTED_2;
                        inject_optical_switch_counter <= to_unsigned(0, 7);
                    else
                        inject_optical_switch_counter <= (inject_optical_switch_counter + 1);
                    end if;
                end if;
            when others => -- SELECTED_2
                inject_sw1_2way <= '0';
                inject_sw2_2way <= '0';
                if ((inject_sel = 0) or (inject_sel = 3)) then
                    inject_optSwitchState <= PULSING_1;
                    inject_optical_switch_counter <= to_unsigned(0, 7);
                end if;
        end case;
        bl := INJECT_CONTROL2_OPTICAL_SWITCH_SELECT_B;
        bh := (bl + INJECT_CONTROL2_OPTICAL_SWITCH_SELECT_W);
        if (inject_control2(bh-1 downto bl) = SWITCH_4WAY_XTALATCH) then
            case inject_switchPulserState is
                when START =>
                    inject_sw4_4way <= '1';
                    inject_switchPulserState <= PULSING;
                    inject_pulse_counter <= to_unsigned(0, 7);
                when PULSING =>
                    inject_sw4_4way <= '0';
                    inject_last_sel <= inject_sel;
                    if bool(inject_edge_strobe) then
                        if (signed(resize(inject_pulse_counter, 8)) >= (OPTICAL_SWITCH_WIDTH - 1)) then
                            inject_switchPulserState <= WAITING;
                            inject_pulse_counter <= to_unsigned(0, 7);
                        else
                            inject_pulse_counter <= (inject_pulse_counter + 1);
                        end if;
                    end if;
                when others => -- WAITING
                    inject_sw4_4way <= '1';
                    if (inject_sel /= inject_last_sel) then
                        inject_switchPulserState <= PULSING;
                        inject_pulse_counter <= to_unsigned(0, 7);
                    end if;
            end case;
        end if;
        case inject_extra_current_counter is
            when "0000" =>
                if bool(inject_edge_strobe) then
                    inject_use_extra_r <= inject_use_extra;
                    inject_extra_current_counter <= to_unsigned(1, 4);
                    inject_cs_mult_a <= unsigned'(inject_laser1_extra_coarse_scale & to_unsigned(0, 1));
                    inject_cs_mult_b <= unsigned'(inject_laser1_coarse & to_unsigned(0, 1));
                    inject_fs_mult_a <= unsigned'(inject_laser1_extra_fine_scale & to_unsigned(0, 1));
                    inject_fs_mult_b <= unsigned'(inject_laser1_fine & to_unsigned(0, 1));
                end if;
            when "0001" =>
                inject_extra_current_counter <= to_unsigned(2, 4);
                if bool(inject_use_extra_r) then
                    inject_laser1_coarse_scaled <= (((inject_cs_mult_p(33-1 downto 17) + inject_fs_mult_p(34-1 downto 18)) + inject_laser1_extra_offset) mod 65536);
                else
                    inject_laser1_coarse_scaled <= inject_laser1_coarse;
                end if;
            when "0010" =>
                inject_extra_current_counter <= to_unsigned(3, 4);
                inject_cs_mult_a <= unsigned'(inject_laser2_extra_coarse_scale & to_unsigned(0, 1));
                inject_cs_mult_b <= unsigned'(inject_laser2_coarse & to_unsigned(0, 1));
                inject_fs_mult_a <= unsigned'(inject_laser2_extra_fine_scale & to_unsigned(0, 1));
                inject_fs_mult_b <= unsigned'(inject_laser2_fine & to_unsigned(0, 1));
            when "0011" =>
                inject_extra_current_counter <= to_unsigned(4, 4);
                if bool(inject_use_extra_r) then
                    inject_laser2_coarse_scaled <= (((inject_cs_mult_p(33-1 downto 17) + inject_fs_mult_p(34-1 downto 18)) + inject_laser2_extra_offset) mod 65536);
                else
                    inject_laser2_coarse_scaled <= inject_laser2_coarse;
                end if;
            when "0100" =>
                inject_extra_current_counter <= to_unsigned(5, 4);
                inject_cs_mult_a <= unsigned'(inject_laser3_extra_coarse_scale & to_unsigned(0, 1));
                inject_cs_mult_b <= unsigned'(inject_laser3_coarse & to_unsigned(0, 1));
                inject_fs_mult_a <= unsigned'(inject_laser3_extra_fine_scale & to_unsigned(0, 1));
                inject_fs_mult_b <= unsigned'(inject_laser3_fine & to_unsigned(0, 1));
            when "0101" =>
                inject_extra_current_counter <= to_unsigned(6, 4);
                if bool(inject_use_extra_r) then
                    inject_laser3_coarse_scaled <= (((inject_cs_mult_p(33-1 downto 17) + inject_fs_mult_p(34-1 downto 18)) + inject_laser3_extra_offset) mod 65536);
                else
                    inject_laser3_coarse_scaled <= inject_laser3_coarse;
                end if;
            when "0110" =>
                inject_extra_current_counter <= to_unsigned(7, 4);
                inject_cs_mult_a <= unsigned'(inject_laser4_extra_coarse_scale & to_unsigned(0, 1));
                inject_cs_mult_b <= unsigned'(inject_laser4_coarse & to_unsigned(0, 1));
                inject_fs_mult_a <= unsigned'(inject_laser4_extra_fine_scale & to_unsigned(0, 1));
                inject_fs_mult_b <= unsigned'(inject_laser4_fine & to_unsigned(0, 1));
            when "0111" =>
                inject_extra_current_counter <= to_unsigned(8, 4);
                if bool(inject_use_extra_r) then
                    inject_laser4_coarse_scaled <= (((inject_cs_mult_p(33-1 downto 17) + inject_fs_mult_p(34-1 downto 18)) + inject_laser4_extra_offset) mod 65536);
                else
                    inject_laser4_coarse_scaled <= inject_laser4_coarse;
                end if;
            when "1111" =>
                inject_extra_current_counter <= to_unsigned(0, 4);
            when others =>
                inject_extra_current_counter <= (inject_extra_current_counter + 1);
        end case;
        inject_dac_strobe <= stdl(inject_extra_current_counter = 15);
    end if;
end process MAIN_INJECT_LOGIC;


MAIN_INJECT_LASER2_DAC_COMB2: process (inject_laser2_dac_counter, inject_laser2_dac_chanB_data, inject_laser2_dac_chanA_data) is
begin
    if ((CHANA_CONTROL_START <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < CHANA_CONTROL_END)) then
        case ((CHANA_CONTROL_END - 1) - to_integer(inject_laser2_dac_counter)) is
            when 0 => lsr2_mosi_temp <= '0';
            when 1 => lsr2_mosi_temp <= '0';
            when 2 => lsr2_mosi_temp <= '0';
            when 3 => lsr2_mosi_temp <= '0';
            when 4 => lsr2_mosi_temp <= '0';
            when 5 => lsr2_mosi_temp <= '0';
            when 6 => lsr2_mosi_temp <= '0';
            when others => lsr2_mosi_temp <= '0';
        end case;
    elsif ((CHANA_DATA_START <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < CHANA_DATA_END)) then
        lsr2_mosi_temp <= inject_laser2_dac_chanA_data(((CHANA_DATA_END - 1) - to_integer(inject_laser2_dac_counter)));
    elsif ((CHANB_CONTROL_START <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < CHANB_CONTROL_END)) then
        case ((CHANB_CONTROL_END - 1) - to_integer(inject_laser2_dac_counter)) is
            when 0 => lsr2_mosi_temp <= '0';
            when 1 => lsr2_mosi_temp <= '0';
            when 2 => lsr2_mosi_temp <= '1';
            when 3 => lsr2_mosi_temp <= '0';
            when 4 => lsr2_mosi_temp <= '1';
            when 5 => lsr2_mosi_temp <= '1';
            when 6 => lsr2_mosi_temp <= '0';
            when others => lsr2_mosi_temp <= '0';
        end case;
    elsif ((CHANB_DATA_START <= inject_laser2_dac_counter) and (inject_laser2_dac_counter < CHANB_DATA_END)) then
        lsr2_mosi_temp <= inject_laser2_dac_chanB_data(((CHANB_DATA_END - 1) - to_integer(inject_laser2_dac_counter)));
    else
        lsr2_mosi_temp <= '0';
    end if;
end process MAIN_INJECT_LASER2_DAC_COMB2;


MAIN_INJECT_LASER2_DAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_laser2_dac_counter <= to_unsigned(0, 6);
        lsr2_ss_temp <= '0';
    elsif rising_edge(clk0) then
        case inject_laser2_dac_state is
            when IDLE =>
                lsr2_ss_temp <= '0';
                if bool(inject_dac_strobe) then
                    inject_laser2_dac_chanA_data <= inject_laser2_coarse_scaled;
                    inject_laser2_dac_chanB_data <= inject_laser2_fine;
                    inject_laser2_dac_counter <= to_unsigned(0, 6);
                    lsr2_ss_temp <= '1';
                    inject_laser2_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_5M) then
                    if (inject_laser2_dac_counter < 49) then
                        if (inject_laser2_dac_counter = 24) then
                            lsr2_ss_temp <= '0';
                        end if;
                        inject_laser2_dac_counter <= (inject_laser2_dac_counter + 1);
                        inject_laser2_dac_state <= WAIT_0;
                    else
                        lsr2_ss_temp <= '0';
                        inject_laser2_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not bool(clk_5M)) then
                    lsr2_ss_temp <= '1';
                    inject_laser2_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser2_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER2_DAC_LOGIC;


MAIN_INJECT_LASER1_DAC_COMB2: process (inject_laser1_dac_counter, inject_laser1_dac_chanB_data, inject_laser1_dac_chanA_data) is
begin
    if ((CHANA_CONTROL_START <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < CHANA_CONTROL_END)) then
        case ((CHANA_CONTROL_END - 1) - to_integer(inject_laser1_dac_counter)) is
            when 0 => lsr1_mosi_temp <= '0';
            when 1 => lsr1_mosi_temp <= '0';
            when 2 => lsr1_mosi_temp <= '0';
            when 3 => lsr1_mosi_temp <= '0';
            when 4 => lsr1_mosi_temp <= '0';
            when 5 => lsr1_mosi_temp <= '0';
            when 6 => lsr1_mosi_temp <= '0';
            when others => lsr1_mosi_temp <= '0';
        end case;
    elsif ((CHANA_DATA_START <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < CHANA_DATA_END)) then
        lsr1_mosi_temp <= inject_laser1_dac_chanA_data(((CHANA_DATA_END - 1) - to_integer(inject_laser1_dac_counter)));
    elsif ((CHANB_CONTROL_START <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < CHANB_CONTROL_END)) then
        case ((CHANB_CONTROL_END - 1) - to_integer(inject_laser1_dac_counter)) is
            when 0 => lsr1_mosi_temp <= '0';
            when 1 => lsr1_mosi_temp <= '0';
            when 2 => lsr1_mosi_temp <= '1';
            when 3 => lsr1_mosi_temp <= '0';
            when 4 => lsr1_mosi_temp <= '1';
            when 5 => lsr1_mosi_temp <= '1';
            when 6 => lsr1_mosi_temp <= '0';
            when others => lsr1_mosi_temp <= '0';
        end case;
    elsif ((CHANB_DATA_START <= inject_laser1_dac_counter) and (inject_laser1_dac_counter < CHANB_DATA_END)) then
        lsr1_mosi_temp <= inject_laser1_dac_chanB_data(((CHANB_DATA_END - 1) - to_integer(inject_laser1_dac_counter)));
    else
        lsr1_mosi_temp <= '0';
    end if;
end process MAIN_INJECT_LASER1_DAC_COMB2;


MAIN_INJECT_LASER1_DAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_laser1_dac_counter <= to_unsigned(0, 6);
        lsr1_ss_temp <= '0';
    elsif rising_edge(clk0) then
        case inject_laser1_dac_state is
            when IDLE =>
                lsr1_ss_temp <= '0';
                if bool(inject_dac_strobe) then
                    inject_laser1_dac_chanA_data <= inject_laser1_coarse_scaled;
                    inject_laser1_dac_chanB_data <= inject_laser1_fine;
                    inject_laser1_dac_counter <= to_unsigned(0, 6);
                    lsr1_ss_temp <= '1';
                    inject_laser1_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_5M) then
                    if (inject_laser1_dac_counter < 49) then
                        if (inject_laser1_dac_counter = 24) then
                            lsr1_ss_temp <= '0';
                        end if;
                        inject_laser1_dac_counter <= (inject_laser1_dac_counter + 1);
                        inject_laser1_dac_state <= WAIT_0;
                    else
                        lsr1_ss_temp <= '0';
                        inject_laser1_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not bool(clk_5M)) then
                    lsr1_ss_temp <= '1';
                    inject_laser1_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser1_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER1_DAC_LOGIC;



signed_mult18x18_1 : entity work.SignedMult18x18_e(Behavioral)
    port map (
    A => inject_coarse_scale_multiplier_a_s, B => inject_coarse_scale_multiplier_b_s, P => inject_coarse_scale_multiplier_p_s
    );


MAIN_INJECT_COARSE_SCALE_MULTIPLIER_COMB: process (inject_cs_mult_a, inject_cs_mult_b, inject_coarse_scale_multiplier_p_s) is
begin
    inject_coarse_scale_multiplier_a_s(17-1 downto 0) <= signed(inject_cs_mult_a);
    inject_coarse_scale_multiplier_a_s(17) <= '0';
    inject_coarse_scale_multiplier_b_s(17-1 downto 0) <= signed(inject_cs_mult_b);
    inject_coarse_scale_multiplier_b_s(17) <= '0';
    inject_cs_mult_p <= unsigned(inject_coarse_scale_multiplier_p_s(34-1 downto 0));
end process MAIN_INJECT_COARSE_SCALE_MULTIPLIER_COMB;


MAIN_INJECT_LASER4_DAC_COMB2: process (inject_laser4_dac_counter, inject_laser4_dac_chanB_data, inject_laser4_dac_chanA_data) is
begin
    if ((CHANA_CONTROL_START <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < CHANA_CONTROL_END)) then
        case ((CHANA_CONTROL_END - 1) - to_integer(inject_laser4_dac_counter)) is
            when 0 => lsr4_mosi_temp <= '0';
            when 1 => lsr4_mosi_temp <= '0';
            when 2 => lsr4_mosi_temp <= '0';
            when 3 => lsr4_mosi_temp <= '0';
            when 4 => lsr4_mosi_temp <= '0';
            when 5 => lsr4_mosi_temp <= '0';
            when 6 => lsr4_mosi_temp <= '0';
            when others => lsr4_mosi_temp <= '0';
        end case;
    elsif ((CHANA_DATA_START <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < CHANA_DATA_END)) then
        lsr4_mosi_temp <= inject_laser4_dac_chanA_data(((CHANA_DATA_END - 1) - to_integer(inject_laser4_dac_counter)));
    elsif ((CHANB_CONTROL_START <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < CHANB_CONTROL_END)) then
        case ((CHANB_CONTROL_END - 1) - to_integer(inject_laser4_dac_counter)) is
            when 0 => lsr4_mosi_temp <= '0';
            when 1 => lsr4_mosi_temp <= '0';
            when 2 => lsr4_mosi_temp <= '1';
            when 3 => lsr4_mosi_temp <= '0';
            when 4 => lsr4_mosi_temp <= '1';
            when 5 => lsr4_mosi_temp <= '1';
            when 6 => lsr4_mosi_temp <= '0';
            when others => lsr4_mosi_temp <= '0';
        end case;
    elsif ((CHANB_DATA_START <= inject_laser4_dac_counter) and (inject_laser4_dac_counter < CHANB_DATA_END)) then
        lsr4_mosi_temp <= inject_laser4_dac_chanB_data(((CHANB_DATA_END - 1) - to_integer(inject_laser4_dac_counter)));
    else
        lsr4_mosi_temp <= '0';
    end if;
end process MAIN_INJECT_LASER4_DAC_COMB2;


MAIN_INJECT_LASER4_DAC_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        inject_laser4_dac_counter <= to_unsigned(0, 6);
        lsr4_ss_temp <= '0';
    elsif rising_edge(clk0) then
        case inject_laser4_dac_state is
            when IDLE =>
                lsr4_ss_temp <= '0';
                if bool(inject_dac_strobe) then
                    inject_laser4_dac_chanA_data <= inject_laser4_coarse_scaled;
                    inject_laser4_dac_chanB_data <= inject_laser4_fine;
                    inject_laser4_dac_counter <= to_unsigned(0, 6);
                    lsr4_ss_temp <= '1';
                    inject_laser4_dac_state <= WAIT_1;
                end if;
            when WAIT_1 =>
                if bool(clk_5M) then
                    if (inject_laser4_dac_counter < 49) then
                        if (inject_laser4_dac_counter = 24) then
                            lsr4_ss_temp <= '0';
                        end if;
                        inject_laser4_dac_counter <= (inject_laser4_dac_counter + 1);
                        inject_laser4_dac_state <= WAIT_0;
                    else
                        lsr4_ss_temp <= '0';
                        inject_laser4_dac_state <= IDLE;
                    end if;
                end if;
            when WAIT_0 =>
                if (not bool(clk_5M)) then
                    lsr4_ss_temp <= '1';
                    inject_laser4_dac_state <= WAIT_1;
                end if;
            when others =>
                inject_laser4_dac_state <= IDLE;
        end case;
    end if;
end process MAIN_INJECT_LASER4_DAC_LOGIC;


MAIN_TWGEN_LOGIC: process (clk0, reset) is
    variable value: unsigned(24 downto 0);
begin
    if bool(reset) then
        twGen_acc(((FPGA_REG_WIDTH + 9) - 1)) <= '1';
        twGen_acc(((FPGA_REG_WIDTH + 9) - 1)-1 downto 0) <= to_unsigned(0, 24);
        twGen_cs <= to_unsigned(0, 16);
        twGen_slope_down <= to_unsigned(0, 16);
        twGen_slope_up <= to_unsigned(0, 16);
        twGen_sweep_low <= to_unsigned(0, 16);
        twGen_sweep_high <= to_unsigned(0, 16);
        twGen_window_low <= to_unsigned(0, 16);
        twGen_window_high <= to_unsigned(0, 16);
        twGen_pzt_offset <= to_unsigned(0, 16);
        twGen_slope <= '1';
        twGen_extra0 <= to_unsigned(0, 9);
        tuner_slope <= '1';
        tuner_value <= to_unsigned(32768, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_acc_addr) then
                    if bool(dsp_wr) then
                        twGen_acc <= resize(dsp_data_out, 25);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_acc, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_cs_addr) then
                    if bool(dsp_wr) then
                        twGen_cs <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_cs, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_slope_down_addr) then
                    if bool(dsp_wr) then
                        twGen_slope_down <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_slope_down, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_slope_up_addr) then
                    if bool(dsp_wr) then
                        twGen_slope_up <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_slope_up, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_sweep_low_addr) then
                    if bool(dsp_wr) then
                        twGen_sweep_low <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_sweep_low, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_sweep_high_addr) then
                    if bool(dsp_wr) then
                        twGen_sweep_high <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_sweep_high, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_window_low_addr) then
                    if bool(dsp_wr) then
                        twGen_window_low <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_window_low, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_window_high_addr) then
                    if bool(dsp_wr) then
                        twGen_window_high <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_window_high, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = TWGen_pzt_offset_addr) then
                    if bool(dsp_wr) then
                        twGen_pzt_offset <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_twGen <= resize(twGen_pzt_offset, 32);
                else
                    dsp_data_in_twGen <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_twGen <= to_unsigned(0, 32);
        end if;
        if bool(twGen_cs(TWGEN_CS_RUN_B)) then
            if (not bool(twGen_cs(TWGEN_CS_CONT_B))) then
                twGen_cs(TWGEN_CS_RUN_B) <= '0';
            end if;
            if bool(twGen_cs(TWGEN_CS_RESET_B)) then
                twGen_acc(((FPGA_REG_WIDTH + 9) - 1)) <= '1';
                twGen_acc(((FPGA_REG_WIDTH + 9) - 1)-1 downto 0) <= to_unsigned(0, 24);
                twGen_slope <= '1';
            else
                value := resize(twGen_acc((FPGA_REG_WIDTH + 9)-1 downto 9), 25);
                tuner_value <= resize(value, 16);
                tuner_in_window <= stdl((value >= twGen_window_low) and (value <= twGen_window_high));
                tuner_slope <= twGen_slope;
                if bool(twGen_cs(TWGEN_CS_TUNE_PZT_B)) then
                    pzt <= resize(((value + twGen_pzt_offset) and to_unsigned(MASK, 25)), 16);
                else
                    pzt <= twGen_pzt_offset;
                end if;
                if bool(pulse_100k) then
                    if bool(twGen_slope) then
                        if ((twGen_acc + twGen_slope_up) > unsigned'(twGen_sweep_high & twGen_extra0)) then
                            twGen_acc <= unsigned'(twGen_sweep_high & twGen_extra0);
                            twGen_slope <= '0';
                        else
                            twGen_acc <= (twGen_acc + twGen_slope_up);
                        end if;
                    else
                        if ((signed(resize(twGen_acc, 26)) - signed(resize(twGen_slope_down, 17))) < signed(resize(unsigned'(twGen_sweep_low & twGen_extra0), 26))) then
                            twGen_acc <= unsigned'(twGen_sweep_low & twGen_extra0);
                            twGen_slope <= '1';
                        else
                            twGen_acc <= (twGen_acc - twGen_slope_down);
                        end if;
                    end if;
                end if;
                if (twGen_acc > unsigned'(twGen_sweep_high & twGen_extra0)) then
                    twGen_acc <= unsigned'(twGen_sweep_high & twGen_extra0);
                elsif (twGen_acc < unsigned'(twGen_sweep_low & twGen_extra0)) then
                    twGen_acc <= unsigned'(twGen_sweep_low & twGen_extra0);
                end if;
            end if;
        end if;
    end if;
end process MAIN_TWGEN_LOGIC;



pwm_laser4_out <= pwm_laser4_pwm;
pwm_laser4_inv_out <= (pwm_laser4_pwm xor pwm_laser4_cs(PWM_CS_CONT_B));
pwm_laser4_temp <= (resize(pwm_laser4_dither_cntr, 9) + resize(pwm_laser4_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_LASER4_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_laser4_cs <= to_unsigned(0, 16);
        pwm_laser4_pulse_width <= to_unsigned(0, 16);
        pwm_laser4_main_cntr <= to_unsigned(0, 8);
        pwm_laser4_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 21) then
                if bool(dsp_wr) then
                    pwm_laser4_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser4 <= resize(pwm_laser4_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 22) then
                if bool(dsp_wr) then
                    pwm_laser4_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser4 <= resize(pwm_laser4_pulse_width, 32);
            else
                dsp_data_in_pwm_laser4 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_laser4 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_laser4_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_laser4_cs(PWM_CS_CONT_B))) then
                pwm_laser4_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_laser4_pwm <= '0';
            if (pwm_laser4_main_cntr < pwm_laser4_pulse_width(width-1 downto (width - main_width))) then
                pwm_laser4_pwm <= '1';
            elsif (pwm_laser4_main_cntr = pwm_laser4_pulse_width(width-1 downto dither_width)) then
                if (pwm_laser4_temp >= mod_dither) then
                    pwm_laser4_pwm <= '1';
                    pwm_laser4_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_laser4_dither_cntr <= resize(pwm_laser4_temp - mod_dither, 8);
                else
                    pwm_laser4_dither_cntr <= resize(pwm_laser4_temp, 8);
                end if;
            end if;
            pwm_laser4_main_cntr <= ((pwm_laser4_main_cntr + 1) mod mod_main);
        end if;
        pwm_laser4_cs(PWM_CS_PWM_OUT_B) <= pwm_laser4_pwm;
    end if;
end process MAIN_PWM_LASER4_LOGIC;



pwm_laser3_out <= pwm_laser3_pwm;
pwm_laser3_inv_out <= (pwm_laser3_pwm xor pwm_laser3_cs(PWM_CS_CONT_B));
pwm_laser3_temp <= (resize(pwm_laser3_dither_cntr, 9) + resize(pwm_laser3_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_LASER3_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_laser3_cs <= to_unsigned(0, 16);
        pwm_laser3_pulse_width <= to_unsigned(0, 16);
        pwm_laser3_main_cntr <= to_unsigned(0, 8);
        pwm_laser3_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 19) then
                if bool(dsp_wr) then
                    pwm_laser3_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser3 <= resize(pwm_laser3_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 20) then
                if bool(dsp_wr) then
                    pwm_laser3_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser3 <= resize(pwm_laser3_pulse_width, 32);
            else
                dsp_data_in_pwm_laser3 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_laser3 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_laser3_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_laser3_cs(PWM_CS_CONT_B))) then
                pwm_laser3_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_laser3_pwm <= '0';
            if (pwm_laser3_main_cntr < pwm_laser3_pulse_width(width-1 downto (width - main_width))) then
                pwm_laser3_pwm <= '1';
            elsif (pwm_laser3_main_cntr = pwm_laser3_pulse_width(width-1 downto dither_width)) then
                if (pwm_laser3_temp >= mod_dither) then
                    pwm_laser3_pwm <= '1';
                    pwm_laser3_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_laser3_dither_cntr <= resize(pwm_laser3_temp - mod_dither, 8);
                else
                    pwm_laser3_dither_cntr <= resize(pwm_laser3_temp, 8);
                end if;
            end if;
            pwm_laser3_main_cntr <= ((pwm_laser3_main_cntr + 1) mod mod_main);
        end if;
        pwm_laser3_cs(PWM_CS_PWM_OUT_B) <= pwm_laser3_pwm;
    end if;
end process MAIN_PWM_LASER3_LOGIC;



pwm_laser1_out <= pwm_laser1_pwm;
pwm_laser1_inv_out <= (pwm_laser1_pwm xor pwm_laser1_cs(PWM_CS_CONT_B));
pwm_laser1_temp <= (resize(pwm_laser1_dither_cntr, 9) + resize(pwm_laser1_pulse_width(dither_width-1 downto 0), 9));


MAIN_PWM_LASER1_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        pwm_laser1_cs <= to_unsigned(0, 16);
        pwm_laser1_pulse_width <= to_unsigned(0, 16);
        pwm_laser1_main_cntr <= to_unsigned(0, 8);
        pwm_laser1_dither_cntr <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 15) then
                if bool(dsp_wr) then
                    pwm_laser1_cs <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser1 <= resize(pwm_laser1_cs, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 16) then
                if bool(dsp_wr) then
                    pwm_laser1_pulse_width <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_pwm_laser1 <= resize(pwm_laser1_pulse_width, 32);
            else
                dsp_data_in_pwm_laser1 <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_pwm_laser1 <= to_unsigned(0, 32);
        end if;
        if bool(pwm_laser1_cs(PWM_CS_RUN_B)) then
            if (not bool(pwm_laser1_cs(PWM_CS_CONT_B))) then
                pwm_laser1_cs(PWM_CS_RUN_B) <= '0';
            end if;
            pwm_laser1_pwm <= '0';
            if (pwm_laser1_main_cntr < pwm_laser1_pulse_width(width-1 downto (width - main_width))) then
                pwm_laser1_pwm <= '1';
            elsif (pwm_laser1_main_cntr = pwm_laser1_pulse_width(width-1 downto dither_width)) then
                if (pwm_laser1_temp >= mod_dither) then
                    pwm_laser1_pwm <= '1';
                    pwm_laser1_cs(PWM_CS_PWM_OUT_B) <= '1';
                    pwm_laser1_dither_cntr <= resize(pwm_laser1_temp - mod_dither, 8);
                else
                    pwm_laser1_dither_cntr <= resize(pwm_laser1_temp, 8);
                end if;
            end if;
            pwm_laser1_main_cntr <= ((pwm_laser1_main_cntr + 1) mod mod_main);
        end if;
        pwm_laser1_cs(PWM_CS_PWM_OUT_B) <= pwm_laser1_pwm;
    end if;
end process MAIN_PWM_LASER1_LOGIC;


MAIN_DYNAMICPWMINLET_COMB: process (dynamicPwmInlet_cs, dynamicPwmInlet_dither_cntr, dynamicPwmInlet_pwm, dynamicPwmInlet_pulse_width) is
begin
    if bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_ENABLE_B)) then
        inlet_valve_pwm <= dynamicPwmInlet_pwm;
    else
        inlet_valve_pwm <= '0';
    end if;
    dynamicPwmInlet_temp <= (resize(dynamicPwmInlet_dither_cntr, 9) + resize(dynamicPwmInlet_pulse_width(dither_width-1 downto 0), 9));
end process MAIN_DYNAMICPWMINLET_COMB;


MAIN_DYNAMICPWMINLET_LOGIC: process (clk0, reset) is
    variable value: unsigned(23 downto 0);
begin
    if bool(reset) then
        dynamicPwmInlet_cs <= to_unsigned(0, 16);
        dynamicPwmInlet_delta <= to_signed(0, 16);
        dynamicPwmInlet_high <= to_unsigned(0, 16);
        dynamicPwmInlet_low <= to_unsigned(0, 16);
        dynamicPwmInlet_slope <= to_unsigned(0, 16);
        dynamicPwmInlet_pulse_width <= to_unsigned(32768, 16);
        dynamicPwmInlet_main_cntr <= to_unsigned(0, 8);
        dynamicPwmInlet_dither_cntr <= to_unsigned(0, 8);
        dynamicPwmInlet_acc((FPGA_REG_WIDTH + extra)-1 downto 0) <= to_unsigned(0, 24);
        dynamicPwmInlet_up <= '0';
        dynamicPwmInlet_extra0 <= to_unsigned(0, 8);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            else
                if (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 148) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_cs <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(dynamicPwmInlet_cs, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 149) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_delta <= resize(signed(dsp_data_out), 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(unsigned(dynamicPwmInlet_delta(FPGA_REG_WIDTH-1 downto 0)), 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 150) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_high <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(dynamicPwmInlet_high, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 151) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_low <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(dynamicPwmInlet_low, 32);
                elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = 152) then
                    if bool(dsp_wr) then
                        dynamicPwmInlet_slope <= resize(dsp_data_out, 16);
                    end if;
                    dsp_data_in_dynamicpwm_inlet <= resize(dynamicPwmInlet_slope, 32);
                else
                    dsp_data_in_dynamicpwm_inlet <= to_unsigned(0, 32);
                end if;
            end if;
        else
            dsp_data_in_dynamicpwm_inlet <= to_unsigned(0, 32);
        end if;
        if bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_RUN_B)) then
            if (not bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_CONT_B))) then
                dynamicPwmInlet_cs(DYNAMICPWM_CS_RUN_B) <= '0';
            end if;
            value := resize(dynamicPwmInlet_acc((FPGA_REG_WIDTH + extra)-1 downto extra), 24);
            if bool(pulse_100k) then
                if bool(dynamicPwmInlet_up) then
                    if ((dynamicPwmInlet_acc + dynamicPwmInlet_slope) > unsigned'(dynamicPwmInlet_high & dynamicPwmInlet_extra0)) then
                        dynamicPwmInlet_acc <= unsigned'(dynamicPwmInlet_high & dynamicPwmInlet_extra0);
                        dynamicPwmInlet_up <= '0';
                    else
                        dynamicPwmInlet_acc <= (dynamicPwmInlet_acc + dynamicPwmInlet_slope);
                    end if;
                else
                    if ((signed(resize(dynamicPwmInlet_acc, 25)) - signed(resize(dynamicPwmInlet_slope, 17))) < signed(resize(unsigned'(dynamicPwmInlet_low & dynamicPwmInlet_extra0), 25))) then
                        dynamicPwmInlet_acc <= unsigned'(dynamicPwmInlet_low & dynamicPwmInlet_extra0);
                        dynamicPwmInlet_up <= '1';
                    else
                        dynamicPwmInlet_acc <= (dynamicPwmInlet_acc - dynamicPwmInlet_slope);
                    end if;
                end if;
                if bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_USE_COMPARATOR_B)) then
                    if (dynamicPwmInlet_delta > 0) then
                        if bool(inlet_valve_comparator) then
                            if ((signed(resize(dynamicPwmInlet_pulse_width, 17)) + dynamicPwmInlet_delta) < MAX_WIDTH) then
                                dynamicPwmInlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmInlet_pulse_width, 17)) + dynamicPwmInlet_delta), 16);
                            else
                                dynamicPwmInlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
                            end if;
                        else
                            if ((signed(resize(dynamicPwmInlet_pulse_width, 17)) - dynamicPwmInlet_delta) > MIN_WIDTH) then
                                dynamicPwmInlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmInlet_pulse_width, 17)) - dynamicPwmInlet_delta), 16);
                            else
                                dynamicPwmInlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
                            end if;
                        end if;
                    else
                        if bool(inlet_valve_comparator) then
                            if ((signed(resize(dynamicPwmInlet_pulse_width, 17)) + dynamicPwmInlet_delta) > MIN_WIDTH) then
                                dynamicPwmInlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmInlet_pulse_width, 17)) + dynamicPwmInlet_delta), 16);
                            else
                                dynamicPwmInlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
                            end if;
                        else
                            if ((signed(resize(dynamicPwmInlet_pulse_width, 17)) - dynamicPwmInlet_delta) < MAX_WIDTH) then
                                dynamicPwmInlet_pulse_width <= resize(unsigned(signed(resize(dynamicPwmInlet_pulse_width, 17)) - dynamicPwmInlet_delta), 16);
                            else
                                dynamicPwmInlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
                            end if;
                        end if;
                    end if;
                else
                    dynamicPwmInlet_pulse_width <= resize(value, 16);
                end if;
            end if;
            if (dynamicPwmInlet_acc > unsigned'(dynamicPwmInlet_high & dynamicPwmInlet_extra0)) then
                dynamicPwmInlet_acc <= unsigned'(dynamicPwmInlet_high & dynamicPwmInlet_extra0);
            end if;
            if (dynamicPwmInlet_acc < unsigned'(dynamicPwmInlet_low & dynamicPwmInlet_extra0)) then
                dynamicPwmInlet_acc <= unsigned'(dynamicPwmInlet_low & dynamicPwmInlet_extra0);
            end if;
            if (dynamicPwmInlet_pulse_width > MAX_WIDTH) then
                dynamicPwmInlet_pulse_width <= to_unsigned(MAX_WIDTH, 16);
            end if;
            if (dynamicPwmInlet_pulse_width < MIN_WIDTH) then
                dynamicPwmInlet_pulse_width <= to_unsigned(MIN_WIDTH, 16);
            end if;
            dynamicPwmInlet_pwm <= dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_INVERT_B);
            if (dynamicPwmInlet_main_cntr < dynamicPwmInlet_pulse_width(width-1 downto (width - main_width))) then
                dynamicPwmInlet_pwm <= stdl((not bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_INVERT_B))));
            elsif (dynamicPwmInlet_main_cntr = dynamicPwmInlet_pulse_width(width-1 downto dither_width)) then
                if (dynamicPwmInlet_temp >= mod_dither) then
                    dynamicPwmInlet_pwm <= stdl((not bool(dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_INVERT_B))));
                    dynamicPwmInlet_dither_cntr <= resize(dynamicPwmInlet_temp - mod_dither, 8);
                else
                    dynamicPwmInlet_dither_cntr <= resize(dynamicPwmInlet_temp, 8);
                end if;
            end if;
            dynamicPwmInlet_main_cntr <= ((dynamicPwmInlet_main_cntr + 1) mod mod_main);
            inlet_valve_dac <= resize(value, 16);
        end if;
        dynamicPwmInlet_cs(DYNAMICPWM_CS_PWM_OUT_B) <= dynamicPwmInlet_pwm;
    end if;
end process MAIN_DYNAMICPWMINLET_LOGIC;


MAIN_SGDBRMANAGER_POSEDGE_SEQUENTIAL: process (clk0, reset) is
begin
    if bool(reset) then
        sgdbrmanager_posEdge_ff <= '0';
    elsif rising_edge(clk0) then
        sgdbrmanager_posEdge_ff <= metadata_strobe;
    end if;
end process MAIN_SGDBRMANAGER_POSEDGE_SEQUENTIAL;



sgdbrmanager_rec_strobe_edge <= stdl(bool(metadata_strobe) and (not bool(sgdbrmanager_posEdge_ff)));


MAIN_SGDBRMANAGER_COMB: process (sgdbrmanager_pb1, sgdbrmanager_pb0, sgdbrmanager_sel_rec_23, sgdbrmanager_scan_address, sgdbrmanager_sgdbr_present, sgdbrmanager_config, sgdbrmanager_csr) is
begin
    if bool(sgdbrmanager_sel_rec_23) then
        rec_addr <= (sgdbrmanager_scan_address xor to_unsigned(2048, 12));
    else
        rec_addr <= sgdbrmanager_scan_address;
    end if;
    pb0_out <= sgdbrmanager_pb0;
    pb1_out <= sgdbrmanager_pb1;
    scan_active_out <= sgdbrmanager_csr(SGDBRMANAGER_CSR_SCAN_ACTIVE_B);
    sgdbr_select <= sgdbrmanager_config((SGDBRMANAGER_CONFIG_SELECT_B + SGDBRMANAGER_CONFIG_SELECT_W)-1 downto SGDBRMANAGER_CONFIG_SELECT_B);
    sgdbr_present <= unsigned'(sgdbrmanager_sgdbr_present(SGDBRMANAGER_SGDBR_PRESENT_SGDBR_D_PRESENT_B) & sgdbrmanager_sgdbr_present(SGDBRMANAGER_SGDBR_PRESENT_SGDBR_C_PRESENT_B) & sgdbrmanager_sgdbr_present(SGDBRMANAGER_SGDBR_PRESENT_SGDBR_B_PRESENT_B) & sgdbrmanager_sgdbr_present(SGDBRMANAGER_SGDBR_PRESENT_SGDBR_A_PRESENT_B));
end process MAIN_SGDBRMANAGER_COMB;


MAIN_SGDBRMANAGER_LOGIC: process (clk0, reset) is
begin
    if bool(reset) then
        sgdbrmanager_csr <= to_unsigned(0, 3);
        sgdbrmanager_config <= to_unsigned(0, 3);
        sgdbrmanager_scan_samples <= to_unsigned(0, 13);
        sgdbrmanager_sample_time <= to_unsigned(0, 16);
        sgdbrmanager_delay_samples <= to_unsigned(0, 16);
        sgdbrmanager_scan_address <= to_unsigned(0, 12);
        sgdbrmanager_sgdbr_present <= to_unsigned(0, 4);
        sgdbrmanager_seq_state <= ADVANCE_ADDRESS;
        sgdbrmanager_holdoff_counter <= to_unsigned(0, 16);
        sgdbrmanager_pb0 <= to_unsigned(0, 16);
        sgdbrmanager_pb1 <= to_unsigned(0, 16);
        sgdbrmanager_sample_time_counter <= to_unsigned(0, 16);
    elsif rising_edge(clk0) then
        if (dsp_addr((EMIF_ADDR_WIDTH - 1)) = stdl(FPGA_REG_MASK)) then
            if False then
                null;
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrmanager_csr_addr) then
                if bool(dsp_wr) then
                    sgdbrmanager_csr <= resize(dsp_data_out, 3);
                end if;
                dsp_data_in_sgdbrmanager <= resize(sgdbrmanager_csr, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrmanager_config_addr) then
                if bool(dsp_wr) then
                    sgdbrmanager_config <= resize(dsp_data_out, 3);
                end if;
                dsp_data_in_sgdbrmanager <= resize(sgdbrmanager_config, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrmanager_scan_samples_addr) then
                if bool(dsp_wr) then
                    sgdbrmanager_scan_samples <= resize(dsp_data_out, 13);
                    sgdbrmanager_scan_address <= resize(dsp_data_out - 1, 12);
                end if;
                dsp_data_in_sgdbrmanager <= resize(sgdbrmanager_scan_samples, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrmanager_sample_time_addr) then
                if bool(dsp_wr) then
                    sgdbrmanager_sample_time <= resize(dsp_data_out, 16);
                end if;
                dsp_data_in_sgdbrmanager <= resize(sgdbrmanager_sample_time, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrmanager_delay_samples_addr) then
                if bool(dsp_wr) then
                    sgdbrmanager_delay_samples <= resize(dsp_data_out, 16);
                    sgdbrmanager_holdoff_counter <= resize(dsp_data_out - 1, 16);
                end if;
                dsp_data_in_sgdbrmanager <= resize(sgdbrmanager_delay_samples, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrmanager_scan_address_addr) then
                dsp_data_in_sgdbrmanager <= resize(sgdbrmanager_scan_address, 32);
            elsif (dsp_addr((EMIF_ADDR_WIDTH - 1)-1 downto 0) = sgdbrmanager_sgdbr_present_addr) then
                if bool(dsp_wr) then
                    sgdbrmanager_sgdbr_present <= resize(dsp_data_out, 4);
                end if;
                dsp_data_in_sgdbrmanager <= resize(sgdbrmanager_sgdbr_present, 32);
            else
                dsp_data_in_sgdbrmanager <= to_unsigned(0, 32);
            end if;
        else
            dsp_data_in_sgdbrmanager <= to_unsigned(0, 32);
        end if;
        pb_strobe_out <= '0';
        rec_we <= '0';
        case sgdbrmanager_seq_state is
            when ADVANCE_ADDRESS =>
                sgdbr_mode <= sgdbrmanager_config(SGDBRMANAGER_CONFIG_MODE_B);
                if bool(sgdbrmanager_config(SGDBRMANAGER_CONFIG_MODE_B)) then
                    if (not bool(sgdbrmanager_csr(SGDBRMANAGER_CSR_SCAN_ACTIVE_B))) then
                        sgdbrmanager_scan_address <= to_unsigned(0, 12);
                        sgdbrmanager_holdoff_counter <= to_unsigned(0, 16);
                        sgdbrmanager_sample_time_counter <= to_unsigned(0, 16);
                        if bool(sgdbrmanager_csr(SGDBRMANAGER_CSR_START_SCAN_B)) then
                            sgdbrmanager_csr(SGDBRMANAGER_CSR_START_SCAN_B) <= '0';
                            sgdbrmanager_csr(SGDBRMANAGER_CSR_DONE_B) <= '0';
                            sgdbrmanager_csr(SGDBRMANAGER_CSR_SCAN_ACTIVE_B) <= '1';
                        end if;
                    else
                        if (signed(resize(sgdbrmanager_sample_time_counter, 17)) < (signed(resize(sgdbrmanager_sample_time, 17)) - 1)) then
                            sgdbrmanager_sample_time_counter <= (sgdbrmanager_sample_time_counter + 1);
                        else
                            sgdbrmanager_sample_time_counter <= to_unsigned(0, 16);
                            if (signed(resize(sgdbrmanager_holdoff_counter, 17)) < (signed(resize(sgdbrmanager_delay_samples, 17)) - 1)) then
                                sgdbrmanager_holdoff_counter <= (sgdbrmanager_holdoff_counter + 1);
                            else
                                if (signed(resize(sgdbrmanager_scan_address, 13)) < (signed(resize(sgdbrmanager_scan_samples, 14)) - 1)) then
                                    sgdbrmanager_scan_address <= (sgdbrmanager_scan_address + 1);
                                else
                                    sgdbrmanager_csr(SGDBRMANAGER_CSR_DONE_B) <= '1';
                                    sgdbrmanager_csr(SGDBRMANAGER_CSR_SCAN_ACTIVE_B) <= '0';
                                end if;
                            end if;
                        end if;
                    end if;
                    sgdbrmanager_mem_flag <= '1';
                    sgdbrmanager_seq_state <= READ_PB_WFM0;
                else
                    sgdbrmanager_csr(SGDBRMANAGER_CSR_SCAN_ACTIVE_B) <= '0';
                end if;
            when READ_PB_WFM0 =>
                if bool(sgdbrmanager_mem_flag) then
                    sgdbrmanager_mem_flag <= '0';
                else
                    sgdbrmanager_mem_flag <= '1';
                    sgdbrmanager_pb0 <= pb_data;
                    pb_wfm_sel <= '1';
                    sgdbrmanager_seq_state <= READ_PB_WFM1;
                end if;
            when READ_PB_WFM1 =>
                if bool(sgdbrmanager_mem_flag) then
                    sgdbrmanager_mem_flag <= '0';
                else
                    sgdbrmanager_pb1 <= pb_data;
                    pb_wfm_sel <= '0';
                    sgdbrmanager_seq_state <= WRITE_PB_DATA;
                end if;
            when WRITE_PB_DATA =>
                pb_strobe_out <= '1';
                sgdbrmanager_seq_state <= AWAIT_REC_STROBE;
            when AWAIT_REC_STROBE =>
                if bool(sgdbrmanager_rec_strobe_edge) then
                    rec_wfm_sel <= '0';
                    rec_data <= resize(ratio1, 18);
                    sgdbrmanager_sel_rec_23 <= '0';
                    sgdbrmanager_seq_state <= WRITE_REC_WFM0;
                    sgdbrmanager_mem_flag <= '1';
                end if;
            when WRITE_REC_WFM0 =>
                if bool(sgdbrmanager_mem_flag) then
                    sgdbrmanager_mem_flag <= '0';
                    rec_we <= '1';
                else
                    rec_data <= resize(meta6, 18);
                    sgdbrmanager_sel_rec_23 <= '1';
                    sgdbrmanager_mem_flag <= '1';
                    sgdbrmanager_seq_state <= WRITE_REC_WFM2;
                end if;
            when WRITE_REC_WFM2 =>
                if bool(sgdbrmanager_mem_flag) then
                    sgdbrmanager_mem_flag <= '0';
                    rec_we <= '1';
                else
                    rec_data <= resize(meta1, 18);
                    sgdbrmanager_sel_rec_23 <= '0';
                    rec_wfm_sel <= '1';
                    sgdbrmanager_mem_flag <= '1';
                    sgdbrmanager_seq_state <= WRITE_REC_WFM1;
                end if;
            when WRITE_REC_WFM1 =>
                if bool(sgdbrmanager_mem_flag) then
                    sgdbrmanager_mem_flag <= '0';
                    rec_we <= '1';
                else
                    rec_data <= resize(average2, 18);
                    sgdbrmanager_sel_rec_23 <= '1';
                    sgdbrmanager_mem_flag <= '1';
                    sgdbrmanager_seq_state <= WRITE_REC_WFM3;
                end if;
            when WRITE_REC_WFM3 =>
                if bool(sgdbrmanager_mem_flag) then
                    sgdbrmanager_mem_flag <= '0';
                    rec_we <= '1';
                else
                    sgdbrmanager_sel_rec_23 <= '0';
                    sgdbrmanager_seq_state <= ADVANCE_ADDRESS;
                end if;
            when others =>
                sgdbrmanager_seq_state <= ADVANCE_ADDRESS;
        end case;
    end if;
end process MAIN_SGDBRMANAGER_LOGIC;

end architecture MyHDL;
