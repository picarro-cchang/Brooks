<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sze.20160213072030.1"><vh>Startup</vh>
<v t="sze.20160213072030.2"><vh>@button make-sphinx</vh></v>
<v t="sze.20160213072030.3"><vh>@settings</vh>
<v t="sze.20160213072030.4"><vh>@string target_language = rest</vh></v>
<v t="sze.20160213072030.5"><vh>For rst3 command</vh>
<v t="sze.20160213072030.6"><vh>@bool rst3_call_docutils = True</vh></v>
<v t="sze.20160213072030.7"><vh>@bool rst3_write_intermediate_file = True</vh></v>
<v t="sze.20160213072030.8"><vh>@string rst3_write_intermediate_extension = .txt</vh></v>
</v>
</v>
</v>
<v t="sze.20160213072048.1"><vh>C# PeakAnalysis block (orig)</vh></v>
<v t="sze.20160213082846.1" a="E"><vh>Python translation</vh>
<v t="sze.20160213082856.1"><vh>Next</vh></v>
</v>
<v t="sze.20160213072344.1" a="E"><vh>C# PeakAnalysis block</vh>
<v t="sze.20160213080557.1" a="E"><vh>&lt;&lt;PeakAnalyzer&gt;&gt;</vh>
<v t="sze.20160213081239.1"><vh>&lt;&lt;Declarations&gt;&gt;</vh></v>
<v t="sze.20160213080648.1"><vh>&lt;&lt;Constructor&gt;&gt;</vh></v>
<v t="sze.20160213080719.1"><vh>&lt;&lt;Disposition&gt;&gt;</vh></v>
<v t="sze.20160213080737.1"><vh>&lt;&lt;Dispose&gt;&gt;</vh></v>
<v t="sze.20160213080827.1" a="E"><vh>&lt;&lt;Next&gt;&gt;</vh>
<v t="sze.20160213091505.1" a="E"><vh>&lt;&lt;not handling cancellation&gt;&gt;</vh>
<v t="sze.20160213092026.1"><vh>&lt;&lt;handle Cancellation&gt;&gt;</vh></v>
<v t="sze.20160213092150.1"><vh>&lt;&lt;return analysis result&gt;&gt;</vh></v>
<v t="sze.20160213092845.1"><vh>&lt;&lt;not in replay mode&gt;&gt;</vh></v>
<v t="sze.20160213092905.1"><vh>&lt;&lt;in replay mode&gt;&gt;</vh></v>
</v>
</v>
<v t="sze.20160213080908.1"><vh>&lt;&lt;SetRankingForDelta&gt;&gt;</vh></v>
<v t="sze.20160213113144.1"><vh>&lt;&lt;GetDispositionWithUncertainty&gt;&gt;</vh></v>
<v t="sze.20160213113206.1"><vh>&lt;&lt;SetTooFewPoints&gt;&gt;</vh></v>
<v t="sze.20160213113226.1"><vh>&lt;&lt;LoadMeasBuffer&gt;&gt;</vh></v>
<v t="sze.20160213081129.1"><vh>&lt;&lt;DoKeelingAnalysis&gt;&gt;</vh></v>
<v t="sze.20160213081157.1"><vh>&lt;&lt;LoadKeelingBuffer&gt;&gt;</vh></v>
<v t="sze.20160213081216.1"><vh>&lt;&lt;FindPeakForDetailAnalysis&gt;&gt;</vh></v>
</v>
</v>
<v t="sze.20160213072030.9"><vh>Leo's cheat sheet</vh>
<v t="sze.20160213072030.10"><vh>Key bindings</vh>
<v t="sze.20160213072030.11"><vh>Selecting outline nodes</vh></v>
<v t="sze.20160213072030.12"><vh>Moving outline nodes</vh></v>
<v t="sze.20160213072030.13"><vh>Moving the cursor</vh></v>
</v>
<v t="sze.20160213072030.14"><vh>Frequently used commands</vh></v>
<v t="sze.20160213072030.15"><vh>Leo directives</vh></v>
<v t="sze.20160213072030.16"><vh>Settings</vh></v>
<v t="sze.20160213072030.17"><vh>Node types</vh></v>
<v t="sze.20160213072030.18"><vh>Notable Plugins</vh></v>
<v t="sze.20160213072030.19"><vh>External files (@&lt;file&gt; nodes)</vh></v>
<v t="sze.20160213072030.20"><vh>Scripting</vh>
<v t="sze.20160213072030.21"><vh>Pre-defined symbols</vh></v>
<v t="sze.20160213072030.22"><vh>Generators</vh></v>
<v t="sze.20160213072030.23"><vh>Commands class</vh></v>
<v t="sze.20160213072030.24"><vh>vnode class</vh></v>
<v t="sze.20160213072030.25"><vh>position class</vh></v>
<v t="sze.20160213072030.26"><vh>leo.core.leoGlobals module</vh></v>
</v>
</v>
<v t="sze.20160213072030.27"><vh>The rst3 tutorial</vh>
<v t="sze.20160213072030.28"><vh>@rst ~/myDocument.html</vh>
<v t="sze.20160213072030.29"><vh>Chapter I</vh>
<v t="sze.20160213072030.30"><vh>@rst-ignore</vh></v>
</v>
<v t="sze.20160213072030.31"><vh>@rst-ignore-tree Chapter 2+</vh>
<v t="sze.20160213072030.32"><vh>Chapter II</vh>
<v t="sze.20160213072030.33"><vh>translation</vh></v>
</v>
</v>
<v t="sze.20160213072030.34"><vh>Chapter XII</vh></v>
<v t="sze.20160213072030.35"><vh>@rst-no-head The End</vh></v>
</v>
<v t="sze.20160213072030.36"><vh>~/myDocument.html.txt</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="sze.20160213072030.1">By convention, a Startup node contains settings, scripts, etc.
that mostly one wants to have hidden.
</t>
<t tx="sze.20160213072030.10"></t>
<t tx="sze.20160213072030.11">When focus is in the outline pane::

    Right-arrow (expand-and-go-right)
    Left-arrow (contract-or-go-left)
    Up-arrow (goto-prev-visible) 
    Down-arrow (goto-next-visible)
    
Regardless of focus::

    Alt-Home (goto-first-visible-node) 
    Alt-End (goto-last-visible-node)
    Alt-Right-arrow (expand-and-go-right)
    Alt-Left-arrow (contract-or-go-left)
    Alt-Up-arrow (goto-prev-visible) 
    Alt-Down-arrow (goto-next-visible)
</t>
<t tx="sze.20160213072030.12">When focus is in the outline::

    Shift-Down-arrow (move-outline-down) 
    Shift-Left-arrow (move-outline-left) 
    Shift-Right-arrow (move-outline-right) 
    Shift-Up-arrow (move-outline-up)

Regardless of focus::

    Alt-Shift-Down-arrow (move-outline-down) 
    Alt-Shift-Left-arrow (move-outline-left) 
    Alt-Shift-Right-arrow (move-outline-right) 
    Alt-Shift-Up-arrow (move-outline-up)
    Ctrl-D (move-outline-down)
    Ctrl-L (move-outline-left) 
    Ctrl-R (move-outline-right)
    Ctrl-U (move-outline-up)
</t>
<t tx="sze.20160213072030.13">When focus is in any of Leo's text panes (body pane, log pane, headlines):

    +-------------------+-----------------------+
    | **Key**           | **Move Cursor**       |
    +-------------------+-----------------------+
    | Arrow keys        | one character         |
    +-------------------+-----------------------+
    | Ctrl-LeftArrow    | back one word         |
    +-------------------+-----------------------+
    | Ctrl-RightArrow   | forward one word      |
    +-------------------+-----------------------+
    | Home              | beginning of line     |
    +-------------------+-----------------------+
    | End               | end of line           |
    +-------------------+-----------------------+
    | Ctrl-Home         | beginning of the body |
    +-------------------+-----------------------+
    | Ctrl-End          | end of body           |
    +-------------------+-----------------------+
    | PageDown          | down one page         |
    +-------------------+-----------------------+
    | PageUp            | up one page           |
    +-------------------+-----------------------+
    
Adding the Shift key modifier to any of the keys above
moves the cursor and extends the selected text.
</t>
<t tx="sze.20160213072030.14">For much more information, see Leo's Commands Reference: http://leoeditor.com/commands.html

Copy/Paste (text)::

    Ctrl-C (copy-text)
    Ctrl-K (kill)
    Ctrl-V (paste-text)
    Ctrl-X (cut-text)
    Ctrl-Y (yank)
    Alt-Y  (yank-pop)
    kill-...

Files::

    Ctrl-N (new) 
    Ctrl-O (open-outline)
    Ctrl-S (save-file) 
    Ctrl-Q (exit-leo)

Focus::

    Alt-T (focus-to-tree) 
    Ctrl-T (toggle-active-pane)
    Ctrl-Tab (tab-cycle-next)
    
Help::

    Alt-0 (vr-toggle)
    F1 (help) 
    F11 (help-for-command) 
    F12 (help-for-python)
    print-bindings
    print-settings
    help-for-...

Find/Replace::

    Ctrl-F (search-with-present-options) 
    Shift-Ctrl-R (replace-string)
    Ctrl-minus (replace-then-find) 
    F3 (find-next) 
    F2 (find-previous)
    
Minibuffer::

    Alt-X (full-command)
    Ctrl-G (keyboard-quit)

Nodes::

    Ctrl-I or Insert (insert-node)
    Ctrl-H (edit-headline)
    &lt;Return&gt; (when editing a headline) (end-edit-headline)
    Ctrl-Shift-C (copy-node)
    Ctrl-Shift-X (cut-node) 
    Ctrl-Shift-V (paste-node) 
    Ctrl-{ (promote)
    Ctrl-} (demote)
    Ctrl-M (mark) 

Undo::

    Ctrl-Z (undo)
    Ctrl-Shift-Z (redo)
</t>
<t tx="sze.20160213072030.15">Directives starting with '@ in the leftmost column
    
For full details, see Leo's Directives reference: http://leoeditor.com/directives.html

    @                       # starts doc part
    @c                      # ends doc part
    @color
    @doc                    # starts doc part
    @killcolor
    @nocolor
    @language python
    @language c
    @language rest          # restructured text
    @language plain         # plain text: no syntax coloring.
    @lineending lineending
    @pagewidth 100
    @raw, @end_raw          # @file only.
    @tabwidth -4            # use spaces
    @tabwidth 8             # use tabs
    @nowrap
    @wrap
    
Leading whitespace is allowed (and significant) for::

    @all
    @others
    </t>
<t tx="sze.20160213072030.16">For documentation see node: "About this file" in leoSettings.leo.

- Key bindings:     @shortcuts
- Visual settings:  @data qt-gui-plugin-style-sheet
- Enabling plugins: @enabled-plugins

To disable a binding for a key, bind it to do-nothing::

    do-nothing = Insert
    
This overrides the following default binding in leoSettings.leo::

    insert-node = Insert
</t>
<t tx="sze.20160213072030.17">Supported by Leo's core:

- @chapters, @chapter
- @rst, @rst-no-head, @rst-ignore, @rst-ignore-tree
- @settings
- @test, @testsetup, @testclass
- @url

Within @settings trees:

- @bool, @color, @directory, @encoding, @int
- @float, @font, @ratio, @path, @string
- @enabled-plugins
- @buttons, @commands
- @menus, @menu, @menuat, @item
- @openwith, @shortcuts

Supported by plugins:

- bookmarks.py: @bookmarks, @bookmark
- at_folder.py: @folder
- at_produce.py: @produce
- at_view.py: @clip, @strip, @view
- expfolder.py: @expfolder
- mod_scripting.py: @button, @command, @script
- viewrendered.py: @graphics-script, @image, @html, @md, @movie and @svg
- rss.py: @feed

</t>
<t tx="sze.20160213072030.18">See the docstring of these plugins for more details:

- bookmarks.py: Manages URL's used as bookmarks.
- contextmenu.py: Brings up context menu when user right-clicks a headline.
- mod_scripting.py: Supports @button and @command nodes.
- quicksearch.py: Adds Nav tab for searching.
- todo.py: Manages to-do lists and simple project management.
- valuespace.py: Creates an outline-oriented spreadsheet.
- viewrendered.py: Creates a rendering pane. Automatically loaded by Leo's help commands.
</t>
<t tx="sze.20160213072030.19">\@&lt;file&gt; nodes create external files::

    @asis &lt;filename&gt;    
    @auto &lt;filename&gt;    
    @edit &lt;filename&gt;
    @file &lt;filename&gt;
    @nosent &lt;filename&gt;  
    @shadow &lt;filename&gt;
    
For full details, see Leo's Directives reference: http://leoeditor.com/directives.html
    
**Section names** have the form::

    &lt;&lt; any text, except double closing angle brackets &gt;&gt;
    
**Section-definition nodes** have headlines starting with a section name.

Leo performs **expansions** for all @&lt;file&gt; nodes except @asis.

Expansion of @all:

- Leo replaces @all by the *unexpanded* body text of *all* nodes.

Expansion of section names and @others:

- Leo replaces section names in body text by the *expanded*
  text of the corresponding section definition node.
  
- Leo replaces @others with the *expanded* text of all nodes
  that *aren't* section-definition nodes.
</t>
<t tx="sze.20160213072030.2">@language python
import os
trace = True
g.cls()
c.setComplexCommand('make-sphinx')
c.save()
aList = c.rstCommands.rst3()
if aList:
    path = g.os_path_finalize_join(g.app.loadDir,'..','doc','html')
    os.chdir(path)
    if len(aList) &gt; 1: g.execute_shell_commands('make clean',trace=trace)
    g.execute_shell_commands('make html',trace=trace)
    fn = aList[0].h.strip() if len(aList) == 1 else 'leo_toc.html'
    fn = g.os_path_finalize_join(path,'_build','html',g.os_path_basename(fn))
    if g.os_path_exists(fn):
        # Don't wait for this command to exit!
        g.execute_shell_commands(['&amp;%s' % (fn)],trace=trace)
</t>
<t tx="sze.20160213072030.20">This section lists the ivars, properties, functions and methods most
commonly used in Leo scripts.

**Very important**: use Alt-1 (toggle-autocompleter) and Alt-2
(toggle-calltips) to recreate these lists as you type.

As an alternative to this chapter, Jacob Peck has written a more informal scripting tutorial:
http://blog.suspended-chord.info/2014/01/28/intro-to-leo-scripting/</t>
<t tx="sze.20160213072030.21">execute-script predefines::

    c: The commander of the present outline.
    g: The leo.core.leoGlobals module.
    p: The presently selected position, c.p.
    
@test scripts predefine all the above, plus::

    self: The instance of unittest.TestCase
</t>
<t tx="sze.20160213072030.22">::

    c.all_positions()
    c.all_unique_positions()
    p.children()
    p.parents()
    p.self_and_parents()
    p.self_and_siblings()
    p.following_siblings()
    p.subtree()
    p.self_and_subtree()
</t>
<t tx="sze.20160213072030.23">::

    c.frame         c's outer frame, a leoFrame instance.
    c.user_dict     a temporary dict for use of scripts and plugins.
    c.redraw()
    c.positionExists(p)

Here is a partial list of the **official ivars** of any leoFrame f::

    f.c                     is the frameâ€™s commander.
    f.body                  is a leoBody instance.
    f.body.bodyCtl          is a leoQTextEditWidget instance.
    f.body.bodyCtrl.widget  is a LeoQTextBrowser(QTextBrowser) instance.
    f.log                   is a leoLog instance.
    f.tree                  is a leoQtTree instance.
    f.tree.treeWidget       is a LeoQTreeWidget (a QTreeWidget) instance.
    
Use autocompletion to explore these objects!
</t>
<t tx="sze.20160213072030.24">::

    v.b: v's body text.
    v.h: v's headline text.
    v.u: v.unknownAttributes, a persistent Python dictionary.
    
v.u (uA's or unknownAttributes or userAttributes) allow plugins or scripts
to associate persistant data with vnodes. For details see:
http://leoeditor.com/customizing.html#adding-extensible-attributes-to-nodes-and-leo-files
</t>
<t tx="sze.20160213072030.25">**Properties**::

    p.b: same as p.v.b.
    p.h: same as p.v.h.
    p.u: same as p.v.u.

**Getters**::

    p.back()
    p.children()
    p.firstChild()
    p.hasBack()
    p.hasChildren()
    p.hasNext()
    p.hasParent()
    p.hasThreadBack()
    p.hasThreadNext()
    p.isAncestorOf(p2)
    p.isAnyAtFileNode()
    p.isAt...Node()
    p.isCloned()
    p.isDirty()
    p.isExpanded()
    p.isMarked()
    p.isRoot()
    p.isVisible()
    p.lastChild()
    p.level()
    p.next()
    p.nodeAfterTree()
    p.nthChild()
    p.numberOfChildren()
    p.parent()
    p.parents()
    p.threadBack()
    p.threadNext()
    p.visBack()
    p.visNext()
    
**Setters**::

    p.setDirty()
    p.setMarked()

**Operations on nodes**::

    p.clone()
    p.contract()
    p.doDelete(new_position)
    p.expand()
    p.insertAfter()
    p.insertAsNthChild(n)
    p.insertBefore()
    p.moveAfter(p2)
    p.moveToNthChildOf(parent,n)
    p.moveToRoot(oldRoot=None)
        # oldRoot **must** be the old root position if it exists.
        
**Moving positions**

The following move positions *themselves*: they change the node to which a
position refers. They do *not* change outline structure in any way! Use
these when generators are not flexible enough::

    p.moveAfter(p2)
    p.moveToBack()
    p.moveToFirstChild()
    p.moveToFirstChildOf(p2)
    p.moveToLastChild()
    p.moveToLastChildOf(p2)
    p.moveToLastNode()
    p.moveToNext()
    p.moveToNodeAfterTree(p2)
    p.moveToNthChild()
    p.moveToNthChildOf(p2)
    p.moveToParent()
    p.moveToRoot()
    p.moveToThreadBack()
    p.moveToThreadNext()
    p.moveToVisBack(c)
    p.moveToVisNext(c)
</t>
<t tx="sze.20160213072030.26">For full details, see @file leoGlobals.py in LeoPyRef.leo.

**g vars**::

    g.app
    g.app.gui
    g.app.windowlist
    g.unitTesting
    g.user_dict  # a temporary dict for use of scripts and plugins.
    
**g decorator**::

    @g.command(command-name)
    
**g functions** (the most interesting: there are many more in leoGlobals.py)::
    
    g.angleBrackets()
    g.app.commanders()
    g.app.gui.guiName()
    g.es(*args,**keys)
    g.es_print(*args,**keys)
    g.es_exception()
    g.getScript(c,p,
        useSelectedText=True,
        forcePythonSentinels=True,
        useSentinels=True)
    g.openWithFileName(fileName,old_c=None,gui=None)
    g.os_path_... # Wrappers for os.path methods.
    g.pdb(message='')
    g.toEncodedString(s,encoding='utf-8',reportErrors=False)
    g.toUnicode(s, encoding='utf-8',reportErrors=False)
    g.trace(*args,**keys)
    g.warning(*args,**keys)
</t>
<t tx="sze.20160213072030.27">Here is an expanded version of the example from
http://leoeditor.com/tutorial-rst3.html

Control-click the URL above to open the page in your browser.

Notes:

1. The Startup node in this file contains the settings for the rst3
   command. If you use sphinx, **set @bool rst3_call_docutils = False**.
   
2. Leo will not create ~/myDocument.html automatically. Only the rst3
   command does that.
   
3. Executing the make-sphinx command will do everything needed to make
   myDocument.html. The @button make-sphinx node (a child of the Startup
   node) creates the make-sphinx command.
   
4. The node myDocument.html.txt is the intermediate file produced by the
   rst3 command.
</t>
<t tx="sze.20160213072030.28">#############
War and Peace
#############

        by Leo Tolstoy/Tolstoi
        
        BOOK ONE: 1805
</t>
<t tx="sze.20160213072030.29">"Well, Prince, so Genoa and Lucca are now just family estates of the
Buonapartes. But I warn you, if you don't tell me that this means war, if
you still try to defend the infamies and horrors perpetrated by that
Antichrist--I really believe he is Antichrist--I will have nothing more to
do with you and you are no longer my friend, no longer my 'faithful slave',
as you call yourself! But how do you do? I see I have frightened you--sit
down and tell me all the news."

It was in July, 1805, and the speaker was the well-known Anna Pavlovna
Scherer, maid of honor and favorite of the Empress Marya Fedorovna. With
these words she greeted Prince Vasili Kuragin, a man of high rank and
importance, who was the first to arrive at her reception. Anna Pavlovna had
had a cough for some days. She was, as she said, suffering from la grippe;
grippe being then a new word in St. Petersburg, used only by the elite.

...stuff happens...</t>
<t tx="sze.20160213072030.3">**Imortant**: to take effect, all settings must be descendants of this
@settings node.

**Note**: This file colors text as reStructuredText by default because of
the setting::

    @string target_language = rest
</t>
<t tx="sze.20160213072030.30">You can make whatever notes 
to yourself you like here, 
as these lines won't appear 
in the output files. :)

</t>
<t tx="sze.20160213072030.31">Neither this node nor any descendant node will appear in the output file.</t>
<t tx="sze.20160213072030.32">TL;DR

...la femme la plus seduisante de Petersbourg,* ...</t>
<t tx="sze.20160213072030.33">*The most fascinating woman in Petersburg.</t>
<t tx="sze.20160213072030.34">From the time the law of Copernicus was discovered and proved, the mere
recognition of the fact that it was not the sun but the earth that moves
sufficed to destroy the whole cosmography of the ancients.

...
</t>
<t tx="sze.20160213072030.35">..  and now we skip to the end of last chapter, while demonstrating use of an
..  organizer node (a node whose name does not appear in the output document),
..  and that rst comments appear as html comments (try 'View Source' on
..  output.html)

In the first case it was necessary to renounce the consciousness of an
unreal immobility in space and to recognize a motion we did not feel; in
the present case it is similarly necessary to renounce a freedom that does
not exist, and to recognize a dependence of which we are not conscious.
   
--- The End ---
</t>
<t tx="sze.20160213072030.36">.. rst3: filename: ~/myDocument.html

#############
War and Peace
#############

        by Leo Tolstoy/Tolstoi
        
        BOOK ONE: 1805

Chapter I
+++++++++

"Well, Prince, so Genoa and Lucca are now just family estates of the
Buonapartes. But I warn you, if you don't tell me that this means war,
if you still try to defend the infamies and horrors perpetrated by
that Antichrist--I really believe he is Antichrist--I will have
nothing more to do with you and you are no longer my friend, no longer
my 'faithful slave,' as you call yourself! But how do you do? I see
I have frightened you--sit down and tell me all the news."

...stuff happens...

Chapter XII
+++++++++++

From the time the law of Copernicus was discovered and proved, the
mere recognition of the fact that it was not the sun but the earth
that moves sufficed to destroy the whole cosmography of the
ancients.

...

.. and now we skip to the end of last chapter, while demonstrating use of an
    organizer node (a node whose name does not appear in the output document),
    and that rst comments appear as html comments (try 'View Source' on
    output.html)

In the first case it was necessary to renounce the consciousness
of an unreal immobility in space and to recognize a motion we did
not feel; in the present case it is similarly necessary to renounce
a freedom that does not exist, and to recognize a dependence of
which we are not conscious.
   
--- The End ---

</t>
<t tx="sze.20160213072030.4">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="sze.20160213072030.5"></t>
<t tx="sze.20160213072030.6"># Use False when using Sphinx</t>
<t tx="sze.20160213072030.7"></t>
<t tx="sze.20160213072030.8"></t>
<t tx="sze.20160213072030.9">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- Created by Leo: http://leoeditor.com/leo_toc.html --&gt;
&lt;?xml-stylesheet ekr_test ?&gt;
&lt;leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" &gt;
&lt;leo_header file_format="2"/&gt;
&lt;vnodes&gt;
&lt;v t="ekr.20131030071311.18723"&gt;&lt;vh&gt;The rst3 tutorial&lt;/vh&gt;
&lt;v t="ekr.20131030071311.18732"&gt;&lt;vh&gt;@rst ~/myDocument.html&lt;/vh&gt;
&lt;v t="ekr.20131030071311.18733"&gt;&lt;vh&gt;Chapter I&lt;/vh&gt;
&lt;v t="ekr.20131030071311.18734"&gt;&lt;vh&gt;@rst-ignore&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20131030071311.18735"&gt;&lt;vh&gt;@rst-ignore-tree Chapter 2+&lt;/vh&gt;
&lt;v t="ekr.20131030071311.18736"&gt;&lt;vh&gt;Chapter II&lt;/vh&gt;
&lt;v t="ekr.20131030071311.18737"&gt;&lt;vh&gt;translation&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20131030071311.18738"&gt;&lt;vh&gt;Chapter XII&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20131030071311.18739"&gt;&lt;vh&gt;@rst-no-head The End&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20131102044158.16563"&gt;&lt;vh&gt;~/myDocument.html.txt&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="ekr.20131030071311.18723"&gt;Here is an expanded version of the example from
http://leoeditor.com/tutorial-rst3.html

Control-click the URL above to open the page in your browser.

Notes:

1. The Startup node in this file contains the settings for the rst3
   command. If you use sphinx, **set @bool rst3_call_docutils = False**.
   
2. Leo will not create ~/myDocument.html automatically. Only the rst3
   command does that.
   
3. Executing the make-sphinx command will do everything needed to make
   myDocument.html. The @button make-sphinx node (a child of the Startup
   node) creates the make-sphinx command.
   
4. The node myDocument.html.txt is the intermediate file produced by the
   rst3 command.
&lt;/t&gt;
&lt;t tx="ekr.20131030071311.18732"&gt;#############
War and Peace
#############

        by Leo Tolstoy/Tolstoi
        
        BOOK ONE: 1805
&lt;/t&gt;
&lt;t tx="ekr.20131030071311.18733"&gt;"Well, Prince, so Genoa and Lucca are now just family estates of the
Buonapartes. But I warn you, if you don't tell me that this means war, if
you still try to defend the infamies and horrors perpetrated by that
Antichrist--I really believe he is Antichrist--I will have nothing more to
do with you and you are no longer my friend, no longer my 'faithful slave',
as you call yourself! But how do you do? I see I have frightened you--sit
down and tell me all the news."

It was in July, 1805, and the speaker was the well-known Anna Pavlovna
Scherer, maid of honor and favorite of the Empress Marya Fedorovna. With
these words she greeted Prince Vasili Kuragin, a man of high rank and
importance, who was the first to arrive at her reception. Anna Pavlovna had
had a cough for some days. She was, as she said, suffering from la grippe;
grippe being then a new word in St. Petersburg, used only by the elite.

...stuff happens...&lt;/t&gt;
&lt;t tx="ekr.20131030071311.18734"&gt;You can make whatever notes 
to yourself you like here, 
as these lines won't appear 
in the output files. :)

&lt;/t&gt;
&lt;t tx="ekr.20131030071311.18735"&gt;Neither this node nor any descendant node will appear in the output file.&lt;/t&gt;
&lt;t tx="ekr.20131030071311.18736"&gt;TL;DR

...la femme la plus seduisante de Petersbourg,* ...&lt;/t&gt;
&lt;t tx="ekr.20131030071311.18737"&gt;*The most fascinating woman in Petersburg.&lt;/t&gt;
&lt;t tx="ekr.20131030071311.18738"&gt;From the time the law of Copernicus was discovered and proved, the mere
recognition of the fact that it was not the sun but the earth that moves
sufficed to destroy the whole cosmography of the ancients.

...
&lt;/t&gt;
&lt;t tx="ekr.20131030071311.18739"&gt;..  and now we skip to the end of last chapter, while demonstrating use of an
..  organizer node (a node whose name does not appear in the output document),
..  and that rst comments appear as html comments (try 'View Source' on
..  output.html)

In the first case it was necessary to renounce the consciousness of an
unreal immobility in space and to recognize a motion we did not feel; in
the present case it is similarly necessary to renounce a freedom that does
not exist, and to recognize a dependence of which we are not conscious.
   
--- The End ---
&lt;/t&gt;
&lt;t tx="ekr.20131102044158.16563"&gt;.. rst3: filename: ~/myDocument.html

#############
War and Peace
#############

        by Leo Tolstoy/Tolstoi
        
        BOOK ONE: 1805

Chapter I
+++++++++

"Well, Prince, so Genoa and Lucca are now just family estates of the
Buonapartes. But I warn you, if you don't tell me that this means war,
if you still try to defend the infamies and horrors perpetrated by
that Antichrist--I really believe he is Antichrist--I will have
nothing more to do with you and you are no longer my friend, no longer
my 'faithful slave,' as you call yourself! But how do you do? I see
I have frightened you--sit down and tell me all the news."

...stuff happens...

Chapter XII
+++++++++++

From the time the law of Copernicus was discovered and proved, the
mere recognition of the fact that it was not the sun but the earth
that moves sufficed to destroy the whole cosmography of the
ancients.

...

.. and now we skip to the end of last chapter, while demonstrating use of an
    organizer node (a node whose name does not appear in the output document),
    and that rst comments appear as html comments (try 'View Source' on
    output.html)

In the first case it was necessary to renounce the consciousness
of an unreal immobility in space and to recognize a motion we did
not feel; in the present case it is similarly necessary to renounce
a freedom that does not exist, and to recognize a dependence of
which we are not conscious.
   
--- The End ---

&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
</t>
<t tx="sze.20160213072048.1">@language c

// #define DEBUG_PEAK_ANALYZER

#if DEBUG_PEAK_ANALYZER
using CsvHelper;
#endif

using Picarro.Surveyor.Algorithms.Helpers;
using Picarro.Surveyor.Algorithms.Payloads;
using Picarro.Surveyor.Core.Constant;
using Picarro.Surveyor.Core.DTO;
using Picarro.Surveyor.Core.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace Picarro.Surveyor.Algorithms.Operations
{
    // Peak analyzer carries out Keeling plot analysis of peaks found by the isotopic methane analyzer
    internal sealed class PeakAnalyzer : IDisposable
    {
#if DEBUG_PEAK_ANALYZER
        private CsvWriter csv;
        private StreamWriter log;
#endif
        private const int TransportLag = 5;
        private const int DoneAnalysisThreshold = 5;
        private const double UncertaintyHighThreshold = 5.0;
        private const double DeltaNegativeThreshold = -80.0;    // Note: Please review the ranking logic upon changing value
        private const double DeltaPositiveThreshold = 0.0;      // Note: Please review the ranking logic upon changing value
        private const double ConcentrationHighThreshold = 20.0;
        private const double MaxDurationSeconds = 30.0;
        private const double SigmaUncertainty = 11.0;
        private const int MinKeelingSamples = 10;
        private const int KeelingSamplesToSkip = 24;
        private const int KeelingEndpointOffset = 6;

        private const int NotNaturalGasRank = 1;
        private const int UnknownRank = 2;
        private const int NaturalGasRank = 0;

        private const double ReferenceGasIsotopicValueTolerance = 2.5;

        private Dictionary&lt;double, int&gt; rankingForDelta;

        private bool isCancelled;
        private bool isHandlingCancellation;
        private bool hasTooFewPoints;
        private bool lastCollecting;
        private bool referenceGas;

        private LinkedList&lt;bool&gt; delayBuffer;
        private LinkedList&lt;DistanceResult&gt; measBuffer;
        private LinkedList&lt;DistanceResult&gt; keelingBuffer;
        private int notCollectingCount;
        private PeakAnalyzerResult lastAnalysis;
        private DistanceResult lastPeak;
        private IsotopicIdentity isotopicIdentity;
        private double referenceGasIsotopicValue;

        public PeakAnalyzer(IsotopicIdentity isotopicIdentity, double referenceGasIsotopicValue)
        {
#if DEBUG_PEAK_ANALYZER
            this.log = new StreamWriter(string.Format(@"c:\logs\peakAnalyzer_{0:yyyyMMddTHHmmssfff}.csv", DateTime.Now));
            this.csv = new CsvWriter(this.log);
            this.csv.WriteField("EpochTime");
            this.csv.WriteField("Distance");
            this.csv.WriteField("Delta");
            this.csv.WriteField("Uncertainty");
            this.csv.WriteField("ReplayMax");
            this.csv.WriteField("ReplayLMin");
            this.csv.WriteField("ReplayRMin");
            this.csv.WriteField("Disposition");
            this.csv.WriteField("ReferenceGas");
            this.csv.NextRecord();
            this.log.AutoFlush = true;
#endif
            
            this.isCancelled = false;
            this.isHandlingCancellation = false;
            this.hasTooFewPoints = false;
            this.lastCollecting = false;
            this.referenceGas = false;

            this.delayBuffer = new LinkedList&lt;bool&gt;();
            this.measBuffer = new LinkedList&lt;DistanceResult&gt;();
            this.keelingBuffer = new LinkedList&lt;DistanceResult&gt;();

            this.notCollectingCount = 0;

            this.lastAnalysis = null;
            this.lastPeak = null;

            this.isotopicIdentity = isotopicIdentity;
            this.referenceGasIsotopicValue = referenceGasIsotopicValue;
            this.rankingForDelta = new Dictionary&lt;double, int&gt;();
            this.SetRankingForDelta();
        }

        private IsotopicAnalysisDisposition Disposition
        {
            get
            {
                if (this.isCancelled)
                {
                    return IsotopicAnalysisDisposition.UserCancellation;
                }
                else if (this.hasTooFewPoints)
                {
                    return IsotopicAnalysisDisposition.SampleSizeTooSmall;
                }

                if (this.lastAnalysis == null)
                {
                    Log.Error("Last Analysis can not be null for the Isotopic disposition determiation");
                    return IsotopicAnalysisDisposition.Unknown;
                }
                else
                {
                    double delta = this.lastAnalysis.Delta;
                    double uncertainty = this.lastAnalysis.Uncertainty;

                    if (uncertainty &gt;= PeakAnalyzer.UncertaintyHighThreshold)
                    {
                        return IsotopicAnalysisDisposition.UncertaintyOutOfRange;
                    }
                    else if ((delta &lt;= PeakAnalyzer.DeltaNegativeThreshold) ||
                        (delta &gt;= PeakAnalyzer.DeltaPositiveThreshold))
                    {
                        return IsotopicAnalysisDisposition.DeltaOutOfRange;
                    }
                    else
                    {
                        if (this.referenceGas)
                        {
                            double rangeMin = delta - uncertainty;
                            double rangeMax = delta + uncertainty;
                            if (rangeMin &lt; this.referenceGasIsotopicValue - ReferenceGasIsotopicValueTolerance ||
                                rangeMax &gt; this.referenceGasIsotopicValue + ReferenceGasIsotopicValueTolerance)
                            {
                                return IsotopicAnalysisDisposition.NotNaturalGas;
                            }
                            else
                            {
                                return IsotopicAnalysisDisposition.NaturalGas;
                            }
                        }
                        else
                        {
                            return this.GetDispositionWithUncertainty(delta, uncertainty);
                        }
                    }
                }
            }
        }

        public void Dispose()
        {
#if DEBUG_PEAK_ANALYZER
            this.log.Close();
#endif
        }

        /*
         * Definitions:
         *      Not Collecting: The air is flowing from the front of the car to back.
         *      Collecting: The air which is saved in coil is replayed by reversing direction.
         * 
         * {           |           } {                                                       }
         * {          | |          } {                                                       }
         * {         |   |         } {                         ====                          }
         * {        |     |        } {                      ==      ==                       }
         * {       |       |       } {                   ==            ==                    }
         * {      |         |      } {                ==                  ==                 }
         * {     |           |     } {            ==                         ==              }
         * {    |             |    } {         ==                               ==           }
         * {   |               |   } {      ==                                     ==        }
         * {  |                 |  } {   ==                                            ==    }
         * {_|___________________|_} {_=___________________________________________________=_}
         * {  Measurement Buffer   } {                  Keeling Buffer                       }
         * T1                       T2                                                      T3
         *
         * Notes: 
         *      - The air in coil may be from the front of car or from a reference gas bottle.
         *      - We are Not Collecting between T1 &amp; T2 and after T3
         *      - We are Collecting between T2 &amp; T3
         *      - Normal Survey mode is Not Collecting
         *      - When Isotopic or Reference Gas capture is requested, system goes in ARMED mode (Not Collecting) until a peak is detected,
         *        then system switches to ANALYSIS mode (Collecting). So Isotopic or Reference Gas capture transitions from 
         *          Not Collecting --&gt; Collecting --&gt; Not Collecting
         * 
         * Phase I: Not Collecting (transitioning from Not Collecting --&gt; Not Collecting)
         *      1. Put samples in Measurement buffer (rolling buffer for MaxDurationSeconds)
         * 
         * Phase II: Collecting (transitioning from Not Collecting --&gt; Collecting)
         *      1. Put samples in Keeling buffer
         *      2. Measurement buffer is populated with samples, save the sample with highest 
         *         CH4 concentration as we need to associate with keeling analysis in Phase IV
         *      3. Clear Measurement buffer
         * 
         * Phase III: Collecting (transitioning from Collecting --&gt; Collecting)
         *      1. Put samples in Keeling buffer
         * 
         * Phase IV: Not Collecting (transitioning from Collecting --&gt; Not Collecting)
         *      1. Put samples in Measurement buffer (in preparation if another analysis is requested)
         *      2. Keeling buffer is populated with samples (from replayed air), do 
         *         detailed keeling analysis to figure out gas signature
        */
        public PeakAnalyzerResult Next(DistanceResult data)
        {
            bool isCollecting = Valve.IsCollecting(data.Data.Data.ValveMask);
            
            // Delay collecting state by some number of samples to compensate for gas transport lag after valve switch.
            this.delayBuffer.AddLast(isCollecting);

            if (this.delayBuffer.Count &gt;= PeakAnalyzer.TransportLag)
            {
                isCollecting = this.delayBuffer.First.Value;
                this.delayBuffer.RemoveFirst();
            }

            // Went back to Survey Active Mode, Not cancelling anymore.
            if (Valve.IsSurveying(data.Data.Data.ValveMask))
            {
                this.isHandlingCancellation = false;
            }

            if (!this.isHandlingCancellation)
            {
                // Cancellation of Isotopic or Reference Gas capture
                // We will get multiple samples upon user cancellation with valve indicating cancel state.
                // But we want to ingore all but the first one.(Using isHandlingCancellation boolean flag)
                if (Valve.IsCancelling(data.Data.Data.ValveMask))
                {
                    this.isHandlingCancellation = true;
                    this.isCancelled = true;
                    var result = new PeakAnalyzerResult(
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        this.Disposition,
                        this.referenceGas,
                        data);

                    this.lastPeak = null;
                    this.lastAnalysis = null;
                    this.isCancelled = false;
                    this.hasTooFewPoints = false;
                    this.lastCollecting = isCollecting;
                    this.referenceGas = false;
                    return result;
                }

                // Set Reference gas to true if referecne gas injection was done
                // Note: It will be cleared and set to false on either analysis completion or cancelation
                if (Valve.IsReferenceGasInjection(data.Data.Data.ValveMask))
                {
                    this.referenceGas = true;
                }

                // An analysis is completed if we are not in the collecting state for N samples
                // and there is some Keeling data to report.
                if ((this.notCollectingCount &gt; PeakAnalyzer.DoneAnalysisThreshold) &amp;&amp; this.lastAnalysis != null)
                {
                    var result = new PeakAnalyzerResult(
                        this.lastAnalysis.Delta,
                        this.lastAnalysis.Uncertainty,
                        this.lastAnalysis.ReplayMax,
                        this.lastAnalysis.ReplayLMin,
                        this.lastAnalysis.ReplayRMin,
                        this.Disposition,
                        this.referenceGas,
                        this.lastAnalysis.Measurement);

#if DEBUG_PEAK_ANALYZER
                this.csv.WriteField(this.lastAnalysis.Measurement.Data.Data.EpochTime);
                this.csv.WriteField(this.lastAnalysis.Measurement.Distance);
                this.csv.WriteField(this.lastAnalysis.Delta);
                this.csv.WriteField(this.lastAnalysis.Uncertainty);
                this.csv.WriteField(this.lastAnalysis.ReplayMax);
                this.csv.WriteField(this.lastAnalysis.ReplayLMin);
                this.csv.WriteField(this.lastAnalysis.ReplayRMin);
                this.csv.WriteField(this.Disposition);
                this.csv.WriteField(this.referenceGas);
                this.csv.NextRecord();
#endif
                    this.lastPeak = null;
                    this.lastAnalysis = null;
                    this.isCancelled = false;
                    this.hasTooFewPoints = false;
                    this.lastCollecting = isCollecting;
                    this.referenceGas = false;
                    return result;
                }

                /*
                 * Phase I or Phase IV
                 */
                if (!isCollecting)
                {
                    /*
                     * Phase I/IV: We are between T1 &amp; T2 or after T3
                     */
                    // Not collecting - keep filling up Measurement buffer
                    // Note: Can be either before collection starts or after collection ends
                    this.LoadMeasBuffer(data);

                    if (this.lastCollecting)
                    {
                        /*
                         * Phase IV: We are at T3
                         */
                        // Just finished collecting - do Keeling analysis
                        this.DoKeelingAnalysis();
                    }
                }

                /*
                 * Phase II or Phase III
                */
                else
                {
                    /*
                     * Phase II/III: We are between T2 &amp; T3
                     */
                    // Collecting - keep filling up Keeling buffer
                    this.LoadKeelingBuffer(data);

                    if (!this.lastCollecting &amp;&amp; (this.measBuffer.Count &gt; 0))
                    {
                        /*
                         * Phase II: We are at T2
                         */
                        // Just started collecting - find the peak from measurement buffer 
                        // to associate with upcoming Keeling analysis
                        this.FindPeakForDetailAnalysis();
                    }
                }
            }

            this.lastCollecting = isCollecting;

            return null;
        }

        private void SetRankingForDelta()
        {
            // Note: Please review the ranking logic if value changes for any of the folowing constants 
            //  - DeltaNegativeThreshold
            //  - isotopicIdentity.NoLowerBound
            //  - isotopicIdentity.YesLowerBound
            //  - isotopicIdentity.YesUpperBound
            //  - isotopicIdentity.NoUpperBound 
            //  - DeltaPositiveThreshold

            // Value between DeltaNegativeThreshold and isotopicIdentity.NoLowerBound indicates "Not Natural Gas"
            for (double i = DeltaNegativeThreshold; i &lt; this.isotopicIdentity.NoLowerBound; i++)
            {
                this.rankingForDelta[i] = NotNaturalGasRank;
            }

            // Value between isotopicIdentity.NoLowerBound and isotopicIdentity.YesLowerBound indicates "Unknown"
            for (double i = this.isotopicIdentity.NoLowerBound; i &lt; this.isotopicIdentity.YesLowerBound; i++)
            {
                this.rankingForDelta[i] = UnknownRank;
            }

            // Value between isotopicIdentity.YesLowerBound and isotopicIdentity.YesUpperBound indicates "Natural Gas"
            for (double i = this.isotopicIdentity.YesLowerBound; i &lt; this.isotopicIdentity.YesUpperBound; i++)
            {
                this.rankingForDelta[i] = NaturalGasRank;
            }

            // Value between isotopicIdentity.YesUpperBound and isotopicIdentity.NoUpperBound indicates "Unknown"
            for (double i = this.isotopicIdentity.YesUpperBound; i &lt; this.isotopicIdentity.NoUpperBound; i++)
            {
                this.rankingForDelta[i] = UnknownRank;
            }

            // Value between isotopicIdentity.NoUpperBound and DeltaPositiveThreshold indicates "Not Natural Gas"
            for (double i = this.isotopicIdentity.NoUpperBound; i &lt; DeltaPositiveThreshold; i++)
            {
                this.rankingForDelta[i] = NotNaturalGasRank;
            }
        }
           
        private IsotopicAnalysisDisposition GetDispositionWithUncertainty(double delta, double uncertainty)
        {
            double rangeMin = delta - uncertainty;
            double rangeMax = delta + uncertainty;
            IsotopicAnalysisDisposition disp = IsotopicAnalysisDisposition.Unknown;

            if (rangeMin &lt;= DeltaNegativeThreshold || 
                rangeMax &gt;= DeltaPositiveThreshold)
            {
                disp = IsotopicAnalysisDisposition.DeltaOutOfRange;
            }
            else
            {
                // Note: For now we are using Math.Floor as the whole range is negative values
                // starting from DeltaNegativeThreshold and ending at DeltaPositiveThreshold

                // Get highest ranking comparing the rangemin and rangemax
                int rank = this.rankingForDelta[Math.Floor(rangeMin)];
                if (rank &lt; this.rankingForDelta[Math.Floor(rangeMax)])
                {
                    rank = this.rankingForDelta[Math.Floor(rangeMax)];
                }

                // Go through the whole range and get ranking withing range if it is greater than the endpoints
                for (double i = rangeMin; i &lt;= rangeMax; i++)
                {
                    if (rank &lt; this.rankingForDelta[Math.Floor(i)])
                    {
                        rank = this.rankingForDelta[Math.Floor(i)];
                    }
                }

                if (rank == NotNaturalGasRank)
                {
                    disp = IsotopicAnalysisDisposition.NotNaturalGas;
                }
                else if (rank == UnknownRank)
                {
                    disp = IsotopicAnalysisDisposition.Unknown;
                }
                else if (rank == NaturalGasRank)
                {
                    disp = IsotopicAnalysisDisposition.NaturalGas;
                }
            }

            return disp;
        }

        private void SetTooFewPoints()
        {
            this.hasTooFewPoints = true;

            if (this.lastPeak != null)
            {
                this.lastAnalysis = new PeakAnalyzerResult(
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    IsotopicAnalysisDisposition.Unknown,
                    this.referenceGas,
                    this.lastPeak);

                this.lastPeak = null;
            }
        }

        private void LoadMeasBuffer(DistanceResult data)
        {
            this.notCollectingCount += 1;
            this.measBuffer.AddLast(data);

            double lastEpochTime = this.measBuffer.Last.Value.Data.Data.EpochTime;
            double firstEpochTime = this.measBuffer.First.Value.Data.Data.EpochTime;

            // Keep MaxDurationSecods worth of data in Measurement buffer by discarding older data.
            while ((lastEpochTime - firstEpochTime) &gt; PeakAnalyzer.MaxDurationSeconds)
            {
                this.measBuffer.RemoveFirst();

                lastEpochTime = this.measBuffer.Last.Value.Data.Data.EpochTime;
                firstEpochTime = this.measBuffer.First.Value.Data.Data.EpochTime;
            }
        }

        private void DoKeelingAnalysis()
        {
            if (this.keelingBuffer.Count &gt; (PeakAnalyzer.MinKeelingSamples + PeakAnalyzer.KeelingSamplesToSkip))
            {
                this.hasTooFewPoints = false;

                int keelingLen = this.keelingBuffer.Count;

                var ch4 = this.keelingBuffer.Select(m =&gt; m.Data.Data.CH4)
                    .Skip(PeakAnalyzer.KeelingSamplesToSkip)
                    .Take(keelingLen - PeakAnalyzer.KeelingSamplesToSkip - (PeakAnalyzer.DoneAnalysisThreshold + PeakAnalyzer.KeelingEndpointOffset)).ToList();
                var delta = this.keelingBuffer.Select(m =&gt; m.Data.Data.DeltaCH4)
                    .Skip(PeakAnalyzer.KeelingSamplesToSkip)
                    .Take(keelingLen - PeakAnalyzer.KeelingSamplesToSkip - (PeakAnalyzer.DoneAnalysisThreshold + PeakAnalyzer.KeelingEndpointOffset)).ToList();

                // Make sure that both ch4 and delta has elements
                if (ch4.Any() &amp;&amp; delta.Any())
                {
                    var inverseCH4 = ch4.Select(m =&gt; 1.0 / Math.Max(m, 0.001));
                    var sigmas = inverseCH4.Select(m =&gt; m * PeakAnalyzer.SigmaUncertainty);

                    double maxCh4 = ch4.Max();
                    double replayMax = maxCh4;
                    int idxMax = ch4.ToList().IndexOf(replayMax);

                    double replayLMin;
                    double replayRMin;

                    if (idxMax == 0)
                    {
                        replayLMin = ch4[0];
                        replayRMin = ch4[0];
                    }
                    else
                    {
                        replayLMin = ch4.Take(idxMax).Min();
                        replayRMin = ch4.Skip(idxMax).Min();
                    }

                    ChiSquaredResult result = ChiSquared.FitStraightLine(
                        inverseCH4.ToArray(),
                        delta.ToArray(),
                        sigmas.ToArray());

                    if (this.lastPeak != null)
                    {
                        this.lastAnalysis = new PeakAnalyzerResult(
                            result.A,
                            result.SigmaA,
                            replayMax,
                            replayLMin,
                            replayRMin,
                            IsotopicAnalysisDisposition.Unknown,
                            this.referenceGas,
                            this.lastPeak);

                        this.lastPeak = null;
                    }
                }
                else
                {
                    this.SetTooFewPoints();
                }
            }
            else
            {
                this.SetTooFewPoints();
            }

            this.keelingBuffer.Clear();
        }

        private void LoadKeelingBuffer(DistanceResult data)
        {
            this.notCollectingCount = 0;

            // Exclude data points where the concentration is above the analyzer specification.
            if (data.Data.Data.CH4 &lt;= PeakAnalyzer.ConcentrationHighThreshold)
            {
                this.keelingBuffer.AddLast(data);
            }
        }

        private void FindPeakForDetailAnalysis()
        {
            var ch4 = this.measBuffer.Select(m =&gt; m.Data.Data.CH4);
            int peakIdx = ch4.ToList().IndexOf(ch4.Max());

            this.lastPeak = this.measBuffer.ElementAt(peakIdx);

            this.measBuffer.Clear();
        }
    }
}
</t>
<t tx="sze.20160213072344.1">@language c

// #define DEBUG_PEAK_ANALYZER

#if DEBUG_PEAK_ANALYZER
using CsvHelper;
#endif

using Picarro.Surveyor.Algorithms.Helpers;
using Picarro.Surveyor.Algorithms.Payloads;
using Picarro.Surveyor.Core.Constant;
using Picarro.Surveyor.Core.DTO;
using Picarro.Surveyor.Core.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace Picarro.Surveyor.Algorithms.Operations
{
    &lt;&lt;PeakAnalyzer&gt;&gt;
}
</t>
<t tx="sze.20160213080557.1">// Peak analyzer carries out Keeling plot analysis of peaks found by the isotopic methane analyzer
internal sealed class PeakAnalyzer : IDisposable
{
    &lt;&lt;Declarations&gt;&gt;
    
    &lt;&lt;Constructor&gt;&gt;
    &lt;&lt;Disposition&gt;&gt;
    &lt;&lt;Dispose&gt;&gt;
    &lt;&lt;Next&gt;&gt;
    &lt;&lt;SetRankingForDelta&gt;&gt;
    &lt;&lt;GetDispositionWithUncertainty&gt;&gt;
    &lt;&lt;SetTooFewPoints&gt;&gt;
    &lt;&lt;LoadMeasBuffer&gt;&gt;
    &lt;&lt;DoKeelingAnalysis&gt;&gt;
    &lt;&lt;LoadKeelingBuffer&gt;&gt;
    &lt;&lt;FindPeakForDetailAnalysis&gt;&gt;
}</t>
<t tx="sze.20160213080648.1">public PeakAnalyzer(IsotopicIdentity isotopicIdentity, double referenceGasIsotopicValue)
{
#if DEBUG_PEAK_ANALYZER
    this.log = new StreamWriter(string.Format(@"c:\logs\peakAnalyzer_{0:yyyyMMddTHHmmssfff}.csv", DateTime.Now));
    this.csv = new CsvWriter(this.log);
    this.csv.WriteField("EpochTime");
    this.csv.WriteField("Distance");
    this.csv.WriteField("Delta");
    this.csv.WriteField("Uncertainty");
    this.csv.WriteField("ReplayMax");
    this.csv.WriteField("ReplayLMin");
    this.csv.WriteField("ReplayRMin");
    this.csv.WriteField("Disposition");
    this.csv.WriteField("ReferenceGas");
    this.csv.NextRecord();
    this.log.AutoFlush = true;
#endif
    
    this.isCancelled = false;
    this.isHandlingCancellation = false;
    this.hasTooFewPoints = false;
    this.lastCollecting = false;
    this.referenceGas = false;

    this.delayBuffer = new LinkedList&lt;bool&gt;();
    this.measBuffer = new LinkedList&lt;DistanceResult&gt;();
    this.keelingBuffer = new LinkedList&lt;DistanceResult&gt;();

    this.notCollectingCount = 0;

    this.lastAnalysis = null;
    this.lastPeak = null;

    this.isotopicIdentity = isotopicIdentity;
    this.referenceGasIsotopicValue = referenceGasIsotopicValue;
    this.rankingForDelta = new Dictionary&lt;double, int&gt;();
    this.SetRankingForDelta();
}</t>
<t tx="sze.20160213080719.1">private IsotopicAnalysisDisposition Disposition
{
    get
    {
        if (this.isCancelled)
        {
            return IsotopicAnalysisDisposition.UserCancellation;
        }
        else if (this.hasTooFewPoints)
        {
            return IsotopicAnalysisDisposition.SampleSizeTooSmall;
        }

        if (this.lastAnalysis == null)
        {
            Log.Error("Last Analysis can not be null for the Isotopic disposition determiation");
            return IsotopicAnalysisDisposition.Unknown;
        }
        else
        {
            double delta = this.lastAnalysis.Delta;
            double uncertainty = this.lastAnalysis.Uncertainty;

            if (uncertainty &gt;= PeakAnalyzer.UncertaintyHighThreshold)
            {
                return IsotopicAnalysisDisposition.UncertaintyOutOfRange;
            }
            else if ((delta &lt;= PeakAnalyzer.DeltaNegativeThreshold) ||
                (delta &gt;= PeakAnalyzer.DeltaPositiveThreshold))
            {
                return IsotopicAnalysisDisposition.DeltaOutOfRange;
            }
            else
            {
                if (this.referenceGas)
                {
                    double rangeMin = delta - uncertainty;
                    double rangeMax = delta + uncertainty;
                    if (rangeMin &lt; this.referenceGasIsotopicValue - ReferenceGasIsotopicValueTolerance ||
                        rangeMax &gt; this.referenceGasIsotopicValue + ReferenceGasIsotopicValueTolerance)
                    {
                        return IsotopicAnalysisDisposition.NotNaturalGas;
                    }
                    else
                    {
                        return IsotopicAnalysisDisposition.NaturalGas;
                    }
                }
                else
                {
                    return this.GetDispositionWithUncertainty(delta, uncertainty);
                }
            }
        }
    }
}</t>
<t tx="sze.20160213080737.1">public void Dispose()
{
#if DEBUG_PEAK_ANALYZER
    this.log.Close();
#endif
}</t>
<t tx="sze.20160213080827.1">/*
 * Definitions:
 *      Not Collecting: The air is flowing from the front of the car to back.
 *      Collecting: The air which is saved in coil is replayed by reversing direction.
 * 
 * {           |           } {                                                       }
 * {          | |          } {                                                       }
 * {         |   |         } {                         ====                          }
 * {        |     |        } {                      ==      ==                       }
 * {       |       |       } {                   ==            ==                    }
 * {      |         |      } {                ==                  ==                 }
 * {     |           |     } {            ==                         ==              }
 * {    |             |    } {         ==                               ==           }
 * {   |               |   } {      ==                                     ==        }
 * {  |                 |  } {   ==                                            ==    }
 * {_|___________________|_} {_=___________________________________________________=_}
 * {  Measurement Buffer   } {                  Keeling Buffer                       }
 * T1                       T2                                                      T3
 *
 * Notes: 
 *      - The air in coil may be from the front of car or from a reference gas bottle.
 *      - We are Not Collecting between T1 &amp; T2 and after T3
 *      - We are Collecting between T2 &amp; T3
 *      - Normal Survey mode is Not Collecting
 *      - When Isotopic or Reference Gas capture is requested, system goes in ARMED mode (Not Collecting) until a peak is detected,
 *        then system switches to ANALYSIS mode (Collecting). So Isotopic or Reference Gas capture transitions from 
 *          Not Collecting --&gt; Collecting --&gt; Not Collecting
 * 
 * Phase I: Not Collecting (transitioning from Not Collecting --&gt; Not Collecting)
 *      1. Put samples in Measurement buffer (rolling buffer for MaxDurationSeconds)
 * 
 * Phase II: Collecting (transitioning from Not Collecting --&gt; Collecting)
 *      1. Put samples in Keeling buffer
 *      2. Measurement buffer is populated with samples, save the sample with highest 
 *         CH4 concentration as we need to associate with keeling analysis in Phase IV
 *      3. Clear Measurement buffer
 * 
 * Phase III: Collecting (transitioning from Collecting --&gt; Collecting)
 *      1. Put samples in Keeling buffer
 * 
 * Phase IV: Not Collecting (transitioning from Collecting --&gt; Not Collecting)
 *      1. Put samples in Measurement buffer (in preparation if another analysis is requested)
 *      2. Keeling buffer is populated with samples (from replayed air), do 
 *         detailed keeling analysis to figure out gas signature
*/
public PeakAnalyzerResult Next(DistanceResult data)
{
    bool isCollecting = Valve.IsCollecting(data.Data.Data.ValveMask);
    
    // Delay collecting state by some number of samples to compensate for gas transport lag after valve switch.
    this.delayBuffer.AddLast(isCollecting);

    if (this.delayBuffer.Count &gt;= PeakAnalyzer.TransportLag)
    {
        isCollecting = this.delayBuffer.First.Value;
        this.delayBuffer.RemoveFirst();
    }

    // Went back to Survey Active Mode, Not cancelling anymore.
    if (Valve.IsSurveying(data.Data.Data.ValveMask))
    {
        this.isHandlingCancellation = false;
    }

    if (!this.isHandlingCancellation)
    {
        &lt;&lt;not handling cancellation&gt;&gt;
    }

    this.lastCollecting = isCollecting;

    return null;
}</t>
<t tx="sze.20160213080908.1">private void SetRankingForDelta()
{
    // Note: Please review the ranking logic if value changes for any of the folowing constants 
    //  - DeltaNegativeThreshold
    //  - isotopicIdentity.NoLowerBound
    //  - isotopicIdentity.YesLowerBound
    //  - isotopicIdentity.YesUpperBound
    //  - isotopicIdentity.NoUpperBound 
    //  - DeltaPositiveThreshold

    // Value between DeltaNegativeThreshold and isotopicIdentity.NoLowerBound indicates "Not Natural Gas"
    for (double i = DeltaNegativeThreshold; i &lt; this.isotopicIdentity.NoLowerBound; i++)
    {
        this.rankingForDelta[i] = NotNaturalGasRank;
    }

    // Value between isotopicIdentity.NoLowerBound and isotopicIdentity.YesLowerBound indicates "Unknown"
    for (double i = this.isotopicIdentity.NoLowerBound; i &lt; this.isotopicIdentity.YesLowerBound; i++)
    {
        this.rankingForDelta[i] = UnknownRank;
    }

    // Value between isotopicIdentity.YesLowerBound and isotopicIdentity.YesUpperBound indicates "Natural Gas"
    for (double i = this.isotopicIdentity.YesLowerBound; i &lt; this.isotopicIdentity.YesUpperBound; i++)
    {
        this.rankingForDelta[i] = NaturalGasRank;
    }

    // Value between isotopicIdentity.YesUpperBound and isotopicIdentity.NoUpperBound indicates "Unknown"
    for (double i = this.isotopicIdentity.YesUpperBound; i &lt; this.isotopicIdentity.NoUpperBound; i++)
    {
        this.rankingForDelta[i] = UnknownRank;
    }

    // Value between isotopicIdentity.NoUpperBound and DeltaPositiveThreshold indicates "Not Natural Gas"
    for (double i = this.isotopicIdentity.NoUpperBound; i &lt; DeltaPositiveThreshold; i++)
    {
        this.rankingForDelta[i] = NotNaturalGasRank;
    }
}
</t>
<t tx="sze.20160213081129.1">private void DoKeelingAnalysis()
{
    if (this.keelingBuffer.Count &gt; (PeakAnalyzer.MinKeelingSamples + PeakAnalyzer.KeelingSamplesToSkip))
    {
        this.hasTooFewPoints = false;

        int keelingLen = this.keelingBuffer.Count;

        var ch4 = this.keelingBuffer.Select(m =&gt; m.Data.Data.CH4)
            .Skip(PeakAnalyzer.KeelingSamplesToSkip)
            .Take(keelingLen - PeakAnalyzer.KeelingSamplesToSkip - (PeakAnalyzer.DoneAnalysisThreshold + PeakAnalyzer.KeelingEndpointOffset)).ToList();
        var delta = this.keelingBuffer.Select(m =&gt; m.Data.Data.DeltaCH4)
            .Skip(PeakAnalyzer.KeelingSamplesToSkip)
            .Take(keelingLen - PeakAnalyzer.KeelingSamplesToSkip - (PeakAnalyzer.DoneAnalysisThreshold + PeakAnalyzer.KeelingEndpointOffset)).ToList();

        // Make sure that both ch4 and delta has elements
        if (ch4.Any() &amp;&amp; delta.Any())
        {
            var inverseCH4 = ch4.Select(m =&gt; 1.0 / Math.Max(m, 0.001));
            var sigmas = inverseCH4.Select(m =&gt; m * PeakAnalyzer.SigmaUncertainty);

            double maxCh4 = ch4.Max();
            double replayMax = maxCh4;
            int idxMax = ch4.ToList().IndexOf(replayMax);

            double replayLMin;
            double replayRMin;

            if (idxMax == 0)
            {
                replayLMin = ch4[0];
                replayRMin = ch4[0];
            }
            else
            {
                replayLMin = ch4.Take(idxMax).Min();
                replayRMin = ch4.Skip(idxMax).Min();
            }

            ChiSquaredResult result = ChiSquared.FitStraightLine(
                inverseCH4.ToArray(),
                delta.ToArray(),
                sigmas.ToArray());

            if (this.lastPeak != null)
            {
                this.lastAnalysis = new PeakAnalyzerResult(
                    result.A,
                    result.SigmaA,
                    replayMax,
                    replayLMin,
                    replayRMin,
                    IsotopicAnalysisDisposition.Unknown,
                    this.referenceGas,
                    this.lastPeak);

                this.lastPeak = null;
            }
        }
        else
        {
            this.SetTooFewPoints();
        }
    }
    else
    {
        this.SetTooFewPoints();
    }

    this.keelingBuffer.Clear();
}</t>
<t tx="sze.20160213081157.1">private void LoadKeelingBuffer(DistanceResult data)
{
    this.notCollectingCount = 0;

    // Exclude data points where the concentration is above the analyzer specification.
    if (data.Data.Data.CH4 &lt;= PeakAnalyzer.ConcentrationHighThreshold)
    {
        this.keelingBuffer.AddLast(data);
    }
}</t>
<t tx="sze.20160213081216.1">private void FindPeakForDetailAnalysis()
{
    var ch4 = this.measBuffer.Select(m =&gt; m.Data.Data.CH4);
    int peakIdx = ch4.ToList().IndexOf(ch4.Max());

    this.lastPeak = this.measBuffer.ElementAt(peakIdx);

    this.measBuffer.Clear();
}</t>
<t tx="sze.20160213081239.1">#if DEBUG_PEAK_ANALYZER
private CsvWriter csv;
private StreamWriter log;
#endif
private const int TransportLag = 5;
private const int DoneAnalysisThreshold = 5;
private const double UncertaintyHighThreshold = 5.0;
private const double DeltaNegativeThreshold = -80.0;    // Note: Please review the ranking logic upon changing value
private const double DeltaPositiveThreshold = 0.0;      // Note: Please review the ranking logic upon changing value
private const double ConcentrationHighThreshold = 20.0;
private const double MaxDurationSeconds = 30.0;
private const double SigmaUncertainty = 11.0;
private const int MinKeelingSamples = 10;
private const int KeelingSamplesToSkip = 24;
private const int KeelingEndpointOffset = 6;

private const int NotNaturalGasRank = 1;
private const int UnknownRank = 2;
private const int NaturalGasRank = 0;

private const double ReferenceGasIsotopicValueTolerance = 2.5;

private Dictionary&lt;double, int&gt; rankingForDelta;

private bool isCancelled;
private bool isHandlingCancellation;
private bool hasTooFewPoints;
private bool lastCollecting;
private bool referenceGas;

private LinkedList&lt;bool&gt; delayBuffer;
private LinkedList&lt;DistanceResult&gt; measBuffer;
private LinkedList&lt;DistanceResult&gt; keelingBuffer;
private int notCollectingCount;
private PeakAnalyzerResult lastAnalysis;
private DistanceResult lastPeak;
private IsotopicIdentity isotopicIdentity;
private double referenceGasIsotopicValue;</t>
<t tx="sze.20160213082846.1"></t>
<t tx="sze.20160213082856.1">@language python

from collections import deque
import numpy as np
from traitlets import (Bool, Dict, Float, Instance, Integer, List, Unicode)

def checkCancelling(value):
    mask = 0x10
    ivalue = int(value)
    return abs(value-ivalue) &lt;= 1.0e-4 and (ivalue &amp; mask) != 0

def checkCollecting(value):
    mask = 0x1
    ivalue = int(value)
    return abs(value-ivalue) &lt;= 1.0e-4 and (ivalue &amp; mask) != 0

def checkReferenceGasInjection(value):
    mask = 0x8
    ivalue = int(value)
    return abs(value-ivalue) &lt;= 1.0e-4 and (ivalue &amp; mask) != 0

def checkSurveying(value):
    return abs(value) &lt;= 1.0e-4
    
def linfit(x,y,sigma):
    # Calculate the linear fit of (x,y) to a line, where sigma are the errors in the y values
    S = sum(1/sigma**2)
    Sx = sum(x/sigma**2)
    Sy = sum(y/sigma**2)
    Sxx = sum(x**2/sigma**2)
    Sxy = sum(x*y/sigma**2)
    t = (x-Sx/S)/sigma
    Stt = sum(t**2)
    b = sum(t*y/sigma)/Stt
    a = (Sy-Sx*b)/S
    sa2 = (1+Sx**2/(S*Stt))/S
    sb2 = 1/Stt
    sab = -Sx/(S*Stt)
    rab = sab/np.sqrt(sa2*sb2)
    return a, b, np.sqrt(sa2), np.sqrt(sb2)
    
class PeakAnalyzerResult(HasTraits):
    delta = FLoat()
    uncertainty Float()
    replayMax = Float()
    replayLMin = Float()
    replayRMin = Float()
    disposition = Unicode()
    refrenceGas = Bool()
    data = Dict()
    
class IsotopicIdentity(HasTraits): # Fetch from database
    noLowerBound = Float(-45.0)
    yesLowerBound = Float(-38.0)
    yesUpperBound = Float(-25.0)
    noUpperBound = Float(-10.0)

class PeakAnalyzerBlock(TransformManyBlock):
    concentrationHighThreshold = Float(20.0)
    delayBuffer = List(Bool())
    deltaPositiveThreshold = Float(0.0)
    deltaNegativeThreshold = Float(-80.0)
    doneAnalysisThreshold = Integer(5)    
    hasTooFewPoints = Bool(False)
    isCancelled = Bool(False)
    isHandlingCancellation = Bool(False)
    isotopicIdentity = Instance(IsotopicIdentity)
    keelingBuffer = List()    
    keelingEndpointOffset = Integer(6)
    keelingSamplesToSkip = Integer(24)
    lastAnalysis = Instance(PeakAnalyzerResult, allow_none=True)
    lastCollecting = Bool(False)
    lastPeak = Dict()
    maxDurationSeconds = Float(30.0)
    measBuffer = List()
    minKeelingSamples = Integer(10)
    notCollectingCount = Integer(0)
    referenceGas = Bool(False)
    referenceGasIsotopicValue = Float(-35.0) # Look up in table
    referenceGasIsotopicValueTolerance = Float(2.5)
    sigmaUncertainty = 11.0
    transportLag = Integer(5)
    uncertaintyHighThreshold = Float(5.0)
    
    def __init__(self):
        super(PeakAnalyzerBlock, self).__init__(self.newData)
        self.delayBuffer = []
        self.isotopicIdentity = IsotopicIdentity()
        self.lastAnalysis = None
        
    def getDisposition(self):
        if self.isCancelled:
            return 'UserCancellation'
        elif self.hasTooFewPoints:
            return 'SampleSizeTooSmall'
        if self.lastAnalysis is None:
            print 'ERROR: Last Analysis cannot be none for disposition determination'
            return 'Unknown'
        else:
            delta = self.lastAnalysis.delta
            uncertainty = self.lastAnalysis.uncertainty
            
            if uncertainty &gt; self.uncertaintyHighThreshold:
                return 'UncertaintyOutOfRange'
            elif delta &lt;= self.deltaNegativeThreshold or delta &gt;= self.deltaPositiveThreshold:
                return 'DeltaOutOfRange'
            else:
                if this.referenceGas:
                    rangeMin = delta - uncertainty
                    rangeMax = delta + uncertainty
                    if (rangeMin &lt; self.referenceGasIsotopicValue - self.referenceGasIsotopicValueTolerance or
                        rangeMax &gt; self.referenceGasIsotopicValue + self.referenceGasIsotopicValueTolerance):
                        return 'NotNaturalGas'
                    else:
                        return 'NaturalGas'
                else:
                    rangeMin = delta - uncertainty
                    rangeMax = delta + uncertainty
                    if rangeMin &lt;= self.deltaNegativeThreshold or rangeMax &gt;= self.deltaPositiveThreshold:
                        return 'DeltaOutOfRange'
                    else:
                        if (rangeMin &gt;= self.isotopicIdentity.yesLowerBound and 
                            rangeMax &lt; self.isotopicIdentity.yesUpperBound):
                            return 'NaturalGas'
                        elif (rangeMin &gt;= self.isotopicIdentity.noUpperBound or
                              rangeMax &lt; self.isotopicIdentity.noLowerBound):
                            return 'NotNaturalGas'
                        else:
                            return 'Unknown'

    def newData(self, newDat):
        # collecting =&gt; tape recorder is playing back
        # not collecting =&gt; analyzer samples inlet directly
        
        result = None
        isCollecting = checkCollecting(newDat['ValveMask'])
        # Delay collecting state by transportLag to compensate for valve switching
        self.delayBuffer.append(isCollecting)
        if len(self.delayBuffer &gt;= self.transportLag):
            isCollecting = self.delayBuffer.pop(0)
            
        if checkSurveying(newDat['ValveMask']):
            self.isHandlingCancellation = False
            
        if not self.isHandlingCancellation:
            result = self.acquisitionActive()
        
        self.lastCollecting = isCollecting
        
        if result is not None:
            yield result
            
    def acquisitionActive(self, newDat):
        if checkCancelling(newDat['ValveMask']):
            self.isHandlingCancellation = True
            self.isCancelled = True
            result = PeakAnalyzerResult(
                delta=0,
                uncertainty=0,
                replayMax=0,
                replayLMin=0.0,
                replayRMin=0.0,
                disposition=self.getDisposition(),
                referenceGas=self.referenceGas,
                data=newDat)
            self.lastPeak = None
            self.lastAnalysis = None
            self.hasTooFewPoints = False
            self.lastCollecting = isCollecting.
            self.referenceGas = False
            return result
            
        if checkReferenceGasInjection(newDat['ValveMask']):
            self.referenceGas = True
    
        if self.notCollectingCount &gt; self.doneAnalysisThreshold and self.lastAnalysis is not None:
            self.lastAnalysis.disposition = self.getDisposition()
            result = self.lastAnalysis
            self.lastPeak = None
            self.lastAnalysis = None
            self.isCancelled = False
            self.hasTooFewPoints = False
            self.lastCollecting = isCollecting
            self.referenceGas = False
            return result
            
        if not isCollecting:
            # Phase I/IV: We are between T1 &amp; T2 or after T3
            # Keep filling up measurement buffer with unstretched peak data
            self.notCollectingCount += 1
            self.measBuffer.append(newDat)
            while self.measBuffer[-1]["EPOCH_TIME"]-measBuffer[0]["EPOCH_TIME"] &gt; maxDurationSeconds:
                self.measBuffer.pop(0)
                
            if self.lastCollecting:
                # We have just transitioned from replay (filling up Keeling buffer) back to real-time
                #  acquisition
                self.doKeelingAnalysis()
        else:
            # Phase II/III: We are between T2 &amp; T3
            # Tape recorder is playing back, keep filling up Keeling buffer
            self.notCollectingCount = 0
            if newDat["CH4"] &lt;= self.concentrationHighThreshold:
                self.keelingBuffer.append(newDat)
                
            if (not self.lastCollecting) and len(self.measBuffer)&gt;0:
                # We have just transitioned from real-time acquisition to replay of the tape recorder
                # This is the time T2. We need to find the peak in measBuff to associate with the 
                #  upcoming Keeling analysis
                ch4 = np.asarray([dat["CH4"] for dat in self.measBuffer])
                self.lastPeak = self.measBuffer[np.argmax(ch4)]
                self.measBuffer = []

    def doKeelingAnalysis(self):
        if len(self.keelingBuffer) &gt; self.minKeelingSamples + self.keelingSamplesToSkip:
            self.hasTooFewPoints = False
            selectedSamples = self.keelingBuffer[self.keelingSamplesToSkip:-(self.doneAnalysisThreshold+self.keelingEndpointOffset)]
            ch4 = np.asarray([dat["CH4"] for dat in selectedSamples])
            delta = np.asarray([dat["Delta_CH4"] for dat in selectedSamples])
            if len(ch4)&gt;0 and len(delta)&gt;0:
                inverseCH4 = 1.0/np.maximum(ch4,0.001)
                sigmas = inveseCH4 * self.sigmaUncertainty
                maxCh4 = max(ch4)
                idxMax = np.argmax(ch4)
                if idxMax == 0:
                    replayLMin = ch4[0]
                    replayRMin = ch4[idxMax:]
                elif idxMax == len(ch4) - 1:
                    replayLMin = ch4[:idxMax]
                    replayRMin = ch4[-1]
                else:
                    replayLMin = min(ch4[:idxMax])
                    replayRMin = min(ch4[idxMax:])
                    
                a,b,sigmaA,sigmaB = linfit(inverseCH4, delta, sigmas)
                
                if self.lastPeak is not None:
                    self.lastAnalysis = PeakAnalyzerResult(
                        delta=a,
                        uncertainty=sigmaA,
                        replayMax=replayMax,
                        replayLMin=replayLMin,
                        replayRMin=replayRMin,
                        disposition='Unknown',
                        referenceGas=self.referenceGas,
                        data=self.lastPeak)
                    self.lastPeak = None
            else:
                self.setTooFewPoints()
        else:
            self.setTooFewPoints()
        self.keelingBuffer = []
        
    def setTooFewPoints(self):
        self.hasTooFewPoints = True
        if self.lastPeak is not None:
            self.lastAnalysis = PeakAnalyzerResult(
                delta=0.0,
                uncertainty=0.0,
                replayMax=0.0,
                replayLMin=0.0,
                replayRMin=0.0,
                disposition='Unknown',
                referenceGas=self.referenceGas,
                data=self.lastPeak)
            self.lastPeak = None
            </t>
<t tx="sze.20160213091505.1">// Cancellation of Isotopic or Reference Gas capture
// We will get multiple samples upon user cancellation with valve indicating cancel state.
// But we want to ingore all but the first one.(Using isHandlingCancellation boolean flag)
if (Valve.IsCancelling(data.Data.Data.ValveMask))
{
    &lt;&lt;handle Cancellation&gt;&gt;
}

// Set Reference gas to true if reference gas injection was done
// Note: It will be cleared and set to false on either analysis completion or cancelation
if (Valve.IsReferenceGasInjection(data.Data.Data.ValveMask))
{
    this.referenceGas = true;
}

// An analysis is completed if we are not in the collecting state for N samples
// and there is some Keeling data to report.
if ((this.notCollectingCount &gt; PeakAnalyzer.DoneAnalysisThreshold) &amp;&amp; this.lastAnalysis != null)
{
    &lt;&lt;return analysis result&gt;&gt;
}

/*
 * Phase I or Phase IV
 */
if (!isCollecting)
{
    &lt;&lt;not in replay mode&gt;&gt;
}

/*
 * Phase II or Phase III
*/
else
{
    &lt;&lt;in replay mode&gt;&gt;
}</t>
<t tx="sze.20160213092026.1">this.isHandlingCancellation = true;
this.isCancelled = true;
var result = new PeakAnalyzerResult(
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    this.Disposition,
    this.referenceGas,
    data);

this.lastPeak = null;
this.lastAnalysis = null;
this.isCancelled = false;
this.hasTooFewPoints = false;
this.lastCollecting = isCollecting;
this.referenceGas = false;
return result;</t>
<t tx="sze.20160213092150.1">var result = new PeakAnalyzerResult(
    this.lastAnalysis.Delta,
    this.lastAnalysis.Uncertainty,
    this.lastAnalysis.ReplayMax,
    this.lastAnalysis.ReplayLMin,
    this.lastAnalysis.ReplayRMin,
    this.Disposition,
    this.referenceGas,
    this.lastAnalysis.Measurement);

#if DEBUG_PEAK_ANALYZER
this.csv.WriteField(this.lastAnalysis.Measurement.Data.Data.EpochTime);
this.csv.WriteField(this.lastAnalysis.Measurement.Distance);
this.csv.WriteField(this.lastAnalysis.Delta);
this.csv.WriteField(this.lastAnalysis.Uncertainty);
this.csv.WriteField(this.lastAnalysis.ReplayMax);
this.csv.WriteField(this.lastAnalysis.ReplayLMin);
this.csv.WriteField(this.lastAnalysis.ReplayRMin);
this.csv.WriteField(this.Disposition);
this.csv.WriteField(this.referenceGas);
this.csv.NextRecord();
#endif
this.lastPeak = null;
this.lastAnalysis = null;
this.isCancelled = false;
this.hasTooFewPoints = false;
this.lastCollecting = isCollecting;
this.referenceGas = false;
return result;</t>
<t tx="sze.20160213092845.1">/*
 * Phase I/IV: We are between T1 &amp; T2 or after T3
 */
// Not collecting - keep filling up Measurement buffer
// Note: Can be either before collection starts or after collection ends
this.LoadMeasBuffer(data);

if (this.lastCollecting)
{
    /*
     * Phase IV: We are at T3
     */
    // Just finished collecting - do Keeling analysis
    this.DoKeelingAnalysis();
}</t>
<t tx="sze.20160213092905.1">/*
 * Phase II/III: We are between T2 &amp; T3
 */
// Collecting - keep filling up Keeling buffer
this.LoadKeelingBuffer(data);

if (!this.lastCollecting &amp;&amp; (this.measBuffer.Count &gt; 0))
{
    /*
     * Phase II: We are at T2
     */
    // Just started collecting - find the peak from measurement buffer 
    // to associate with upcoming Keeling analysis
    this.FindPeakForDetailAnalysis();
}</t>
<t tx="sze.20160213113144.1">private IsotopicAnalysisDisposition GetDispositionWithUncertainty(double delta, double uncertainty)
{
    double rangeMin = delta - uncertainty;
    double rangeMax = delta + uncertainty;
    IsotopicAnalysisDisposition disp = IsotopicAnalysisDisposition.Unknown;

    if (rangeMin &lt;= DeltaNegativeThreshold || 
        rangeMax &gt;= DeltaPositiveThreshold)
    {
        disp = IsotopicAnalysisDisposition.DeltaOutOfRange;
    }
    else
    {
        // Note: For now we are using Math.Floor as the whole range is negative values
        // starting from DeltaNegativeThreshold and ending at DeltaPositiveThreshold

        // Get highest ranking comparing the rangemin and rangemax
        int rank = this.rankingForDelta[Math.Floor(rangeMin)];
        if (rank &lt; this.rankingForDelta[Math.Floor(rangeMax)])
        {
            rank = this.rankingForDelta[Math.Floor(rangeMax)];
        }

        // Go through the whole range and get ranking withing range if it is greater than the endpoints
        for (double i = rangeMin; i &lt;= rangeMax; i++)
        {
            if (rank &lt; this.rankingForDelta[Math.Floor(i)])
            {
                rank = this.rankingForDelta[Math.Floor(i)];
            }
        }

        if (rank == NotNaturalGasRank)
        {
            disp = IsotopicAnalysisDisposition.NotNaturalGas;
        }
        else if (rank == UnknownRank)
        {
            disp = IsotopicAnalysisDisposition.Unknown;
        }
        else if (rank == NaturalGasRank)
        {
            disp = IsotopicAnalysisDisposition.NaturalGas;
        }
    }

    return disp;
}</t>
<t tx="sze.20160213113206.1">private void SetTooFewPoints()
{
    this.hasTooFewPoints = true;

    if (this.lastPeak != null)
    {
        this.lastAnalysis = new PeakAnalyzerResult(
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            IsotopicAnalysisDisposition.Unknown,
            this.referenceGas,
            this.lastPeak);

        this.lastPeak = null;
    }
}</t>
<t tx="sze.20160213113226.1">private void LoadMeasBuffer(DistanceResult data)
{
    this.notCollectingCount += 1;
    this.measBuffer.AddLast(data);

    double lastEpochTime = this.measBuffer.Last.Value.Data.Data.EpochTime;
    double firstEpochTime = this.measBuffer.First.Value.Data.Data.EpochTime;

    // Keep MaxDurationSecods worth of data in Measurement buffer by discarding older data.
    while ((lastEpochTime - firstEpochTime) &gt; PeakAnalyzer.MaxDurationSeconds)
    {
        this.measBuffer.RemoveFirst();

        lastEpochTime = this.measBuffer.Last.Value.Data.Data.EpochTime;
        firstEpochTime = this.measBuffer.First.Value.Data.Data.EpochTime;
    }
}</t>
</tnodes>
</leo_file>
